{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CPLUS QGIS plugin \u00b6 Introduction \u00b6 The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilising natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localised data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritising these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimise their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognises that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialog and cooperation between governments, local communities, indigenous groups, conservation organisations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios. CPLUS model \u00b6 Activities \u00b6 Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model Algorithms \u00b6 Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms References \u00b6 https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126 Site contents \u00b6 The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testing and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developer's environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Home"},{"location":"#cplus-qgis-plugin","text":"","title":"CPLUS QGIS plugin"},{"location":"#introduction","text":"The challenge of mitigating climate change and achieving global and national climate targets requires innovative and holistic approaches. In this pursuit, the Climate Positive Land Use Strategy (CPLUS) decision support tool has emerged as a crucial resource. CPLUS is a spatially-explicit roadmap designed to guide land-use planning strategies, utilising natural climate solutions to drive meaningful and sustainable change. The CPLUS decision support tool combines open-source technology, localised data sets, and modelled products to empower policymakers, land managers, and stakeholders in making informed decisions. By integrating spatial information, such as land cover, carbon stocks, and potential for carbon sequestration, CPLUS enables the identification of key areas for intervention and investment. By prioritising these nature-based interventions, CPLUS seeks to harness the power of ecosystems and optimise their climate mitigation potential. One of the distinguishing features of CPLUS is its ability to address both global and national climate targets. While global climate targets provide a broad framework for action, national targets require context-specific strategies tailored to the unique characteristics of each country. The CPLUS decision support tool considers these diverse factors and assists in designing land-use planning strategies that align with national commitments while contributing to global climate goals. Furthermore, CPLUS recognises that effective land-use planning involves collaboration and engagement among various stakeholders. It fosters dialog and cooperation between governments, local communities, indigenous groups, conservation organisations, and private entities, facilitating the development of inclusive and equitable solutions. By involving diverse perspectives and expertise, CPLUS ensures that the decision-making process is participatory and informed by local knowledge. Piloted in the Bushbuckridge Municipality in the Kruger to Canyons Biosphere of South Africa, the CPLUS framework was tested with a diverse set of stakeholders to identify land use priorities and understand the carbon benefits and biodiversity, ecosystem services co-benefits of different scenarios.","title":"Introduction"},{"location":"#cplus-model","text":"","title":"CPLUS model"},{"location":"#activities","text":"Figure 1 shows a flow diagram of the CPLUS analysis model. Figure 1: Simplified analysis model","title":"Activities"},{"location":"#algorithms","text":"Shown in Figure 2 is the algorithms applied by the CPLUS model analysis model. Figure 2: CPLUS simplified analysis workflow with algorithms","title":"Algorithms"},{"location":"#references","text":"https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126","title":"References"},{"location":"#site-contents","text":"The aim of this is site is to provide details on the models and algorithms used by the CPLUS plugin, help a user on using the plugin, guide administrators on testing and providing feedback for the plugin, and provide guidance to developers who want to contribute to the plugin. Here is a quick introduction on the sections on the site: Users : Help for users of the plugin Quick Start : Installation guide and how to get started with the plugin Guide : Detailed workflow on how to use the plugin Manual : Descriptions of each UI element Administrators : Help for an administrator of the plugin Guide : Detailed guide for administrative requirements Repository : Downloadable versions of the plugin Developers : People who want to contribute towards improving the plugin Setup : How to set up the developer's environment for the plugin Architecture : Documentation : Help on adding towards the API documentation for a developer API : Application programming interface for the plugin About : Information on CI and other contributors to the plugin","title":"Site contents"},{"location":"about/ci/","text":"Conservation International \u00b6 Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyse a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/ci/#conservation-international","text":"Through the help of community leaders and policymakers, the mission of Conservation International (CI) is to combat climate change and preserve carbon stores. CI and the Climate Positive Land Use Strategy (CPLUS) project need the ability to spatially analyse a given area to determine the best land use in order to naturally combat climate change and the effects thereof on a global scale. Further, reports need to be generated to communicate to stakeholders the importance of conserving and maintaining certain areas and the need to restore lost climate-positive environments. Thus, mitigating the negative effects of climate change produced by our daily activities. The aim is to ensure a better future for everyone.","title":"Conservation International"},{"location":"about/kartoza/","text":"Kartoza \u00b6 Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/kartoza/#kartoza","text":"Kartoza will make geospatial data and technology work for you by partnering with us for training, development and maintenance of GIS systems. Kartoza is a South Africa-based Free and Open Source GIS (FOSSGIS) service provider. We use GIS software to solve complex location-related problems for individuals, businesses and governments around the world. Our team develops software using FOSSGIS to give you the freedom to share and modify your GIS as your needs grow and change.","title":"Kartoza"},{"location":"about/license/","text":"License \u00b6","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"administrator/","text":"Administrators \u00b6 This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Conservation International"},{"location":"administrator/#administrators","text":"This section is for administrators of the plugin: The guide details how to create new tasks, and how to download and install a staging version of the plugin. The repository provides access to different versions of the plugin. This includes version based on specific pull requests.","title":"Administrators"},{"location":"administrator/guide/","text":"Administrators guide \u00b6 Pilot area data \u00b6 This section deals with making updates to the data of the pilot study area (Bushbuck Ridge). This needs to be done in the GitHub repository, or locally on the repository clone, and then pushed into the repository. The change can be made as follows: The following JSON files needs to be considered when doing this, all of which are stored in \"src/cplus_plugin/data/default\" activities.json ncs_pathways.json priority_weighted_layers.json Activities \u00b6 In this file, existing activities can be edited (e.g. change name or description), be removed or a new activity can be added. Here is a quick overview of an activity stored in the JSON file Each activity contains the following elements: uuid : A universal unique identifier (UUID) for the activity name : A unique name for the activity description : Detailed description of the activity style : The style which will be applied to the activity pixel value in the scenario layer activity_layer : The name of a valid QGIS color ramp that will be applied to the output activity layer Editing these will have an effect on the activity in the plugin When adding a new activity to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove an activity from the list of activities, an administrator can simply remove the entry in the JSON file. Remove this text to remove an activity: To update the list of priority weighted layers for an activity, the ID needs to be retrieved: Open the priority_weighted_layers.json file Each available PWL will be listed under \"layers\" Save the file A section on PWL editing will soon follow. NCS pathways \u00b6 An administrator can access/edit the NCS pathways as follows: Open the ncs_pathways.json file Here is a description of each element: uuid : A unique identifier for the pathway name : Unique title for the pathway description : Detailed description of the pathway path : Directory with file name for the pathway data layer_type : Numerical value zero - 0 - for rasters Editing these elements will make changes to the pilot area data in the plugin When adding a new pathway to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a pathway from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove an NCS pathway: Priority weighted layers \u00b6 Do the following to change/add/remove priority weighted layers for the pilot study area Open the priority_weighted_layers.json file Here is a description of each element: uuid : A unique ID for the PWL name : Unique name for the PWL description : A detailed description of the PWL selected : Whether the PWL should be selected on default path : A directory with file name for the PWL data. This should be a raster Changing the above values will have an impact on the data in the plugin for the pilot study area When adding a new PWL to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a PWL from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a PWL: Default Global Priority Weighted Layers (PWLs) \u00b6 This section relates to the set of default global datasets within the plugin. There are Default Global PWLs so that users can use high-quality baseline data without needing to manually upload their own layers. Administrative users can manage (add, delete, edit, or download) Global Priority Weighted Layers (PWLs) in the plugin settings. To access the Default Global PWLs, administrative users can click on the dropdown arrow on the plugin icon. Then they can click on Settings . In the window that pops up, administrative users should scroll down to the Global priority weighted layers (PWLs) Section where there is a list of Default Global Priority Weighted Layers (PWLs). There are buttons that allow users to: - Download a Global PWL - Add a new Global PWL - Edit a Global PWL - Delete a Global PWL Adding or Editing a Priority Weighted Layer (PWL) \u00b6 If an administrative user clicks on the Add or Edit buttons, a window appears that allows them to add/edit the information related to the PWL. Administrative users need to provide a Name , provide a Description , choose the Map layer from a local file, choose the Privacy type , provide License information, and provide a Version for the PWL. Once everything is filled in, administrative users can click on the OK button. If at any point, the administrative user wants to leave the window without saving their current state, they can click on Cancel . Once an administrative user clicks on OK , the plugin begins the process of uploading the layer. Note: If any of the provided information is not correct, when the user clicks on OK an error message will appear in the window (it will provide information on where the issue occurred in the form). E.g. no layer name has been provided: If the administrative user clicks on the Delete button, a window pops up asking them to confirm their decision. Once an administrative user is done managing the Default Global PWLs, the can click on the OK button to close the Settings window. If they do not want to keep their changes, they can click on the Cancel button. Bugs and suggestions \u00b6 This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue . An issue entry from is as shown in Figure 1 Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers. Staging version of the plugin \u00b6 When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to have the latest features tested by an external group including the CI team. Get the staging version \u00b6 Go to the repository: https://github.com/ConservationInternational/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See the Installation section in the Quick Start guide on how to install the CPLUS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Guide"},{"location":"administrator/guide/#administrators-guide","text":"","title":"Administrators guide"},{"location":"administrator/guide/#pilot-area-data","text":"This section deals with making updates to the data of the pilot study area (Bushbuck Ridge). This needs to be done in the GitHub repository, or locally on the repository clone, and then pushed into the repository. The change can be made as follows: The following JSON files needs to be considered when doing this, all of which are stored in \"src/cplus_plugin/data/default\" activities.json ncs_pathways.json priority_weighted_layers.json","title":"Pilot area data"},{"location":"administrator/guide/#activities","text":"In this file, existing activities can be edited (e.g. change name or description), be removed or a new activity can be added. Here is a quick overview of an activity stored in the JSON file Each activity contains the following elements: uuid : A universal unique identifier (UUID) for the activity name : A unique name for the activity description : Detailed description of the activity style : The style which will be applied to the activity pixel value in the scenario layer activity_layer : The name of a valid QGIS color ramp that will be applied to the output activity layer Editing these will have an effect on the activity in the plugin When adding a new activity to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove an activity from the list of activities, an administrator can simply remove the entry in the JSON file. Remove this text to remove an activity: To update the list of priority weighted layers for an activity, the ID needs to be retrieved: Open the priority_weighted_layers.json file Each available PWL will be listed under \"layers\" Save the file A section on PWL editing will soon follow.","title":"Activities"},{"location":"administrator/guide/#ncs-pathways","text":"An administrator can access/edit the NCS pathways as follows: Open the ncs_pathways.json file Here is a description of each element: uuid : A unique identifier for the pathway name : Unique title for the pathway description : Detailed description of the pathway path : Directory with file name for the pathway data layer_type : Numerical value zero - 0 - for rasters Editing these elements will make changes to the pilot area data in the plugin When adding a new pathway to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a pathway from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove an NCS pathway:","title":"NCS pathways"},{"location":"administrator/guide/#priority-weighted-layers","text":"Do the following to change/add/remove priority weighted layers for the pilot study area Open the priority_weighted_layers.json file Here is a description of each element: uuid : A unique ID for the PWL name : Unique name for the PWL description : A detailed description of the PWL selected : Whether the PWL should be selected on default path : A directory with file name for the PWL data. This should be a raster Changing the above values will have an impact on the data in the plugin for the pilot study area When adding a new PWL to the list (or a UUID needs to change), the user needs to provide a UUID. This can be done as follows: Open a UUID generator . Other UUID generators can also be used, but the provided link will suffice Best will be to make use of version 4 Click Generate a version 4 UUID Copy and paste the newly generated UUID To remove a PWL from the list of layers, an administrator can simply remove the entry in the JSON file. Remove this text to remove a PWL:","title":"Priority weighted layers"},{"location":"administrator/guide/#default-global-priority-weighted-layers-pwls","text":"This section relates to the set of default global datasets within the plugin. There are Default Global PWLs so that users can use high-quality baseline data without needing to manually upload their own layers. Administrative users can manage (add, delete, edit, or download) Global Priority Weighted Layers (PWLs) in the plugin settings. To access the Default Global PWLs, administrative users can click on the dropdown arrow on the plugin icon. Then they can click on Settings . In the window that pops up, administrative users should scroll down to the Global priority weighted layers (PWLs) Section where there is a list of Default Global Priority Weighted Layers (PWLs). There are buttons that allow users to: - Download a Global PWL - Add a new Global PWL - Edit a Global PWL - Delete a Global PWL","title":"Default Global Priority Weighted Layers (PWLs)"},{"location":"administrator/guide/#adding-or-editing-a-priority-weighted-layer-pwl","text":"If an administrative user clicks on the Add or Edit buttons, a window appears that allows them to add/edit the information related to the PWL. Administrative users need to provide a Name , provide a Description , choose the Map layer from a local file, choose the Privacy type , provide License information, and provide a Version for the PWL. Once everything is filled in, administrative users can click on the OK button. If at any point, the administrative user wants to leave the window without saving their current state, they can click on Cancel . Once an administrative user clicks on OK , the plugin begins the process of uploading the layer. Note: If any of the provided information is not correct, when the user clicks on OK an error message will appear in the window (it will provide information on where the issue occurred in the form). E.g. no layer name has been provided: If the administrative user clicks on the Delete button, a window pops up asking them to confirm their decision. Once an administrative user is done managing the Default Global PWLs, the can click on the OK button to close the Settings window. If they do not want to keep their changes, they can click on the Cancel button.","title":"Adding or Editing a Priority Weighted Layer (PWL)"},{"location":"administrator/guide/#bugs-and-suggestions","text":"This section relates to creating an issue for when a bug is found in the plugin, or if the user has a suggested improvement for the plugin. Go to the CPLUS repository Click on the Issues tab Click on New Issue . An issue entry from is as shown in Figure 1 Title: Short, but descriptive Description: Detailed description. If it's a bug, an explanation on how to replicate the bug will be best. Screenshots of the bug or suggestion will also be helpful Figure 1: An example of a new GitHub issue Select a Label (e.g. bug, enhancement, etc.) as shown in Figure 2 Figure 2: Selecting a label for an issue Select the CPLUS Project ( Figure 3 ). This will add the issue/task to the project board Figure 3: Selecting a Project for an issue The end result should be similar to Figure 4 . Figure 4: An example of a finalized issue Click Submit new issue The issue will now be submitted to the GitHub repository and be available to the developers.","title":"Bugs and suggestions"},{"location":"administrator/guide/#staging-version-of-the-plugin","text":"When a pull requested is performed, an automatic staging version is created. This will allow a developer to test their changes to the plugin with other changes which has not been merged into the main branch. Another advantage of this approach is to have the latest features tested by an external group including the CI team.","title":"Staging version of the plugin"},{"location":"administrator/guide/#get-the-staging-version","text":"Go to the repository: https://github.com/ConservationInternational/cplus-plugin To the right there is a section named Releases Click on Latest release Download the cplus_plugin .zip file if you want to install the plugin in QGIS Developers will likely be interested in Source code (zip) and Source code (tar.gz) options See the Installation section in the Quick Start guide on how to install the CPLUS plugin If you want to have a look at past versions of the plugin: On the repository page, click on Releases A list of option will appear Choose the version you are interested in, and follow the steps discussed above","title":"Get the staging version"},{"location":"administrator/repository/","text":"Pull requests artifacts PR title PR url Artifact name Artifact link Created date Main branch artifacts Commit link Artifact name Artifact link Created date import { Octokit, App } from \"https://esm.sh/octokit\"; const octokit = new Octokit(); const pulls = await octokit.request( \"GET /repos/ConservationInternational/cplus-plugin/pulls\", {'state':'all'} ); const fetched_artifacts = await octokit.request( \"GET /repos/ConservationInternational/cplus-plugin/actions/artifacts\", {'per_page': 30} ); const pulls_artifacts = []; const commits_artifacts = []; const artifacts_comments = []; for ( const pull of pulls.data ){ const head_sha = pull['head']['sha']; const pull_artifact = {}; const artifact_comments = []; if (pull == undefined) continue; for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['workflow_run']['head_sha'] == head_sha && artifact['name'].indexOf('cplus_plugin') != -1 ){ pull_artifact['pull'] = pull; pull_artifact['artifact'] = artifact; artifact_comments['artifact'] = artifact; artifact_comments['comments'] = pull['comments_url']; } } pulls_artifacts.push(pull_artifact); artifacts_comments.push(artifact_comments); } for ( const artifact of fetched_artifacts.data.artifacts){ if ( artifact['name'].indexOf('cplus_plugin') == -1){ continue; } const commit = await octokit.request( \"GET /repos/ConservationInternational/cplus-plugin/commits/\"+ artifact['workflow_run']['head_sha'] ); if ( commit == undefined | commit.data.parents.length < 2 ){ continue; } const commit_artifact = { 'commit': commit, 'artifact': artifact }; commits_artifacts.push(commit_artifact); } const pulls_tbody = document.getElementById('pulls_tbody'); const main_tbody = document.getElementById('main_tbody'); for (const pull_artifact of pulls_artifacts){ if (pull_artifact['pull'] == undefined) { continue; } const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( pull_artifact['pull']['title'] ); pull_link.appendChild(link_node); pull_link.textContent = pull_artifact['pull']['html_url']; pull_link.title = pull_artifact['pull']['html_url']; pull_link.href = pull_artifact['pull']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(first_td); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( pull_artifact['artifact']['name'] ); const date_node = document.createTextNode( pull_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = pull_artifact['artifact']['archive_download_url']; artifact_link.href = pull_artifact['artifact']['archive_download_url']; artifact_link.id = pull_artifact['artifact']['name']; third_td.appendChild(second_link_node); fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); pulls_tbody.appendChild(tr) } for( const artifact_comment of artifacts_comments){ if (artifact_comment['comments'] === undefined) continue; const comments = await fetch(artifact_comment['comments']); const result = comments.json().then(function(results){ for(const comment of results){ if (comment.body.indexOf(\"Download the plugin zip file here\") != -1){ const artifact_link_regex = /(https?:\\/\\/[^ ]*)/; const matches = comment.body.match(artifact_link_regex); const art_link = matches[0]; const artifact_name = artifact_comment['artifact']['name']; const artifact_url = art_link.split(\"\\n\")[0]; const pull_artifact = document.getElementById(artifact_name); if( pull_artifact == undefined){ continue; } pull_artifact.textContent = artifact_url; pull_artifact.href = artifact_url; } } }) } for (const commit_artifact of commits_artifacts){ if (commit_artifact['commit'] === undefined) continue; const tr = document.createElement('tr'); const first_td = document.createElement('td'); const second_td = document.createElement('td'); const third_td = document.createElement('td'); const fourth_td = document.createElement('td'); const fifth_td = document.createElement('td'); const pull_link = document.createElement(\"a\"); const link_node = document.createTextNode( commit_artifact['commit']['data']['sha'] ); pull_link.appendChild(link_node); pull_link.textContent = commit_artifact['commit']['data']['html_url']; pull_link.title = commit_artifact['commit']['data']['html_url']; pull_link.href = commit_artifact['commit']['data']['html_url']; first_td.appendChild(link_node); second_td.appendChild(pull_link); tr.appendChild(second_td); const artifact_link = document.createElement(\"a\"); const second_link_node = document.createTextNode( commit_artifact['artifact']['name'] ); const date_node = document.createTextNode( commit_artifact['artifact']['created_at'] ); artifact_link.appendChild(second_link_node); artifact_link.textContent = commit_artifact['artifact']['archive_download_url']; artifact_link.href = commit_artifact['artifact']['archive_download_url']; third_td.appendChild(second_link_node); artifact_link.id = commit_artifact['artifact']['name']; fourth_td.appendChild(artifact_link); fifth_td.appendChild(date_node); tr.appendChild(third_td); tr.appendChild(fourth_td); tr.appendChild(fifth_td); main_tbody.appendChild(tr) } const response = await fetch( \"https://raw.githubusercontent.com/ConservationInternational/cplus-plugin/docs/docs/administrator/repository/artifacts_list.txt\" ); const file_text_promise = response.text(); const res = file_text_promise.then(function(result){ const art_list = result.split(\"\\n\"); for( const art of art_list){ if( art === \"\"){ continue; } const parts = art.split(\" - \"); const artifact_name = parts[0].trim(); const artifact_url = parts[1].trim(); const main_artifact = document.getElementById(artifact_name); if( main_artifact == undefined){ continue; } main_artifact.textContent = artifact_url; main_artifact.href = artifact_url; } const loading_div = document.getElementById('loading_div'); loading_div.remove(); });","title":"Repository"},{"location":"developer/","text":"Developers \u00b6 Section which aims at guiding developers of the plugin: Setup details how to set up a developer's environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Conservation International"},{"location":"developer/#developers","text":"Section which aims at guiding developers of the plugin: Setup details how to set up a developer's environment of the plugin. Developers documentation details how a developer should document changes to the code. Architecture of the plugin","title":"Developers"},{"location":"developer/api/core/api_carbon/","text":"Carbon Calculation Utilities \u00b6 Contains functions for carbon calculations. BasePathwaysCarbonCalculator \u00b6 BasePathwaysCarbonCalculator ( activity ) Base class for carbon calculators for NCS pathways. This class encapsulates the common logic for preparing the NCS pathways. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity activity property \u00b6 activity Gets the activity used to calculate carbon values. Returns: Type Description Activity The activity for calculating carbon values. calculation_type property \u00b6 calculation_type Returns the type of calculation being performed. Should be overridden by subclasses. Returns: Type Description str The calculation type name. pathway_type property \u00b6 pathway_type Returns the NCS pathway type used in the carbon calculation. Needs to be overridden in subclasses. Returns: Type Description NCS pathway type to be applied in the calculation. get_pathways \u00b6 get_pathways () Returns NCS pathways based on the type defined in subclass implementations. Returns: Type Description List [ NcsPathway ] NCS pathways of the type defined in the subclass. If the type of the NCS pathway in the activity is not defined, then it will be excluded from the list. Source code in src/cplus_plugin/lib/carbon.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 def get_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathways based on the type defined in subclass implementations. :returns: NCS pathways of the type defined in the subclass. If the type of the NCS pathway in the activity is not defined, then it will be excluded from the list. \"\"\" if self . pathway_type == NcsPathwayType . UNDEFINED : return [] if self . _activity is None : log ( f \" { LOG_PREFIX } - The activity is invalid, null reference.\" , info = False , ) return [] if len ( self . _activity . pathways ) == 0 : log ( f \" { LOG_PREFIX } - There are no pathways in \" f \" { self . _activity . name } activity.\" , info = False , ) return [] type_pathways = [ pathway for pathway in self . _activity . pathways if pathway . pathway_type == self . pathway_type ] return type_pathways run \u00b6 run () Calculates carbon value for the referenced activity. Subclasses need to implement this function. Returns: Type Description float The total carbon value. Source code in src/cplus_plugin/lib/carbon.py 556 557 558 559 560 561 562 563 564 def run ( self ) -> float : \"\"\"Calculates carbon value for the referenced activity. Subclasses need to implement this function. :returns: The total carbon value. :rtype: float \"\"\" raise NotImplementedError ( \"Subclasses must implement the 'run' function.\" ) BaseProtectPathwaysCarbonCalculator \u00b6 BaseProtectPathwaysCarbonCalculator ( activity ) Bases: BasePathwaysCarbonCalculator Base class for carbon calculators that process protect pathways. This class encapsulates the common logic for preparing and processing protect NCS pathways before calculating carbon values. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity pathway_type property \u00b6 pathway_type Returns the NCS protect pathway type used in the carbon calculation. Returns: Type Description NCS protect pathway type applied in the calculation. run \u00b6 run () Calculates the total carbon value for the referenced activity. Returns: Type Description float The total carbon value. If there are no protect NCS pathways, returns 0.0. If errors occur, returns -1.0. Source code in src/cplus_plugin/lib/carbon.py 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def run ( self ) -> float : \"\"\"Calculates the total carbon value for the referenced activity. :returns: The total carbon value. If there are no protect NCS pathways, returns 0.0. If errors occur, returns -1.0. :rtype: float \"\"\" prepared_layer = self . _prepare_protect_pathways_layer () if prepared_layer is None : return 0.0 total_carbon = self . _calculate_carbon ( prepared_layer ) if total_carbon == - 1.0 : log ( f \" { LOG_PREFIX } - Error occurred in calculating the total \" f \" { self . calculation_type . lower () } . See preceding logs for details.\" , info = False , ) else : log ( f \"Finished calculating the total { self . calculation_type . lower () } \" f \"of { self . _activity . name } as { total_carbon !s} \" ) return total_carbon CarbonImpactManageCalculator \u00b6 CarbonImpactManageCalculator ( activity ) Bases: CarbonImpactPathwayCalculator Class for carbon impact calculation for manage NCS pathways. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity pathway_type property \u00b6 pathway_type Returns the NCS manage pathway type used in the carbon calculation. Returns: Type Description NCS manage pathway type applied in the calculation. CarbonImpactPathwayCalculator \u00b6 CarbonImpactPathwayCalculator ( activity ) Bases: BasePathwaysCarbonCalculator Generic calculator for NCS pathway area-based carbon impact calculations. Subclasses only need to override pathway_type and calculation_type. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity run \u00b6 run () Calculates the carbon impact for the configured pathway_type. Returns: Type Description float The total carbon impact value. If there are no matching pathways, returns 0.0. If errors occur, returns -1.0. Source code in src/cplus_plugin/lib/carbon.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 def run ( self ) -> float : \"\"\"Calculates the carbon impact for the configured pathway_type. :returns: The total carbon impact value. If there are no matching pathways, returns 0.0. If errors occur, returns -1.0. :rtype: float \"\"\" pathways = self . get_pathways () if len ( pathways ) == 0 : log ( f \" { LOG_PREFIX } - There are no { self . pathway_type . name . lower () } pathways in \" f \" { self . _activity . name } activity.\" , info = False , ) return 0.0 pathway_carbon_info = [ NcsPathwayCarbonInfo ( layer , pathway . type_options [ CARBON_IMPACT_ATTRIBUTE ]) for pathway in pathways for layer in [ pathway . to_map_layer ()] if layer . isValid () and CARBON_IMPACT_ATTRIBUTE in pathway . type_options ] if len ( pathway_carbon_info ) == 0 : log ( f \" { LOG_PREFIX } - There are no valid { self . pathway_type . name . lower () } pathway layers in \" f \" { self . _activity . name } activity.\" , info = False , ) return 0.0 if len ( pathway_carbon_info ) != len ( pathways ): log ( f \" { LOG_PREFIX } - Some { self . pathway_type . name . lower () } pathway layers are invalid and will be \" f \"excluded from the { self . calculation_type . lower () } calculation.\" , info = False , ) return calculate_pathway_carbon_by_area ( pathway_carbon_info ) CarbonImpactProtectCalculator \u00b6 CarbonImpactProtectCalculator ( activity ) Bases: BaseProtectPathwaysCarbonCalculator Calculates the carbon impact of protect NCS pathways in an activity using the biomass reference layer. It specifically searches for protect pathways in the activity. If there are no protect pathways is found, it will return 0. This is designed to be called within a QgsExpressionFunction. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity CarbonImpactRestoreCalculator \u00b6 CarbonImpactRestoreCalculator ( activity ) Bases: CarbonImpactPathwayCalculator Class for carbon impact calculation for restore NCS pathways. This class differs from CarbonImpactManageCalculator only in the pathway_type it returns (NcsPathwayType.RESTORE), reusing the generic pathway calculation logic provided by CarbonImpactPathwayCalculator. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity pathway_type property \u00b6 pathway_type Returns the NCS restore pathway type used in the carbon calculation. Returns: Type Description NCS restore pathway type applied in the calculation. IrrecoverableCarbonCalculator \u00b6 IrrecoverableCarbonCalculator ( activity ) Bases: BaseProtectPathwaysCarbonCalculator Calculates the total irrecoverable carbon of an activity using the mean-based reference carbon layer. It specifically searches for protect pathways in the activity. If there are no protect pathways is found, it will return 0. This is designed to be called within a QgsExpressionFunction. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity NcsPathwayCarbonInfo dataclass \u00b6 NcsPathwayCarbonInfo ( layer , carbon_impact_per_ha ) Container for NcsPathway layer and corresponding carbon impact value. calculate_activity_naturebase_carbon_impact \u00b6 calculate_activity_naturebase_carbon_impact ( activity ) Calculates the carbon mitigation impact of an activity from Naturbase pathway. It sums the carbon mitigation values across each NCS Naturebase pathway that constitutes the activity. Parameters: Name Type Description Default activity Activity The specific activity. required Returns: Type Description float Returns the total carbon impact of the activity, or -1.0 if the activity does not exist or lacks Naturebase pathways. Source code in src/cplus_plugin/lib/carbon.py 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def calculate_activity_naturebase_carbon_impact ( activity : Activity ) -> float : \"\"\"Calculates the carbon mitigation impact of an activity from Naturbase pathway. It sums the carbon mitigation values across each NCS Naturebase pathway that constitutes the activity. :param activity: The specific activity. :type activity: Activity :returns: Returns the total carbon impact of the activity, or -1.0 if the activity does not exist or lacks Naturebase pathways. :rtype: float \"\"\" if activity is None or len ( activity . pathways ) == 0 : return - 1.0 pathways = [ pathway for pathway in activity . pathways if pathway . name . startswith ( \"Naturebase:\" ) and isinstance ( pathway . carbon_impact_value , Number ) ] if not pathways : return - 1.0 return float ( sum ( p . carbon_impact_value for p in pathways )) calculate_irrecoverable_carbon_from_mean \u00b6 calculate_irrecoverable_carbon_from_mean ( ncs_pathways_layer ) Calculates the total irrecoverable carbon in tonnes for protect NCS pathways using the reference layer defined in settings that is based on the mean value per hectare. Parameters: Name Type Description Default ncs_pathways_layer QgsRasterLayer Layer containing an aggregate of protect NCS pathways. required Returns: Type Description float The total irrecoverable carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def calculate_irrecoverable_carbon_from_mean ( ncs_pathways_layer : QgsRasterLayer , ) -> float : \"\"\"Calculates the total irrecoverable carbon in tonnes for protect NCS pathways using the reference layer defined in settings that is based on the mean value per hectare. :param ncs_pathways_layer: Layer containing an aggregate of protect NCS pathways. :type ncs_pathways_layer: QgsRasterLayer :returns: The total irrecoverable carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. :rtype: float \"\"\" source_type_int = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_SOURCE_TYPE , default = DataSourceType . UNDEFINED . value , setting_type = int , ) reference_source_path = \"\" if source_type_int == DataSourceType . LOCAL . value : reference_source_path = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_LOCAL_SOURCE , default = \"\" ) elif source_type_int == DataSourceType . ONLINE . value : reference_source_path = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_ONLINE_LOCAL_PATH , default = \"\" ) if not reference_source_path : log ( f \" { LOG_PREFIX } - Data source for reference irrecoverable carbon layer not found.\" , info = False , ) return - 1.0 log ( \"Calculating the total irrecoverable carbon from mean...\" ) intersecting_pixel_values = _get_intersecting_pixel_values ( ncs_pathways_layer , reference_source_path , \"mean_irrecoverable_carbon\" , \"Irrecoverable Carbon\" , ) # Empty list indicates that an error occurred if intersecting_pixel_values is None : return - 1.0 pixel_count = len ( intersecting_pixel_values ) if pixel_count == 0 : return 0.0 # Calculate using mean-based approach: mean \u00d7 pixel_count \u00d7 area_per_pixel ic_mean = sum ( intersecting_pixel_values ) / float ( pixel_count ) return MEAN_REFERENCE_LAYER_AREA * pixel_count * ic_mean calculate_pathway_carbon_by_area \u00b6 calculate_pathway_carbon_by_area ( ncs_pathways_carbon_info ) Calculates the carbon impact in tonnes for NCS pathways by multiplying the area of the NCS pathway layers with the user-defined carbon impact rate for the specific NCS pathway. Parameters: Name Type Description Default ncs_pathways_carbon_info List [ NcsPathwayCarbonInfo ] Container for pathway rasters and their corresponding carbon impact values. required Returns: Type Description float The total carbon impact for NCS pathways. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def calculate_pathway_carbon_by_area ( ncs_pathways_carbon_info : typing . List [ NcsPathwayCarbonInfo ], ) -> float : \"\"\"Calculates the carbon impact in tonnes for NCS pathways by multiplying the area of the NCS pathway layers with the user-defined carbon impact rate for the specific NCS pathway. :param ncs_pathways_carbon_info: Container for pathway rasters and their corresponding carbon impact values. :type ncs_pathways_carbon_info: typing.List[NcsPathwayCarbonInfo] :returns: The total carbon impact for NCS pathways. If no pathways found, returns 0.0. :rtype: float \"\"\" if not ncs_pathways_carbon_info : log ( f \" { LOG_PREFIX } - No pathways found for calculating \" f \"carbon impact for pathways.\" , info = False , ) return 0.0 log ( \"Calculating carbon impact for pathways...\" ) total_carbon = 0.0 for carbon_info in ncs_pathways_carbon_info : area = calculate_raster_area ( carbon_info . layer , 1 ) if area != - 1.0 : total_carbon += area * carbon_info . carbon_impact_per_ha return total_carbon calculate_stored_carbon \u00b6 calculate_stored_carbon ( ncs_pathways_layer ) Calculates the total stored carbon in tonnes for protect NCS pathways by summing pixel values from the biomass reference layer defined in settings. Parameters: Name Type Description Default ncs_pathways_layer QgsRasterLayer Layer containing an aggregate of protect NCS pathways. required Returns: Type Description float The total stored carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def calculate_stored_carbon ( ncs_pathways_layer : QgsRasterLayer , ) -> float : \"\"\"Calculates the total stored carbon in tonnes for protect NCS pathways by summing pixel values from the biomass reference layer defined in settings. :param ncs_pathways_layer: Layer containing an aggregate of protect NCS pathways. :type ncs_pathways_layer: QgsRasterLayer :returns: The total stored carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. :rtype: float \"\"\" reference_source_path = settings_manager . get_value ( Settings . STORED_CARBON_BIOMASS_PATH , default = \"\" ) if not reference_source_path : log ( f \" { LOG_PREFIX } - Data source for reference biomass layer not found.\" , info = False , ) return - 1.0 log ( \"Calculating the stored carbon...\" ) intersecting_pixel_values = _get_intersecting_pixel_values ( ncs_pathways_layer , reference_source_path , \"biomass_stored_carbon\" , \"Stored Carbon\" , ) # Empty list indicates an error occurred if intersecting_pixel_values is None : return - 1.0 pixel_count = len ( intersecting_pixel_values ) if pixel_count == 0 : return 0.0 # Calculate by direct summation of pixel values return sum ( intersecting_pixel_values )","title":"Carbon"},{"location":"developer/api/core/api_carbon/#carbon-calculation-utilities","text":"Contains functions for carbon calculations.","title":"Carbon Calculation Utilities"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator","text":"BasePathwaysCarbonCalculator ( activity ) Base class for carbon calculators for NCS pathways. This class encapsulates the common logic for preparing the NCS pathways. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"BasePathwaysCarbonCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator.activity","text":"activity Gets the activity used to calculate carbon values. Returns: Type Description Activity The activity for calculating carbon values.","title":"activity"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator.calculation_type","text":"calculation_type Returns the type of calculation being performed. Should be overridden by subclasses. Returns: Type Description str The calculation type name.","title":"calculation_type"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator.pathway_type","text":"pathway_type Returns the NCS pathway type used in the carbon calculation. Needs to be overridden in subclasses. Returns: Type Description NCS pathway type to be applied in the calculation.","title":"pathway_type"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator.get_pathways","text":"get_pathways () Returns NCS pathways based on the type defined in subclass implementations. Returns: Type Description List [ NcsPathway ] NCS pathways of the type defined in the subclass. If the type of the NCS pathway in the activity is not defined, then it will be excluded from the list. Source code in src/cplus_plugin/lib/carbon.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 def get_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathways based on the type defined in subclass implementations. :returns: NCS pathways of the type defined in the subclass. If the type of the NCS pathway in the activity is not defined, then it will be excluded from the list. \"\"\" if self . pathway_type == NcsPathwayType . UNDEFINED : return [] if self . _activity is None : log ( f \" { LOG_PREFIX } - The activity is invalid, null reference.\" , info = False , ) return [] if len ( self . _activity . pathways ) == 0 : log ( f \" { LOG_PREFIX } - There are no pathways in \" f \" { self . _activity . name } activity.\" , info = False , ) return [] type_pathways = [ pathway for pathway in self . _activity . pathways if pathway . pathway_type == self . pathway_type ] return type_pathways","title":"get_pathways"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BasePathwaysCarbonCalculator.run","text":"run () Calculates carbon value for the referenced activity. Subclasses need to implement this function. Returns: Type Description float The total carbon value. Source code in src/cplus_plugin/lib/carbon.py 556 557 558 559 560 561 562 563 564 def run ( self ) -> float : \"\"\"Calculates carbon value for the referenced activity. Subclasses need to implement this function. :returns: The total carbon value. :rtype: float \"\"\" raise NotImplementedError ( \"Subclasses must implement the 'run' function.\" )","title":"run"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BaseProtectPathwaysCarbonCalculator","text":"BaseProtectPathwaysCarbonCalculator ( activity ) Bases: BasePathwaysCarbonCalculator Base class for carbon calculators that process protect pathways. This class encapsulates the common logic for preparing and processing protect NCS pathways before calculating carbon values. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"BaseProtectPathwaysCarbonCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BaseProtectPathwaysCarbonCalculator.pathway_type","text":"pathway_type Returns the NCS protect pathway type used in the carbon calculation. Returns: Type Description NCS protect pathway type applied in the calculation.","title":"pathway_type"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.BaseProtectPathwaysCarbonCalculator.run","text":"run () Calculates the total carbon value for the referenced activity. Returns: Type Description float The total carbon value. If there are no protect NCS pathways, returns 0.0. If errors occur, returns -1.0. Source code in src/cplus_plugin/lib/carbon.py 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 def run ( self ) -> float : \"\"\"Calculates the total carbon value for the referenced activity. :returns: The total carbon value. If there are no protect NCS pathways, returns 0.0. If errors occur, returns -1.0. :rtype: float \"\"\" prepared_layer = self . _prepare_protect_pathways_layer () if prepared_layer is None : return 0.0 total_carbon = self . _calculate_carbon ( prepared_layer ) if total_carbon == - 1.0 : log ( f \" { LOG_PREFIX } - Error occurred in calculating the total \" f \" { self . calculation_type . lower () } . See preceding logs for details.\" , info = False , ) else : log ( f \"Finished calculating the total { self . calculation_type . lower () } \" f \"of { self . _activity . name } as { total_carbon !s} \" ) return total_carbon","title":"run"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactManageCalculator","text":"CarbonImpactManageCalculator ( activity ) Bases: CarbonImpactPathwayCalculator Class for carbon impact calculation for manage NCS pathways. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"CarbonImpactManageCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactManageCalculator.pathway_type","text":"pathway_type Returns the NCS manage pathway type used in the carbon calculation. Returns: Type Description NCS manage pathway type applied in the calculation.","title":"pathway_type"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactPathwayCalculator","text":"CarbonImpactPathwayCalculator ( activity ) Bases: BasePathwaysCarbonCalculator Generic calculator for NCS pathway area-based carbon impact calculations. Subclasses only need to override pathway_type and calculation_type. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"CarbonImpactPathwayCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactPathwayCalculator.run","text":"run () Calculates the carbon impact for the configured pathway_type. Returns: Type Description float The total carbon impact value. If there are no matching pathways, returns 0.0. If errors occur, returns -1.0. Source code in src/cplus_plugin/lib/carbon.py 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 def run ( self ) -> float : \"\"\"Calculates the carbon impact for the configured pathway_type. :returns: The total carbon impact value. If there are no matching pathways, returns 0.0. If errors occur, returns -1.0. :rtype: float \"\"\" pathways = self . get_pathways () if len ( pathways ) == 0 : log ( f \" { LOG_PREFIX } - There are no { self . pathway_type . name . lower () } pathways in \" f \" { self . _activity . name } activity.\" , info = False , ) return 0.0 pathway_carbon_info = [ NcsPathwayCarbonInfo ( layer , pathway . type_options [ CARBON_IMPACT_ATTRIBUTE ]) for pathway in pathways for layer in [ pathway . to_map_layer ()] if layer . isValid () and CARBON_IMPACT_ATTRIBUTE in pathway . type_options ] if len ( pathway_carbon_info ) == 0 : log ( f \" { LOG_PREFIX } - There are no valid { self . pathway_type . name . lower () } pathway layers in \" f \" { self . _activity . name } activity.\" , info = False , ) return 0.0 if len ( pathway_carbon_info ) != len ( pathways ): log ( f \" { LOG_PREFIX } - Some { self . pathway_type . name . lower () } pathway layers are invalid and will be \" f \"excluded from the { self . calculation_type . lower () } calculation.\" , info = False , ) return calculate_pathway_carbon_by_area ( pathway_carbon_info )","title":"run"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactProtectCalculator","text":"CarbonImpactProtectCalculator ( activity ) Bases: BaseProtectPathwaysCarbonCalculator Calculates the carbon impact of protect NCS pathways in an activity using the biomass reference layer. It specifically searches for protect pathways in the activity. If there are no protect pathways is found, it will return 0. This is designed to be called within a QgsExpressionFunction. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"CarbonImpactProtectCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactRestoreCalculator","text":"CarbonImpactRestoreCalculator ( activity ) Bases: CarbonImpactPathwayCalculator Class for carbon impact calculation for restore NCS pathways. This class differs from CarbonImpactManageCalculator only in the pathway_type it returns (NcsPathwayType.RESTORE), reusing the generic pathway calculation logic provided by CarbonImpactPathwayCalculator. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"CarbonImpactRestoreCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.CarbonImpactRestoreCalculator.pathway_type","text":"pathway_type Returns the NCS restore pathway type used in the carbon calculation. Returns: Type Description NCS restore pathway type applied in the calculation.","title":"pathway_type"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.IrrecoverableCarbonCalculator","text":"IrrecoverableCarbonCalculator ( activity ) Bases: BaseProtectPathwaysCarbonCalculator Calculates the total irrecoverable carbon of an activity using the mean-based reference carbon layer. It specifically searches for protect pathways in the activity. If there are no protect pathways is found, it will return 0. This is designed to be called within a QgsExpressionFunction. Source code in src/cplus_plugin/lib/carbon.py 486 487 488 489 490 def __init__ ( self , activity : typing . Union [ str , Activity ]): if isinstance ( activity , str ): activity = settings_manager . get_activity ( activity ) self . _activity = activity","title":"IrrecoverableCarbonCalculator"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.NcsPathwayCarbonInfo","text":"NcsPathwayCarbonInfo ( layer , carbon_impact_per_ha ) Container for NcsPathway layer and corresponding carbon impact value.","title":"NcsPathwayCarbonInfo"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.calculate_activity_naturebase_carbon_impact","text":"calculate_activity_naturebase_carbon_impact ( activity ) Calculates the carbon mitigation impact of an activity from Naturbase pathway. It sums the carbon mitigation values across each NCS Naturebase pathway that constitutes the activity. Parameters: Name Type Description Default activity Activity The specific activity. required Returns: Type Description float Returns the total carbon impact of the activity, or -1.0 if the activity does not exist or lacks Naturebase pathways. Source code in src/cplus_plugin/lib/carbon.py 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 def calculate_activity_naturebase_carbon_impact ( activity : Activity ) -> float : \"\"\"Calculates the carbon mitigation impact of an activity from Naturbase pathway. It sums the carbon mitigation values across each NCS Naturebase pathway that constitutes the activity. :param activity: The specific activity. :type activity: Activity :returns: Returns the total carbon impact of the activity, or -1.0 if the activity does not exist or lacks Naturebase pathways. :rtype: float \"\"\" if activity is None or len ( activity . pathways ) == 0 : return - 1.0 pathways = [ pathway for pathway in activity . pathways if pathway . name . startswith ( \"Naturebase:\" ) and isinstance ( pathway . carbon_impact_value , Number ) ] if not pathways : return - 1.0 return float ( sum ( p . carbon_impact_value for p in pathways ))","title":"calculate_activity_naturebase_carbon_impact"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.calculate_irrecoverable_carbon_from_mean","text":"calculate_irrecoverable_carbon_from_mean ( ncs_pathways_layer ) Calculates the total irrecoverable carbon in tonnes for protect NCS pathways using the reference layer defined in settings that is based on the mean value per hectare. Parameters: Name Type Description Default ncs_pathways_layer QgsRasterLayer Layer containing an aggregate of protect NCS pathways. required Returns: Type Description float The total irrecoverable carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def calculate_irrecoverable_carbon_from_mean ( ncs_pathways_layer : QgsRasterLayer , ) -> float : \"\"\"Calculates the total irrecoverable carbon in tonnes for protect NCS pathways using the reference layer defined in settings that is based on the mean value per hectare. :param ncs_pathways_layer: Layer containing an aggregate of protect NCS pathways. :type ncs_pathways_layer: QgsRasterLayer :returns: The total irrecoverable carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. :rtype: float \"\"\" source_type_int = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_SOURCE_TYPE , default = DataSourceType . UNDEFINED . value , setting_type = int , ) reference_source_path = \"\" if source_type_int == DataSourceType . LOCAL . value : reference_source_path = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_LOCAL_SOURCE , default = \"\" ) elif source_type_int == DataSourceType . ONLINE . value : reference_source_path = settings_manager . get_value ( Settings . IRRECOVERABLE_CARBON_ONLINE_LOCAL_PATH , default = \"\" ) if not reference_source_path : log ( f \" { LOG_PREFIX } - Data source for reference irrecoverable carbon layer not found.\" , info = False , ) return - 1.0 log ( \"Calculating the total irrecoverable carbon from mean...\" ) intersecting_pixel_values = _get_intersecting_pixel_values ( ncs_pathways_layer , reference_source_path , \"mean_irrecoverable_carbon\" , \"Irrecoverable Carbon\" , ) # Empty list indicates that an error occurred if intersecting_pixel_values is None : return - 1.0 pixel_count = len ( intersecting_pixel_values ) if pixel_count == 0 : return 0.0 # Calculate using mean-based approach: mean \u00d7 pixel_count \u00d7 area_per_pixel ic_mean = sum ( intersecting_pixel_values ) / float ( pixel_count ) return MEAN_REFERENCE_LAYER_AREA * pixel_count * ic_mean","title":"calculate_irrecoverable_carbon_from_mean"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.calculate_pathway_carbon_by_area","text":"calculate_pathway_carbon_by_area ( ncs_pathways_carbon_info ) Calculates the carbon impact in tonnes for NCS pathways by multiplying the area of the NCS pathway layers with the user-defined carbon impact rate for the specific NCS pathway. Parameters: Name Type Description Default ncs_pathways_carbon_info List [ NcsPathwayCarbonInfo ] Container for pathway rasters and their corresponding carbon impact values. required Returns: Type Description float The total carbon impact for NCS pathways. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def calculate_pathway_carbon_by_area ( ncs_pathways_carbon_info : typing . List [ NcsPathwayCarbonInfo ], ) -> float : \"\"\"Calculates the carbon impact in tonnes for NCS pathways by multiplying the area of the NCS pathway layers with the user-defined carbon impact rate for the specific NCS pathway. :param ncs_pathways_carbon_info: Container for pathway rasters and their corresponding carbon impact values. :type ncs_pathways_carbon_info: typing.List[NcsPathwayCarbonInfo] :returns: The total carbon impact for NCS pathways. If no pathways found, returns 0.0. :rtype: float \"\"\" if not ncs_pathways_carbon_info : log ( f \" { LOG_PREFIX } - No pathways found for calculating \" f \"carbon impact for pathways.\" , info = False , ) return 0.0 log ( \"Calculating carbon impact for pathways...\" ) total_carbon = 0.0 for carbon_info in ncs_pathways_carbon_info : area = calculate_raster_area ( carbon_info . layer , 1 ) if area != - 1.0 : total_carbon += area * carbon_info . carbon_impact_per_ha return total_carbon","title":"calculate_pathway_carbon_by_area"},{"location":"developer/api/core/api_carbon/#src.cplus_plugin.lib.carbon.calculate_stored_carbon","text":"calculate_stored_carbon ( ncs_pathways_layer ) Calculates the total stored carbon in tonnes for protect NCS pathways by summing pixel values from the biomass reference layer defined in settings. Parameters: Name Type Description Default ncs_pathways_layer QgsRasterLayer Layer containing an aggregate of protect NCS pathways. required Returns: Type Description float The total stored carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. Source code in src/cplus_plugin/lib/carbon.py 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def calculate_stored_carbon ( ncs_pathways_layer : QgsRasterLayer , ) -> float : \"\"\"Calculates the total stored carbon in tonnes for protect NCS pathways by summing pixel values from the biomass reference layer defined in settings. :param ncs_pathways_layer: Layer containing an aggregate of protect NCS pathways. :type ncs_pathways_layer: QgsRasterLayer :returns: The total stored carbon for protect NCS pathways. If there are any errors, returns -1.0. If no pathways found, returns 0.0. :rtype: float \"\"\" reference_source_path = settings_manager . get_value ( Settings . STORED_CARBON_BIOMASS_PATH , default = \"\" ) if not reference_source_path : log ( f \" { LOG_PREFIX } - Data source for reference biomass layer not found.\" , info = False , ) return - 1.0 log ( \"Calculating the stored carbon...\" ) intersecting_pixel_values = _get_intersecting_pixel_values ( ncs_pathways_layer , reference_source_path , \"biomass_stored_carbon\" , \"Stored Carbon\" , ) # Empty list indicates an error occurred if intersecting_pixel_values is None : return - 1.0 pixel_count = len ( intersecting_pixel_values ) if pixel_count == 0 : return 0.0 # Calculate by direct summation of pixel values return sum ( intersecting_pixel_values )","title":"calculate_stored_carbon"},{"location":"developer/api/core/api_conf/","text":"Configuration \u00b6 Handles storage and retrieval of the plugin QgsSettings. ScenarioSettings dataclass \u00b6 ScenarioSettings ( uuid , name , description , extent , activities , priority_layer_groups , state = ScenarioState . IDLE , server_uuid = None , clip_to_studyarea = False , studyarea_path = None , crs = None , constant_raster_collection = None ) Bases: Scenario Plugin Scenario settings. from_qgs_settings classmethod \u00b6 from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" activities_list = settings . value ( \"activities\" , []) server_uuid = settings . value ( \"server_uuid\" , None ) activities = [] try : for activity in activities_list : setting_activity = json . loads ( activity ) saved_activity = settings_manager . get_activity ( setting_activity . get ( \"uuid\" ) ) if saved_activity is None : continue for pathways in setting_activity [ PATHWAYS_ATTRIBUTE ]: for path_uuid , path in pathways . items (): pathway = settings_manager . get_ncs_pathway ( path_uuid ) if pathway : pathway . path = path saved_activity . add_ncs_pathway ( pathway ) saved_activity . path = setting_activity . get ( \"path\" ) activities . append ( saved_activity ) except Exception as e : log ( f \"Problem fetching saved activities, { e } \" ) return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), extent = [], activities = activities , priority_layer_groups = [], server_uuid = uuid . UUID ( server_uuid ) if server_uuid else None , clip_to_studyarea = settings . value ( \"clip_to_studyarea\" , False ), studyarea_path = settings . value ( \"studyarea_path\" , None ), ) get_scenario_extent classmethod \u00b6 get_scenario_extent ( identifier ) Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @classmethod def get_scenario_extent ( cls , identifier ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = ( f \" { settings_manager . _get_scenario_settings_base ( identifier ) } /extent/spatial\" ) with qgis_settings ( spatial_key ) as settings : bbox = settings . value ( \"bbox\" , None ) bbox = [ float ( b ) for b in bbox ] crs = settings . value ( \"crs\" , None ) spatial_extent = SpatialExtent ( bbox = bbox , crs = crs ) return spatial_extent Settings \u00b6 Bases: Enum Plugin settings names SettingsManager \u00b6 Bases: QObject Manages saving/loading settings for the plugin in QgsSettings. delete_all_scenarios \u00b6 delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 540 541 542 543 544 545 546 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name ) delete_all_scenarios_results \u00b6 delete_all_scenarios_results () Deletes all the plugin scenarios results settings. Source code in src/cplus_plugin/conf.py 656 657 658 659 660 661 662 663 def delete_all_scenarios_results ( self ): \"\"\"Deletes all the plugin scenarios results settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } / { self . SCENARIO_GROUP_NAME } /\" f \" { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for scenario_result in settings . childGroups (): settings . remove ( scenario_result ) delete_online_scenario \u00b6 delete_online_scenario () Delete online scenario from QGIS settings Source code in src/cplus_plugin/conf.py 528 529 530 531 532 533 534 535 536 537 538 def delete_online_scenario ( self ): \"\"\"Delete online scenario from QGIS settings\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): scenario = settings_manager . get_scenario ( scenario_identifier ) if scenario . server_uuid : settings_manager . delete_scenario_result ( scenario_identifier ) settings_manager . delete_scenario ( scenario_identifier ) delete_online_task \u00b6 delete_online_task () Delete the online task with the passed scenarion id. Source code in src/cplus_plugin/conf.py 1558 1559 1560 1561 1562 1563 1564 def delete_online_task ( self ): \"\"\"Delete the online task with the passed scenarion id.\"\"\" log ( \"delete online task\" ) with qgis_settings ( self . BASE_GROUP_NAME ) as settings : a = settings . value ( self . ONLINE_TASK_BASE ) log ( a ) settings . remove ( self . ONLINE_TASK_BASE ) delete_priority_group \u00b6 delete_priority_group ( identifier ) Removes priority group that match the passed identifier Parameters: Name Type Description Default identifier str Priority group identifier required Source code in src/cplus_plugin/conf.py 990 991 992 993 994 995 996 997 998 999 1000 1001 def delete_priority_group ( self , identifier ): \"\"\"Removes priority group that match the passed identifier :param identifier: Priority group identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } /\" ) as settings : for priority_group in settings . childGroups (): if str ( priority_group ) == str ( identifier ): settings . remove ( priority_group ) delete_priority_groups \u00b6 delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 1003 1004 1005 1006 1007 1008 1009 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group ) delete_priority_layer \u00b6 delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 879 880 881 882 883 884 885 886 887 888 889 890 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer ) delete_priority_layers \u00b6 delete_priority_layers () Deletes all the plugin priority weighting layers settings. Source code in src/cplus_plugin/conf.py 871 872 873 874 875 876 877 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority weighting layers settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer ) delete_scenario \u00b6 delete_scenario ( scenario_id ) Delete the scenario with the passed scenarion id. Parameters: Name Type Description Default scenario_id str Scenario identifier required Source code in src/cplus_plugin/conf.py 514 515 516 517 518 519 520 521 522 523 524 525 526 def delete_scenario ( self , scenario_id ): \"\"\"Delete the scenario with the passed scenarion id. :param scenario_id: Scenario identifier :type scenario_id: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): if str ( scenario_identifier ) == str ( scenario_id ): settings . remove ( scenario_identifier ) delete_scenario_result \u00b6 delete_scenario_result ( scenario_id ) Delete the scenario result that contains the scenario id. Parameters: Name Type Description Default scenario_id str Scenario identifier required Source code in src/cplus_plugin/conf.py 642 643 644 645 646 647 648 649 650 651 652 653 654 def delete_scenario_result ( self , scenario_id ): \"\"\"Delete the scenario result that contains the scenario id. :param scenario_id: Scenario identifier :type scenario_id: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): if str ( scenario_identifier ) == str ( scenario_id ): settings . remove ( scenario_identifier ) delete_settings \u00b6 delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 369 370 371 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" ) find_activity_by_name \u00b6 find_activity_by_name ( name ) Finds an activity setting inside the plugin QgsSettings that equals or matches the name. Parameters: Name Type Description Default name str Activity name. required Returns: Type Description Activity Activity object. Source code in src/cplus_plugin/conf.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 def find_activity_by_name ( self , name ) -> typing . Dict : \"\"\"Finds an activity setting inside the plugin QgsSettings that equals or matches the name. :param name: Activity name. :type name: str :returns: Activity object. :rtype: Activity \"\"\" for activity in self . get_all_activities (): model_name = activity . name trimmed_name = model_name . replace ( \" \" , \"_\" ) if model_name == name or model_name in name or trimmed_name in name : return activity return None find_group_by_name \u00b6 find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id ) find_layer_by_name \u00b6 find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layer name. required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 def find_layer_by_name ( self , name : str ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layer name. :type name: str :returns: Priority layers dict :rtype: dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id ) if found_id is not None else None find_layers_by_group \u00b6 find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the given group name. Parameters: Name Type Description Default group str Priority group name. required Returns: Type Description list Priority layers list. Source code in src/cplus_plugin/conf.py 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 def find_layers_by_group ( self , group : str ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the given group name. :param group: Priority group name. :type group: str :returns: Priority layers list. :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers find_settings \u00b6 find_settings ( name ) Returns the plugin setting keys from the plugin root group that matches the passed name Parameters: Name Type Description Default name str Setting name to search for required Returns: Type Description list List of the matching settings names Source code in src/cplus_plugin/conf.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def find_settings ( self , name ): \"\"\"Returns the plugin setting keys from the plugin root group that matches the passed name :param name: Setting name to search for :type name: str :returns result: List of the matching settings names :rtype result: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } \" ) as settings : for settings_name in settings . childKeys (): if name in settings_name : result . append ( settings_name ) return result get_activity \u00b6 get_activity ( activity_uuid ) Gets an activity object matching the given unique identifier. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity object. required Returns: Type Description Activity Returns the activity object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 def get_activity ( self , activity_uuid : str ) -> typing . Union [ Activity , None ]: \"\"\"Gets an activity object matching the given unique identifier. :param activity_uuid: Unique identifier of the activity object. :type activity_uuid: str :returns: Returns the activity object matching the given identifier else None if not found. :rtype: Activity \"\"\" activity = None activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : activity = settings . value ( activity_uuid , None ) ncs_uuids = [] if activity is not None : activity_dict = {} try : activity_dict = json . loads ( activity ) except json . JSONDecodeError : log ( \"Activity JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in activity_dict : ncs_uuids = activity_dict [ PATHWAYS_ATTRIBUTE ] activity = create_activity ( activity_dict ) if activity is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : activity . add_ncs_pathway ( ncs ) return activity get_all_activities \u00b6 get_all_activities () Get all the activity objects stored in settings. Returns: Type Description list Returns all the activity objects. Source code in src/cplus_plugin/conf.py 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 def get_all_activities ( self ) -> typing . List [ Activity ]: \"\"\"Get all the activity objects stored in settings. :returns: Returns all the activity objects. :rtype: list \"\"\" activities = [] activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : keys = settings . childKeys () for k in keys : activity = self . get_activity ( k ) if activity is not None : activities . append ( activity ) return sorted ( activities , key = lambda activity : activity . name ) get_all_constant_raster_metadata_ids \u00b6 get_all_constant_raster_metadata_ids () Get all constant raster metadata IDs stored in settings. Returns: Type Description List [ str ] List of metadata IDs Source code in src/cplus_plugin/conf.py 1659 1660 1661 1662 1663 1664 1665 1666 def get_all_constant_raster_metadata_ids ( self ) -> typing . List [ str ]: \"\"\"Get all constant raster metadata IDs stored in settings. :returns: List of metadata IDs \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : return settings . childKeys () get_all_layer_mapping \u00b6 get_all_layer_mapping () Return all layer mapping. Returns: Type Description dict All layer mapping Source code in src/cplus_plugin/conf.py 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 def get_all_layer_mapping ( self ) -> typing . Dict : \"\"\"Return all layer mapping. :return: All layer mapping :rtype: dict \"\"\" layer_mapping = {} layer_mapping_root = self . _get_layer_mappings_settings_base () with qgis_settings ( layer_mapping_root ) as settings : keys = settings . childKeys () for k in keys : layer_raw = settings . value ( k , dict ()) if len ( layer_raw ) > 0 : try : layer = json . loads ( layer_raw ) layer_mapping [ k ] = layer except json . JSONDecodeError : log ( \"Layer Mapping JSON is invalid\" ) return layer_mapping get_all_ncs_pathways \u00b6 get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name ) get_constant_raster_collection \u00b6 get_constant_raster_collection ( metadata_id ) Load constant raster collection data from settings. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required Returns: Type Description Optional [ dict ] Dictionary representation of the collection, or None if not found Source code in src/cplus_plugin/conf.py 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 def get_constant_raster_collection ( self , metadata_id : str ) -> typing . Optional [ dict ]: \"\"\"Load constant raster collection data from settings. :param metadata_id: Unique identifier for the metadata :returns: Dictionary representation of the collection, or None if not found \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : json_str = settings . value ( metadata_id , None ) if json_str : return json . loads ( json_str ) return None get_default_layers \u00b6 get_default_layers ( layer_type , as_dict = False ) Returns list of default layers by type. Parameters: Name Type Description Default layer_type str ncs_pathway, priority_layer, or ncs_carbon required Returns: Type Description typing.List[dict] List of dictionary of ncs pathway Source code in src/cplus_plugin/conf.py 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 def get_default_layers ( self , layer_type : str , as_dict = False ) -> typing . List [ dict ]: \"\"\"Returns list of default layers by type. :param layer_type: ncs_pathway, priority_layer, or ncs_carbon :type layer_type: str :return: List of dictionary of ncs pathway :rtype: typing.List[dict] \"\"\" layers = [] default_layers_root = self . _get_default_layers_settings_base () with qgis_settings ( default_layers_root ) as settings : layers_str = settings . value ( layer_type , \"\" ) if layers_str : try : layers = json . loads ( layers_str ) except json . JSONDecodeError : log ( \"Layers JSON is invalid\" ) if as_dict : if layer_type == \"ncs_carbon\" : layers = { f \" { layer [ 'layer_uuid' ] } / { layer [ 'name' ] } \" : layer for layer in layers } else : layers = { layer [ \"layer_uuid\" ]: layer for layer in layers } return layers get_layer_mapping \u00b6 get_layer_mapping ( identifier ) Retrieves the layer mapping that matches the passed identifier. Parameters: Name Type Description Default identifier str Layer mapping identifier required Returns: Type Description typing.Dict Layer mapping Source code in src/cplus_plugin/conf.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_layer_mapping ( self , identifier : str ) -> typing . Dict : \"\"\"Retrieves the layer mapping that matches the passed identifier. :param identifier: Layer mapping identifier :type identifier: str path :return: Layer mapping :rtype: typing.Dict \"\"\" layer_mapping = {} layer_mapping_root = self . _get_layer_mappings_settings_base () with qgis_settings ( layer_mapping_root ) as settings : layer = settings . value ( identifier , dict ()) if len ( layer ) > 0 : try : layer_mapping = json . loads ( layer ) except json . JSONDecodeError : log ( \"Layer Mapping JSON is invalid\" ) return layer_mapping get_metric_configuration \u00b6 get_metric_configuration () Gets the activity metric configuration. Returns: Type Description MetricConfiguration The activity metric configuration or None if not defined or if an error occurred when deserializing. Source code in src/cplus_plugin/conf.py 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 def get_metric_configuration ( self ) -> typing . Optional [ MetricConfiguration ]: \"\"\"Gets the activity metric configuration. :returns: The activity metric configuration or None if not defined or if an error occurred when deserializing. :rtype: MetricConfiguration \"\"\" metric_configuration_str = self . get_value ( METRIC_CONFIGURATION_PROPERTY , None ) if not metric_configuration_str : return None metric_configuration_dict = {} try : metric_configuration_dict = json . loads ( metric_configuration_str ) except json . JSONDecodeError : log ( \"Metric configuration JSON is invalid.\" ) return create_metric_configuration ( metric_configuration_dict , self . get_all_activities () ) get_metric_profile_collection \u00b6 get_metric_profile_collection () Gets the metric profile collection. Returns: Type Description MetricProfileCollection A metric profile collection or None if not defined or an error occurred when deserializing. Source code in src/cplus_plugin/conf.py 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 def get_metric_profile_collection ( self ) -> typing . Optional [ MetricProfileCollection ]: \"\"\"Gets the metric profile collection. :returns: A metric profile collection or None if not defined or an error occurred when deserializing. :rtype: MetricProfileCollection \"\"\" metric_profile_collection_str = self . get_value ( METRIC_COLLECTION_PROPERTY , None ) if not metric_profile_collection_str : return None metric_profile_collection_dict = {} try : metric_profile_collection_dict = json . loads ( metric_profile_collection_str ) except json . JSONDecodeError : log ( \"Metric profile collection JSON is invalid.\" ) return create_metrics_profile_collection ( metric_profile_collection_dict , self . get_all_activities () ) get_nature_base_zonal_stats \u00b6 get_nature_base_zonal_stats () Gets the last saved result set of Naturebase mean zonal stats. Returns: Type Description typing.Optional[ResultInfo] Result set of Naturebase mean zonal stats or None if it does not exist or an error occurred during the deserialization process. Source code in src/cplus_plugin/conf.py 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def get_nature_base_zonal_stats ( self ) -> typing . Optional [ ResultInfo ]: \"\"\"Gets the last saved result set of Naturebase mean zonal stats. :returns: Result set of Naturebase mean zonal stats or None if it does not exist or an error occurred during the deserialization process. :rtype: typing.Optional[ResultInfo] \"\"\" result_info_str = self . get_value ( NATURE_BASE_MEAN_ZONAL_STATS_ATTRIBUTE , None ) if not result_info_str : return None result_info_dict = {} try : result_info_dict = json . loads ( result_info_str ) except json . JSONDecodeError : log ( \"Naturebase zonal stats JSON is invalid.\" ) return None return create_result_info ( result_info_dict ) get_ncs_pathway \u00b6 get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway get_ncs_pathway_dict \u00b6 get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict get_priority_group \u00b6 get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" if identifier is None : return None settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) priority_group [ \"description\" ] = settings . value ( \"description\" ) return priority_group get_priority_groups \u00b6 get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), \"description\" : priority_settings . value ( \"description\" ), } priority_groups . append ( group ) return priority_groups get_priority_layer \u00b6 get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier UUID Priority layers identifier required Returns: Type Description dict Priority layer dict or None if not found. Source code in src/cplus_plugin/conf.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict or None if not found. :rtype: dict \"\"\" priority_layer = None settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] if len ( settings . childKeys ()) <= 0 : return priority_layer with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"user_defined\" ] = settings . value ( \"user_defined\" , defaultValue = True , type = bool ) priority_layer [ \"is_carbon\" ] = settings . value ( \"is_carbon\" , defaultValue = True , type = bool ) priority_layer [ \"type\" ] = settings . value ( \"type\" , defaultValue = 0 , type = int ) priority_layer [ \"groups\" ] = groups return priority_layer get_priority_layers \u00b6 get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"user_defined\" : priority_settings . value ( \"user_defined\" , defaultValue = True , type = bool ), \"type\" : priority_settings . value ( \"type\" , defaultValue = 0 , type = int ), \"groups\" : groups , \"is_carbon\" : priority_settings . value ( \"is_carbon\" , defaultValue = True , type = bool ), } priority_layer_list . append ( layer ) return priority_layer_list get_running_online_scenario \u00b6 get_running_online_scenario () Retrieves running online scenario UUID. Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 def get_running_online_scenario ( self ) -> typing . Dict : \"\"\"Retrieves running online scenario UUID. :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" scenario_settings_key = self . _get_online_tasks_settings_base () with qgis_settings ( scenario_settings_key ) as settings : return settings . value ( self . ONLINE_TASK_BASE ) get_scenario \u00b6 get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( scenario_uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : if scenario_uuid == scenario_id : scenario = ScenarioSettings . from_qgs_settings ( scenario_uuid , scenario_settings ) scenario . extent = scenario . get_scenario_extent ( scenario_uuid ) return scenario return None get_scenario_result \u00b6 get_scenario_result ( scenario_id ) Retrieves the scenario result that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario result Source code in src/cplus_plugin/conf.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def get_scenario_result ( self , scenario_id ): \"\"\"Retrieves the scenario result that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario result :rtype: ScenarioSettings \"\"\" scenario_settings_key = self . _get_scenario_results_settings_base ( scenario_id ) with qgis_settings ( scenario_settings_key ) as scenario_settings : created_date = scenario_settings . value ( \"created_date\" ) analysis_output = scenario_settings . value ( \"analysis_output\" ) output_layer_name = scenario_settings . value ( \"output_layer_name\" ) scenario_directory = scenario_settings . value ( \"scenario_directory\" ) if analysis_output is None : return None try : created_date = datetime . datetime . strptime ( created_date , \"%Y_%m_ %d _%H_%M_%S\" ) analysis_output = json . loads ( analysis_output ) except Exception as e : log ( f \"Problem fetching scenario result, { e } \" ) return None return ScenarioResult ( scenario = None , created_date = created_date , analysis_output = analysis_output , output_layer_name = output_layer_name , scenario_directory = scenario_directory , ) return None get_scenarios \u00b6 get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( scenario_uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( scenario_uuid , scenario_settings ) scenario . extent = scenario . get_scenario_extent ( scenario_uuid ) result . append ( scenario ) return result get_scenarios_results \u00b6 get_scenarios_results () Gets all the saved scenarios results. Returns: Type Description list List of the scenario results Source code in src/cplus_plugin/conf.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def get_scenarios_results ( self ): \"\"\"Gets all the saved scenarios results. :returns: List of the scenario results :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } / { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_results_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : created_date = scenario_settings . value ( \"created_date\" ) analysis_output = scenario_settings . value ( \"analysis_output\" ) output_layer_name = scenario_settings . value ( \"output_layer_name\" ) scenario_directory = scenario_settings . value ( \"scenario_directory\" ) try : created_date = datetime . datetime . strptime ( created_date , \"%Y_%m_ %d _%H_%M_%S\" ) analysis_output = json . loads ( analysis_output ) except Exception as e : log ( f \"Problem fetching scenario result, { e } \" ) return None result . append ( ScenarioResult ( scenario = None , created_date = created_date , analysis_output = analysis_output , output_layer_name = output_layer_name , scenario_directory = scenario_directory , ) ) return result get_value \u00b6 get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default ) load_custom_constant_raster_types \u00b6 load_custom_constant_raster_types () Load custom constant raster type definitions from settings. Returns: Type Description List [ dict ] List of custom type definition dictionaries Source code in src/cplus_plugin/conf.py 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 def load_custom_constant_raster_types ( self ) -> typing . List [ dict ]: \"\"\"Load custom constant raster type definitions from settings. :returns: List of custom type definition dictionaries \"\"\" json_str = self . get_value ( Settings . CUSTOM_CONSTANT_RASTER_TYPES , \"[]\" ) try : return json . loads ( json_str ) if json_str else [] except json . JSONDecodeError : return [] remove \u00b6 remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 361 362 363 364 365 366 367 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" ) remove_activity \u00b6 remove_activity ( activity_uuid ) Removes an activity settings entry using the UUID. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity to be removed. required Source code in src/cplus_plugin/conf.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 def remove_activity ( self , activity_uuid : str ): \"\"\"Removes an activity settings entry using the UUID. :param activity_uuid: Unique identifier of the activity to be removed. :type activity_uuid: str \"\"\" if self . get_activity ( activity_uuid ) is not None : self . remove ( f \" { self . ACTIVITY_BASE } / { activity_uuid } \" ) remove_constant_raster_collection \u00b6 remove_constant_raster_collection ( metadata_id ) Removes the constant raster collection entry with the given identifier. Parameters: Name Type Description Default metadata_id str Unique identifier of the constant raster collection. required Source code in src/cplus_plugin/conf.py 1649 1650 1651 1652 1653 1654 1655 1656 1657 def remove_constant_raster_collection ( self , metadata_id : str ): \"\"\"Removes the constant raster collection entry with the given identifier. :param metadata_id: Unique identifier of the constant raster collection. :type metadata_id: str \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () if self . get_constant_raster_collection ( metadata_id ) is not None : self . remove ( f \" { constant_raster_root } / { metadata_id } \" ) remove_default_layer \u00b6 remove_default_layer ( layer ) Remove default layer from settings. Parameters: Name Type Description Default layer dict layer to be removed required Source code in src/cplus_plugin/conf.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 def remove_default_layer ( self , layer : dict ): \"\"\"Remove default layer from settings. :param layer: layer to be removed :type layer: dict \"\"\" layer_type = layer . get ( \"type\" ) layer_uuid = layer . get ( \"layer_uuid\" ) default_layers = self . get_default_layers ( layer_type ) layers_to_save = [ lyr for lyr in default_layers if lyr [ \"layer_uuid\" ] != layer_uuid ] self . save_default_layers ( layer_type , layers_to_save ) remove_default_layers \u00b6 remove_default_layers () Remove default layers from settings. Source code in src/cplus_plugin/conf.py 1130 1131 1132 def remove_default_layers ( self ): \"\"\"Remove default layers from settings.\"\"\" self . remove ( self . SERVER_DEFAULT_LAYERS ) remove_layer_mapping \u00b6 remove_layer_mapping ( identifier ) Remove layer mapping from settings. Source code in src/cplus_plugin/conf.py 1079 1080 1081 def remove_layer_mapping ( self , identifier : str ): \"\"\"Remove layer mapping from settings.\"\"\" self . remove ( f \" { self . LAYER_MAPPING_BASE } / { identifier } \" ) remove_ncs_pathway \u00b6 remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" ) save_activity \u00b6 save_activity ( activity ) Saves an activity object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default activity Union [ Activity , dict ] Activity object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 def save_activity ( self , activity : typing . Union [ Activity , dict ]): \"\"\"Saves an activity object serialized to a json string indexed by the UUID. :param activity: Activity object or attribute values in a dictionary which are then serialized to a JSON string. :type activity: Activity, dict \"\"\" if isinstance ( activity , Activity ): layer_styles = activity . layer_styles style_pixel_value = activity . style_pixel_value mask_paths = activity . mask_paths ncs_pathways = [] for ncs in activity . pathways : ncs_pathways . append ( str ( ncs . uuid )) activity = layer_component_to_dict ( activity ) activity [ MASK_PATHS_SEGMENT ] = mask_paths activity [ PATHWAYS_ATTRIBUTE ] = ncs_pathways activity [ STYLE_ATTRIBUTE ] = layer_styles activity [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value activity_str = json . dumps ( todict ( activity ), cls = CustomJsonEncoder ) activity_uuid = activity [ UUID_ATTRIBUTE ] activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : settings . setValue ( activity_uuid , activity_str ) save_constant_raster_collection \u00b6 save_constant_raster_collection ( metadata_id , collection_data ) Save constant raster collection data to settings. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required collection_data dict Dictionary representation of the collection required Source code in src/cplus_plugin/conf.py 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 def save_constant_raster_collection ( self , metadata_id : str , collection_data : dict ) -> None : \"\"\"Save constant raster collection data to settings. :param metadata_id: Unique identifier for the metadata :param collection_data: Dictionary representation of the collection \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : json_str = json . dumps ( collection_data ) settings . setValue ( metadata_id , json_str ) save_custom_constant_raster_types \u00b6 save_custom_constant_raster_types ( custom_types ) Save custom constant raster type definitions to settings. Parameters: Name Type Description Default custom_types List [ dict ] List of custom type definition dictionaries required Source code in src/cplus_plugin/conf.py 1668 1669 1670 1671 1672 1673 1674 1675 1676 def save_custom_constant_raster_types ( self , custom_types : typing . List [ dict ] ) -> None : \"\"\"Save custom constant raster type definitions to settings. :param custom_types: List of custom type definition dictionaries \"\"\" json_str = json . dumps ( custom_types ) self . set_value ( Settings . CUSTOM_CONSTANT_RASTER_TYPES , json_str ) save_default_layers \u00b6 save_default_layers ( type , layers ) Save default layers by type Parameters: Name Type Description Default type str ncs_pathway, priority_layer, or ncs_carbon required layers List layer list required Source code in src/cplus_plugin/conf.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def save_default_layers ( self , type : str , layers : typing . List ): \"\"\"Save default layers by type :param type: ncs_pathway, priority_layer, or ncs_carbon :type type: str :param layers: layer list :type layers: typing.List \"\"\" default_layers_root = self . _get_default_layers_settings_base () with qgis_settings ( default_layers_root ) as settings : settings . setValue ( type , json . dumps ( layers )) save_layer_mapping \u00b6 save_layer_mapping ( input_layer , identifier = None ) Save the layer mapping into the plugin settings Parameters: Name Type Description Default input_layer dict Layer mapping required identifier str file identifier using path None Source code in src/cplus_plugin/conf.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 def save_layer_mapping ( self , input_layer : dict , identifier : str = None ): \"\"\"Save the layer mapping into the plugin settings :param input_layer: Layer mapping :type input_layer: dict :param identifier: file identifier using path :type identifier: str \"\"\" if not identifier : identifier = input_layer [ \"path\" ] . replace ( os . sep , \"--\" ) settings_key = self . _get_layer_mappings_settings_base () with qgis_settings ( settings_key ) as settings : settings . setValue ( identifier , json . dumps ( input_layer )) save_metric_configuration \u00b6 save_metric_configuration ( metric_configuration ) Serializes the metric configuration in settings as a JSON string. Parameters: Name Type Description Default metric_configuration MetricConfiguration Activity NPV collection serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1485 1486 1487 1488 1489 1490 1491 1492 1493 def save_metric_configuration ( self , metric_configuration : MetricConfiguration ): \"\"\"Serializes the metric configuration in settings as a JSON string. :param metric_configuration: Activity NPV collection serialized to a JSON string. :type metric_configuration: ActivityNpvCollection \"\"\" metric_configuration_dict = metric_configuration_to_dict ( metric_configuration ) metric_configuration_str = json . dumps ( metric_configuration_dict ) self . set_value ( METRIC_CONFIGURATION_PROPERTY , metric_configuration_str ) save_metric_profile_collection \u00b6 save_metric_profile_collection ( metric_profile_collection ) Serializes a metric profile collection in settings as a JSON string. Parameters: Name Type Description Default metric_profile_collection MetricProfileCollection Collection of metric profile configurations to be serialized. required Source code in src/cplus_plugin/conf.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def save_metric_profile_collection ( self , metric_profile_collection : MetricProfileCollection ): \"\"\"Serializes a metric profile collection in settings as a JSON string. :param metric_profile_collection: Collection of metric profile configurations to be serialized. :type metric_profile_collection: MetricProfileCollection \"\"\" metric_profile_collection_dict = metric_profile_collection_to_dict ( metric_profile_collection ) metric_profile_collection_str = json . dumps ( metric_profile_collection_dict ) self . set_value ( METRIC_COLLECTION_PROPERTY , metric_profile_collection_str ) save_nature_base_zonal_stats \u00b6 save_nature_base_zonal_stats ( result_info ) Saves the results of the calculation of mean zonal stats. Parameters: Name Type Description Default result_info ResultInfo Results from the online calculation of mean zonal statistics of Naturebase layers. required Source code in src/cplus_plugin/conf.py 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 def save_nature_base_zonal_stats ( self , result_info : ResultInfo ): \"\"\"Saves the results of the calculation of mean zonal stats. :param result_info: Results from the online calculation of mean zonal statistics of Naturebase layers. :type result_info: ResultInfo \"\"\" result_info_dict = result_info_to_dict ( result_info ) if not result_info_dict : log ( \"Naturebase zonal stats cannot be saved, result set is empty.\" ) return result_str = json . dumps ( result_info_dict ) self . set_value ( NATURE_BASE_MEAN_ZONAL_STATS_ATTRIBUTE , result_str ) save_ncs_pathway \u00b6 save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str ) save_online_scenario \u00b6 save_online_scenario ( scenario_uuid ) Save the passed scenario settings into the plugin settings as online task Parameters: Name Type Description Default scenario_uuid str Scenario UUID required Source code in src/cplus_plugin/conf.py 1531 1532 1533 1534 1535 1536 1537 def save_online_scenario ( self , scenario_uuid ): \"\"\"Save the passed scenario settings into the plugin settings as online task :param scenario_uuid: Scenario UUID :type scenario_uuid: str \"\"\" settings_manager . set_value ( self . ONLINE_TASK_BASE , scenario_uuid ) save_priority_group \u00b6 save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 976 977 978 979 980 981 982 983 984 985 986 987 988 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ]) settings . setValue ( \"description\" , priority_group . get ( \"description\" )) save_priority_layer \u00b6 save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) settings . setValue ( \"user_defined\" , priority_layer . get ( \"user_defined\" , True )) settings . setValue ( \"is_carbon\" , priority_layer . get ( \"is_carbon\" , False )) settings . setValue ( \"type\" , priority_layer . get ( \"type\" , 0 )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"uuid\" , str ( group . get ( \"uuid\" ))) group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit () save_scenario \u00b6 save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) activities = [] for activity in scenario_settings . activities : if isinstance ( activity , Activity ): layer_styles = activity . layer_styles style_pixel_value = activity . style_pixel_value ncs_pathways = [] for ncs in activity . pathways : ncs_pathways . append ({ str ( ncs . uuid ): ncs . path }) activity = layer_component_to_dict ( activity ) activity [ PATHWAYS_ATTRIBUTE ] = ncs_pathways activity [ STYLE_ATTRIBUTE ] = layer_styles activity [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value activities . append ( json . dumps ( activity )) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"uuid\" , str ( scenario_settings . uuid )) settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"activities\" , activities ) settings . setValue ( \"server_uuid\" , ( str ( scenario_settings . server_uuid ) if scenario_settings . server_uuid else None ), ) settings . setValue ( \"clip_to_studyarea\" , scenario_settings . clip_to_studyarea ) settings . setValue ( \"studyarea_path\" , scenario_settings . studyarea_path ) settings . setValue ( \"crs\" , scenario_settings . crs ) save_scenario_extent \u00b6 save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key str QgsSettings group key required extent SpatialExtent Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key Scenario extent required Source code in src/cplus_plugin/conf.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: QgsSettings group key :type key: str :param extent: Scenario extent :type extent: SpatialExtent Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . bbox spatial_crs = extent . crs spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent ) settings . setValue ( \"crs\" , spatial_crs ) save_scenario_result \u00b6 save_scenario_result ( scenario_result , scenario_id ) Save the scenario results plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def save_scenario_result ( self , scenario_result , scenario_id ): \"\"\"Save the scenario results plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_results_settings_base ( scenario_id ) analysis_output = json . dumps ( scenario_result . analysis_output ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"scenario_id\" , scenario_id ) settings . setValue ( \"created_date\" , scenario_result . created_date . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ), ) settings . setValue ( \"analysis_output\" , analysis_output ) settings . setValue ( \"output_layer_name\" , scenario_result . output_layer_name ) settings . setValue ( \"scenario_directory\" , scenario_result . scenario_directory ) set_current_priority_layer \u00b6 set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 def set_current_priority_layer ( self , identifier : str ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) ) set_value \u00b6 set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value ) update_activities \u00b6 update_activities () Updates the attributes of the existing activities. Source code in src/cplus_plugin/conf.py 1447 1448 1449 1450 1451 1452 def update_activities ( self ): \"\"\"Updates the attributes of the existing activities.\"\"\" activities = self . get_all_activities () for activity in activities : self . update_activity ( activity ) update_activity \u00b6 update_activity ( activity ) Updates the attributes of the activity object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default activity Activity Activity object to be updated. required Source code in src/cplus_plugin/conf.py 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 def update_activity ( self , activity : Activity ): \"\"\"Updates the attributes of the activity object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param activity: Activity object to be updated. :type activity: Activity \"\"\" # Remove then re-insert self . remove_activity ( str ( activity . uuid )) self . save_activity ( activity ) update_constant_raster_collection \u00b6 update_constant_raster_collection ( metadata_id , collection_data ) Update constant raster collection data with the given metadata identifier. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required collection_data dict Dictionary representation of the collection required Source code in src/cplus_plugin/conf.py 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 def update_constant_raster_collection ( self , metadata_id : str , collection_data : dict ): \"\"\"Update constant raster collection data with the given metadata identifier. :param metadata_id: Unique identifier for the metadata :param collection_data: Dictionary representation of the collection \"\"\" if self . get_constant_raster_collection ( metadata_id ) is not None : self . remove_constant_raster_collection ( metadata_id ) self . save_constant_raster_collection ( metadata_id , collection_data ) update_ncs_pathway \u00b6 update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # PWLs path update updated_pwls = [] for layer in ncs_pathway . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path updated_pwls . append ( layer ) ncs_pathway . priority_layers = updated_pwls # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway ) update_ncs_pathways \u00b6 update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs ) qgis_settings \u00b6 qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"Configuration"},{"location":"developer/api/core/api_conf/#configuration","text":"Handles storage and retrieval of the plugin QgsSettings.","title":"Configuration"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings","text":"ScenarioSettings ( uuid , name , description , extent , activities , priority_layer_groups , state = ScenarioState . IDLE , server_uuid = None , clip_to_studyarea = False , studyarea_path = None , crs = None , constant_raster_collection = None ) Bases: Scenario Plugin Scenario settings.","title":"ScenarioSettings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.from_qgs_settings","text":"from_qgs_settings ( identifier , settings ) Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. Parameters: Name Type Description Default identifier str Scenario identifier required settings QgsSettings Scenario identifier required Returns: Type Description ScenarioSettings Scenario settings object Source code in src/cplus_plugin/conf.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 @classmethod def from_qgs_settings ( cls , identifier : str , settings : QgsSettings ): \"\"\"Reads QGIS settings and parses them into a scenario settings instance with the respective settings values as properties. :param identifier: Scenario identifier :type identifier: str :param settings: Scenario identifier :type settings: QgsSettings :returns: Scenario settings object :rtype: ScenarioSettings \"\"\" activities_list = settings . value ( \"activities\" , []) server_uuid = settings . value ( \"server_uuid\" , None ) activities = [] try : for activity in activities_list : setting_activity = json . loads ( activity ) saved_activity = settings_manager . get_activity ( setting_activity . get ( \"uuid\" ) ) if saved_activity is None : continue for pathways in setting_activity [ PATHWAYS_ATTRIBUTE ]: for path_uuid , path in pathways . items (): pathway = settings_manager . get_ncs_pathway ( path_uuid ) if pathway : pathway . path = path saved_activity . add_ncs_pathway ( pathway ) saved_activity . path = setting_activity . get ( \"path\" ) activities . append ( saved_activity ) except Exception as e : log ( f \"Problem fetching saved activities, { e } \" ) return cls ( uuid = uuid . UUID ( identifier ), name = settings . value ( \"name\" , None ), description = settings . value ( \"description\" , None ), extent = [], activities = activities , priority_layer_groups = [], server_uuid = uuid . UUID ( server_uuid ) if server_uuid else None , clip_to_studyarea = settings . value ( \"clip_to_studyarea\" , False ), studyarea_path = settings . value ( \"studyarea_path\" , None ), )","title":"from_qgs_settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.ScenarioSettings.get_scenario_extent","text":"get_scenario_extent ( identifier ) Fetches Scenario extent from the passed scenario settings. Returns: Type Description SpatialExtent Spatial extent instance extent Source code in src/cplus_plugin/conf.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @classmethod def get_scenario_extent ( cls , identifier ): \"\"\"Fetches Scenario extent from the passed scenario settings. :returns: Spatial extent instance extent :rtype: SpatialExtent \"\"\" spatial_key = ( f \" { settings_manager . _get_scenario_settings_base ( identifier ) } /extent/spatial\" ) with qgis_settings ( spatial_key ) as settings : bbox = settings . value ( \"bbox\" , None ) bbox = [ float ( b ) for b in bbox ] crs = settings . value ( \"crs\" , None ) spatial_extent = SpatialExtent ( bbox = bbox , crs = crs ) return spatial_extent","title":"get_scenario_extent"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.Settings","text":"Bases: Enum Plugin settings names","title":"Settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager","text":"Bases: QObject Manages saving/loading settings for the plugin in QgsSettings.","title":"SettingsManager"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_all_scenarios","text":"delete_all_scenarios () Deletes all the plugin scenarios settings. Source code in src/cplus_plugin/conf.py 540 541 542 543 544 545 546 def delete_all_scenarios ( self ): \"\"\"Deletes all the plugin scenarios settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_name in settings . childGroups (): settings . remove ( scenario_name )","title":"delete_all_scenarios"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_all_scenarios_results","text":"delete_all_scenarios_results () Deletes all the plugin scenarios results settings. Source code in src/cplus_plugin/conf.py 656 657 658 659 660 661 662 663 def delete_all_scenarios_results ( self ): \"\"\"Deletes all the plugin scenarios results settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } / { self . SCENARIO_GROUP_NAME } /\" f \" { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for scenario_result in settings . childGroups (): settings . remove ( scenario_result )","title":"delete_all_scenarios_results"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_online_scenario","text":"delete_online_scenario () Delete online scenario from QGIS settings Source code in src/cplus_plugin/conf.py 528 529 530 531 532 533 534 535 536 537 538 def delete_online_scenario ( self ): \"\"\"Delete online scenario from QGIS settings\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): scenario = settings_manager . get_scenario ( scenario_identifier ) if scenario . server_uuid : settings_manager . delete_scenario_result ( scenario_identifier ) settings_manager . delete_scenario ( scenario_identifier )","title":"delete_online_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_online_task","text":"delete_online_task () Delete the online task with the passed scenarion id. Source code in src/cplus_plugin/conf.py 1558 1559 1560 1561 1562 1563 1564 def delete_online_task ( self ): \"\"\"Delete the online task with the passed scenarion id.\"\"\" log ( \"delete online task\" ) with qgis_settings ( self . BASE_GROUP_NAME ) as settings : a = settings . value ( self . ONLINE_TASK_BASE ) log ( a ) settings . remove ( self . ONLINE_TASK_BASE )","title":"delete_online_task"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_group","text":"delete_priority_group ( identifier ) Removes priority group that match the passed identifier Parameters: Name Type Description Default identifier str Priority group identifier required Source code in src/cplus_plugin/conf.py 990 991 992 993 994 995 996 997 998 999 1000 1001 def delete_priority_group ( self , identifier ): \"\"\"Removes priority group that match the passed identifier :param identifier: Priority group identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } /\" ) as settings : for priority_group in settings . childGroups (): if str ( priority_group ) == str ( identifier ): settings . remove ( priority_group )","title":"delete_priority_group"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_groups","text":"delete_priority_groups () Deletes all the plugin priority groups settings. Source code in src/cplus_plugin/conf.py 1003 1004 1005 1006 1007 1008 1009 def delete_priority_groups ( self ): \"\"\"Deletes all the plugin priority groups settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for priority_group in settings . childGroups (): settings . remove ( priority_group )","title":"delete_priority_groups"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layer","text":"delete_priority_layer ( identifier ) Removes priority layer that match the passed identifier Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 879 880 881 882 883 884 885 886 887 888 889 890 def delete_priority_layer ( self , identifier ): \"\"\"Removes priority layer that match the passed identifier :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): if str ( priority_layer ) == str ( identifier ): settings . remove ( priority_layer )","title":"delete_priority_layer"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_priority_layers","text":"delete_priority_layers () Deletes all the plugin priority weighting layers settings. Source code in src/cplus_plugin/conf.py 871 872 873 874 875 876 877 def delete_priority_layers ( self ): \"\"\"Deletes all the plugin priority weighting layers settings.\"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for priority_layer in settings . childGroups (): settings . remove ( priority_layer )","title":"delete_priority_layers"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_scenario","text":"delete_scenario ( scenario_id ) Delete the scenario with the passed scenarion id. Parameters: Name Type Description Default scenario_id str Scenario identifier required Source code in src/cplus_plugin/conf.py 514 515 516 517 518 519 520 521 522 523 524 525 526 def delete_scenario ( self , scenario_id ): \"\"\"Delete the scenario with the passed scenarion id. :param scenario_id: Scenario identifier :type scenario_id: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): if str ( scenario_identifier ) == str ( scenario_id ): settings . remove ( scenario_identifier )","title":"delete_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_scenario_result","text":"delete_scenario_result ( scenario_id ) Delete the scenario result that contains the scenario id. Parameters: Name Type Description Default scenario_id str Scenario identifier required Source code in src/cplus_plugin/conf.py 642 643 644 645 646 647 648 649 650 651 652 653 654 def delete_scenario_result ( self , scenario_id ): \"\"\"Delete the scenario result that contains the scenario id. :param scenario_id: Scenario identifier :type scenario_id: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for scenario_identifier in settings . childGroups (): if str ( scenario_identifier ) == str ( scenario_id ): settings . remove ( scenario_identifier )","title":"delete_scenario_result"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.delete_settings","text":"delete_settings () Deletes the all the plugin settings. Source code in src/cplus_plugin/conf.py 369 370 371 def delete_settings ( self ): \"\"\"Deletes the all the plugin settings.\"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } \" )","title":"delete_settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_activity_by_name","text":"find_activity_by_name ( name ) Finds an activity setting inside the plugin QgsSettings that equals or matches the name. Parameters: Name Type Description Default name str Activity name. required Returns: Type Description Activity Activity object. Source code in src/cplus_plugin/conf.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 def find_activity_by_name ( self , name ) -> typing . Dict : \"\"\"Finds an activity setting inside the plugin QgsSettings that equals or matches the name. :param name: Activity name. :type name: str :returns: Activity object. :rtype: Activity \"\"\" for activity in self . get_all_activities (): model_name = activity . name trimmed_name = model_name . replace ( \" \" , \"_\" ) if model_name == name or model_name in name or trimmed_name in name : return activity return None","title":"find_activity_by_name"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_group_by_name","text":"find_group_by_name ( name ) Finds a priority group setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Name of the group required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 def find_group_by_name ( self , name ) -> typing . Dict : \"\"\"Finds a priority group setting inside the plugin QgsSettings by name. :param name: Name of the group :type name: str :returns: Priority group :rtype: typing.Dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for group_id in settings . childGroups (): group_settings_key = self . _get_priority_groups_settings_base ( group_id ) with qgis_settings ( group_settings_key ) as group_settings_key : group_name = group_settings_key . value ( \"name\" ) if group_name == name : found_id = uuid . UUID ( group_id ) break return self . get_priority_group ( found_id )","title":"find_group_by_name"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layer_by_name","text":"find_layer_by_name ( name ) Finds a priority layer setting inside the plugin QgsSettings by name. Parameters: Name Type Description Default name str Priority layer name. required Returns: Type Description dict Priority layers dict Source code in src/cplus_plugin/conf.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 def find_layer_by_name ( self , name : str ) -> typing . Dict : \"\"\"Finds a priority layer setting inside the plugin QgsSettings by name. :param name: Priority layer name. :type name: str :returns: Priority layers dict :rtype: dict \"\"\" found_id = None with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): layer_settings_key = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( layer_settings_key ) as layer_settings : layer_name = layer_settings . value ( \"name\" ) if layer_name == name : found_id = uuid . UUID ( layer_id ) break return self . get_priority_layer ( found_id ) if found_id is not None else None","title":"find_layer_by_name"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_layers_by_group","text":"find_layers_by_group ( group ) Finds priority layers inside the plugin QgsSettings that contain the given group name. Parameters: Name Type Description Default group str Priority group name. required Returns: Type Description list Priority layers list. Source code in src/cplus_plugin/conf.py 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 def find_layers_by_group ( self , group : str ) -> typing . List : \"\"\"Finds priority layers inside the plugin QgsSettings that contain the given group name. :param group: Priority group name. :type group: str :returns: Priority layers list. :rtype: list \"\"\" layers = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for layer_id in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( layer_id ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : if group == group_settings . value ( \"name\" ): layers . append ( self . get_priority_layer ( layer_id )) return layers","title":"find_layers_by_group"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.find_settings","text":"find_settings ( name ) Returns the plugin setting keys from the plugin root group that matches the passed name Parameters: Name Type Description Default name str Setting name to search for required Returns: Type Description list List of the matching settings names Source code in src/cplus_plugin/conf.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def find_settings ( self , name ): \"\"\"Returns the plugin setting keys from the plugin root group that matches the passed name :param name: Setting name to search for :type name: str :returns result: List of the matching settings names :rtype result: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } \" ) as settings : for settings_name in settings . childKeys (): if name in settings_name : result . append ( settings_name ) return result","title":"find_settings"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_activity","text":"get_activity ( activity_uuid ) Gets an activity object matching the given unique identifier. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity object. required Returns: Type Description Activity Returns the activity object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 def get_activity ( self , activity_uuid : str ) -> typing . Union [ Activity , None ]: \"\"\"Gets an activity object matching the given unique identifier. :param activity_uuid: Unique identifier of the activity object. :type activity_uuid: str :returns: Returns the activity object matching the given identifier else None if not found. :rtype: Activity \"\"\" activity = None activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : activity = settings . value ( activity_uuid , None ) ncs_uuids = [] if activity is not None : activity_dict = {} try : activity_dict = json . loads ( activity ) except json . JSONDecodeError : log ( \"Activity JSON is invalid.\" ) if PATHWAYS_ATTRIBUTE in activity_dict : ncs_uuids = activity_dict [ PATHWAYS_ATTRIBUTE ] activity = create_activity ( activity_dict ) if activity is not None : for ncs_uuid in ncs_uuids : ncs = self . get_ncs_pathway ( ncs_uuid ) if ncs is not None : activity . add_ncs_pathway ( ncs ) return activity","title":"get_activity"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_activities","text":"get_all_activities () Get all the activity objects stored in settings. Returns: Type Description list Returns all the activity objects. Source code in src/cplus_plugin/conf.py 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 def get_all_activities ( self ) -> typing . List [ Activity ]: \"\"\"Get all the activity objects stored in settings. :returns: Returns all the activity objects. :rtype: list \"\"\" activities = [] activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : keys = settings . childKeys () for k in keys : activity = self . get_activity ( k ) if activity is not None : activities . append ( activity ) return sorted ( activities , key = lambda activity : activity . name )","title":"get_all_activities"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_constant_raster_metadata_ids","text":"get_all_constant_raster_metadata_ids () Get all constant raster metadata IDs stored in settings. Returns: Type Description List [ str ] List of metadata IDs Source code in src/cplus_plugin/conf.py 1659 1660 1661 1662 1663 1664 1665 1666 def get_all_constant_raster_metadata_ids ( self ) -> typing . List [ str ]: \"\"\"Get all constant raster metadata IDs stored in settings. :returns: List of metadata IDs \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : return settings . childKeys ()","title":"get_all_constant_raster_metadata_ids"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_layer_mapping","text":"get_all_layer_mapping () Return all layer mapping. Returns: Type Description dict All layer mapping Source code in src/cplus_plugin/conf.py 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 def get_all_layer_mapping ( self ) -> typing . Dict : \"\"\"Return all layer mapping. :return: All layer mapping :rtype: dict \"\"\" layer_mapping = {} layer_mapping_root = self . _get_layer_mappings_settings_base () with qgis_settings ( layer_mapping_root ) as settings : keys = settings . childKeys () for k in keys : layer_raw = settings . value ( k , dict ()) if len ( layer_raw ) > 0 : try : layer = json . loads ( layer_raw ) layer_mapping [ k ] = layer except json . JSONDecodeError : log ( \"Layer Mapping JSON is invalid\" ) return layer_mapping","title":"get_all_layer_mapping"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_all_ncs_pathways","text":"get_all_ncs_pathways () Get all the NCS pathway objects stored in settings. Returns: Type Description list Returns all the NCS pathway objects. Source code in src/cplus_plugin/conf.py 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 def get_all_ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Get all the NCS pathway objects stored in settings. :returns: Returns all the NCS pathway objects. :rtype: list \"\"\" ncs_pathways = [] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : keys = settings . childKeys () for k in keys : ncs_pathway = self . get_ncs_pathway ( k ) if ncs_pathway is not None : ncs_pathways . append ( ncs_pathway ) return sorted ( ncs_pathways , key = lambda ncs : ncs . name )","title":"get_all_ncs_pathways"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_constant_raster_collection","text":"get_constant_raster_collection ( metadata_id ) Load constant raster collection data from settings. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required Returns: Type Description Optional [ dict ] Dictionary representation of the collection, or None if not found Source code in src/cplus_plugin/conf.py 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 def get_constant_raster_collection ( self , metadata_id : str ) -> typing . Optional [ dict ]: \"\"\"Load constant raster collection data from settings. :param metadata_id: Unique identifier for the metadata :returns: Dictionary representation of the collection, or None if not found \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : json_str = settings . value ( metadata_id , None ) if json_str : return json . loads ( json_str ) return None","title":"get_constant_raster_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_default_layers","text":"get_default_layers ( layer_type , as_dict = False ) Returns list of default layers by type. Parameters: Name Type Description Default layer_type str ncs_pathway, priority_layer, or ncs_carbon required Returns: Type Description typing.List[dict] List of dictionary of ncs pathway Source code in src/cplus_plugin/conf.py 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 def get_default_layers ( self , layer_type : str , as_dict = False ) -> typing . List [ dict ]: \"\"\"Returns list of default layers by type. :param layer_type: ncs_pathway, priority_layer, or ncs_carbon :type layer_type: str :return: List of dictionary of ncs pathway :rtype: typing.List[dict] \"\"\" layers = [] default_layers_root = self . _get_default_layers_settings_base () with qgis_settings ( default_layers_root ) as settings : layers_str = settings . value ( layer_type , \"\" ) if layers_str : try : layers = json . loads ( layers_str ) except json . JSONDecodeError : log ( \"Layers JSON is invalid\" ) if as_dict : if layer_type == \"ncs_carbon\" : layers = { f \" { layer [ 'layer_uuid' ] } / { layer [ 'name' ] } \" : layer for layer in layers } else : layers = { layer [ \"layer_uuid\" ]: layer for layer in layers } return layers","title":"get_default_layers"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_layer_mapping","text":"get_layer_mapping ( identifier ) Retrieves the layer mapping that matches the passed identifier. Parameters: Name Type Description Default identifier str Layer mapping identifier required Returns: Type Description typing.Dict Layer mapping Source code in src/cplus_plugin/conf.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 def get_layer_mapping ( self , identifier : str ) -> typing . Dict : \"\"\"Retrieves the layer mapping that matches the passed identifier. :param identifier: Layer mapping identifier :type identifier: str path :return: Layer mapping :rtype: typing.Dict \"\"\" layer_mapping = {} layer_mapping_root = self . _get_layer_mappings_settings_base () with qgis_settings ( layer_mapping_root ) as settings : layer = settings . value ( identifier , dict ()) if len ( layer ) > 0 : try : layer_mapping = json . loads ( layer ) except json . JSONDecodeError : log ( \"Layer Mapping JSON is invalid\" ) return layer_mapping","title":"get_layer_mapping"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_metric_configuration","text":"get_metric_configuration () Gets the activity metric configuration. Returns: Type Description MetricConfiguration The activity metric configuration or None if not defined or if an error occurred when deserializing. Source code in src/cplus_plugin/conf.py 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 def get_metric_configuration ( self ) -> typing . Optional [ MetricConfiguration ]: \"\"\"Gets the activity metric configuration. :returns: The activity metric configuration or None if not defined or if an error occurred when deserializing. :rtype: MetricConfiguration \"\"\" metric_configuration_str = self . get_value ( METRIC_CONFIGURATION_PROPERTY , None ) if not metric_configuration_str : return None metric_configuration_dict = {} try : metric_configuration_dict = json . loads ( metric_configuration_str ) except json . JSONDecodeError : log ( \"Metric configuration JSON is invalid.\" ) return create_metric_configuration ( metric_configuration_dict , self . get_all_activities () )","title":"get_metric_configuration"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_metric_profile_collection","text":"get_metric_profile_collection () Gets the metric profile collection. Returns: Type Description MetricProfileCollection A metric profile collection or None if not defined or an error occurred when deserializing. Source code in src/cplus_plugin/conf.py 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 def get_metric_profile_collection ( self ) -> typing . Optional [ MetricProfileCollection ]: \"\"\"Gets the metric profile collection. :returns: A metric profile collection or None if not defined or an error occurred when deserializing. :rtype: MetricProfileCollection \"\"\" metric_profile_collection_str = self . get_value ( METRIC_COLLECTION_PROPERTY , None ) if not metric_profile_collection_str : return None metric_profile_collection_dict = {} try : metric_profile_collection_dict = json . loads ( metric_profile_collection_str ) except json . JSONDecodeError : log ( \"Metric profile collection JSON is invalid.\" ) return create_metrics_profile_collection ( metric_profile_collection_dict , self . get_all_activities () )","title":"get_metric_profile_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_nature_base_zonal_stats","text":"get_nature_base_zonal_stats () Gets the last saved result set of Naturebase mean zonal stats. Returns: Type Description typing.Optional[ResultInfo] Result set of Naturebase mean zonal stats or None if it does not exist or an error occurred during the deserialization process. Source code in src/cplus_plugin/conf.py 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 def get_nature_base_zonal_stats ( self ) -> typing . Optional [ ResultInfo ]: \"\"\"Gets the last saved result set of Naturebase mean zonal stats. :returns: Result set of Naturebase mean zonal stats or None if it does not exist or an error occurred during the deserialization process. :rtype: typing.Optional[ResultInfo] \"\"\" result_info_str = self . get_value ( NATURE_BASE_MEAN_ZONAL_STATS_ATTRIBUTE , None ) if not result_info_str : return None result_info_dict = {} try : result_info_dict = json . loads ( result_info_str ) except json . JSONDecodeError : log ( \"Naturebase zonal stats JSON is invalid.\" ) return None return create_result_info ( result_info_dict )","title":"get_nature_base_zonal_stats"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway","text":"get_ncs_pathway ( ncs_uuid ) Gets an NCS pathway object matching the given unique identified. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description NcsPathway Returns the NCS pathway object matching the given identifier else None if not found. Source code in src/cplus_plugin/conf.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 def get_ncs_pathway ( self , ncs_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Gets an NCS pathway object matching the given unique identified. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway object matching the given identifier else None if not found. :rtype: NcsPathway \"\"\" ncs_pathway = None ncs_dict = self . get_ncs_pathway_dict ( ncs_uuid ) if len ( ncs_dict ) == 0 : return None ncs_pathway = create_ncs_pathway ( ncs_dict ) return ncs_pathway","title":"get_ncs_pathway"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_ncs_pathway_dict","text":"get_ncs_pathway_dict ( ncs_uuid ) Gets an NCS pathway attribute values as a dictionary. Parameters: Name Type Description Default ncs_uuid str Unique identifier for the NCS pathway object. required Returns: Type Description dict Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. Source code in src/cplus_plugin/conf.py 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 def get_ncs_pathway_dict ( self , ncs_uuid : str ) -> dict : \"\"\"Gets an NCS pathway attribute values as a dictionary. :param ncs_uuid: Unique identifier for the NCS pathway object. :type ncs_uuid: str :returns: Returns the NCS pathway attribute values matching the given identifier else an empty dictionary if not found. :rtype: dict \"\"\" ncs_pathway_dict = {} ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : ncs_model = settings . value ( ncs_uuid , dict ()) if len ( ncs_model ) > 0 : try : ncs_pathway_dict = json . loads ( ncs_model ) except json . JSONDecodeError : log ( \"NCS pathway JSON is invalid\" ) return ncs_pathway_dict","title":"get_ncs_pathway_dict"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_group","text":"get_priority_group ( identifier ) Retrieves the priority group that matches the passed identifier. Parameters: Name Type Description Default identifier str Priority group identifier required Returns: Type Description typing.Dict Priority group Source code in src/cplus_plugin/conf.py 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 def get_priority_group ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority group that matches the passed identifier. :param identifier: Priority group identifier :type identifier: str :returns: Priority group :rtype: typing.Dict \"\"\" if identifier is None : return None settings_key = self . _get_priority_groups_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : priority_group = { \"uuid\" : identifier } priority_group [ \"name\" ] = settings . value ( \"name\" ) priority_group [ \"value\" ] = settings . value ( \"value\" ) priority_group [ \"description\" ] = settings . value ( \"description\" ) return priority_group","title":"get_priority_group"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_groups","text":"get_priority_groups () Gets all the available priority groups in the plugin. Returns: Type Description list List of the priority groups instances Source code in src/cplus_plugin/conf.py 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 def get_priority_groups ( self ) -> typing . List [ typing . Dict ]: \"\"\"Gets all the available priority groups in the plugin. :returns: List of the priority groups instances :rtype: list \"\"\" priority_groups = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_groups_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : group = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"value\" : priority_settings . value ( \"value\" ), \"description\" : priority_settings . value ( \"description\" ), } priority_groups . append ( group ) return priority_groups","title":"get_priority_groups"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layer","text":"get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier UUID Priority layers identifier required Returns: Type Description dict Priority layer dict or None if not found. Source code in src/cplus_plugin/conf.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict or None if not found. :rtype: dict \"\"\" priority_layer = None settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as settings : groups_key = f \" { settings_key } /groups\" groups = [] if len ( settings . childKeys ()) <= 0 : return priority_layer with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) priority_layer = { \"uuid\" : str ( identifier )} priority_layer [ \"name\" ] = settings . value ( \"name\" ) priority_layer [ \"description\" ] = settings . value ( \"description\" ) priority_layer [ \"path\" ] = settings . value ( \"path\" ) priority_layer [ \"selected\" ] = settings . value ( \"selected\" , type = bool ) priority_layer [ \"user_defined\" ] = settings . value ( \"user_defined\" , defaultValue = True , type = bool ) priority_layer [ \"is_carbon\" ] = settings . value ( \"is_carbon\" , defaultValue = True , type = bool ) priority_layer [ \"type\" ] = settings . value ( \"type\" , defaultValue = 0 , type = int ) priority_layer [ \"groups\" ] = groups return priority_layer","title":"get_priority_layer"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_priority_layers","text":"get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/conf.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" priority_layer_list = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): priority_layer_settings = self . _get_priority_layers_settings_base ( uuid ) with qgis_settings ( priority_layer_settings ) as priority_settings : groups_key = f \" { priority_layer_settings } /groups\" groups = [] with qgis_settings ( groups_key ) as groups_settings : for name in groups_settings . childGroups (): group_settings_key = f \" { groups_key } / { name } \" with qgis_settings ( group_settings_key ) as group_settings : stored_group = {} stored_group [ \"uuid\" ] = group_settings . value ( \"uuid\" ) stored_group [ \"name\" ] = group_settings . value ( \"name\" ) stored_group [ \"value\" ] = group_settings . value ( \"value\" ) groups . append ( stored_group ) layer = { \"uuid\" : uuid , \"name\" : priority_settings . value ( \"name\" ), \"description\" : priority_settings . value ( \"description\" ), \"path\" : priority_settings . value ( \"path\" ), \"selected\" : priority_settings . value ( \"selected\" , type = bool ), \"user_defined\" : priority_settings . value ( \"user_defined\" , defaultValue = True , type = bool ), \"type\" : priority_settings . value ( \"type\" , defaultValue = 0 , type = int ), \"groups\" : groups , \"is_carbon\" : priority_settings . value ( \"is_carbon\" , defaultValue = True , type = bool ), } priority_layer_list . append ( layer ) return priority_layer_list","title":"get_priority_layers"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_running_online_scenario","text":"get_running_online_scenario () Retrieves running online scenario UUID. Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 def get_running_online_scenario ( self ) -> typing . Dict : \"\"\"Retrieves running online scenario UUID. :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" scenario_settings_key = self . _get_online_tasks_settings_base () with qgis_settings ( scenario_settings_key ) as settings : return settings . value ( self . ONLINE_TASK_BASE )","title":"get_running_online_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenario","text":"get_scenario ( scenario_id ) Retrieves the first scenario that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario settings instance Source code in src/cplus_plugin/conf.py 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 def get_scenario ( self , scenario_id ): \"\"\"Retrieves the first scenario that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario settings instance :rtype: ScenarioSettings \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( scenario_uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : if scenario_uuid == scenario_id : scenario = ScenarioSettings . from_qgs_settings ( scenario_uuid , scenario_settings ) scenario . extent = scenario . get_scenario_extent ( scenario_uuid ) return scenario return None","title":"get_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenario_result","text":"get_scenario_result ( scenario_id ) Retrieves the scenario result that matched the passed scenario id. Parameters: Name Type Description Default scenario_id str Scenario id required Returns: Type Description ScenarioSettings Scenario result Source code in src/cplus_plugin/conf.py 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def get_scenario_result ( self , scenario_id ): \"\"\"Retrieves the scenario result that matched the passed scenario id. :param scenario_id: Scenario id :type scenario_id: str :returns: Scenario result :rtype: ScenarioSettings \"\"\" scenario_settings_key = self . _get_scenario_results_settings_base ( scenario_id ) with qgis_settings ( scenario_settings_key ) as scenario_settings : created_date = scenario_settings . value ( \"created_date\" ) analysis_output = scenario_settings . value ( \"analysis_output\" ) output_layer_name = scenario_settings . value ( \"output_layer_name\" ) scenario_directory = scenario_settings . value ( \"scenario_directory\" ) if analysis_output is None : return None try : created_date = datetime . datetime . strptime ( created_date , \"%Y_%m_ %d _%H_%M_%S\" ) analysis_output = json . loads ( analysis_output ) except Exception as e : log ( f \"Problem fetching scenario result, { e } \" ) return None return ScenarioResult ( scenario = None , created_date = created_date , analysis_output = analysis_output , output_layer_name = output_layer_name , scenario_directory = scenario_directory , ) return None","title":"get_scenario_result"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenarios","text":"get_scenarios () Gets all the available scenarios settings in the plugin. Returns: Type Description list List of the scenario settings instances Source code in src/cplus_plugin/conf.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def get_scenarios ( self ): \"\"\"Gets all the available scenarios settings in the plugin. :returns: List of the scenario settings instances :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . SCENARIO_GROUP_NAME } \" ) as settings : for scenario_uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_settings_base ( scenario_uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : scenario = ScenarioSettings . from_qgs_settings ( scenario_uuid , scenario_settings ) scenario . extent = scenario . get_scenario_extent ( scenario_uuid ) result . append ( scenario ) return result","title":"get_scenarios"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_scenarios_results","text":"get_scenarios_results () Gets all the saved scenarios results. Returns: Type Description list List of the scenario results Source code in src/cplus_plugin/conf.py 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 def get_scenarios_results ( self ): \"\"\"Gets all the saved scenarios results. :returns: List of the scenario results :rtype: list \"\"\" result = [] with qgis_settings ( f \" { self . BASE_GROUP_NAME } / { self . SCENARIO_RESULTS_GROUP_NAME } \" ) as settings : for uuid in settings . childGroups (): scenario_settings_key = self . _get_scenario_results_settings_base ( uuid ) with qgis_settings ( scenario_settings_key ) as scenario_settings : created_date = scenario_settings . value ( \"created_date\" ) analysis_output = scenario_settings . value ( \"analysis_output\" ) output_layer_name = scenario_settings . value ( \"output_layer_name\" ) scenario_directory = scenario_settings . value ( \"scenario_directory\" ) try : created_date = datetime . datetime . strptime ( created_date , \"%Y_%m_ %d _%H_%M_%S\" ) analysis_output = json . loads ( analysis_output ) except Exception as e : log ( f \"Problem fetching scenario result, { e } \" ) return None result . append ( ScenarioResult ( scenario = None , created_date = created_date , analysis_output = analysis_output , output_layer_name = output_layer_name , scenario_directory = scenario_directory , ) ) return result","title":"get_scenarios_results"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.get_value","text":"get_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/conf.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 def get_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" if setting_type : return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default , setting_type ) return self . settings . value ( f \" { self . BASE_GROUP_NAME } / { name } \" , default )","title":"get_value"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.load_custom_constant_raster_types","text":"load_custom_constant_raster_types () Load custom constant raster type definitions from settings. Returns: Type Description List [ dict ] List of custom type definition dictionaries Source code in src/cplus_plugin/conf.py 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 def load_custom_constant_raster_types ( self ) -> typing . List [ dict ]: \"\"\"Load custom constant raster type definitions from settings. :returns: List of custom type definition dictionaries \"\"\" json_str = self . get_value ( Settings . CUSTOM_CONSTANT_RASTER_TYPES , \"[]\" ) try : return json . loads ( json_str ) if json_str else [] except json . JSONDecodeError : return []","title":"load_custom_constant_raster_types"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove","text":"remove ( name ) Remove the setting with the specified name. Parameters: Name Type Description Default name str Name of the setting key required Source code in src/cplus_plugin/conf.py 361 362 363 364 365 366 367 def remove ( self , name ): \"\"\"Remove the setting with the specified name. :param name: Name of the setting key :type name: str \"\"\" self . settings . remove ( f \" { self . BASE_GROUP_NAME } / { name } \" )","title":"remove"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_activity","text":"remove_activity ( activity_uuid ) Removes an activity settings entry using the UUID. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity to be removed. required Source code in src/cplus_plugin/conf.py 1454 1455 1456 1457 1458 1459 1460 1461 1462 def remove_activity ( self , activity_uuid : str ): \"\"\"Removes an activity settings entry using the UUID. :param activity_uuid: Unique identifier of the activity to be removed. :type activity_uuid: str \"\"\" if self . get_activity ( activity_uuid ) is not None : self . remove ( f \" { self . ACTIVITY_BASE } / { activity_uuid } \" )","title":"remove_activity"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_constant_raster_collection","text":"remove_constant_raster_collection ( metadata_id ) Removes the constant raster collection entry with the given identifier. Parameters: Name Type Description Default metadata_id str Unique identifier of the constant raster collection. required Source code in src/cplus_plugin/conf.py 1649 1650 1651 1652 1653 1654 1655 1656 1657 def remove_constant_raster_collection ( self , metadata_id : str ): \"\"\"Removes the constant raster collection entry with the given identifier. :param metadata_id: Unique identifier of the constant raster collection. :type metadata_id: str \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () if self . get_constant_raster_collection ( metadata_id ) is not None : self . remove ( f \" { constant_raster_root } / { metadata_id } \" )","title":"remove_constant_raster_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_default_layer","text":"remove_default_layer ( layer ) Remove default layer from settings. Parameters: Name Type Description Default layer dict layer to be removed required Source code in src/cplus_plugin/conf.py 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 def remove_default_layer ( self , layer : dict ): \"\"\"Remove default layer from settings. :param layer: layer to be removed :type layer: dict \"\"\" layer_type = layer . get ( \"type\" ) layer_uuid = layer . get ( \"layer_uuid\" ) default_layers = self . get_default_layers ( layer_type ) layers_to_save = [ lyr for lyr in default_layers if lyr [ \"layer_uuid\" ] != layer_uuid ] self . save_default_layers ( layer_type , layers_to_save )","title":"remove_default_layer"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_default_layers","text":"remove_default_layers () Remove default layers from settings. Source code in src/cplus_plugin/conf.py 1130 1131 1132 def remove_default_layers ( self ): \"\"\"Remove default layers from settings.\"\"\" self . remove ( self . SERVER_DEFAULT_LAYERS )","title":"remove_default_layers"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_layer_mapping","text":"remove_layer_mapping ( identifier ) Remove layer mapping from settings. Source code in src/cplus_plugin/conf.py 1079 1080 1081 def remove_layer_mapping ( self , identifier : str ): \"\"\"Remove layer mapping from settings.\"\"\" self . remove ( f \" { self . LAYER_MAPPING_BASE } / { identifier } \" )","title":"remove_layer_mapping"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Removes an NCS pathway settings entry using the UUID. Parameters: Name Type Description Default ncs_uuid str Unique identifier of the NCS pathway entry to removed. required Source code in src/cplus_plugin/conf.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 def remove_ncs_pathway ( self , ncs_uuid : str ): \"\"\"Removes an NCS pathway settings entry using the UUID. :param ncs_uuid: Unique identifier of the NCS pathway entry to removed. :type ncs_uuid: str \"\"\" if self . get_ncs_pathway ( ncs_uuid ) is not None : self . remove ( f \" { self . NCS_PATHWAY_BASE } / { ncs_uuid } \" )","title":"remove_ncs_pathway"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_activity","text":"save_activity ( activity ) Saves an activity object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default activity Union [ Activity , dict ] Activity object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 def save_activity ( self , activity : typing . Union [ Activity , dict ]): \"\"\"Saves an activity object serialized to a json string indexed by the UUID. :param activity: Activity object or attribute values in a dictionary which are then serialized to a JSON string. :type activity: Activity, dict \"\"\" if isinstance ( activity , Activity ): layer_styles = activity . layer_styles style_pixel_value = activity . style_pixel_value mask_paths = activity . mask_paths ncs_pathways = [] for ncs in activity . pathways : ncs_pathways . append ( str ( ncs . uuid )) activity = layer_component_to_dict ( activity ) activity [ MASK_PATHS_SEGMENT ] = mask_paths activity [ PATHWAYS_ATTRIBUTE ] = ncs_pathways activity [ STYLE_ATTRIBUTE ] = layer_styles activity [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value activity_str = json . dumps ( todict ( activity ), cls = CustomJsonEncoder ) activity_uuid = activity [ UUID_ATTRIBUTE ] activity_root = self . _get_activity_settings_base () with qgis_settings ( activity_root ) as settings : settings . setValue ( activity_uuid , activity_str )","title":"save_activity"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_constant_raster_collection","text":"save_constant_raster_collection ( metadata_id , collection_data ) Save constant raster collection data to settings. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required collection_data dict Dictionary representation of the collection required Source code in src/cplus_plugin/conf.py 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 def save_constant_raster_collection ( self , metadata_id : str , collection_data : dict ) -> None : \"\"\"Save constant raster collection data to settings. :param metadata_id: Unique identifier for the metadata :param collection_data: Dictionary representation of the collection \"\"\" constant_raster_root = self . _get_constant_raster_collection_settings_base () with qgis_settings ( constant_raster_root ) as settings : json_str = json . dumps ( collection_data ) settings . setValue ( metadata_id , json_str )","title":"save_constant_raster_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_custom_constant_raster_types","text":"save_custom_constant_raster_types ( custom_types ) Save custom constant raster type definitions to settings. Parameters: Name Type Description Default custom_types List [ dict ] List of custom type definition dictionaries required Source code in src/cplus_plugin/conf.py 1668 1669 1670 1671 1672 1673 1674 1675 1676 def save_custom_constant_raster_types ( self , custom_types : typing . List [ dict ] ) -> None : \"\"\"Save custom constant raster type definitions to settings. :param custom_types: List of custom type definition dictionaries \"\"\" json_str = json . dumps ( custom_types ) self . set_value ( Settings . CUSTOM_CONSTANT_RASTER_TYPES , json_str )","title":"save_custom_constant_raster_types"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_default_layers","text":"save_default_layers ( type , layers ) Save default layers by type Parameters: Name Type Description Default type str ncs_pathway, priority_layer, or ncs_carbon required layers List layer list required Source code in src/cplus_plugin/conf.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 def save_default_layers ( self , type : str , layers : typing . List ): \"\"\"Save default layers by type :param type: ncs_pathway, priority_layer, or ncs_carbon :type type: str :param layers: layer list :type layers: typing.List \"\"\" default_layers_root = self . _get_default_layers_settings_base () with qgis_settings ( default_layers_root ) as settings : settings . setValue ( type , json . dumps ( layers ))","title":"save_default_layers"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_layer_mapping","text":"save_layer_mapping ( input_layer , identifier = None ) Save the layer mapping into the plugin settings Parameters: Name Type Description Default input_layer dict Layer mapping required identifier str file identifier using path None Source code in src/cplus_plugin/conf.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 def save_layer_mapping ( self , input_layer : dict , identifier : str = None ): \"\"\"Save the layer mapping into the plugin settings :param input_layer: Layer mapping :type input_layer: dict :param identifier: file identifier using path :type identifier: str \"\"\" if not identifier : identifier = input_layer [ \"path\" ] . replace ( os . sep , \"--\" ) settings_key = self . _get_layer_mappings_settings_base () with qgis_settings ( settings_key ) as settings : settings . setValue ( identifier , json . dumps ( input_layer ))","title":"save_layer_mapping"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_metric_configuration","text":"save_metric_configuration ( metric_configuration ) Serializes the metric configuration in settings as a JSON string. Parameters: Name Type Description Default metric_configuration MetricConfiguration Activity NPV collection serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1485 1486 1487 1488 1489 1490 1491 1492 1493 def save_metric_configuration ( self , metric_configuration : MetricConfiguration ): \"\"\"Serializes the metric configuration in settings as a JSON string. :param metric_configuration: Activity NPV collection serialized to a JSON string. :type metric_configuration: ActivityNpvCollection \"\"\" metric_configuration_dict = metric_configuration_to_dict ( metric_configuration ) metric_configuration_str = json . dumps ( metric_configuration_dict ) self . set_value ( METRIC_CONFIGURATION_PROPERTY , metric_configuration_str )","title":"save_metric_configuration"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_metric_profile_collection","text":"save_metric_profile_collection ( metric_profile_collection ) Serializes a metric profile collection in settings as a JSON string. Parameters: Name Type Description Default metric_profile_collection MetricProfileCollection Collection of metric profile configurations to be serialized. required Source code in src/cplus_plugin/conf.py 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def save_metric_profile_collection ( self , metric_profile_collection : MetricProfileCollection ): \"\"\"Serializes a metric profile collection in settings as a JSON string. :param metric_profile_collection: Collection of metric profile configurations to be serialized. :type metric_profile_collection: MetricProfileCollection \"\"\" metric_profile_collection_dict = metric_profile_collection_to_dict ( metric_profile_collection ) metric_profile_collection_str = json . dumps ( metric_profile_collection_dict ) self . set_value ( METRIC_COLLECTION_PROPERTY , metric_profile_collection_str )","title":"save_metric_profile_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_nature_base_zonal_stats","text":"save_nature_base_zonal_stats ( result_info ) Saves the results of the calculation of mean zonal stats. Parameters: Name Type Description Default result_info ResultInfo Results from the online calculation of mean zonal statistics of Naturebase layers. required Source code in src/cplus_plugin/conf.py 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 def save_nature_base_zonal_stats ( self , result_info : ResultInfo ): \"\"\"Saves the results of the calculation of mean zonal stats. :param result_info: Results from the online calculation of mean zonal statistics of Naturebase layers. :type result_info: ResultInfo \"\"\" result_info_dict = result_info_to_dict ( result_info ) if not result_info_dict : log ( \"Naturebase zonal stats cannot be saved, result set is empty.\" ) return result_str = json . dumps ( result_info_dict ) self . set_value ( NATURE_BASE_MEAN_ZONAL_STATS_ATTRIBUTE , result_str )","title":"save_nature_base_zonal_stats"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_ncs_pathway","text":"save_ncs_pathway ( ncs_pathway ) Saves an NCS pathway object serialized to a json string indexed by the UUID. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , dict ] NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. required Source code in src/cplus_plugin/conf.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 def save_ncs_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , dict ]): \"\"\"Saves an NCS pathway object serialized to a json string indexed by the UUID. :param ncs_pathway: NCS pathway object or attribute values in a dictionary which are then serialized to a JSON string. :type ncs_pathway: NcsPathway, dict \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_pathway = ncs_pathway_to_dict ( ncs_pathway ) ncs_str = json . dumps ( ncs_pathway ) ncs_uuid = ncs_pathway [ UUID_ATTRIBUTE ] ncs_root = self . _get_ncs_pathway_settings_base () with qgis_settings ( ncs_root ) as settings : settings . setValue ( ncs_uuid , ncs_str )","title":"save_ncs_pathway"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_online_scenario","text":"save_online_scenario ( scenario_uuid ) Save the passed scenario settings into the plugin settings as online task Parameters: Name Type Description Default scenario_uuid str Scenario UUID required Source code in src/cplus_plugin/conf.py 1531 1532 1533 1534 1535 1536 1537 def save_online_scenario ( self , scenario_uuid ): \"\"\"Save the passed scenario settings into the plugin settings as online task :param scenario_uuid: Scenario UUID :type scenario_uuid: str \"\"\" settings_manager . set_value ( self . ONLINE_TASK_BASE , scenario_uuid )","title":"save_online_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_group","text":"save_priority_group ( priority_group ) Save the priority group into the plugin settings Parameters: Name Type Description Default priority_group str Priority group required Source code in src/cplus_plugin/conf.py 976 977 978 979 980 981 982 983 984 985 986 987 988 def save_priority_group ( self , priority_group ): \"\"\"Save the priority group into the plugin settings :param priority_group: Priority group :type priority_group: str \"\"\" settings_key = self . _get_priority_groups_settings_base ( priority_group [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"name\" , priority_group [ \"name\" ]) settings . setValue ( \"value\" , priority_group [ \"value\" ]) settings . setValue ( \"description\" , priority_group . get ( \"description\" ))","title":"save_priority_group"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_priority_layer","text":"save_priority_layer ( priority_layer ) Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal Parameters: Name Type Description Default priority_layer dict Priority layer required Source code in src/cplus_plugin/conf.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 def save_priority_layer ( self , priority_layer ): \"\"\"Save the priority layer into the plugin settings. Updates the layer with new priority groups. Note: Emits priority_layers_changed signal :param priority_layer: Priority layer :type priority_layer: dict \"\"\" settings_key = self . _get_priority_layers_settings_base ( priority_layer [ \"uuid\" ]) with qgis_settings ( settings_key ) as settings : groups = priority_layer . get ( \"groups\" , []) settings . setValue ( \"name\" , priority_layer [ \"name\" ]) settings . setValue ( \"description\" , priority_layer [ \"description\" ]) settings . setValue ( \"path\" , priority_layer [ \"path\" ]) settings . setValue ( \"selected\" , priority_layer . get ( \"selected\" , False )) settings . setValue ( \"user_defined\" , priority_layer . get ( \"user_defined\" , True )) settings . setValue ( \"is_carbon\" , priority_layer . get ( \"is_carbon\" , False )) settings . setValue ( \"type\" , priority_layer . get ( \"type\" , 0 )) groups_key = f \" { settings_key } /groups\" with qgis_settings ( groups_key ) as groups_settings : for group_id in groups_settings . childGroups (): groups_settings . remove ( group_id ) for group in groups : group_key = f \" { groups_key } / { group [ 'name' ] } \" with qgis_settings ( group_key ) as group_settings : group_settings . setValue ( \"uuid\" , str ( group . get ( \"uuid\" ))) group_settings . setValue ( \"name\" , group [ \"name\" ]) group_settings . setValue ( \"value\" , group [ \"value\" ]) self . priority_layers_changed . emit ()","title":"save_priority_layer"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario","text":"save_scenario ( scenario_settings ) Save the passed scenario settings into the plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 def save_scenario ( self , scenario_settings ): \"\"\"Save the passed scenario settings into the plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_settings_base ( scenario_settings . uuid ) self . save_scenario_extent ( settings_key , scenario_settings . extent ) activities = [] for activity in scenario_settings . activities : if isinstance ( activity , Activity ): layer_styles = activity . layer_styles style_pixel_value = activity . style_pixel_value ncs_pathways = [] for ncs in activity . pathways : ncs_pathways . append ({ str ( ncs . uuid ): ncs . path }) activity = layer_component_to_dict ( activity ) activity [ PATHWAYS_ATTRIBUTE ] = ncs_pathways activity [ STYLE_ATTRIBUTE ] = layer_styles activity [ PIXEL_VALUE_ATTRIBUTE ] = style_pixel_value activities . append ( json . dumps ( activity )) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"uuid\" , str ( scenario_settings . uuid )) settings . setValue ( \"name\" , scenario_settings . name ) settings . setValue ( \"description\" , scenario_settings . description ) settings . setValue ( \"activities\" , activities ) settings . setValue ( \"server_uuid\" , ( str ( scenario_settings . server_uuid ) if scenario_settings . server_uuid else None ), ) settings . setValue ( \"clip_to_studyarea\" , scenario_settings . clip_to_studyarea ) settings . setValue ( \"studyarea_path\" , scenario_settings . studyarea_path ) settings . setValue ( \"crs\" , scenario_settings . crs )","title":"save_scenario"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario_extent","text":"save_scenario_extent ( key , extent ) Saves the scenario extent into plugin settings using the provided settings group key. Parameters: Name Type Description Default key str QgsSettings group key required extent SpatialExtent Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key Scenario extent required Source code in src/cplus_plugin/conf.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def save_scenario_extent ( self , key , extent ): \"\"\"Saves the scenario extent into plugin settings using the provided settings group key. :param key: QgsSettings group key :type key: str :param extent: Scenario extent :type extent: SpatialExtent Args: extent (SpatialExtent): Scenario extent key (str): QgsSettings group key \"\"\" spatial_extent = extent . bbox spatial_crs = extent . crs spatial_key = f \" { key } /extent/spatial/\" with qgis_settings ( spatial_key ) as settings : settings . setValue ( \"bbox\" , spatial_extent ) settings . setValue ( \"crs\" , spatial_crs )","title":"save_scenario_extent"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.save_scenario_result","text":"save_scenario_result ( scenario_result , scenario_id ) Save the scenario results plugin settings Parameters: Name Type Description Default scenario_settings ScenarioSettings Scenario settings required Source code in src/cplus_plugin/conf.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def save_scenario_result ( self , scenario_result , scenario_id ): \"\"\"Save the scenario results plugin settings :param scenario_settings: Scenario settings :type scenario_settings: ScenarioSettings \"\"\" settings_key = self . _get_scenario_results_settings_base ( scenario_id ) analysis_output = json . dumps ( scenario_result . analysis_output ) with qgis_settings ( settings_key ) as settings : settings . setValue ( \"scenario_id\" , scenario_id ) settings . setValue ( \"created_date\" , scenario_result . created_date . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ), ) settings . setValue ( \"analysis_output\" , analysis_output ) settings . setValue ( \"output_layer_name\" , scenario_result . output_layer_name ) settings . setValue ( \"scenario_directory\" , scenario_result . scenario_directory )","title":"save_scenario_result"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_current_priority_layer","text":"set_current_priority_layer ( identifier ) Set current priority layer Parameters: Name Type Description Default identifier str Priority layer identifier required Source code in src/cplus_plugin/conf.py 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 def set_current_priority_layer ( self , identifier : str ): \"\"\"Set current priority layer :param identifier: Priority layer identifier :type identifier: str \"\"\" with qgis_settings ( f \" { self . BASE_GROUP_NAME } /\" f \" { self . PRIORITY_LAYERS_GROUP_NAME } /\" ) as settings : for priority_layer in settings . childGroups (): settings_key = self . _get_priority_layers_settings_base ( identifier ) with qgis_settings ( settings_key ) as layer_settings : layer_settings . setValue ( \"selected\" , str ( priority_layer ) == str ( identifier ) )","title":"set_current_priority_layer"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.set_value","text":"set_value ( name , value ) Adds a new setting key and value on the plugin specific settings. Parameters: Name Type Description Default name str Name of setting key required value Any Value of the setting required Source code in src/cplus_plugin/conf.py 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def set_value ( self , name : str , value ): \"\"\"Adds a new setting key and value on the plugin specific settings. :param name: Name of setting key :type name: str :param value: Value of the setting :type value: Any \"\"\" self . settings . setValue ( f \" { self . BASE_GROUP_NAME } / { name } \" , value ) if isinstance ( name , Settings ): name = name . value self . settings_updated . emit ( name , value )","title":"set_value"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_activities","text":"update_activities () Updates the attributes of the existing activities. Source code in src/cplus_plugin/conf.py 1447 1448 1449 1450 1451 1452 def update_activities ( self ): \"\"\"Updates the attributes of the existing activities.\"\"\" activities = self . get_all_activities () for activity in activities : self . update_activity ( activity )","title":"update_activities"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_activity","text":"update_activity ( activity ) Updates the attributes of the activity object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. Parameters: Name Type Description Default activity Activity Activity object to be updated. required Source code in src/cplus_plugin/conf.py 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 def update_activity ( self , activity : Activity ): \"\"\"Updates the attributes of the activity object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated. :param activity: Activity object to be updated. :type activity: Activity \"\"\" # Remove then re-insert self . remove_activity ( str ( activity . uuid )) self . save_activity ( activity )","title":"update_activity"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_constant_raster_collection","text":"update_constant_raster_collection ( metadata_id , collection_data ) Update constant raster collection data with the given metadata identifier. Parameters: Name Type Description Default metadata_id str Unique identifier for the metadata required collection_data dict Dictionary representation of the collection required Source code in src/cplus_plugin/conf.py 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 def update_constant_raster_collection ( self , metadata_id : str , collection_data : dict ): \"\"\"Update constant raster collection data with the given metadata identifier. :param metadata_id: Unique identifier for the metadata :param collection_data: Dictionary representation of the collection \"\"\" if self . get_constant_raster_collection ( metadata_id ) is not None : self . remove_constant_raster_collection ( metadata_id ) self . save_constant_raster_collection ( metadata_id , collection_data )","title":"update_constant_raster_collection"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathway","text":"update_ncs_pathway ( ncs_pathway ) Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be updated. required Source code in src/cplus_plugin/conf.py 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 def update_ncs_pathway ( self , ncs_pathway : NcsPathway ): \"\"\"Updates the attributes of the NCS pathway object in settings. On the path, the BASE_DIR in settings is used to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway setting will not be updated, this only applies for default pathways. :param ncs_pathway: NCS pathway object to be updated. :type ncs_pathway: NcsPathway \"\"\" base_dir = self . get_value ( Settings . BASE_DIR ) if not base_dir : return # Pathway location for default pathway if not ncs_pathway . user_defined : p = Path ( ncs_pathway . path ) # Only update if path does not exist otherwise # fallback to check under base directory. if not p . exists (): abs_path = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } /\" f \" { p . name } \" abs_path = str ( os . path . normpath ( abs_path )) ncs_pathway . path = abs_path # Carbon location abs_carbon_paths = [] for cb_path in ncs_pathway . carbon_paths : cp = Path ( cb_path ) # Similarly, if the given carbon path does not exist then try # to use the default one in the ncs_carbon directory. if not cp . exists (): abs_carbon_path = f \" { base_dir } / { NCS_CARBON_SEGMENT } /\" f \" { cp . name } \" abs_carbon_path = str ( os . path . normpath ( abs_carbon_path )) abs_carbon_paths . append ( abs_carbon_path ) else : abs_carbon_paths . append ( cb_path ) ncs_pathway . carbon_paths = abs_carbon_paths # PWLs path update updated_pwls = [] for layer in ncs_pathway . priority_layers : if layer in PRIORITY_LAYERS and base_dir not in layer . get ( PATH_ATTRIBUTE ): abs_pwl_path = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } /\" f \" { layer . get ( PATH_ATTRIBUTE ) } \" ) abs_pwl_path = str ( os . path . normpath ( abs_pwl_path )) layer [ PATH_ATTRIBUTE ] = abs_pwl_path updated_pwls . append ( layer ) ncs_pathway . priority_layers = updated_pwls # Remove then re-insert self . remove_ncs_pathway ( str ( ncs_pathway . uuid )) self . save_ncs_pathway ( ncs_pathway )","title":"update_ncs_pathway"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.SettingsManager.update_ncs_pathways","text":"update_ncs_pathways () Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. Source code in src/cplus_plugin/conf.py 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 def update_ncs_pathways ( self ): \"\"\"Updates the path attribute of all NCS pathway settings based on the BASE_DIR settings to reflect the absolute path of each NCS pathway layer. If BASE_DIR is empty then the NCS pathway settings will not be updated. \"\"\" ncs_pathways = self . get_all_ncs_pathways () for ncs in ncs_pathways : self . update_ncs_pathway ( ncs )","title":"update_ncs_pathways"},{"location":"developer/api/core/api_conf/#src.cplus_plugin.conf.qgis_settings","text":"qgis_settings ( group_root , settings = None ) Context manager to help defining groups when creating QgsSettings. :yields: Instance of the created settings :ytype: QgsSettings Parameters: Name Type Description Default group_root str Name of the root group for the settings required settings QgsSettings QGIS settings to use None Source code in src/cplus_plugin/conf.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @contextlib . contextmanager def qgis_settings ( group_root : str , settings = None ): \"\"\"Context manager to help defining groups when creating QgsSettings. :param group_root: Name of the root group for the settings :type group_root: str :param settings: QGIS settings to use :type settings: QgsSettings :yields: Instance of the created settings :ytype: QgsSettings \"\"\" if settings is None : settings = QgsSettings () settings . beginGroup ( group_root ) try : yield settings finally : settings . endGroup ()","title":"qgis_settings"},{"location":"developer/api/core/api_financials/","text":"Financial Helper Functions \u00b6 Contains functions for financial computations. calculate_activity_npv \u00b6 calculate_activity_npv ( activity_id , activity_area ) Determines the NPV of an activity by multiplying the NPV per ha by the area of the activity. The NPV per hectare of the activity is based on the value specified in the constant raster manager. Parameters: Name Type Description Default activity_id str The ID of the specific activity. The function will check whether the NPV rate had been defined for the activity. required activity_area float The area of the activity in hectares. required Returns: Type Description float Returns the NPV of the activity, or -1.0 if the activity does not exist or if found, does not have its NPV per ha defined. Source code in src/cplus_plugin/lib/financials.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def calculate_activity_npv ( activity_id : str , activity_area : float ) -> float : \"\"\"Determines the NPV of an activity by multiplying the NPV per ha by the area of the activity. The NPV per hectare of the activity is based on the value specified in the constant raster manager. :param activity_id: The ID of the specific activity. The function will check whether the NPV rate had been defined for the activity. :type activity_id: str :param activity_area: The area of the activity in hectares. :type activity_area: float :returns: Returns the NPV of the activity, or -1.0 if the activity does not exist or if found, does not have its NPV per ha defined. :rtype: float \"\"\" activity = settings_manager . get_activity ( activity_id ) if not activity : return - 1.0 npv_collection = constant_raster_registry . collection_by_id ( NPV_METADATA_ID ) if not npv_collection : return - 1.0 activity_npv = npv_collection . activity_npv ( str ( activity . uuid )) if not activity_npv or not activity_npv . params . absolute : return - 1.0 return float ( activity_npv . params . absolute * activity_area ) compute_discount_value \u00b6 compute_discount_value ( revenue , cost , year , discount ) Calculates the discounted value for the given year. Parameters: Name Type Description Default revenue float Projected total revenue. required cost float Projected total costs. required year int Relative year i.e. between 1 and 99. required discount float Discount value as a percent i.e. between 0 and 100. required Returns: Type Description float The discounted value for the given year. Source code in src/cplus_plugin/lib/financials.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def compute_discount_value ( revenue : float , cost : float , year : int , discount : float ) -> float : \"\"\"Calculates the discounted value for the given year. :param revenue: Projected total revenue. :type revenue: float :param cost: Projected total costs. :type cost: float :param year: Relative year i.e. between 1 and 99. :type year: int :param discount: Discount value as a percent i.e. between 0 and 100. :type discount: float :returns: The discounted value for the given year. :rtype: float \"\"\" return ( revenue - cost ) / (( 1 + discount / 100.0 ) ** ( year - 1 )) create_npv_pwls \u00b6 create_npv_pwls ( npv_collection , context , multi_step_feedback , feedback , target_crs_id , target_pixel_size , target_extent , on_finish_func = None , on_removed_func = None ) Creates constant raster layers based on the normalized NPV values for the specified NCS pathways. Parameters: Name Type Description Default npv_collection ActivityNpvCollection The NCS pathway NPV collection containing the NPV parameters for NCS pathway. required context QgsProcessingContext Context information for performing the processing. required multi_step_feedback QgsProcessingMultiStepFeedback Feedback for updating the status of processing. required feedback QgsProcessingFeedback Underlying feedback object for communicating to the caller. required target_crs_id str CRS identifier of the target layers. required target_pixel_size float Pixel size of the target layer: required target_extent str Extent of the output layer as xmin, xmax, ymin, ymax. required on_finish_func Callable Function to be executed when a constant raster has been created. None on_removed_func Callable Function to be executed when a disabled NPV PWL has been removed. None Returns: Type Description list A list containing the processing results (as a dictionary) for each successful run. Source code in src/cplus_plugin/lib/financials.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_npv_pwls ( npv_collection : ActivityNpvCollection , context : QgsProcessingContext , multi_step_feedback : QgsProcessingMultiStepFeedback , feedback : QgsProcessingFeedback , target_crs_id : str , target_pixel_size : float , target_extent : str , on_finish_func : typing . Callable = None , on_removed_func : typing . Callable = None , ) -> typing . List : \"\"\"Creates constant raster layers based on the normalized NPV values for the specified NCS pathways. :param npv_collection: The NCS pathway NPV collection containing the NPV parameters for NCS pathway. :type npv_collection: ActivityNpvCollection :param context: Context information for performing the processing. :type context: QgsProcessingContext :param multi_step_feedback: Feedback for updating the status of processing. :type multi_step_feedback: QgsProcessingMultiStepFeedback :param feedback: Underlying feedback object for communicating to the caller. :type feedback: QgsProcessingFeedback :param target_crs_id: CRS identifier of the target layers. :type target_crs_id: str :param target_pixel_size: Pixel size of the target layer: :type target_pixel_size: float :param target_extent: Extent of the output layer as xmin, xmax, ymin, ymax. :type target_extent: str :param on_finish_func: Function to be executed when a constant raster has been created. :type on_finish_func: Callable :param on_removed_func: Function to be executed when a disabled NPV PWL has been removed. :type on_finish_func: Callable :returns: A list containing the processing results (as a dictionary) for each successful run. :rtype: list \"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if not base_dir : log ( message = tr ( \"No base directory for saving NPV PWLs.\" ), info = False ) return [] # Create NPV PWL subdirectory FileUtils . create_npv_pwls_dir ( base_dir ) # NPV PWL root directory npv_base_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { NPV_PRIORITY_LAYERS_SEGMENT } \" current_step = 0 multi_step_feedback . setCurrentStep ( current_step ) results = [] for i , pathway_npv in enumerate ( npv_collection . mappings ): if feedback . isCanceled (): break if pathway_npv . pathway is None or pathway_npv . params is None : log ( tr ( \"Could not create or update NCS pathway NPV as NCS \" \"pathway and NPV parameter information is missing.\" ), info = False , ) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) continue base_layer_name = clean_filename ( pathway_npv . base_name . replace ( \" \" , \"_\" ) . lower () ) # Delete existing NPV PWLs. Relevant layers will be re-created # where applicable. for del_npv_path in pathlib . Path ( npv_base_dir ) . glob ( f \"* { base_layer_name } *\" ): try : log ( f \" { tr ( 'Deleting' ) } - NPV PWL { del_npv_path } \" ) pathlib . Path ( del_npv_path ) . unlink () except OSError as os_ex : base_msg_tr = tr ( \"Unable to delete NPV PWL\" ) conclusion_msg_tr = tr ( \"File will be deleted in subsequent processes if not locked\" ) log ( f \" { base_msg_tr } : { os_ex . strerror } . { conclusion_msg_tr } .\" , info = False ) # Delete if PWL previously existed and is now disabled if not pathway_npv . enabled : if npv_collection . remove_existing : # Delete corresponding PWL entry in the settings del_pwl = settings_manager . find_layer_by_name ( pathway_npv . base_name ) if del_pwl is not None : pwl_id = del_pwl . get ( \"uuid\" , None ) if pwl_id is not None : settings_manager . delete_priority_layer ( pwl_id ) if on_removed_func is not None : on_removed_func ( str ( del_pwl [ \"uuid\" ])) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) continue # Output layer name npv_pwl_path = f \" { npv_base_dir } / { base_layer_name } _ { datetime . datetime . now () . strftime ( '%Y_%m_ %d _%H_%M_%S' ) } .tif\" output_post_processing_func = None if on_finish_func is not None : output_post_processing_func = partial ( on_finish_func , pathway_npv , npv_pwl_path ) try : alg_params = { \"EXTENT\" : target_extent , \"TARGET_CRS\" : target_crs_id , \"PIXEL_SIZE\" : target_pixel_size , \"NUMBER\" : pathway_npv . params . normalized_npv , \"OUTPUT\" : npv_pwl_path , } res = processing . run ( \"native:createconstantrasterlayer\" , alg_params , context = context , feedback = multi_step_feedback , onFinish = output_post_processing_func , ) results . append ( res ) except QgsProcessingException as ex : err_tr = tr ( \"Error creating NPV PWL\" ) log ( f \" { err_tr } { npv_pwl_path } \" ) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) return results","title":"Financials"},{"location":"developer/api/core/api_financials/#financial-helper-functions","text":"Contains functions for financial computations.","title":"Financial Helper Functions"},{"location":"developer/api/core/api_financials/#src.cplus_plugin.lib.financials.calculate_activity_npv","text":"calculate_activity_npv ( activity_id , activity_area ) Determines the NPV of an activity by multiplying the NPV per ha by the area of the activity. The NPV per hectare of the activity is based on the value specified in the constant raster manager. Parameters: Name Type Description Default activity_id str The ID of the specific activity. The function will check whether the NPV rate had been defined for the activity. required activity_area float The area of the activity in hectares. required Returns: Type Description float Returns the NPV of the activity, or -1.0 if the activity does not exist or if found, does not have its NPV per ha defined. Source code in src/cplus_plugin/lib/financials.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def calculate_activity_npv ( activity_id : str , activity_area : float ) -> float : \"\"\"Determines the NPV of an activity by multiplying the NPV per ha by the area of the activity. The NPV per hectare of the activity is based on the value specified in the constant raster manager. :param activity_id: The ID of the specific activity. The function will check whether the NPV rate had been defined for the activity. :type activity_id: str :param activity_area: The area of the activity in hectares. :type activity_area: float :returns: Returns the NPV of the activity, or -1.0 if the activity does not exist or if found, does not have its NPV per ha defined. :rtype: float \"\"\" activity = settings_manager . get_activity ( activity_id ) if not activity : return - 1.0 npv_collection = constant_raster_registry . collection_by_id ( NPV_METADATA_ID ) if not npv_collection : return - 1.0 activity_npv = npv_collection . activity_npv ( str ( activity . uuid )) if not activity_npv or not activity_npv . params . absolute : return - 1.0 return float ( activity_npv . params . absolute * activity_area )","title":"calculate_activity_npv"},{"location":"developer/api/core/api_financials/#src.cplus_plugin.lib.financials.compute_discount_value","text":"compute_discount_value ( revenue , cost , year , discount ) Calculates the discounted value for the given year. Parameters: Name Type Description Default revenue float Projected total revenue. required cost float Projected total costs. required year int Relative year i.e. between 1 and 99. required discount float Discount value as a percent i.e. between 0 and 100. required Returns: Type Description float The discounted value for the given year. Source code in src/cplus_plugin/lib/financials.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def compute_discount_value ( revenue : float , cost : float , year : int , discount : float ) -> float : \"\"\"Calculates the discounted value for the given year. :param revenue: Projected total revenue. :type revenue: float :param cost: Projected total costs. :type cost: float :param year: Relative year i.e. between 1 and 99. :type year: int :param discount: Discount value as a percent i.e. between 0 and 100. :type discount: float :returns: The discounted value for the given year. :rtype: float \"\"\" return ( revenue - cost ) / (( 1 + discount / 100.0 ) ** ( year - 1 ))","title":"compute_discount_value"},{"location":"developer/api/core/api_financials/#src.cplus_plugin.lib.financials.create_npv_pwls","text":"create_npv_pwls ( npv_collection , context , multi_step_feedback , feedback , target_crs_id , target_pixel_size , target_extent , on_finish_func = None , on_removed_func = None ) Creates constant raster layers based on the normalized NPV values for the specified NCS pathways. Parameters: Name Type Description Default npv_collection ActivityNpvCollection The NCS pathway NPV collection containing the NPV parameters for NCS pathway. required context QgsProcessingContext Context information for performing the processing. required multi_step_feedback QgsProcessingMultiStepFeedback Feedback for updating the status of processing. required feedback QgsProcessingFeedback Underlying feedback object for communicating to the caller. required target_crs_id str CRS identifier of the target layers. required target_pixel_size float Pixel size of the target layer: required target_extent str Extent of the output layer as xmin, xmax, ymin, ymax. required on_finish_func Callable Function to be executed when a constant raster has been created. None on_removed_func Callable Function to be executed when a disabled NPV PWL has been removed. None Returns: Type Description list A list containing the processing results (as a dictionary) for each successful run. Source code in src/cplus_plugin/lib/financials.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def create_npv_pwls ( npv_collection : ActivityNpvCollection , context : QgsProcessingContext , multi_step_feedback : QgsProcessingMultiStepFeedback , feedback : QgsProcessingFeedback , target_crs_id : str , target_pixel_size : float , target_extent : str , on_finish_func : typing . Callable = None , on_removed_func : typing . Callable = None , ) -> typing . List : \"\"\"Creates constant raster layers based on the normalized NPV values for the specified NCS pathways. :param npv_collection: The NCS pathway NPV collection containing the NPV parameters for NCS pathway. :type npv_collection: ActivityNpvCollection :param context: Context information for performing the processing. :type context: QgsProcessingContext :param multi_step_feedback: Feedback for updating the status of processing. :type multi_step_feedback: QgsProcessingMultiStepFeedback :param feedback: Underlying feedback object for communicating to the caller. :type feedback: QgsProcessingFeedback :param target_crs_id: CRS identifier of the target layers. :type target_crs_id: str :param target_pixel_size: Pixel size of the target layer: :type target_pixel_size: float :param target_extent: Extent of the output layer as xmin, xmax, ymin, ymax. :type target_extent: str :param on_finish_func: Function to be executed when a constant raster has been created. :type on_finish_func: Callable :param on_removed_func: Function to be executed when a disabled NPV PWL has been removed. :type on_finish_func: Callable :returns: A list containing the processing results (as a dictionary) for each successful run. :rtype: list \"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if not base_dir : log ( message = tr ( \"No base directory for saving NPV PWLs.\" ), info = False ) return [] # Create NPV PWL subdirectory FileUtils . create_npv_pwls_dir ( base_dir ) # NPV PWL root directory npv_base_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { NPV_PRIORITY_LAYERS_SEGMENT } \" current_step = 0 multi_step_feedback . setCurrentStep ( current_step ) results = [] for i , pathway_npv in enumerate ( npv_collection . mappings ): if feedback . isCanceled (): break if pathway_npv . pathway is None or pathway_npv . params is None : log ( tr ( \"Could not create or update NCS pathway NPV as NCS \" \"pathway and NPV parameter information is missing.\" ), info = False , ) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) continue base_layer_name = clean_filename ( pathway_npv . base_name . replace ( \" \" , \"_\" ) . lower () ) # Delete existing NPV PWLs. Relevant layers will be re-created # where applicable. for del_npv_path in pathlib . Path ( npv_base_dir ) . glob ( f \"* { base_layer_name } *\" ): try : log ( f \" { tr ( 'Deleting' ) } - NPV PWL { del_npv_path } \" ) pathlib . Path ( del_npv_path ) . unlink () except OSError as os_ex : base_msg_tr = tr ( \"Unable to delete NPV PWL\" ) conclusion_msg_tr = tr ( \"File will be deleted in subsequent processes if not locked\" ) log ( f \" { base_msg_tr } : { os_ex . strerror } . { conclusion_msg_tr } .\" , info = False ) # Delete if PWL previously existed and is now disabled if not pathway_npv . enabled : if npv_collection . remove_existing : # Delete corresponding PWL entry in the settings del_pwl = settings_manager . find_layer_by_name ( pathway_npv . base_name ) if del_pwl is not None : pwl_id = del_pwl . get ( \"uuid\" , None ) if pwl_id is not None : settings_manager . delete_priority_layer ( pwl_id ) if on_removed_func is not None : on_removed_func ( str ( del_pwl [ \"uuid\" ])) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) continue # Output layer name npv_pwl_path = f \" { npv_base_dir } / { base_layer_name } _ { datetime . datetime . now () . strftime ( '%Y_%m_ %d _%H_%M_%S' ) } .tif\" output_post_processing_func = None if on_finish_func is not None : output_post_processing_func = partial ( on_finish_func , pathway_npv , npv_pwl_path ) try : alg_params = { \"EXTENT\" : target_extent , \"TARGET_CRS\" : target_crs_id , \"PIXEL_SIZE\" : target_pixel_size , \"NUMBER\" : pathway_npv . params . normalized_npv , \"OUTPUT\" : npv_pwl_path , } res = processing . run ( \"native:createconstantrasterlayer\" , alg_params , context = context , feedback = multi_step_feedback , onFinish = output_post_processing_func , ) results . append ( res ) except QgsProcessingException as ex : err_tr = tr ( \"Error creating NPV PWL\" ) log ( f \" { err_tr } { npv_pwl_path } \" ) current_step += 1 multi_step_feedback . setCurrentStep ( current_step ) return results","title":"create_npv_pwls"},{"location":"developer/api/core/api_main/","text":"Main \u00b6 QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . cplus_action = None self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setCheckable ( True ) self . toolButton . setPopupMode ( QToolButton . ToolButtonPopupMode . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) create_priority_layers () clean_up_finance_pwl_references () initialize_model_settings () # Initialize default report settings initialize_report_settings () initialize_api_url () # Upgrade metric configuration to profile collection upgrade_metric_configuration_to_profile_collection () # Initialize constant raster metadata registry initialize_constant_raster_registry () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . main_widget . visibilityChanged . connect ( self . on_dock_widget_visibility_changed ) # Create options factories self . cplus_options_factory = CplusOptionsFactory ( main_widget = self . main_widget ) self . reports_options_factory = ReportOptionsFactory () self . carbon_options_factory = CarbonOptionsFactory () self . log_options_factory = LogOptionsFactory () self . options_factory = None add_action \u00b6 add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) self . actions . append ( action ) return action create_dock_widget_action \u00b6 create_dock_widget_action () Create the action corresponding to the main dock widget. Source code in src/cplus_plugin/main.py 338 339 340 341 342 343 344 345 346 347 def create_dock_widget_action ( self ): \"\"\"Create the action corresponding to the main dock widget.\"\"\" self . cplus_action = self . main_widget . toggleViewAction () self . cplus_action . setIcon ( QIcon ( ICON_PATH )) self . cplus_action . setText ( self . tr ( \"CPLUS\" )) self . menu . addAction ( self . cplus_action ) self . toolButton . menu () . addAction ( self . cplus_action ) self . toolButton . setDefaultAction ( self . cplus_action ) self . actions . append ( self . cplus_action ) initGui \u00b6 initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" # Create main dock widget action self . create_dock_widget_action () self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Register plugin options factories self . iface . registerOptionsWidgetFactory ( self . cplus_options_factory ) self . iface . registerOptionsWidgetFactory ( self . reports_options_factory ) self . iface . registerOptionsWidgetFactory ( self . carbon_options_factory ) # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) # Install report font self . install_report_font () # Register metric functions. Note that these are # scoped for specific contexts. register_metric_functions () install_report_font \u00b6 install_report_font () Checks if the report font exists and install it. Source code in src/cplus_plugin/main.py 400 401 402 403 404 405 406 407 408 409 410 411 def install_report_font ( self ): \"\"\"Checks if the report font exists and install it.\"\"\" font_exists = contains_font_family ( REPORT_FONT_NAME ) if not font_exists : log ( message = self . tr ( \"Installing report font...\" )) status = install_font ( REPORT_FONT_NAME . lower ()) if status : log ( message = self . tr ( \"Report font successfully installed.\" )) else : log ( message = self . tr ( \"Report font could not be installed.\" ), info = False ) else : log ( message = \"Report font exists.\" ) onClosePlugin \u00b6 onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 299 300 301 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False on_dock_widget_visibility_changed \u00b6 on_dock_widget_visibility_changed ( visible ) Slot raised when the visibility of the main docket widget changes. Parameters: Name Type Description Default visible bool True if the dock widget is visible, else False. required Source code in src/cplus_plugin/main.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def on_dock_widget_visibility_changed ( self , visible : bool ): \"\"\"Slot raised when the visibility of the main docket widget changes. :param visible: True if the dock widget is visible, else False. :type visible: bool \"\"\" # Set default dock position on first time load. if visible : app_window = self . iface . mainWindow () dock_area = app_window . dockWidgetArea ( self . main_widget ) if ( dock_area == Qt . DockWidgetArea . NoDockWidgetArea and not self . main_widget . isFloating () ): self . iface . addDockWidget ( Qt . DockWidgetArea . RightDockWidgetArea , self . main_widget ) self . main_widget . show () on_layout_designer_opened \u00b6 on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 373 374 375 376 377 378 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . Type . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout ) open_about \u00b6 open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 396 397 398 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE ) open_help \u00b6 open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 392 393 394 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE ) register_layout_items \u00b6 register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 380 381 382 383 384 385 386 387 388 389 390 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata ) run \u00b6 run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . create_dock_widget_action () self . iface . addDockWidget ( Qt . DockWidgetArea . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True run_settings \u00b6 run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 369 370 371 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) tr \u00b6 tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 156 157 158 159 160 161 162 163 164 165 166 167 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message ) unload \u00b6 unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) # Unregister plugin options factories self . iface . unregisterOptionsWidgetFactory ( self . cplus_options_factory ) self . iface . unregisterOptionsWidgetFactory ( self . reports_options_factory ) self . iface . unregisterOptionsWidgetFactory ( self . log_options_factory ) # Unregister metric functions unregister_metric_functions () except Exception as e : log ( str ( e ), info = False )","title":"Main"},{"location":"developer/api/core/api_main/#main","text":"QGIS CPLUS Plugin Implementation. Source code in src/cplus_plugin/main.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def __init__ ( self , iface ): self . iface = iface self . plugin_dir = os . path . dirname ( __file__ ) locale = QgsSettings () . value ( \"locale/userLocale\" )[ 0 : 2 ] locale_path = os . path . join ( self . plugin_dir , \"i18n\" , \"CPLUS {} .qm\" . format ( locale )) if os . path . exists ( locale_path ): self . translator = QTranslator () self . translator . load ( locale_path ) QCoreApplication . installTranslator ( self . translator ) # Declare instance attributes self . actions = [] self . pluginIsActive = False self . cplus_action = None self . menu = QMenu ( \"&CPLUS\" ) self . menu . setIcon ( QIcon ( ICON_PATH )) self . raster_menu = self . iface . rasterMenu () self . raster_menu . addMenu ( self . menu ) self . toolbar = self . iface . addToolBar ( \"Open CPLUS\" ) self . toolbar . setObjectName ( \"CPLUS\" ) self . toolButton = QToolButton () self . toolButton . setMenu ( QMenu ()) self . toolButton . setCheckable ( True ) self . toolButton . setPopupMode ( QToolButton . ToolButtonPopupMode . MenuButtonPopup ) self . toolBtnAction = self . toolbar . addWidget ( self . toolButton ) self . actions . append ( self . toolBtnAction ) create_priority_layers () clean_up_finance_pwl_references () initialize_model_settings () # Initialize default report settings initialize_report_settings () initialize_api_url () # Upgrade metric configuration to profile collection upgrade_metric_configuration_to_profile_collection () # Initialize constant raster metadata registry initialize_constant_raster_registry () self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . main_widget . visibilityChanged . connect ( self . on_dock_widget_visibility_changed ) # Create options factories self . cplus_options_factory = CplusOptionsFactory ( main_widget = self . main_widget ) self . reports_options_factory = ReportOptionsFactory () self . carbon_options_factory = CarbonOptionsFactory () self . log_options_factory = LogOptionsFactory () self . options_factory = None","title":"Main"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.add_action","text":"add_action ( icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None ) Add a toolbar icon to the toolbar. Parameters: Name Type Description Default icon_path str Path to the icon for this action required text str Text that should be shown in menu items for this action required callback function Function to be called when the action is triggered required enabled_flag bool A flag indicating if the action should be enabled True add_to_menu bool Flag indicating whether the action should also be added to the menu True add_to_web_menu bool Flag indicating whether the action should also be added to the web menu True add_to_toolbar bool Flag indicating whether the action should also be added to the toolbar True set_as_default_action bool Flag indicating whether the action is the default action False status_tip str Optional text to show in a popup when mouse pointer hovers over the action None parent QWidget Parent widget for the new action None whats_this str Optional text to show in the status bar when the mouse pointer hovers over the action None Returns: Type Description QAction The action that was created Source code in src/cplus_plugin/main.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 def add_action ( self , icon_path , text , callback , enabled_flag = True , add_to_menu = True , add_to_web_menu = True , add_to_toolbar = True , set_as_default_action = False , status_tip = None , whats_this = None , parent = None , ): \"\"\"Add a toolbar icon to the toolbar. :param icon_path: Path to the icon for this action :type icon_path: str :param text: Text that should be shown in menu items for this action :type text: str :param callback: Function to be called when the action is triggered :type callback: function :param enabled_flag: A flag indicating if the action should be enabled :type enabled_flag: bool :param add_to_menu: Flag indicating whether the action should also be added to the menu :type add_to_menu: bool :param add_to_web_menu: Flag indicating whether the action should also be added to the web menu :type add_to_web_menu: bool :param add_to_toolbar: Flag indicating whether the action should also be added to the toolbar :type add_to_toolbar: bool :param set_as_default_action: Flag indicating whether the action is the default action :type set_as_default_action: bool :param status_tip: Optional text to show in a popup when mouse pointer hovers over the action :type status_tip: str :param parent: Parent widget for the new action :type parent: QWidget :param whats_this: Optional text to show in the status bar when the mouse pointer hovers over the action :type whats_this: str :returns: The action that was created :rtype: QAction \"\"\" icon = QIcon ( icon_path ) action = QAction ( icon , text , parent ) action . triggered . connect ( callback ) action . setEnabled ( enabled_flag ) if status_tip is not None : action . setStatusTip ( status_tip ) if whats_this is not None : action . setWhatsThis ( whats_this ) if add_to_menu : self . menu . addAction ( action ) # If we want to read this # if add_to_web_menu: # self.iface.addPluginToWebMenu(self.menu, action) if add_to_toolbar : self . toolButton . menu () . addAction ( action ) if set_as_default_action : self . toolButton . setDefaultAction ( action ) self . actions . append ( action ) return action","title":"add_action"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.create_dock_widget_action","text":"create_dock_widget_action () Create the action corresponding to the main dock widget. Source code in src/cplus_plugin/main.py 338 339 340 341 342 343 344 345 346 347 def create_dock_widget_action ( self ): \"\"\"Create the action corresponding to the main dock widget.\"\"\" self . cplus_action = self . main_widget . toggleViewAction () self . cplus_action . setIcon ( QIcon ( ICON_PATH )) self . cplus_action . setText ( self . tr ( \"CPLUS\" )) self . menu . addAction ( self . cplus_action ) self . toolButton . menu () . addAction ( self . cplus_action ) self . toolButton . setDefaultAction ( self . cplus_action ) self . actions . append ( self . cplus_action )","title":"create_dock_widget_action"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.initGui","text":"initGui () Create the menu entries and toolbar icons inside the QGIS GUI. Source code in src/cplus_plugin/main.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def initGui ( self ): \"\"\"Create the menu entries and toolbar icons inside the QGIS GUI.\"\"\" # Create main dock widget action self . create_dock_widget_action () self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"settings.svg\" ), text = self . tr ( \"Settings\" ), callback = self . run_settings , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Settings\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"mActionHelpContents_green.svg\" ), text = self . tr ( \"Help\" ), callback = self . open_help , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS Help\" ), ) self . add_action ( os . path . join ( os . path . dirname ( __file__ ), \"icons\" , \"info_green.svg\" ), text = self . tr ( \"About\" ), callback = self . open_about , parent = self . iface . mainWindow (), status_tip = self . tr ( \"CPLUS About\" ), ) # Register plugin options factories self . iface . registerOptionsWidgetFactory ( self . cplus_options_factory ) self . iface . registerOptionsWidgetFactory ( self . reports_options_factory ) self . iface . registerOptionsWidgetFactory ( self . carbon_options_factory ) # Register custom layout items self . register_layout_items () # Register custom report variables when a layout is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) # Install report font self . install_report_font () # Register metric functions. Note that these are # scoped for specific contexts. register_metric_functions ()","title":"initGui"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.install_report_font","text":"install_report_font () Checks if the report font exists and install it. Source code in src/cplus_plugin/main.py 400 401 402 403 404 405 406 407 408 409 410 411 def install_report_font ( self ): \"\"\"Checks if the report font exists and install it.\"\"\" font_exists = contains_font_family ( REPORT_FONT_NAME ) if not font_exists : log ( message = self . tr ( \"Installing report font...\" )) status = install_font ( REPORT_FONT_NAME . lower ()) if status : log ( message = self . tr ( \"Report font successfully installed.\" )) else : log ( message = self . tr ( \"Report font could not be installed.\" ), info = False ) else : log ( message = \"Report font exists.\" )","title":"install_report_font"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.onClosePlugin","text":"onClosePlugin () Cleanup necessary items here when plugin widget is closed. Source code in src/cplus_plugin/main.py 299 300 301 def onClosePlugin ( self ): \"\"\"Cleanup necessary items here when plugin widget is closed.\"\"\" self . pluginIsActive = False","title":"onClosePlugin"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.on_dock_widget_visibility_changed","text":"on_dock_widget_visibility_changed ( visible ) Slot raised when the visibility of the main docket widget changes. Parameters: Name Type Description Default visible bool True if the dock widget is visible, else False. required Source code in src/cplus_plugin/main.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 def on_dock_widget_visibility_changed ( self , visible : bool ): \"\"\"Slot raised when the visibility of the main docket widget changes. :param visible: True if the dock widget is visible, else False. :type visible: bool \"\"\" # Set default dock position on first time load. if visible : app_window = self . iface . mainWindow () dock_area = app_window . dockWidgetArea ( self . main_widget ) if ( dock_area == Qt . DockWidgetArea . NoDockWidgetArea and not self . main_widget . isFloating () ): self . iface . addDockWidget ( Qt . DockWidgetArea . RightDockWidgetArea , self . main_widget ) self . main_widget . show ()","title":"on_dock_widget_visibility_changed"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.on_layout_designer_opened","text":"on_layout_designer_opened ( designer ) Register custom report variables in a print layout only. Source code in src/cplus_plugin/main.py 373 374 375 376 377 378 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Register custom report variables in a print layout only.\"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . Type . PrintLayout : layout = designer . layout () report_manager . register_variables ( layout )","title":"on_layout_designer_opened"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_about","text":"open_about () Opens the about documentation for the plugin in a browser Source code in src/cplus_plugin/main.py 396 397 398 def open_about ( self ): \"\"\"Opens the about documentation for the plugin in a browser\"\"\" open_documentation ( ABOUT_DOCUMENTATION_SITE )","title":"open_about"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.open_help","text":"open_help () Opens documentation home page for the plugin in a browser Source code in src/cplus_plugin/main.py 392 393 394 def open_help ( self ): \"\"\"Opens documentation home page for the plugin in a browser\"\"\" open_documentation ( DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.register_layout_items","text":"register_layout_items () Register custom layout items. Source code in src/cplus_plugin/main.py 380 381 382 383 384 385 386 387 388 389 390 def register_layout_items ( self ): \"\"\"Register custom layout items.\"\"\" # Register map layout item QgsApplication . layoutItemRegistry () . addLayoutItemType ( CplusMapRepeatItemLayoutItemMetadata () ) # Register map GUI metadata item_gui_registry = QgsGui . layoutItemGuiRegistry () map_item_gui_metadata = CplusMapLayoutItemGuiMetadata () item_gui_registry . addLayoutItemGuiMetadata ( map_item_gui_metadata )","title":"register_layout_items"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run","text":"run () Creates the main widget for the plugin. Source code in src/cplus_plugin/main.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 def run ( self ): \"\"\"Creates the main widget for the plugin.\"\"\" if self . main_widget is None : self . main_widget = QgisCplusMain ( iface = self . iface , parent = self . iface . mainWindow () ) self . create_dock_widget_action () self . iface . addDockWidget ( Qt . DockWidgetArea . RightDockWidgetArea , self . main_widget ) self . main_widget . show () if not self . pluginIsActive : self . pluginIsActive = True","title":"run"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.run_settings","text":"run_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/main.py 369 370 371 def run_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"run_settings"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message str String for translation required Returns: Type Description QString Translated version of the message Source code in src/cplus_plugin/main.py 156 157 158 159 160 161 162 163 164 165 166 167 def tr ( self , message ) -> str : \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation :type message: str :returns: Translated version of the message :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QCoreApplication . translate ( \"CPLUS\" , message )","title":"tr"},{"location":"developer/api/core/api_main/#src.cplus_plugin.main.QgisCplus.unload","text":"unload () Removes the plugin menu item and icon from QGIS GUI. Source code in src/cplus_plugin/main.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 def unload ( self ): \"\"\"Removes the plugin menu item and icon from QGIS GUI.\"\"\" try : for action in self . actions : self . iface . removePluginMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removePluginWebMenu ( self . tr ( \"&CPLUS\" ), action ) self . iface . removeToolBarIcon ( action ) # Unregister plugin options factories self . iface . unregisterOptionsWidgetFactory ( self . cplus_options_factory ) self . iface . unregisterOptionsWidgetFactory ( self . reports_options_factory ) self . iface . unregisterOptionsWidgetFactory ( self . log_options_factory ) # Unregister metric functions unregister_metric_functions () except Exception as e : log ( str ( e ), info = False )","title":"unload"},{"location":"developer/api/core/api_report_scenario_comparison_table/","text":"Scenario Comparison Table Generator \u00b6 Scenario comparison table information. ScenarioComparisonTableInfo \u00b6 ScenarioComparisonTableInfo ( results , parent = None ) Bases: QObject Get area information for the scenarios in the corresponding ScenarioResult objects and uses this information to generate QgsLayoutTableColumn and QgsTableCell objects for use in a scenario comparison table. Source code in src/cplus_plugin/lib/reports/comparison_table.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , results : typing . List [ ScenarioResult ], parent = None ): super () . __init__ ( parent ) self . _scenario_results = results self . _activity_header_info = [] self . _scenario_activity_name_pixel = {} self . _contents = [] self . _area_calculated = False self . _area_feedback = QgsProcessingFeedback () self . _multistep_area_feedback = QgsProcessingMultiStepFeedback ( len ( results ), self . _area_feedback ) # Extract the header information and populate mapping of activity # pixel value with the corresponding name for result in self . _scenario_results : name_pixel_mapping = {} for pixel_value , activity in enumerate ( result . scenario . activities , 1 ): activity_info = ( str ( activity . uuid ), activity . name ) name_pixel_mapping [ pixel_value ] = activity . name if activity_info in self . _activity_header_info : continue self . _activity_header_info . append ( activity_info ) self . _scenario_activity_name_pixel [ result . scenario . uuid ] = ( name_pixel_mapping ) columns property \u00b6 columns Headers for the scenario comparison table. The columns start with one titled 'Scenario' which will contain the scenario name in the rows. Returns: Type Description list Table headers based on the activities in the scenarios. feedback property \u00b6 feedback Returns a feedback object for updating or canceling the process of area calculation. Returns: Type Description QgsProcessingFeedback Feedback for updating or canceling the process. contents \u00b6 contents () Calculates the area of scenario layers and creates the corresponding table rows for use in a QgsLayoutTable derivative. The area_calculated signal is emitted once for every scenario area calculated or acquired using alternative mechanisms. This function is idempotent and will only return the results from the first call. Subsequent calls will return the same result. Returns: Type Description list A nested list containing area information for each scenario. Source code in src/cplus_plugin/lib/reports/comparison_table.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def contents ( self ) -> typing . List [ typing . List [ QgsTableCell ]]: \"\"\"Calculates the area of scenario layers and creates the corresponding table rows for use in a QgsLayoutTable derivative. The `area_calculated` signal is emitted once for every scenario area calculated or acquired using alternative mechanisms. This function is idempotent and will only return the results from the first call. Subsequent calls will return the same result. :returns: A nested list containing area information for each scenario. :rtype: list \"\"\" if self . _area_calculated : return self . _contents result_data = [] current_step = 0 self . _multistep_area_feedback . setCurrentStep ( current_step ) for result in self . _scenario_results : if self . _area_feedback . isCanceled (): return self . _contents layer = layer_from_scenario_result ( result ) if layer is None : msg = ( f \"Unable to calculate area for scenario comparison a\" f \"s layer for { result . scenario . name } could not \" f \"be created.\" ) log ( msg ) current_step += 1 self . _multistep_area_feedback . setCurrentStep ( current_step ) continue area_info = calculate_raster_area_by_pixel_value ( layer , feedback = self . _multistep_area_feedback ) int_area_info = { int ( pixel_value ): area for pixel_value , area in area_info . items () } scenario_area_info = ScenarioAreaInfo ( result . scenario . name , result . scenario . uuid , int_area_info ) # Remap activity pixel value with the name for the calculated area activity_pixel_name_info = self . _scenario_activity_name_pixel [ result . scenario . uuid ] activity_name_area_info = { activity_pixel_name_info [ pixel_value ]: area for pixel_value , area in int_area_info . items () } self . area_calculated . emit ( scenario_area_info ) if len ( int_area_info ) == 0 : msg = \"No activity areas from the calculation\" log ( msg ) row_data = [ QgsTableCell ( result . scenario . name )] for header_info in self . _activity_header_info : activity_name = header_info [ 1 ] if activity_name in activity_name_area_info : activity_area = activity_name_area_info [ activity_name ] else : activity_area = self . NOT_AVAILABLE_STR area_cell = QgsTableCell ( activity_area ) area_cell . setHorizontalAlignment ( QtCore . Qt . AlignmentFlag . AlignHCenter ) if isinstance ( activity_area , Number ): number_format = QgsBasicNumericFormat () number_format . setThousandsSeparator ( \",\" ) number_format . setShowTrailingZeros ( True ) number_format . setNumberDecimalPlaces ( self . AREA_DECIMAL_PLACES ) area_cell . setNumericFormat ( number_format ) row_data . append ( area_cell ) result_data . append ( row_data ) current_step += 1 self . _multistep_area_feedback . setCurrentStep ( current_step ) self . _contents = result_data self . _area_calculated = True return self . _contents","title":"Comparison Table"},{"location":"developer/api/core/api_report_scenario_comparison_table/#scenario-comparison-table-generator","text":"Scenario comparison table information.","title":"Scenario Comparison Table Generator"},{"location":"developer/api/core/api_report_scenario_comparison_table/#src.cplus_plugin.lib.reports.comparison_table.ScenarioComparisonTableInfo","text":"ScenarioComparisonTableInfo ( results , parent = None ) Bases: QObject Get area information for the scenarios in the corresponding ScenarioResult objects and uses this information to generate QgsLayoutTableColumn and QgsTableCell objects for use in a scenario comparison table. Source code in src/cplus_plugin/lib/reports/comparison_table.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , results : typing . List [ ScenarioResult ], parent = None ): super () . __init__ ( parent ) self . _scenario_results = results self . _activity_header_info = [] self . _scenario_activity_name_pixel = {} self . _contents = [] self . _area_calculated = False self . _area_feedback = QgsProcessingFeedback () self . _multistep_area_feedback = QgsProcessingMultiStepFeedback ( len ( results ), self . _area_feedback ) # Extract the header information and populate mapping of activity # pixel value with the corresponding name for result in self . _scenario_results : name_pixel_mapping = {} for pixel_value , activity in enumerate ( result . scenario . activities , 1 ): activity_info = ( str ( activity . uuid ), activity . name ) name_pixel_mapping [ pixel_value ] = activity . name if activity_info in self . _activity_header_info : continue self . _activity_header_info . append ( activity_info ) self . _scenario_activity_name_pixel [ result . scenario . uuid ] = ( name_pixel_mapping )","title":"ScenarioComparisonTableInfo"},{"location":"developer/api/core/api_report_scenario_comparison_table/#src.cplus_plugin.lib.reports.comparison_table.ScenarioComparisonTableInfo.columns","text":"columns Headers for the scenario comparison table. The columns start with one titled 'Scenario' which will contain the scenario name in the rows. Returns: Type Description list Table headers based on the activities in the scenarios.","title":"columns"},{"location":"developer/api/core/api_report_scenario_comparison_table/#src.cplus_plugin.lib.reports.comparison_table.ScenarioComparisonTableInfo.feedback","text":"feedback Returns a feedback object for updating or canceling the process of area calculation. Returns: Type Description QgsProcessingFeedback Feedback for updating or canceling the process.","title":"feedback"},{"location":"developer/api/core/api_report_scenario_comparison_table/#src.cplus_plugin.lib.reports.comparison_table.ScenarioComparisonTableInfo.contents","text":"contents () Calculates the area of scenario layers and creates the corresponding table rows for use in a QgsLayoutTable derivative. The area_calculated signal is emitted once for every scenario area calculated or acquired using alternative mechanisms. This function is idempotent and will only return the results from the first call. Subsequent calls will return the same result. Returns: Type Description list A nested list containing area information for each scenario. Source code in src/cplus_plugin/lib/reports/comparison_table.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def contents ( self ) -> typing . List [ typing . List [ QgsTableCell ]]: \"\"\"Calculates the area of scenario layers and creates the corresponding table rows for use in a QgsLayoutTable derivative. The `area_calculated` signal is emitted once for every scenario area calculated or acquired using alternative mechanisms. This function is idempotent and will only return the results from the first call. Subsequent calls will return the same result. :returns: A nested list containing area information for each scenario. :rtype: list \"\"\" if self . _area_calculated : return self . _contents result_data = [] current_step = 0 self . _multistep_area_feedback . setCurrentStep ( current_step ) for result in self . _scenario_results : if self . _area_feedback . isCanceled (): return self . _contents layer = layer_from_scenario_result ( result ) if layer is None : msg = ( f \"Unable to calculate area for scenario comparison a\" f \"s layer for { result . scenario . name } could not \" f \"be created.\" ) log ( msg ) current_step += 1 self . _multistep_area_feedback . setCurrentStep ( current_step ) continue area_info = calculate_raster_area_by_pixel_value ( layer , feedback = self . _multistep_area_feedback ) int_area_info = { int ( pixel_value ): area for pixel_value , area in area_info . items () } scenario_area_info = ScenarioAreaInfo ( result . scenario . name , result . scenario . uuid , int_area_info ) # Remap activity pixel value with the name for the calculated area activity_pixel_name_info = self . _scenario_activity_name_pixel [ result . scenario . uuid ] activity_name_area_info = { activity_pixel_name_info [ pixel_value ]: area for pixel_value , area in int_area_info . items () } self . area_calculated . emit ( scenario_area_info ) if len ( int_area_info ) == 0 : msg = \"No activity areas from the calculation\" log ( msg ) row_data = [ QgsTableCell ( result . scenario . name )] for header_info in self . _activity_header_info : activity_name = header_info [ 1 ] if activity_name in activity_name_area_info : activity_area = activity_name_area_info [ activity_name ] else : activity_area = self . NOT_AVAILABLE_STR area_cell = QgsTableCell ( activity_area ) area_cell . setHorizontalAlignment ( QtCore . Qt . AlignmentFlag . AlignHCenter ) if isinstance ( activity_area , Number ): number_format = QgsBasicNumericFormat () number_format . setThousandsSeparator ( \",\" ) number_format . setShowTrailingZeros ( True ) number_format . setNumberDecimalPlaces ( self . AREA_DECIMAL_PLACES ) area_cell . setNumericFormat ( number_format ) row_data . append ( area_cell ) result_data . append ( row_data ) current_step += 1 self . _multistep_area_feedback . setCurrentStep ( current_step ) self . _contents = result_data self . _area_calculated = True return self . _contents","title":"contents"},{"location":"developer/api/core/api_reports_generator/","text":"Report Generator \u00b6 CPLUS Report generator. BaseScenarioReportGenerator \u00b6 BaseScenarioReportGenerator ( parent , context , feedback = None ) Bases: QObject Base class for generating a scenario report. Source code in src/cplus_plugin/lib/reports/generator.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def __init__ ( self , parent : QtCore . QObject , context : BaseReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent ) self . _context = context self . _feedback = context . feedback or feedback if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_canceled ) self . _error_messages : typing . List [ str ] = [] self . _error_occurred = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" context property \u00b6 context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. feedback property \u00b6 feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified. layout property \u00b6 layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful. output_dir property \u00b6 output_dir Creates, if it does not exist, the output directory where the report_templates will be saved. Returns: Type Description str Output directory where the report_templates will be saved. output_layout_path property \u00b6 output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file. run \u00b6 run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result () set_label_font classmethod \u00b6 set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh () BaseScenarioReportGeneratorTask \u00b6 BaseScenarioReportGeneratorTask ( description , context ) Bases: QgsTask Base proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , description : str , context : BaseReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = BaseScenarioReportGenerator ( self , self . _context , self . _context . feedback ) self . _generator . status_changed . connect ( self . _on_status_changed ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added ) context property \u00b6 context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator. result property \u00b6 result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. cancel \u00b6 cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 176 177 178 179 180 181 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel () run \u00b6 run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for report generation.\" ) msgs : typing . List [ str ] = [ msg ] scenario_identifier = None if hasattr ( self . _context , \"scenario\" ): scenario_identifier = self . _context . scenario . uuid self . _result = ReportResult ( False , scenario_identifier , \"\" , tuple ( msgs )) return self . _result . success DuplicatableRepeatPageReportGenerator \u00b6 DuplicatableRepeatPageReportGenerator ( parent , context , feedback = None ) Bases: BaseScenarioReportGenerator Incorporates extra functionality for duplicating a repeat page. Subclass must have _repeat_page and _repeat_page_num members. Source code in src/cplus_plugin/lib/reports/generator.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def __init__ ( self , parent : QtCore . QObject , context : BaseReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent ) self . _context = context self . _feedback = context . feedback or feedback if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_canceled ) self . _error_messages : typing . List [ str ] = [] self . _error_occurred = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\" duplicate_repeat_page \u00b6 duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True get_dimension_for_repeat_item \u00b6 get_dimension_for_repeat_item ( repeat_item ) Calculates the number of rows and columns for rendering items based on the size of CPLUS repeat item. It also determines the recommended width and height of the repeat area. Parameters: Name Type Description Default repeat_item CplusMapRepeatItem The map repeat item where the items will be rendered. required Returns: Type Description RepeatAreaDimension A recommended number of rows and columns respectively for rendering the repeat items as well the recommended dimension of the repeat area. Source code in src/cplus_plugin/lib/reports/generator.py 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 def get_dimension_for_repeat_item ( self , repeat_item : CplusMapRepeatItem ) -> typing . Optional [ RepeatAreaDimension ]: \"\"\"Calculates the number of rows and columns for rendering items based on the size of CPLUS repeat item. It also determines the recommended width and height of the repeat area. :param repeat_item: The map repeat item where the items will be rendered. :type repeat_item: CplusMapRepeatItem :returns: A recommended number of rows and columns respectively for rendering the repeat items as well the recommended dimension of the repeat area. :rtype: RepeatAreaDimension \"\"\" num_rows , num_cols = - 1 , - 1 if MINIMUM_ITEM_HEIGHT <= 0 or MINIMUM_ITEM_WIDTH <= 0 : tr_msg = tr ( \"Minimum repeat item dimensions cannot be used\" ) self . _error_messages . append ( tr_msg ) return None repeat_size = repeat_item . sizeWithUnits () repeat_width = repeat_size . width () repeat_height = repeat_size . height () repeat_ref_point = repeat_item . pagePositionWithUnits () repeat_ref_x = repeat_ref_point . x () repeat_ref_y = repeat_ref_point . y () # Determine number of columns num_cols = - 1 adjusted_item_width = MINIMUM_ITEM_WIDTH if repeat_width < MINIMUM_ITEM_WIDTH : tr_msg = tr ( \"Repeat item width is too small to render the model items\" ) self . _error_messages . append ( tr_msg ) return None else : num_cols = int ( repeat_width // MINIMUM_ITEM_WIDTH ) bleed_item_width = ( repeat_width - ( num_cols * MINIMUM_ITEM_WIDTH ) ) / num_cols adjusted_item_width = MINIMUM_ITEM_WIDTH + bleed_item_width # Determine number of rows num_rows = - 1 adjusted_item_height = MINIMUM_ITEM_HEIGHT if repeat_height < MINIMUM_ITEM_HEIGHT : tr_msg = tr ( \"Repeat item height is too small to render the model items\" ) self . _error_messages . append ( tr_msg ) return None else : num_rows = int ( repeat_height // MINIMUM_ITEM_HEIGHT ) bleed_item_height = ( repeat_height - ( num_rows * MINIMUM_ITEM_HEIGHT ) ) / num_rows adjusted_item_height = MINIMUM_ITEM_HEIGHT + bleed_item_height return RepeatAreaDimension ( num_rows , num_cols , adjusted_item_width , adjusted_item_height ) ScenarioAnalysisReportGenerator \u00b6 ScenarioAnalysisReportGenerator ( parent , context , feedback = None ) Bases: DuplicatableRepeatPageReportGenerator Generator for CPLUS scenario analysis report. Source code in src/cplus_plugin/lib/reports/generator.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 def __init__ ( self , parent : QtCore . QObject , context : ReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent , context , feedback ) self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None self . _activities_area = {} self . _pixel_area_info = {} self . _use_custom_metrics = context . custom_metrics self . _metrics_configuration = None self . _setup_metrics_configuration () self . _activity_pie_html = \"\" if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled ) activity_pie_html property \u00b6 activity_pie_html Returns the HTML path for the pie chart showing the activity area distribution. We want to use the QgsLayoutItemHtml to render the HTML file however, it cannot be rendered in a background thread hence we make the HTML available for use in the main application thread when the task has finished. Returns: Type Description str The path to the HTML file containing the activity area pie chart. output_dir property \u00b6 output_dir Creates, if it does not exist, the output directory where the analysis report_templates will be saved. This is relative to the base directory and scenario output sub-folder. Returns: Type Description str Output directory where the analysis report_templates will be saved. repeat_page property \u00b6 repeat_page Returns the page item that will be repeated based on the number of activities in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found. export_to_pdf \u00b6 export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False format_number classmethod \u00b6 format_number ( value , no_decimal_places = False ) Formats a number to two decimals places. Returns: Type Description str String representation of a number rounded off to two decimal places with a comma thousands' separator or just returns the value as passed in if its not a number. Source code in src/cplus_plugin/lib/reports/generator.py 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 @classmethod def format_number ( cls , value : typing . Any , no_decimal_places : bool = False ) -> str : \"\"\"Formats a number to two decimals places. :returns: String representation of a number rounded off to two decimal places with a comma thousands' separator or just returns the value as passed in if its not a number. :rtype: str \"\"\" if not isinstance ( value , Number ): return value number_format = QgsBasicNumericFormat () number_format . setThousandsSeparator ( \",\" ) number_format . setShowTrailingZeros ( True ) decimal_places = 0 if no_decimal_places else cls . AREA_DECIMAL_PLACES number_format . setNumberDecimalPlaces ( decimal_places ) return number_format . formatDouble ( value , QgsNumericFormatContext ()) ScenarioAnalysisReportGeneratorTask \u00b6 ScenarioAnalysisReportGeneratorTask ( description , context ) Bases: BaseScenarioReportGeneratorTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 245 246 247 248 249 250 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description , context ) self . _generator = ScenarioAnalysisReportGenerator ( self , context , self . _context . feedback ) self . _generator . status_changed . connect ( self . _on_status_changed ) finished \u00b6 finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) # Add pie chart to layout item since it has to be done in # the main application thread (for HTML layout items) html_path = self . _generator . activity_pie_html if not html_path : log ( \"Activity area pie chart could not be rendered.\" , info = False ) else : html_frame = layout . itemById ( ACTIVITY_AREA_HTML_ID ) if html_frame : pie_url = QtCore . QUrl . fromLocalFile ( html_path ) html_item = html_frame . multiFrame () html_item . setUrl ( pie_url ) html_item . update () else : log ( f \"scenario pie: HTML layout item ' { ACTIVITY_AREA_HTML_ID } ' not found in the layout.\" ) project . layoutManager () . addLayout ( layout ) project . write () if feedback is not None : feedback . setProgress ( 100 ) ScenarioComparisonReportGenerator \u00b6 ScenarioComparisonReportGenerator ( parent , context , feedback = None ) Bases: DuplicatableRepeatPageReportGenerator Generator for CPLUS scenario comparison reports. Source code in src/cplus_plugin/lib/reports/generator.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def __init__ ( self , parent : QtCore . QObject , context : ScenarioComparisonReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent , context , feedback ) # Repeat item for half page one self . _page_one_repeat_item = None # For duplicating page self . _repeat_page_item = None self . _repeat_page = None self . _repeat_page_num = - 1 self . _area_calculation_reference = 25 self . _comparison_info = ScenarioComparisonTableInfo ( self . _context . results ) self . _comparison_info . feedback . progressChanged . connect ( self . _on_area_calculation_changed ) output_dir property \u00b6 output_dir Creates, if it does not exist, the output directory where the comparison report_templates will be saved. This is relative to the base directory and comparison reports sub-folder. Returns: Type Description str Output directory where the scenario report_templates will be saved. ScenarioComparisonReportGeneratorTask \u00b6 ScenarioComparisonReportGeneratorTask ( description , context ) Bases: BaseScenarioReportGeneratorTask Proxy class for initiating the generation of scenario comparison reports. Source code in src/cplus_plugin/lib/reports/generator.py 353 354 355 356 357 def __init__ ( self , description : str , context : ScenarioComparisonReportContext ): super () . __init__ ( description , context ) self . _generator = ScenarioComparisonReportGenerator ( self , context , self . _context . feedback ) finished \u00b6 finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"scenario comparison report. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \"Comparison report - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the scenario comparison report.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 )","title":"Generator"},{"location":"developer/api/core/api_reports_generator/#report-generator","text":"CPLUS Report generator.","title":"Report Generator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator","text":"BaseScenarioReportGenerator ( parent , context , feedback = None ) Bases: QObject Base class for generating a scenario report. Source code in src/cplus_plugin/lib/reports/generator.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def __init__ ( self , parent : QtCore . QObject , context : BaseReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent ) self . _context = context self . _feedback = context . feedback or feedback if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_canceled ) self . _error_messages : typing . List [ str ] = [] self . _error_occurred = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\"","title":"BaseScenarioReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.feedback","text":"feedback Returns the feedback object for process update and cancellation. Returns: Type Description QgsFeedback Feedback object or None if not specified.","title":"feedback"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.layout","text":"layout Returns the layout object used to generate the report. Returns: Type Description QgsPrintLayout The layout object used to generate the report or None if the process was not successful.","title":"layout"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.output_dir","text":"output_dir Creates, if it does not exist, the output directory where the report_templates will be saved. Returns: Type Description str Output directory where the report_templates will be saved.","title":"output_dir"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.output_layout_path","text":"output_layout_path Absolute path to a temporary file containing the layout as a QPT file. When this object is used within a QgsTask, it is recommended to use this layout path to reconstruct the layout rather calling the layout attribute since it was created in a separate thread. Returns: Type Description str Path to the layout template file.","title":"output_layout_path"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.run","text":"run () Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def run ( self ) -> ReportResult : \"\"\"Initiates the report generation process and returns a result which contains information on whether the process succeeded or failed. :returns: The result of the report generation process. :rtype: ReportResult \"\"\" try : return self . _run () except Exception as ex : # Last resort to capture general exceptions. exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . _error_messages . append ( exc_info ) return self . _get_failed_result ()","title":"run"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGenerator.set_label_font","text":"set_label_font ( label , size , bold = False , italic = False ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False Source code in src/cplus_plugin/lib/reports/generator.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) label . setTextFormat ( txt_format ) label . refresh ()","title":"set_label_font"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGeneratorTask","text":"BaseScenarioReportGeneratorTask ( description , context ) Bases: QgsTask Base proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 138 139 140 141 142 143 144 145 146 147 def __init__ ( self , description : str , context : BaseReportContext ): super () . __init__ ( description ) self . _context = context self . _result = None self . _generator = BaseScenarioReportGenerator ( self , self . _context , self . _context . feedback ) self . _generator . status_changed . connect ( self . _on_status_changed ) self . layout_manager = QgsProject . instance () . layoutManager () self . layout_manager . layoutAdded . connect ( self . _on_layout_added )","title":"BaseScenarioReportGeneratorTask"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGeneratorTask.context","text":"context Returns the report context used by the generator. Returns: Type Description ReportContext Report context object used by the generator.","title":"context"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGeneratorTask.result","text":"result Returns the result object which contains information on whether the process succeeded or failed. Returns: Type Description ReportResult The result of the report generation process.","title":"result"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGeneratorTask.cancel","text":"cancel () Cancel the report generation task. Source code in src/cplus_plugin/lib/reports/generator.py 176 177 178 179 180 181 def cancel ( self ): \"\"\"Cancel the report generation task.\"\"\" if self . _context . feedback : self . _context . feedback . cancel () super () . cancel ()","title":"cancel"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.BaseScenarioReportGeneratorTask.run","text":"run () Initiates the report generation process and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the report generation process succeeded or False it if failed. Source code in src/cplus_plugin/lib/reports/generator.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def run ( self ) -> bool : \"\"\"Initiates the report generation process and returns a result indicating whether the process succeeded or failed. :returns: True if the report generation process succeeded or False it if failed. :rtype: bool \"\"\" if self . isCanceled (): return False if self . _context . project_file : self . _result = self . _generator . run () else : msg = tr ( \"Unable to serialize current project for report generation.\" ) msgs : typing . List [ str ] = [ msg ] scenario_identifier = None if hasattr ( self . _context , \"scenario\" ): scenario_identifier = self . _context . scenario . uuid self . _result = ReportResult ( False , scenario_identifier , \"\" , tuple ( msgs )) return self . _result . success","title":"run"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.DuplicatableRepeatPageReportGenerator","text":"DuplicatableRepeatPageReportGenerator ( parent , context , feedback = None ) Bases: BaseScenarioReportGenerator Incorporates extra functionality for duplicating a repeat page. Subclass must have _repeat_page and _repeat_page_num members. Source code in src/cplus_plugin/lib/reports/generator.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 def __init__ ( self , parent : QtCore . QObject , context : BaseReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent ) self . _context = context self . _feedback = context . feedback or feedback if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_canceled ) self . _error_messages : typing . List [ str ] = [] self . _error_occurred = False self . _layout = None self . _project = None self . _variable_register = LayoutVariableRegister () self . _report_output_dir = \"\" self . _output_layout_path = \"\"","title":"DuplicatableRepeatPageReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.DuplicatableRepeatPageReportGenerator.duplicate_repeat_page","text":"duplicate_repeat_page ( position ) Duplicates the repeat page and adds it to the layout at the given position. Parameters: Name Type Description Default position int Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. required Returns: Type Description bool True if the page was successfully duplicated else False. Source code in src/cplus_plugin/lib/reports/generator.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 def duplicate_repeat_page ( self , position : int ) -> bool : \"\"\"Duplicates the repeat page and adds it to the layout at the given position. :param position: Zero-based position to insert the duplicated page. If the position is greater than the number of pages, then the duplicated page will be inserted at the end of the layout. :type position: int :returns: True if the page was successfully duplicated else False. :rtype: bool \"\"\" if self . _repeat_page is None : return False if self . _layout is None : return False if self . _repeat_page_num == - 1 : tr_msg = \"Repeat page not found in page collection\" self . _error_messages . append ( tr_msg ) return False new_page = QgsLayoutItemPage ( self . _layout ) new_page . attemptResize ( self . _repeat_page . sizeWithUnits ()) new_page . setPageStyleSymbol ( self . _repeat_page . pageStyleSymbol () . clone ()) # Insert empty repeat page at the given position if position < self . _layout . pageCollection () . pageCount (): self . _layout . pageCollection () . insertPage ( new_page , position ) else : # Add at the end position = self . _layout . pageCollection () . pageCount () self . _layout . pageCollection () . addPage ( new_page ) doc = QtXml . QDomDocument () el = doc . createElement ( \"CopyItems\" ) ctx = QgsReadWriteContext () repeat_page_items = self . _layout . pageCollection () . itemsOnPage ( self . _repeat_page_num ) for item in repeat_page_items : item . writeXml ( el , doc , ctx ) doc . appendChild ( el ) # Clear element identifier references nodes = doc . elementsByTagName ( \"LayoutItem\" ) for n in range ( nodes . count ()): node = nodes . at ( n ) if node . isElement (): node . toElement () . removeAttribute ( \"uuid\" ) page_ref_point = self . _layout . pageCollection () . pagePositionToLayoutPosition ( position , QgsLayoutPoint ( 0 , 0 ) ) _ = self . _layout . addItemsFromXml ( el , doc , ctx , page_ref_point , True ) return True","title":"duplicate_repeat_page"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.DuplicatableRepeatPageReportGenerator.get_dimension_for_repeat_item","text":"get_dimension_for_repeat_item ( repeat_item ) Calculates the number of rows and columns for rendering items based on the size of CPLUS repeat item. It also determines the recommended width and height of the repeat area. Parameters: Name Type Description Default repeat_item CplusMapRepeatItem The map repeat item where the items will be rendered. required Returns: Type Description RepeatAreaDimension A recommended number of rows and columns respectively for rendering the repeat items as well the recommended dimension of the repeat area. Source code in src/cplus_plugin/lib/reports/generator.py 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 def get_dimension_for_repeat_item ( self , repeat_item : CplusMapRepeatItem ) -> typing . Optional [ RepeatAreaDimension ]: \"\"\"Calculates the number of rows and columns for rendering items based on the size of CPLUS repeat item. It also determines the recommended width and height of the repeat area. :param repeat_item: The map repeat item where the items will be rendered. :type repeat_item: CplusMapRepeatItem :returns: A recommended number of rows and columns respectively for rendering the repeat items as well the recommended dimension of the repeat area. :rtype: RepeatAreaDimension \"\"\" num_rows , num_cols = - 1 , - 1 if MINIMUM_ITEM_HEIGHT <= 0 or MINIMUM_ITEM_WIDTH <= 0 : tr_msg = tr ( \"Minimum repeat item dimensions cannot be used\" ) self . _error_messages . append ( tr_msg ) return None repeat_size = repeat_item . sizeWithUnits () repeat_width = repeat_size . width () repeat_height = repeat_size . height () repeat_ref_point = repeat_item . pagePositionWithUnits () repeat_ref_x = repeat_ref_point . x () repeat_ref_y = repeat_ref_point . y () # Determine number of columns num_cols = - 1 adjusted_item_width = MINIMUM_ITEM_WIDTH if repeat_width < MINIMUM_ITEM_WIDTH : tr_msg = tr ( \"Repeat item width is too small to render the model items\" ) self . _error_messages . append ( tr_msg ) return None else : num_cols = int ( repeat_width // MINIMUM_ITEM_WIDTH ) bleed_item_width = ( repeat_width - ( num_cols * MINIMUM_ITEM_WIDTH ) ) / num_cols adjusted_item_width = MINIMUM_ITEM_WIDTH + bleed_item_width # Determine number of rows num_rows = - 1 adjusted_item_height = MINIMUM_ITEM_HEIGHT if repeat_height < MINIMUM_ITEM_HEIGHT : tr_msg = tr ( \"Repeat item height is too small to render the model items\" ) self . _error_messages . append ( tr_msg ) return None else : num_rows = int ( repeat_height // MINIMUM_ITEM_HEIGHT ) bleed_item_height = ( repeat_height - ( num_rows * MINIMUM_ITEM_HEIGHT ) ) / num_rows adjusted_item_height = MINIMUM_ITEM_HEIGHT + bleed_item_height return RepeatAreaDimension ( num_rows , num_cols , adjusted_item_width , adjusted_item_height )","title":"get_dimension_for_repeat_item"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator","text":"ScenarioAnalysisReportGenerator ( parent , context , feedback = None ) Bases: DuplicatableRepeatPageReportGenerator Generator for CPLUS scenario analysis report. Source code in src/cplus_plugin/lib/reports/generator.py 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 def __init__ ( self , parent : QtCore . QObject , context : ReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent , context , feedback ) self . _repeat_page = None self . _repeat_page_num = - 1 self . _repeat_item = None self . _reference_layer_group = None self . _scenario_layer = None self . _area_processing_feedback = None self . _activities_area = {} self . _pixel_area_info = {} self . _use_custom_metrics = context . custom_metrics self . _metrics_configuration = None self . _setup_metrics_configuration () self . _activity_pie_html = \"\" if self . _feedback : self . _feedback . canceled . connect ( self . _on_feedback_cancelled )","title":"ScenarioAnalysisReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator.activity_pie_html","text":"activity_pie_html Returns the HTML path for the pie chart showing the activity area distribution. We want to use the QgsLayoutItemHtml to render the HTML file however, it cannot be rendered in a background thread hence we make the HTML available for use in the main application thread when the task has finished. Returns: Type Description str The path to the HTML file containing the activity area pie chart.","title":"activity_pie_html"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator.output_dir","text":"output_dir Creates, if it does not exist, the output directory where the analysis report_templates will be saved. This is relative to the base directory and scenario output sub-folder. Returns: Type Description str Output directory where the analysis report_templates will be saved.","title":"output_dir"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator.repeat_page","text":"repeat_page Returns the page item that will be repeated based on the number of activities in the scenario. A repeat page is a layout page item that contains the first instance of a CplusMapRepeatItem. Returns: Type Description QgsLayoutItemPage Page item containing a CplusMapRepeatItem or None if not found.","title":"repeat_page"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator.export_to_pdf","text":"export_to_pdf () Exports the layout to a PDF file in the output directory using the layout name as the file name. Returns: Type Description bool True if the layout was successfully exported else False. Source code in src/cplus_plugin/lib/reports/generator.py 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 def export_to_pdf ( self ) -> bool : \"\"\"Exports the layout to a PDF file in the output directory using the layout name as the file name. :returns: True if the layout was successfully exported else False. :rtype: bool \"\"\" if self . _layout is None or self . _project is None or not self . output_dir : return False exporter = QgsLayoutExporter ( self . _layout ) pdf_path = f \" { self . output_dir } / { self . _layout . name () } .pdf\" result = exporter . exportToPdf ( pdf_path , QgsLayoutExporter . PdfExportSettings ()) if result == QgsLayoutExporter . ExportResult . Success : return True else : tr_msg = tr ( \"Could not export layout to PDF\" ) self . _error_messages . append ( f \" { tr_msg } { pdf_path } .\" ) return False","title":"export_to_pdf"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGenerator.format_number","text":"format_number ( value , no_decimal_places = False ) Formats a number to two decimals places. Returns: Type Description str String representation of a number rounded off to two decimal places with a comma thousands' separator or just returns the value as passed in if its not a number. Source code in src/cplus_plugin/lib/reports/generator.py 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 @classmethod def format_number ( cls , value : typing . Any , no_decimal_places : bool = False ) -> str : \"\"\"Formats a number to two decimals places. :returns: String representation of a number rounded off to two decimal places with a comma thousands' separator or just returns the value as passed in if its not a number. :rtype: str \"\"\" if not isinstance ( value , Number ): return value number_format = QgsBasicNumericFormat () number_format . setThousandsSeparator ( \",\" ) number_format . setShowTrailingZeros ( True ) decimal_places = 0 if no_decimal_places else cls . AREA_DECIMAL_PLACES number_format . setNumberDecimalPlaces ( decimal_places ) return number_format . formatDouble ( value , QgsNumericFormatContext ())","title":"format_number"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGeneratorTask","text":"ScenarioAnalysisReportGeneratorTask ( description , context ) Bases: BaseScenarioReportGeneratorTask Proxy class for initiating the report generation process. Source code in src/cplus_plugin/lib/reports/generator.py 245 246 247 248 249 250 def __init__ ( self , description : str , context : ReportContext ): super () . __init__ ( description , context ) self . _generator = ScenarioAnalysisReportGenerator ( self , context , self . _context . feedback ) self . _generator . status_changed . connect ( self . _on_status_changed )","title":"ScenarioAnalysisReportGeneratorTask"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioAnalysisReportGeneratorTask.finished","text":"finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"report for { self . _context . scenario . name } \" f \"scenario. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \" { self . _context . scenario . name } - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the report for \" f \" { self . _context . scenario . name } scenario.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return # Zoom the extents of map items in the layout then export to PDF self . _zoom_map_items_to_current_extents ( layout ) # Add pie chart to layout item since it has to be done in # the main application thread (for HTML layout items) html_path = self . _generator . activity_pie_html if not html_path : log ( \"Activity area pie chart could not be rendered.\" , info = False ) else : html_frame = layout . itemById ( ACTIVITY_AREA_HTML_ID ) if html_frame : pie_url = QtCore . QUrl . fromLocalFile ( html_path ) html_item = html_frame . multiFrame () html_item . setUrl ( pie_url ) html_item . update () else : log ( f \"scenario pie: HTML layout item ' { ACTIVITY_AREA_HTML_ID } ' not found in the layout.\" ) project . layoutManager () . addLayout ( layout ) project . write () if feedback is not None : feedback . setProgress ( 100 )","title":"finished"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioComparisonReportGenerator","text":"ScenarioComparisonReportGenerator ( parent , context , feedback = None ) Bases: DuplicatableRepeatPageReportGenerator Generator for CPLUS scenario comparison reports. Source code in src/cplus_plugin/lib/reports/generator.py 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 def __init__ ( self , parent : QtCore . QObject , context : ScenarioComparisonReportContext , feedback : QgsFeedback = None , ): super () . __init__ ( parent , context , feedback ) # Repeat item for half page one self . _page_one_repeat_item = None # For duplicating page self . _repeat_page_item = None self . _repeat_page = None self . _repeat_page_num = - 1 self . _area_calculation_reference = 25 self . _comparison_info = ScenarioComparisonTableInfo ( self . _context . results ) self . _comparison_info . feedback . progressChanged . connect ( self . _on_area_calculation_changed )","title":"ScenarioComparisonReportGenerator"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioComparisonReportGenerator.output_dir","text":"output_dir Creates, if it does not exist, the output directory where the comparison report_templates will be saved. This is relative to the base directory and comparison reports sub-folder. Returns: Type Description str Output directory where the scenario report_templates will be saved.","title":"output_dir"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioComparisonReportGeneratorTask","text":"ScenarioComparisonReportGeneratorTask ( description , context ) Bases: BaseScenarioReportGeneratorTask Proxy class for initiating the generation of scenario comparison reports. Source code in src/cplus_plugin/lib/reports/generator.py 353 354 355 356 357 def __init__ ( self , description : str , context : ScenarioComparisonReportContext ): super () . __init__ ( description , context ) self . _generator = ScenarioComparisonReportGenerator ( self , context , self . _context . feedback )","title":"ScenarioComparisonReportGeneratorTask"},{"location":"developer/api/core/api_reports_generator/#src.cplus_plugin.lib.reports.generator.ScenarioComparisonReportGeneratorTask.finished","text":"finished ( result ) If successful, add the layout to the project. Parameters: Name Type Description Default result bool Flag indicating if the result of the report generation process. True if successful, else False. required Source code in src/cplus_plugin/lib/reports/generator.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 def finished ( self , result : bool ): \"\"\"If successful, add the layout to the project. :param result: Flag indicating if the result of the report generation process. True if successful, else False. :type result: bool \"\"\" if len ( self . _result . messages ) > 0 : log ( f \"Warnings and errors occurred when generating the \" f \"scenario comparison report. See details below:\" , info = False , ) for err in self . _result . messages : err_msg = f \"Comparison report - { err } \\n \" log ( err_msg , info = False ) if result : log ( f \"Successfully generated the scenario comparison report.\" ) layout_path = self . _generator . output_layout_path if not layout_path : log ( \"Output layout could not be saved.\" , info = False ) return feedback = self . _context . feedback project = QgsProject . instance () layout = _load_layout_from_file ( layout_path , project ) if layout is None : log ( \"Could not load layout from file.\" , info = False ) return project . layoutManager () . addLayout ( layout ) if feedback is not None : feedback . setProgress ( 100 )","title":"finished"},{"location":"developer/api/core/api_reports_layout_items/","text":"Layout Items \u00b6 Custom CPLUS layout items. BasicScenarioDetailsItem \u00b6 BasicScenarioDetailsItem ( * args , ** kwargs ) Bases: QgsLayoutItemGroup Contains elements showing the basic details of a scenario such as a title, description, map and legend. Source code in src/cplus_plugin/lib/reports/layout_items.py 134 135 136 137 138 139 140 141 def __init__ ( self , * args , ** kwargs ): self . _result : ScenarioResult = kwargs . pop ( \"scenario_result\" , None ) self . _project = kwargs . pop ( \"project\" , None ) super () . __init__ ( * args , ** kwargs ) self . _add_scenario_layout_items () self . _update_scenario_details () attemptResize \u00b6 attemptResize ( * args , ** kwargs ) Override to set the correct position of the legend item. Source code in src/cplus_plugin/lib/reports/layout_items.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def attemptResize ( self , * args , ** kwargs ): \"\"\"Override to set the correct position of the legend item.\"\"\" super () . attemptResize ( * args , ** kwargs ) group_height = self . sizeWithUnits () . height () group_width = self . sizeWithUnits () . width () reference_point = self . pagePositionWithUnits () reference_point_x = reference_point . x () reference_point_y = reference_point . y () # Set position of the legend legend_height = self . _legend . sizeWithUnits () . height () / 2 new_reference_y = reference_point_y + ( group_height - legend_height ) legend_ref_point = QgsLayoutPoint ( reference_point_x , new_reference_y , self . layout () . units () ) self . _legend . attemptMove ( legend_ref_point , True , False , self . page ()) self . _legend . attemptResize ( QgsLayoutSize ( group_width , legend_height , self . layout () . units ()) ) # Set height for the map map_height = group_height - ( legend_height + self . _title_label . sizeWithUnits () . height () + self . _description_label . sizeWithUnits () . height () ) self . _scenario_map . attemptResize ( QgsLayoutSize ( self . _scenario_map . sizeWithUnits () . width (), map_height , self . layout () . units (), ) ) set_label_font classmethod \u00b6 set_label_font ( label , size , bold = False , italic = False , color = None ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False color QColor Color for the text or None for the default color. None Source code in src/cplus_plugin/lib/reports/layout_items.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , color : QtGui . QColor = None , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool :param color: Color for the text or None for the default color. :type color: QtGui.QColor \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) if color is not None : label . setFontColor ( color ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) if color is not None : txt_format . setColor ( color ) label . setTextFormat ( txt_format ) label . refresh () CplusMapRepeatItem \u00b6 CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or activity will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN ) model_component_type property writable \u00b6 model_component_type Gets the model component type associated with this map item i.e. NCS pathway or activity. Returns: Type Description Enum Type of the model component. icon \u00b6 icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 94 95 96 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" ) readPropertiesFromElement \u00b6 readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 106 107 108 109 110 111 112 113 114 115 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status type \u00b6 type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 82 83 84 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE visibleName \u00b6 visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 86 87 88 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" ) visiblePluralName \u00b6 visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 90 91 92 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" ) writePropertiesToElement \u00b6 writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 98 99 100 101 102 103 104 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status CplusMapRepeatItemLayoutItemMetadata \u00b6 CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 121 122 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" )) createItem \u00b6 createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 124 125 126 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"Layout items"},{"location":"developer/api/core/api_reports_layout_items/#layout-items","text":"Custom CPLUS layout items.","title":"Layout Items"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.BasicScenarioDetailsItem","text":"BasicScenarioDetailsItem ( * args , ** kwargs ) Bases: QgsLayoutItemGroup Contains elements showing the basic details of a scenario such as a title, description, map and legend. Source code in src/cplus_plugin/lib/reports/layout_items.py 134 135 136 137 138 139 140 141 def __init__ ( self , * args , ** kwargs ): self . _result : ScenarioResult = kwargs . pop ( \"scenario_result\" , None ) self . _project = kwargs . pop ( \"project\" , None ) super () . __init__ ( * args , ** kwargs ) self . _add_scenario_layout_items () self . _update_scenario_details ()","title":"BasicScenarioDetailsItem"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.BasicScenarioDetailsItem.attemptResize","text":"attemptResize ( * args , ** kwargs ) Override to set the correct position of the legend item. Source code in src/cplus_plugin/lib/reports/layout_items.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 def attemptResize ( self , * args , ** kwargs ): \"\"\"Override to set the correct position of the legend item.\"\"\" super () . attemptResize ( * args , ** kwargs ) group_height = self . sizeWithUnits () . height () group_width = self . sizeWithUnits () . width () reference_point = self . pagePositionWithUnits () reference_point_x = reference_point . x () reference_point_y = reference_point . y () # Set position of the legend legend_height = self . _legend . sizeWithUnits () . height () / 2 new_reference_y = reference_point_y + ( group_height - legend_height ) legend_ref_point = QgsLayoutPoint ( reference_point_x , new_reference_y , self . layout () . units () ) self . _legend . attemptMove ( legend_ref_point , True , False , self . page ()) self . _legend . attemptResize ( QgsLayoutSize ( group_width , legend_height , self . layout () . units ()) ) # Set height for the map map_height = group_height - ( legend_height + self . _title_label . sizeWithUnits () . height () + self . _description_label . sizeWithUnits () . height () ) self . _scenario_map . attemptResize ( QgsLayoutSize ( self . _scenario_map . sizeWithUnits () . width (), map_height , self . layout () . units (), ) )","title":"attemptResize"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.BasicScenarioDetailsItem.set_label_font","text":"set_label_font ( label , size , bold = False , italic = False , color = None ) Set font properties of the given layout label item. Parameters: Name Type Description Default label QgsLayoutItemLabel Label item whose font properties will be updated. required size float Point size of the font. required bold bool True if font is to be bold, else False (default). False italic bool True if font is to be in italics, else False (default). False color QColor Color for the text or None for the default color. None Source code in src/cplus_plugin/lib/reports/layout_items.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 @classmethod def set_label_font ( cls , label : QgsLayoutItemLabel , size : float , bold : bool = False , italic : bool = False , color : QtGui . QColor = None , ): \"\"\"Set font properties of the given layout label item. :param label: Label item whose font properties will be updated. :type label: QgsLayoutItemLabel :param size: Point size of the font. :type size: int :param bold: True if font is to be bold, else False (default). :type bold: bool :param italic: True if font is to be in italics, else False (default). :type italic: bool :param color: Color for the text or None for the default color. :type color: QtGui.QColor \"\"\" font = get_report_font ( size , bold , italic ) version = Qgis . versionInt () # Text format size unit if version < 33000 : unit_type = QgsUnitTypes . RenderUnit . RenderPoints else : unit_type = Qgis . RenderUnit . Points # Label font setting option if version < 32400 : label . setFont ( font ) if color is not None : label . setFontColor ( color ) else : txt_format = QgsTextFormat () txt_format . setFont ( font ) txt_format . setSize ( size ) txt_format . setSizeUnit ( unit_type ) if color is not None : txt_format . setColor ( color ) label . setTextFormat ( txt_format ) label . refresh ()","title":"set_label_font"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem","text":"CplusMapRepeatItem ( * args , ** kwargs ) Bases: QgsLayoutItemShape Defines an outline area within a layout where map items containing NCS pathway or activity will be drawn. Source code in src/cplus_plugin/lib/reports/layout_items.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . setShapeType ( QgsLayoutItemShape . Shape . Rectangle ) # We shall use a frame so that it can be turned off / on # using the item properties UI. The symbol is just a proxy. # Symbol properties symbol_props = { \"color\" : \"229,182,54,0\" , \"style\" : \"solid\" , \"outline_style\" : \"dash\" , \"line_color\" : \"132,192,68\" , \"outline_width\" : \"0\" , \"joinstyle\" : \"miter\" , } symbol = QgsFillSymbol . createSimple ( symbol_props ) self . setSymbol ( symbol ) self . _model_component_type = kwargs . pop ( \"model_component_type\" , ModelComponentType . UNKNOWN )","title":"CplusMapRepeatItem"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.model_component_type","text":"model_component_type Gets the model component type associated with this map item i.e. NCS pathway or activity. Returns: Type Description Enum Type of the model component.","title":"model_component_type"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.icon","text":"icon () Override for custom CPLUS map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 94 95 96 def icon ( self ) -> QtGui . QIcon : \"\"\"Override for custom CPLUS map item.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus.svg\" )","title":"icon"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.readPropertiesFromElement","text":"readPropertiesFromElement ( element , document , context ) Override reading of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 106 107 108 109 110 111 112 113 114 115 def readPropertiesFromElement ( self , element , document , context ): \"\"\"Override reading of item properties.\"\"\" status = super () . readPropertiesFromElement ( element , document , context ) if status : model_component_type = element . attribute ( \"modelComponentType\" , \"\" ) self . _model_component_type = ModelComponentType . from_string ( model_component_type ) return status","title":"readPropertiesFromElement"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.type","text":"type () Return item's unique type identifier. Source code in src/cplus_plugin/lib/reports/layout_items.py 82 83 84 def type ( self ): \"\"\"Return item's unique type identifier.\"\"\" return CPLUS_MAP_REPEAT_ITEM_TYPE","title":"type"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visibleName","text":"visibleName () Override for visible name of the item. Source code in src/cplus_plugin/lib/reports/layout_items.py 86 87 88 def visibleName ( self ) -> str : \"\"\"Override for visible name of the item.\"\"\" return tr ( \"CPLUS Map Repeat Area Item\" )","title":"visibleName"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.visiblePluralName","text":"visiblePluralName () Override for plural name of the items. Source code in src/cplus_plugin/lib/reports/layout_items.py 90 91 92 def visiblePluralName ( self ) -> str : \"\"\"Override for plural name of the items.\"\"\" return tr ( \"CPLUS Map Repeat Area Items\" )","title":"visiblePluralName"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItem.writePropertiesToElement","text":"writePropertiesToElement ( el , document , context ) Override saving of item properties. Source code in src/cplus_plugin/lib/reports/layout_items.py 98 99 100 101 102 103 104 def writePropertiesToElement ( self , el , document , context ): \"\"\"Override saving of item properties.\"\"\" status = super () . writePropertiesToElement ( el , document , context ) if status : el . setAttribute ( \"modelComponentType\" , self . _model_component_type . value ) return status","title":"writePropertiesToElement"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata","text":"CplusMapRepeatItemLayoutItemMetadata () Bases: QgsLayoutItemAbstractMetadata Metadata info of the cplus map repeat item. Source code in src/cplus_plugin/lib/reports/layout_items.py 121 122 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , tr ( \"CPLUS Map Repeat Area Item\" ))","title":"CplusMapRepeatItemLayoutItemMetadata"},{"location":"developer/api/core/api_reports_layout_items/#src.cplus_plugin.lib.reports.layout_items.CplusMapRepeatItemLayoutItemMetadata.createItem","text":"createItem ( layout ) Factory method that return the cplus map item. Source code in src/cplus_plugin/lib/reports/layout_items.py 124 125 126 def createItem ( self , layout ) -> CplusMapRepeatItem : \"\"\"Factory method that return the cplus map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem"},{"location":"developer/api/core/api_reports_manager/","text":"Report Manager \u00b6 Registers custom report variables for layout design and handles report generation. ReportManager \u00b6 ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . iface = iface self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} # Flag for checking number of comparison report tasks self . _running_comparison_tasks = 0 self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) # Set default zoom when a report is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) self . root_output_dir = \"\" variable_register property \u00b6 variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope. create_comparison_report_context classmethod \u00b6 create_comparison_report_context ( scenario_results , feedback ) Create contextual information for generating the scenario comparison report. Parameters: Name Type Description Default scenario_results List [ ScenarioResult ] Collection of scenario results to be compared. required feedback QgsFeedback Feedback object for reporting back to the main application. required Source code in src/cplus_plugin/lib/reports/manager.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 @classmethod def create_comparison_report_context ( cls , scenario_results : typing . List [ ScenarioResult ], feedback : QgsFeedback ) -> typing . Optional [ ScenarioComparisonReportContext ]: \"\"\"Create contextual information for generating the scenario comparison report. :param scenario_results: Collection of scenario results to be compared. :type scenario_results: list :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback \"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if base_dir is None : log ( f \"Base directory is empty, unable to generate comparison report.\" ) return None FileUtils . create_comparison_reports_dir ( base_dir ) folder_name = datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) report_dir = os . path . normpath ( f \" { base_dir } / { COMPARISON_REPORT_SEGMENT } / { folder_name } \" ) FileUtils . create_new_dir ( report_dir ) project_file_path = os . path . join ( report_dir , f \" { COMPARISON_REPORT_SEGMENT } .qgz\" ) # Save project file. result = cls . _save_current_project ( project_file_path ) if not result : log ( f \"Unable to save the project for scenario report generation.\" ) return None layout_name = f \" { DEFAULT_BASE_COMPARISON_REPORT_NAME } { folder_name } \" template_path = FileUtils . report_template_path ( SCENARIO_COMPARISON_TEMPLATE_NAME ) return ScenarioComparisonReportContext ( template_path = template_path , name = layout_name , project_file = project_file_path , feedback = feedback , results = scenario_results , output_dir = report_dir , ) create_report_context classmethod \u00b6 create_report_context ( scenario_result , feedback , use_custom_metrics = False ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario_result ScenarioResult Result of the scenario analysis. required feedback QgsFeedback Feedback object for reporting back to the main application. required use_custom_metrics bool True to use custom metrics else False. If True and the metrics configuration is empty or undefined, then the default activity table in the scenario analysis report will be used. False Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 @classmethod def create_report_context ( cls , scenario_result : ScenarioResult , feedback : QgsFeedback , use_custom_metrics : bool = False , ) -> typing . Optional [ ReportContext ]: \"\"\"Creates the report context for use in the report generator task. :param scenario_result: Result of the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :param use_custom_metrics: True to use custom metrics else False. If True and the metrics configuration is empty or undefined, then the default activity table in the scenario analysis report will be used. :type use_custom_metrics: bool :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" output_dir = os . path . normpath ( scenario_result . scenario_directory ) if not output_dir or not Path ( output_dir ) . exists (): log ( f \"Unable to generate the report. { output_dir } not found. \\n \" ) return None scenario_report_dir = os . path . normpath ( f \" { output_dir } /reports\" ) FileUtils . create_new_dir ( scenario_report_dir ) cleaned_scenario_name = clean_filename ( scenario_result . scenario . name ) project_file_path = os . path . join ( scenario_report_dir , f \" { cleaned_scenario_name } .qgz\" ) if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } _ { counter !s} .qgz\" , ) if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. result = cls . _save_current_project ( project_file_path ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario_result . scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 metrics_configuration = None metric_collection = settings_manager . get_metric_profile_collection () if metric_collection : current_metric_profile = metric_collection . get_current_profile () if current_metric_profile : metrics_configuration = current_metric_profile . config if ( use_custom_metrics and metrics_configuration is not None and metrics_configuration . is_valid () ): # Metrics template template_path = FileUtils . report_template_path ( SCENARIO_ANALYSIS_METRICS_TEMPLATE_NAME ) else : # Default template template_path = FileUtils . report_template_path ( SCENARIO_ANALYSIS_TEMPLATE_NAME ) return ReportContext ( template_path = template_path , scenario = scenario_result . scenario , name = context_name , scenario_output_dir = scenario_report_dir , project_file = project_file_path , feedback = feedback , output_layer_name = scenario_result . output_layer_name , custom_metrics = use_custom_metrics , ) create_scenario_dir \u00b6 create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str generate \u00b6 generate ( scenario_result , feedback = None , use_custom_metrics = False ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None use_custom_metrics bool True to use custom metrics else False. If True and there is no active profile or if the metrics configuration profile is empty or undefined, then the default activity table in the scenario analysis report will be used. False Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None , use_custom_metrics : bool = False , ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :param use_custom_metrics: True to use custom metrics else False. If True and there is no active profile or if the metrics configuration profile is empty or undefined, then the default activity table in the scenario analysis report will be used. :type use_custom_metrics: bool :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate report_templates.\" ) return ReportSubmitStatus ( False , None , \"\" ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario_result , feedback , use_custom_metrics ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None , \"\" ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback , \"\" ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ScenarioAnalysisReportGeneratorTask ( description , ctx ) report_task_completed = partial ( self . report_task_completed , report_task ) report_task . taskCompleted . connect ( report_task_completed ) report_task . taskTerminated . connect ( report_task_completed ) report_task . status_changed . connect ( self . on_analysis_status_changed ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback , str ( task_id )) generate_comparison_report \u00b6 generate_comparison_report ( scenario_results , feedback = None ) Generates a report comparing the two or more scenarios. Parameters: Name Type Description Default scenario_results List [ ScenarioResult ] Collection of scenario results to be compared. required feedback QgsFeedback Feedback object for reporting back to the main application. Default is None. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 def generate_comparison_report ( self , scenario_results : typing . List [ ScenarioResult ], feedback : QgsFeedback = None , ) -> ReportSubmitStatus : \"\"\"Generates a report comparing the two or more scenarios. :param scenario_results: Collection of scenario results to be compared. :type scenario_results: list :param feedback: Feedback object for reporting back to the main application. Default is None. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" if self . _running_comparison_tasks == self . COMPARISON_REPORT_LIMIT : log ( \"Reached limit of comparison report processes, try again later.\" ) return ReportSubmitStatus ( False , None , \"\" ) if feedback is None : feedback = QgsFeedback ( self ) comparison_context = self . create_comparison_report_context ( scenario_results , feedback ) if comparison_context is None : return ReportSubmitStatus ( False , None , \"\" ) description = tr ( \"Generating scenario comparison report\" ) task = ScenarioComparisonReportGeneratorTask ( description , comparison_context ) task . statusChanged . connect ( self . on_comparison_task_status_changed ) task_id = self . task_manager . addTask ( task ) return ReportSubmitStatus ( True , feedback , str ( task_id )) on_analysis_status_changed \u00b6 on_analysis_status_changed ( message ) Slot raised when the status for a scenario analysis changes. Parameters: Name Type Description Default message str Status message. required Source code in src/cplus_plugin/lib/reports/manager.py 345 346 347 348 349 350 351 352 353 354 def on_analysis_status_changed ( self , message : str ): \"\"\"Slot raised when the status for a scenario analysis changes. :param message: Status message. :type message: str \"\"\" if not message : return self . status_changed . emit ( message ) on_comparison_task_status_changed \u00b6 on_comparison_task_status_changed ( status ) Slot raised when the comparison task status has changed. Parameters: Name Type Description Default status int Task status: required Source code in src/cplus_plugin/lib/reports/manager.py 549 550 551 552 553 554 555 556 557 558 def on_comparison_task_status_changed ( self , status : int ): \"\"\"Slot raised when the comparison task status has changed. :param status: Task status: :type status: int \"\"\" if status == QgsTask . TaskStatus . Running : self . _running_comparison_tasks += 1 elif status in ( QgsTask . TaskStatus . Complete , QgsTask . TaskStatus . Terminated ): self . _running_comparison_tasks -= 1 on_layout_designer_opened \u00b6 on_layout_designer_opened ( designer ) Sets a default zoom level for the report when opened for the first time. Source code in src/cplus_plugin/lib/reports/manager.py 608 609 610 611 612 613 614 615 616 617 618 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Sets a default zoom level for the report when opened for the first time. \"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . Type . PrintLayout : layout = designer . layout () if self . _variable_register . is_analysis_report ( layout ): view = designer . view () view . zoomActual () view . emitZoomLevelChanged () on_task_status_changed \u00b6 on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS scenario analysis report if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id ) open_layout_designer \u00b6 open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def open_layout_designer ( self , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False _ = self . iface . openLayoutDesigner ( layout ) return True register_variables \u00b6 register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 99 100 101 102 103 104 105 106 107 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout ) remove_report_task \u00b6 remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True remove_task_by_result \u00b6 remove_task_by_result ( submit_result ) Remove a report task based on the submit result. Parameters: Name Type Description Default submit_result ReportSubmitStatus Submit result information. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given submit result. Source code in src/cplus_plugin/lib/reports/manager.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def remove_task_by_result ( self , submit_result : ReportSubmitStatus ) -> bool : \"\"\"Remove a report task based on the submit result. :param submit_result: Submit result information. :type submit_result: ReportSubmitStatus :returns: True if the task has been successfully removed else False if there is no associated task for the given submit result. :rtype: bool \"\"\" for scenario_id , task_id in self . _report_tasks . items (): if int ( submit_result . identifier ) == task_id : self . remove_report_task ( scenario_id ) return True task = self . task_by_id ( int ( submit_result . identifier )) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): submit_result . feedback . cancel () task . cancel () return True return False report_result \u00b6 report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ] scenario_by_task_id \u00b6 scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ] task_by_id \u00b6 task_by_id ( task_id ) Gets the task using its identifier. Parameters: Name Type Description Default task_id int Task identifier. required Returns: Type Description QgsTask The tas corresponding to the given ID or None if not found. Source code in src/cplus_plugin/lib/reports/manager.py 109 110 111 112 113 114 115 116 117 118 119 def task_by_id ( self , task_id : int ) -> typing . Optional [ QgsTask ]: \"\"\"Gets the task using its identifier. :param task_id: Task identifier. :type task_id: int :returns: The tas corresponding to the given ID or None if not found. :rtype: QgsTask \"\"\" return self . task_manager . task ( task_id ) view_pdf classmethod \u00b6 view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"Manager"},{"location":"developer/api/core/api_reports_manager/#report-manager","text":"Registers custom report variables for layout design and handles report generation.","title":"Report Manager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager","text":"ReportManager ( parent = None ) Bases: QObject Registers custom report variables for layout design and handles report generation. Source code in src/cplus_plugin/lib/reports/manager.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . iface = iface self . _variable_register = LayoutVariableRegister () self . report_name = tr ( \"Scenario Analysis Report\" ) # Task id (value) indexed by scenario id (key) self . _report_tasks = {} # Report results (value) indexed by scenario id (key) self . _report_results = {} # Flag for checking number of comparison report tasks self . _running_comparison_tasks = 0 self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_task_status_changed ) # Set default zoom when a report is opened self . iface . layoutDesignerOpened . connect ( self . on_layout_designer_opened ) self . root_output_dir = \"\"","title":"ReportManager"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.variable_register","text":"variable_register Get the instance of the variable register used for the management of variables. Returns: Type Description LayoutVariableRegister The register for managing variables in report layout scope.","title":"variable_register"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_comparison_report_context","text":"create_comparison_report_context ( scenario_results , feedback ) Create contextual information for generating the scenario comparison report. Parameters: Name Type Description Default scenario_results List [ ScenarioResult ] Collection of scenario results to be compared. required feedback QgsFeedback Feedback object for reporting back to the main application. required Source code in src/cplus_plugin/lib/reports/manager.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 @classmethod def create_comparison_report_context ( cls , scenario_results : typing . List [ ScenarioResult ], feedback : QgsFeedback ) -> typing . Optional [ ScenarioComparisonReportContext ]: \"\"\"Create contextual information for generating the scenario comparison report. :param scenario_results: Collection of scenario results to be compared. :type scenario_results: list :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback \"\"\" base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if base_dir is None : log ( f \"Base directory is empty, unable to generate comparison report.\" ) return None FileUtils . create_comparison_reports_dir ( base_dir ) folder_name = datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) report_dir = os . path . normpath ( f \" { base_dir } / { COMPARISON_REPORT_SEGMENT } / { folder_name } \" ) FileUtils . create_new_dir ( report_dir ) project_file_path = os . path . join ( report_dir , f \" { COMPARISON_REPORT_SEGMENT } .qgz\" ) # Save project file. result = cls . _save_current_project ( project_file_path ) if not result : log ( f \"Unable to save the project for scenario report generation.\" ) return None layout_name = f \" { DEFAULT_BASE_COMPARISON_REPORT_NAME } { folder_name } \" template_path = FileUtils . report_template_path ( SCENARIO_COMPARISON_TEMPLATE_NAME ) return ScenarioComparisonReportContext ( template_path = template_path , name = layout_name , project_file = project_file_path , feedback = feedback , results = scenario_results , output_dir = report_dir , )","title":"create_comparison_report_context"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_report_context","text":"create_report_context ( scenario_result , feedback , use_custom_metrics = False ) Creates the report context for use in the report generator task. Parameters: Name Type Description Default scenario_result ScenarioResult Result of the scenario analysis. required feedback QgsFeedback Feedback object for reporting back to the main application. required use_custom_metrics bool True to use custom metrics else False. If True and the metrics configuration is empty or undefined, then the default activity table in the scenario analysis report will be used. False Returns: Type Description ReportContext A report context object containing the information for generating the report else None if it could not be created. Source code in src/cplus_plugin/lib/reports/manager.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 @classmethod def create_report_context ( cls , scenario_result : ScenarioResult , feedback : QgsFeedback , use_custom_metrics : bool = False , ) -> typing . Optional [ ReportContext ]: \"\"\"Creates the report context for use in the report generator task. :param scenario_result: Result of the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback object for reporting back to the main application. :type feedback: QgsFeedback :param use_custom_metrics: True to use custom metrics else False. If True and the metrics configuration is empty or undefined, then the default activity table in the scenario analysis report will be used. :type use_custom_metrics: bool :returns: A report context object containing the information for generating the report else None if it could not be created. :rtype: ReportContext \"\"\" output_dir = os . path . normpath ( scenario_result . scenario_directory ) if not output_dir or not Path ( output_dir ) . exists (): log ( f \"Unable to generate the report. { output_dir } not found. \\n \" ) return None scenario_report_dir = os . path . normpath ( f \" { output_dir } /reports\" ) FileUtils . create_new_dir ( scenario_report_dir ) cleaned_scenario_name = clean_filename ( scenario_result . scenario . name ) project_file_path = os . path . join ( scenario_report_dir , f \" { cleaned_scenario_name } .qgz\" ) if os . path . exists ( project_file_path ): counter = 1 while True : project_file_path = os . path . join ( scenario_report_dir , f \" { scenario_result . scenario . name } _ { counter !s} .qgz\" , ) if not os . path . exists ( project_file_path ): break counter += 1 # Write project to file for use in the task since QgsProject # instances are not thread safe. result = cls . _save_current_project ( project_file_path ) if not result : return None # Set base name for the layout and PDF file suffixed with a number # depending on the number of runs. layout_manager = QgsProject . instance () . layoutManager () counter = 1 context_name = \"\" while True : layout_name = f \" { scenario_result . scenario . name } { counter !s} \" matching_layout = layout_manager . layoutByName ( layout_name ) if matching_layout is None : context_name = layout_name break counter += 1 metrics_configuration = None metric_collection = settings_manager . get_metric_profile_collection () if metric_collection : current_metric_profile = metric_collection . get_current_profile () if current_metric_profile : metrics_configuration = current_metric_profile . config if ( use_custom_metrics and metrics_configuration is not None and metrics_configuration . is_valid () ): # Metrics template template_path = FileUtils . report_template_path ( SCENARIO_ANALYSIS_METRICS_TEMPLATE_NAME ) else : # Default template template_path = FileUtils . report_template_path ( SCENARIO_ANALYSIS_TEMPLATE_NAME ) return ReportContext ( template_path = template_path , scenario = scenario_result . scenario , name = context_name , scenario_output_dir = scenario_report_dir , project_file = project_file_path , feedback = feedback , output_layer_name = scenario_result . output_layer_name , custom_metrics = use_custom_metrics , )","title":"create_report_context"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.create_scenario_dir","text":"create_scenario_dir ( scenario ) Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. Parameters: Name Type Description Default scenario Scenario Reference scenario object. required Returns: Type Description str The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. Source code in src/cplus_plugin/lib/reports/manager.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def create_scenario_dir ( self , scenario : Scenario ) -> str : \"\"\"Creates an output directory (within BASE_DIR) for saving the analysis outputs for the given scenario. :param scenario: Reference scenario object. :type scenario: Scenario :returns: The absolute path to the output directory. If BASE_DIR does not exist, it will not create the directory and will return an empty string. If the current user does not have write permissions to the base directory, it will return an empty string. :rtype: str \"\"\" if not self . root_output_dir : return \"\" output_path = Path ( self . root_output_dir ) if not output_path . exists (): try : output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"outputs subdirectory in the base directory.\" ) log ( msg ) return \"\" scenario_path_str = f \" { self . root_output_dir } / { str ( scenario . uuid ) } \" scenario_output_path = Path ( scenario_path_str ) if not scenario_output_path . exists (): try : scenario_output_path . mkdir () except FileNotFoundError : msg = ( \"Missing parent directory when creating \" \"scenario subdirectory in the outputs directory.\" ) log ( msg ) return \"\" return scenario_path_str","title":"create_scenario_dir"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.generate","text":"generate ( scenario_result , feedback = None , use_custom_metrics = False ) Initiates the report generation process using information resulting from the scenario analysis. Parameters: Name Type Description Default scenario_result ScenarioResult Contains details from the scenario analysis. required feedback QgsFeedback Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. None use_custom_metrics bool True to use custom metrics else False. If True and there is no active profile or if the metrics configuration profile is empty or undefined, then the default activity table in the scenario analysis report will be used. False Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def generate ( self , scenario_result : ScenarioResult , feedback : QgsFeedback = None , use_custom_metrics : bool = False , ) -> ReportSubmitStatus : \"\"\"Initiates the report generation process using information resulting from the scenario analysis. :param scenario_result: Contains details from the scenario analysis. :type scenario_result: ScenarioResult :param feedback: Feedback for reporting back to the main application. If one is not specified then the manager will create one for the context. :type feedback: QgsFeedback :param use_custom_metrics: True to use custom metrics else False. If True and there is no active profile or if the metrics configuration profile is empty or undefined, then the default activity table in the scenario analysis report will be used. :type use_custom_metrics: bool :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" if not scenario_result . output_layer_name : log ( \"Layer name for output scenario is empty. Cannot generate report_templates.\" ) return ReportSubmitStatus ( False , None , \"\" ) if feedback is None : feedback = QgsFeedback ( self ) ctx = self . create_report_context ( scenario_result , feedback , use_custom_metrics ) if ctx is None : log ( \"Could not create report context. Check directory settings.\" ) return ReportSubmitStatus ( False , None , \"\" ) scenario_id = str ( ctx . scenario . uuid ) if scenario_id in self . _report_tasks : return ReportSubmitStatus ( False , ctx . feedback , \"\" ) msg_tr = tr ( \"Generating report for\" ) description = f \" { msg_tr } { ctx . scenario . name } \" report_task = ScenarioAnalysisReportGeneratorTask ( description , ctx ) report_task_completed = partial ( self . report_task_completed , report_task ) report_task . taskCompleted . connect ( report_task_completed ) report_task . taskTerminated . connect ( report_task_completed ) report_task . status_changed . connect ( self . on_analysis_status_changed ) task_id = self . task_manager . addTask ( report_task ) self . _report_tasks [ scenario_id ] = task_id return ReportSubmitStatus ( True , ctx . feedback , str ( task_id ))","title":"generate"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.generate_comparison_report","text":"generate_comparison_report ( scenario_results , feedback = None ) Generates a report comparing the two or more scenarios. Parameters: Name Type Description Default scenario_results List [ ScenarioResult ] Collection of scenario results to be compared. required feedback QgsFeedback Feedback object for reporting back to the main application. Default is None. None Returns: Type Description ReportSubmitStatus True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. Source code in src/cplus_plugin/lib/reports/manager.py 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 def generate_comparison_report ( self , scenario_results : typing . List [ ScenarioResult ], feedback : QgsFeedback = None , ) -> ReportSubmitStatus : \"\"\"Generates a report comparing the two or more scenarios. :param scenario_results: Collection of scenario results to be compared. :type scenario_results: list :param feedback: Feedback object for reporting back to the main application. Default is None. :type feedback: QgsFeedback :returns: True if the report generation process was successfully submitted else False if a running process is re-submitted. Object also contains feedback object for report updating and cancellation. :rtype: ReportSubmitStatus \"\"\" if self . _running_comparison_tasks == self . COMPARISON_REPORT_LIMIT : log ( \"Reached limit of comparison report processes, try again later.\" ) return ReportSubmitStatus ( False , None , \"\" ) if feedback is None : feedback = QgsFeedback ( self ) comparison_context = self . create_comparison_report_context ( scenario_results , feedback ) if comparison_context is None : return ReportSubmitStatus ( False , None , \"\" ) description = tr ( \"Generating scenario comparison report\" ) task = ScenarioComparisonReportGeneratorTask ( description , comparison_context ) task . statusChanged . connect ( self . on_comparison_task_status_changed ) task_id = self . task_manager . addTask ( task ) return ReportSubmitStatus ( True , feedback , str ( task_id ))","title":"generate_comparison_report"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_analysis_status_changed","text":"on_analysis_status_changed ( message ) Slot raised when the status for a scenario analysis changes. Parameters: Name Type Description Default message str Status message. required Source code in src/cplus_plugin/lib/reports/manager.py 345 346 347 348 349 350 351 352 353 354 def on_analysis_status_changed ( self , message : str ): \"\"\"Slot raised when the status for a scenario analysis changes. :param message: Status message. :type message: str \"\"\" if not message : return self . status_changed . emit ( message )","title":"on_analysis_status_changed"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_comparison_task_status_changed","text":"on_comparison_task_status_changed ( status ) Slot raised when the comparison task status has changed. Parameters: Name Type Description Default status int Task status: required Source code in src/cplus_plugin/lib/reports/manager.py 549 550 551 552 553 554 555 556 557 558 def on_comparison_task_status_changed ( self , status : int ): \"\"\"Slot raised when the comparison task status has changed. :param status: Task status: :type status: int \"\"\" if status == QgsTask . TaskStatus . Running : self . _running_comparison_tasks += 1 elif status in ( QgsTask . TaskStatus . Complete , QgsTask . TaskStatus . Terminated ): self . _running_comparison_tasks -= 1","title":"on_comparison_task_status_changed"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_layout_designer_opened","text":"on_layout_designer_opened ( designer ) Sets a default zoom level for the report when opened for the first time. Source code in src/cplus_plugin/lib/reports/manager.py 608 609 610 611 612 613 614 615 616 617 618 def on_layout_designer_opened ( self , designer : QgsLayoutDesignerInterface ): \"\"\"Sets a default zoom level for the report when opened for the first time. \"\"\" layout_type = designer . masterLayout () . layoutType () if layout_type == QgsMasterLayoutInterface . Type . PrintLayout : layout = designer . layout () if self . _variable_register . is_analysis_report ( layout ): view = designer . view () view . zoomActual () view . emitZoomLevelChanged ()","title":"on_layout_designer_opened"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.on_task_status_changed","text":"on_task_status_changed ( task_id , status ) Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/reports/manager.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def on_task_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a task has changed. This function will emit when the report generation task has started or when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" scenario_id = self . scenario_by_task_id ( task_id ) # Not related to CPLUS scenario analysis report if not scenario_id : return if status == QgsTask . TaskStatus . Running : self . generate_started . emit ( scenario_id ) elif status == QgsTask . TaskStatus . Complete : # Get result task = self . task_manager . task ( task_id ) result = task . result if result is not None : self . _report_results [ scenario_id ] = result # Remove task self . remove_report_task ( scenario_id ) self . generate_completed . emit ( scenario_id )","title":"on_task_status_changed"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.open_layout_designer","text":"open_layout_designer ( result ) Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. Source code in src/cplus_plugin/lib/reports/manager.py 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 def open_layout_designer ( self , result : ReportResult ) -> bool : \"\"\"Opens the analysis report in the layout designer. The layout needs to exist in the currently loaded project. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the layout was successfully loaded, else False if the result from the generation process was False or if the layout does not exist in the current project. :rtype: bool \"\"\" if not result . success : return False layout = QgsProject . instance () . layoutManager () . layoutByName ( result . name ) if layout is None : return False _ = self . iface . openLayoutDesigner ( layout ) return True","title":"open_layout_designer"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/manager.py 99 100 101 102 103 104 105 106 107 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" self . _variable_register . register_variables ( layout )","title":"register_variables"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.remove_report_task","text":"remove_report_task ( scenario_id ) Remove report task associated with the given scenario. Parameters: Name Type Description Default scenario_id str Identified of the scenario whose report generation process is to be removed. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given scenario. Source code in src/cplus_plugin/lib/reports/manager.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def remove_report_task ( self , scenario_id : str ) -> bool : \"\"\"Remove report task associated with the given scenario. :param scenario_id: Identified of the scenario whose report generation process is to be removed. :type scenario_id: str :returns: True if the task has been successfully removed else False if there is no associated task for the given scenario. :rtype: bool \"\"\" if scenario_id not in self . _report_tasks : return False task_id = self . _report_tasks [ scenario_id ] task = self . task_manager . task ( task_id ) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): task . cancel () _ = self . _report_tasks . pop ( scenario_id ) return True","title":"remove_report_task"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.remove_task_by_result","text":"remove_task_by_result ( submit_result ) Remove a report task based on the submit result. Parameters: Name Type Description Default submit_result ReportSubmitStatus Submit result information. required Returns: Type Description bool True if the task has been successfully removed else False if there is no associated task for the given submit result. Source code in src/cplus_plugin/lib/reports/manager.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def remove_task_by_result ( self , submit_result : ReportSubmitStatus ) -> bool : \"\"\"Remove a report task based on the submit result. :param submit_result: Submit result information. :type submit_result: ReportSubmitStatus :returns: True if the task has been successfully removed else False if there is no associated task for the given submit result. :rtype: bool \"\"\" for scenario_id , task_id in self . _report_tasks . items (): if int ( submit_result . identifier ) == task_id : self . remove_report_task ( scenario_id ) return True task = self . task_by_id ( int ( submit_result . identifier )) if task is None : return False if ( task . status () != QgsTask . TaskStatus . Complete or task . status () != QgsTask . TaskStatus . Terminated ): submit_result . feedback . cancel () task . cancel () return True return False","title":"remove_task_by_result"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.report_result","text":"report_result ( scenario_id ) Gets the report result for the scenario with the given ID. Parameters: Name Type Description Default scenario_id str Identifier of the scenario whose report is to be retrieved. required Returns: Type Description ReportResult Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the success attribute. For scenarios that had not been submitted for report generation, a None object will be returned. Source code in src/cplus_plugin/lib/reports/manager.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def report_result ( self , scenario_id : str ) -> typing . Union [ ReportResult , None ]: \"\"\"Gets the report result for the scenario with the given ID. :param scenario_id: Identifier of the scenario whose report is to be retrieved. :type scenario_id: str :returns: Result of the report generation process. Caller needs to check if the process was successful or there was an error by checking the status of the `success` attribute. For scenarios that had not been submitted for report generation, a None object will be returned. :rtype: ReportResult \"\"\" if scenario_id not in self . _report_results : return None return self . _report_results [ scenario_id ]","title":"report_result"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.scenario_by_task_id","text":"scenario_by_task_id ( task_id ) Gets the scenario identifier for the report generation t ask with the given ID. Parameters: Name Type Description Default task_id int ID of the task whose corresponding scenario is to be retrieved. required Returns: Type Description str Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. Source code in src/cplus_plugin/lib/reports/manager.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def scenario_by_task_id ( self , task_id : int ) -> str : \"\"\"Gets the scenario identifier for the report generation t ask with the given ID. :param task_id: ID of the task whose corresponding scenario is to be retrieved. :type task_id: int :returns: Scenario identifier whose report is being generated by a process with the given task id or an empty string if there was no match. :rtype: str \"\"\" scenario_ids = [ sid for sid , tid in self . _report_tasks . items () if tid == task_id ] if len ( scenario_ids ) == 0 : return \"\" return scenario_ids [ 0 ]","title":"scenario_by_task_id"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.task_by_id","text":"task_by_id ( task_id ) Gets the task using its identifier. Parameters: Name Type Description Default task_id int Task identifier. required Returns: Type Description QgsTask The tas corresponding to the given ID or None if not found. Source code in src/cplus_plugin/lib/reports/manager.py 109 110 111 112 113 114 115 116 117 118 119 def task_by_id ( self , task_id : int ) -> typing . Optional [ QgsTask ]: \"\"\"Gets the task using its identifier. :param task_id: Task identifier. :type task_id: int :returns: The tas corresponding to the given ID or None if not found. :rtype: QgsTask \"\"\" return self . task_manager . task ( task_id )","title":"task_by_id"},{"location":"developer/api/core/api_reports_manager/#src.cplus_plugin.lib.reports.manager.ReportManager.view_pdf","text":"view_pdf ( result ) Opens the analysis in the host's default PDF viewer. Parameters: Name Type Description Default result ReportResult Result object from the report generation process. required Returns: Type Description bool True if the PDF was successfully loaded, else False if the result from the generation process was False. Source code in src/cplus_plugin/lib/reports/manager.py 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 @classmethod def view_pdf ( cls , result : ReportResult ) -> bool : \"\"\"Opens the analysis in the host's default PDF viewer. :param result: Result object from the report generation process. :type result: ReportResult :returns: True if the PDF was successfully loaded, else False if the result from the generation process was False. :rtype: bool \"\"\" if not result . success : return False pdf_url = QtCore . QUrl . fromLocalFile ( result . pdf_path ) if pdf_url . isEmpty (): return False return QtGui . QDesktopServices . openUrl ( pdf_url )","title":"view_pdf"},{"location":"developer/api/core/api_reports_metrics/","text":"Helper Functions for Metric Expressions \u00b6 Provides variables and functions for custom activity metrics. ActivityIrrecoverableCarbonFunction \u00b6 ActivityIrrecoverableCarbonFunction () Bases: QgsScopedExpressionFunction Calculates the total irrecoverable carbon of an activity using the means-based reference carbon layer. Source code in src/cplus_plugin/lib/reports/metrics.py 62 63 64 65 66 67 68 69 70 def __init__ ( self ): help_html = function_help_to_html ( FUNC_MEAN_BASED_IC , tr ( MEAN_BASED_IRRECOVERABLE_CARBON_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_MEAN_BASED_IC } ()\" , \"42,500\" )], ) super () . __init__ ( FUNC_MEAN_BASED_IC , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityIrrecoverableCarbonFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 104 105 106 107 108 109 110 def clone ( self ) -> \"ActivityIrrecoverableCarbonFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityIrrecoverableCarbonFunction \"\"\" return ActivityIrrecoverableCarbonFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) irrecoverable_carbon_calculator = IrrecoverableCarbonCalculator ( activity_id ) return irrecoverable_carbon_calculator . run () ActivityManageCarbonImpactFunction \u00b6 ActivityManageCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of manage NCS pathways in an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 314 315 316 317 318 319 320 321 322 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_MANAGE , tr ( MANAGE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_MANAGE } ()\" , \"4,500\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_MANAGE , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityManageCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 356 357 358 359 360 361 362 def clone ( self ) -> \"ActivityManageCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityManageCarbonImpactFunction \"\"\" return ActivityManageCarbonImpactFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) manage_carbon_calculator = CarbonImpactManageCalculator ( activity_id ) return manage_carbon_calculator . run () ActivityNpvFunction \u00b6 ActivityNpvFunction () Bases: QgsScopedExpressionFunction Calculates the financial NPV of an activity by extracting the individual NPV values of the pathways in the activity. Source code in src/cplus_plugin/lib/reports/metrics.py 118 119 120 121 122 123 124 125 126 def __init__ ( self ): help_html = function_help_to_html ( FUNC_ACTIVITY_NPV , tr ( NPV_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_ACTIVITY_NPV } ()\" , \"125,800\" )], ) super () . __init__ ( FUNC_ACTIVITY_NPV , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityNpvFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 165 166 167 168 169 170 171 def clone ( self ) -> \"ActivityNpvFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityNpvFunction \"\"\" return ActivityNpvFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ) or not context . hasVariable ( VAR_ACTIVITY_AREA ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) activity_area = context . variable ( VAR_ACTIVITY_AREA ) if not isinstance ( activity_area , ( float , int )): return - 1.0 return calculate_activity_npv ( activity_id , activity_area ) ActivityProtectCarbonImpactFunction \u00b6 ActivityProtectCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of protect NCS pathways in an activity using the reference biomass layer. Source code in src/cplus_plugin/lib/reports/metrics.py 256 257 258 259 260 261 262 263 264 265 266 267 268 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_PROTECT , tr ( PROTECT_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_PROTECT } ()\" , \"12,800\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_PROTECT , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True , ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityProtectCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 302 303 304 305 306 307 308 def clone ( self ) -> \"ActivityProtectCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityProtectCarbonImpactFunction \"\"\" return ActivityProtectCarbonImpactFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) protect_carbon_calculator = CarbonImpactProtectCalculator ( activity_id ) return protect_carbon_calculator . run () ActivityPwlImpactFunction \u00b6 ActivityPwlImpactFunction () Bases: QgsScopedExpressionFunction Calculates the PWL impact an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def __init__ ( self ): arg_name = \"custom_impact\" example_intro = ( f \"For an activity with an area of 20,000 ha, \" f \" { FUNC_PWL_IMPACT } (1.5) will return\" ) help_html = function_help_to_html ( FUNC_PWL_IMPACT , tr ( PWL_IMPACT_EXPRESSION_DESCRIPTION ), [ ( arg_name , tr ( \"An integer or float representing the \" \"number of jobs created per hectare.\" ), False , ) ], [( tr ( example_intro ), \"30,000\" )], ) super () . __init__ ( FUNC_PWL_IMPACT , 1 , BASE_PLUGIN_NAME , help_html , isContextual = True ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityPwlImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 242 243 244 245 246 247 248 def clone ( self ) -> \"ActivityPwlImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityPwlImpactFunction \"\"\" return ActivityPwlImpactFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if len ( values ) == 0 : return - 1.0 if not context . hasVariable ( VAR_ACTIVITY_ID ) or not context . hasVariable ( VAR_ACTIVITY_AREA ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) num_jobs = values [ 0 ] if not isinstance ( num_jobs , ( float , int )): return - 1.0 return calculate_activity_pwl_impact ( activity_id , num_jobs ) ActivityRestoreCarbonImpactFunction \u00b6 ActivityRestoreCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of restore NCS pathways in an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 368 369 370 371 372 373 374 375 376 377 378 379 380 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_RESTORE , tr ( RESTORE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_RESTORE } ()\" , \"4,500\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_RESTORE , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True , ) clone \u00b6 clone () Gets a clone of this function. Returns: Type Description ActivityRestoreCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 414 415 416 417 418 419 420 def clone ( self ) -> \"ActivityRestoreCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityRestoreCarbonImpactFunction \"\"\" return ActivityRestoreCarbonImpactFunction () func \u00b6 func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) restore_carbon_calculator = CarbonImpactRestoreCalculator ( activity_id ) return restore_carbon_calculator . run () MetricsExpressionContextGenerator \u00b6 Bases: QgsExpressionContextGenerator Helper class that generates the metrics expression context for use in QGIS objects that expect an expression context generator. createExpressionContext \u00b6 createExpressionContext () Returns a metrics expression context. Returns: Type Description QgsExpressionContext Metrics expression context with CPLUS-specific functions and variables. Source code in src/cplus_plugin/lib/reports/metrics.py 629 630 631 632 633 634 635 636 def createExpressionContext ( self ) -> QgsExpressionContext : \"\"\"Returns a metrics expression context. :returns: Metrics expression context with CPLUS-specific functions and variables. :rtype: QgsExpressionContext \"\"\" return create_metrics_expression_context () calculate_activity_pwl_impact \u00b6 calculate_activity_pwl_impact ( activity_id , number_jobs ) Calculates the PWL impact an activity. It sums up the result of the number of jobs multiplied by the area of each NCS pathway that constitutes the activity. Parameters: Name Type Description Default activity_id str The ID of the specific activity. required number_jobs float Number of jobs for the activity. required Returns: Type Description float Returns the total pwl impact of the activity, or -1.0 if the activity does not exist or if found, lacks pathways or if the area of all pathways could not be computed. Source code in src/cplus_plugin/lib/reports/metrics.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 def calculate_activity_pwl_impact ( activity_id : str , number_jobs : float ) -> float : \"\"\"Calculates the PWL impact an activity. It sums up the result of the number of jobs multiplied by the area of each NCS pathway that constitutes the activity. :param activity_id: The ID of the specific activity. :type activity_id: str :param number_jobs: Number of jobs for the activity. :type number_jobs: float :returns: Returns the total pwl impact of the activity, or -1.0 if the activity does not exist or if found, lacks pathways or if the area of all pathways could not be computed. :rtype: float \"\"\" activity = settings_manager . get_activity ( activity_id ) if activity is None or len ( activity . pathways ) == 0 : return - 1.0 pathway_areas = [] for pathway in activity . pathways : pathway_layer = pathway . to_map_layer () if pathway_layer is None : continue area = calculate_raster_area ( pathway_layer , 1 ) if area == - 1.0 : log ( f \"Could not compute the area for { pathway . name } \" f \"pathway in PWL impact assessment for { activity . name } \" f \"activity.\" , info = False , ) continue pathway_areas . append ( area ) if len ( pathway_areas ) == 0 : return - 1.0 return float ( sum ( pathway_areas )) * number_jobs create_metrics_expression_context \u00b6 create_metrics_expression_context ( project = None ) Gets the expression context to use in the initial set up (e.g. expression builder) as well as computation stage of activity metrics. It includes the global and project scopes. Parameters: Name Type Description Default project QgsProject The QGIS project whose functions and variables will be included in the expression context. If not specified, the current project will be used. None Returns: Type Description QgsExpressionContext The expression to use in the customization of activity metrics. Source code in src/cplus_plugin/lib/reports/metrics.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def create_metrics_expression_context ( project : QgsProject = None , ) -> QgsExpressionContext : \"\"\"Gets the expression context to use in the initial set up (e.g. expression builder) as well as computation stage of activity metrics. It includes the global and project scopes. :param project: The QGIS project whose functions and variables will be included in the expression context. If not specified, the current project will be used. :type project: QgsProject :returns: The expression to use in the customization of activity metrics. :rtype: QgsExpressionContext \"\"\" if project is None : project = QgsProject . instance () metric_expression_context = QgsExpressionContext () metric_expression_context . appendScope ( QgsExpressionContextUtils . globalScope ()) metric_expression_context . appendScope ( QgsExpressionContextUtils . projectScope ( project ) ) metric_expression_context . appendScope ( create_metrics_expression_scope ()) # Highlight some key variables metric_expression_context . setHighlightedVariables ([ VAR_ACTIVITY_AREA ]) return metric_expression_context create_metrics_expression_scope \u00b6 create_metrics_expression_scope () Creates the expression context scope for activity metrics. The initial variable values will be arbitrary and will only be updated just prior to the evaluation of the expression in a separate function. Returns: Type Description QgsExpressionContextScope The expression scope for activity metrics. Source code in src/cplus_plugin/lib/reports/metrics.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def create_metrics_expression_scope () -> QgsExpressionContextScope : \"\"\"Creates the expression context scope for activity metrics. The initial variable values will be arbitrary and will only be updated just prior to the evaluation of the expression in a separate function. :returns: The expression scope for activity metrics. :rtype: QgsExpressionContextScope \"\"\" expression_scope = QgsExpressionContextScope ( BASE_PLUGIN_NAME ) # Activity area expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_AREA , 1 , description = tr ( \"The total area, in hectares, of the activity being evaluated.\" ), ) ) # Activity name expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_NAME , \"\" , description = tr ( \"The name of the activity being evaluated.\" ), ) ) # Activity total naturebase data carbon impact expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_NATUREBASE_CARBON_IMPACT , - 1 , description = tr ( NATUREBASE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), ) ) # Add functions expression_scope . addFunction ( FUNC_PWL_IMPACT , ActivityPwlImpactFunction ()) expression_scope . addFunction ( FUNC_ACTIVITY_NPV , ActivityNpvFunction ()) expression_scope . addFunction ( FUNC_MEAN_BASED_IC , ActivityIrrecoverableCarbonFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_PROTECT , ActivityProtectCarbonImpactFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_MANAGE , ActivityManageCarbonImpactFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_RESTORE , ActivityRestoreCarbonImpactFunction () ) return expression_scope evaluate_activity_metric \u00b6 evaluate_activity_metric ( context , activity_info , expression_str ) Calculates the metrics for an activity using the information in the expression context and for an activity in the info object. The context will first be updated with the latest activity information in the info object before the expression is evaluated. Parameters: Name Type Description Default context QgsExpressionContext Expression context containing the global, project and metrics scopes respectively. required activity_info ActivityContextInfo Contains information about an activity whose attribute values will be used to evaluate the expression. required expression_str str Expression to be evaluated. required Returns: Type Description MetricEvalResult The result of the activity's metric calculation. Source code in src/cplus_plugin/lib/reports/metrics.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 def evaluate_activity_metric ( context : QgsExpressionContext , activity_info : ActivityContextInfo , expression_str : str , ) -> MetricEvalResult : \"\"\"Calculates the metrics for an activity using the information in the expression context and for an activity in the info object. The context will first be updated with the latest activity information in the info object before the expression is evaluated. :param context: Expression context containing the global, project and metrics scopes respectively. :type context: QgsExpressionContext :param activity_info: Contains information about an activity whose attribute values will be used to evaluate the expression. :type activity_info: ActivityContextInfo :param expression_str: Expression to be evaluated. :type expression_str: str :returns: The result of the activity's metric calculation. :rtype: MetricEvalResult \"\"\" # Update context with activity information metrics_scope = context . activeScopeForVariable ( VAR_ACTIVITY_AREA ) if metrics_scope is None : return MetricEvalResult ( False , None ) # Update context metrics_scope . setVariable ( VAR_ACTIVITY_ID , str ( activity_info . activity . uuid )) metrics_scope . setVariable ( VAR_ACTIVITY_NAME , activity_info . activity . name ) metrics_scope . setVariable ( VAR_ACTIVITY_AREA , activity_info . area ) metrics_scope . setVariable ( VAR_ACTIVITY_NATUREBASE_CARBON_IMPACT , activity_info . total_naturebase_carbon ) expression = QgsExpression ( expression_str ) expression . prepare ( context ) result = expression . evaluate ( context ) if expression . hasEvalError () or expression . hasParserError (): if expression . hasEvalError (): exp_error = expression . evalErrorString () else : exp_error = expression . parserErrorString () log ( f \"Error evaluating activity metric: { exp_error } \" , info = False ) return MetricEvalResult ( False , None ) return MetricEvalResult ( True , result ) metric_function_by_name \u00b6 metric_function_by_name ( name ) Gets a metric function in the library based on the name. Returns: Type Description QgsScopedExpressionFunction Corresponding function in the metrics library or None if not found. Source code in src/cplus_plugin/lib/reports/metrics.py 523 524 525 526 527 528 529 530 531 532 def metric_function_by_name ( name : str ) -> typing . Optional [ QgsScopedExpressionFunction ]: \"\"\"Gets a metric function in the library based on the name. :returns: Corresponding function in the metrics library or None if not found. :rtype: QgsScopedExpressionFunction \"\"\" matching_func = [ func for func in METRICS_LIBRARY if func . name () == name ] return matching_func [ 0 ] if len ( matching_func ) > 0 else None register_metric_functions \u00b6 register_metric_functions () Register our custom functions with the expression engine. Source code in src/cplus_plugin/lib/reports/metrics.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def register_metric_functions (): \"\"\"Register our custom functions with the expression engine.\"\"\" # Irrecoverable carbon mean_based_irrecoverable_carbon_function = ActivityIrrecoverableCarbonFunction () METRICS_LIBRARY . append ( mean_based_irrecoverable_carbon_function ) # Activity NPV activity_npv_function = ActivityNpvFunction () METRICS_LIBRARY . append ( activity_npv_function ) # PWL impact activity_pwl_impact_function = ActivityPwlImpactFunction () METRICS_LIBRARY . append ( activity_pwl_impact_function ) # Protect carbon impact protect_carbon_function = ActivityProtectCarbonImpactFunction () METRICS_LIBRARY . append ( protect_carbon_function ) # Manage carbon impact manage_carbon_function = ActivityManageCarbonImpactFunction () METRICS_LIBRARY . append ( manage_carbon_function ) # Restore carbon impact restore_carbon_function = ActivityRestoreCarbonImpactFunction () METRICS_LIBRARY . append ( restore_carbon_function ) for func in METRICS_LIBRARY : QgsExpression . registerFunction ( func ) unregister_metric_functions \u00b6 unregister_metric_functions () Unregister the custom metric functions from the expression engine. Source code in src/cplus_plugin/lib/reports/metrics.py 513 514 515 516 517 518 519 520 def unregister_metric_functions (): \"\"\"Unregister the custom metric functions from the expression engine. \"\"\" func_names = [ func . name () for func in METRICS_LIBRARY ] for fn in func_names : QgsExpression . unregisterFunction ( fn )","title":"Metrics"},{"location":"developer/api/core/api_reports_metrics/#helper-functions-for-metric-expressions","text":"Provides variables and functions for custom activity metrics.","title":"Helper Functions for Metric Expressions"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityIrrecoverableCarbonFunction","text":"ActivityIrrecoverableCarbonFunction () Bases: QgsScopedExpressionFunction Calculates the total irrecoverable carbon of an activity using the means-based reference carbon layer. Source code in src/cplus_plugin/lib/reports/metrics.py 62 63 64 65 66 67 68 69 70 def __init__ ( self ): help_html = function_help_to_html ( FUNC_MEAN_BASED_IC , tr ( MEAN_BASED_IRRECOVERABLE_CARBON_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_MEAN_BASED_IC } ()\" , \"42,500\" )], ) super () . __init__ ( FUNC_MEAN_BASED_IC , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True )","title":"ActivityIrrecoverableCarbonFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityIrrecoverableCarbonFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityIrrecoverableCarbonFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 104 105 106 107 108 109 110 def clone ( self ) -> \"ActivityIrrecoverableCarbonFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityIrrecoverableCarbonFunction \"\"\" return ActivityIrrecoverableCarbonFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityIrrecoverableCarbonFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) irrecoverable_carbon_calculator = IrrecoverableCarbonCalculator ( activity_id ) return irrecoverable_carbon_calculator . run ()","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityManageCarbonImpactFunction","text":"ActivityManageCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of manage NCS pathways in an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 314 315 316 317 318 319 320 321 322 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_MANAGE , tr ( MANAGE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_MANAGE } ()\" , \"4,500\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_MANAGE , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True )","title":"ActivityManageCarbonImpactFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityManageCarbonImpactFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityManageCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 356 357 358 359 360 361 362 def clone ( self ) -> \"ActivityManageCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityManageCarbonImpactFunction \"\"\" return ActivityManageCarbonImpactFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityManageCarbonImpactFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) manage_carbon_calculator = CarbonImpactManageCalculator ( activity_id ) return manage_carbon_calculator . run ()","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityNpvFunction","text":"ActivityNpvFunction () Bases: QgsScopedExpressionFunction Calculates the financial NPV of an activity by extracting the individual NPV values of the pathways in the activity. Source code in src/cplus_plugin/lib/reports/metrics.py 118 119 120 121 122 123 124 125 126 def __init__ ( self ): help_html = function_help_to_html ( FUNC_ACTIVITY_NPV , tr ( NPV_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_ACTIVITY_NPV } ()\" , \"125,800\" )], ) super () . __init__ ( FUNC_ACTIVITY_NPV , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True )","title":"ActivityNpvFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityNpvFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityNpvFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 165 166 167 168 169 170 171 def clone ( self ) -> \"ActivityNpvFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityNpvFunction \"\"\" return ActivityNpvFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityNpvFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ) or not context . hasVariable ( VAR_ACTIVITY_AREA ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) activity_area = context . variable ( VAR_ACTIVITY_AREA ) if not isinstance ( activity_area , ( float , int )): return - 1.0 return calculate_activity_npv ( activity_id , activity_area )","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityProtectCarbonImpactFunction","text":"ActivityProtectCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of protect NCS pathways in an activity using the reference biomass layer. Source code in src/cplus_plugin/lib/reports/metrics.py 256 257 258 259 260 261 262 263 264 265 266 267 268 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_PROTECT , tr ( PROTECT_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_PROTECT } ()\" , \"12,800\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_PROTECT , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True , )","title":"ActivityProtectCarbonImpactFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityProtectCarbonImpactFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityProtectCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 302 303 304 305 306 307 308 def clone ( self ) -> \"ActivityProtectCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityProtectCarbonImpactFunction \"\"\" return ActivityProtectCarbonImpactFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityProtectCarbonImpactFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) protect_carbon_calculator = CarbonImpactProtectCalculator ( activity_id ) return protect_carbon_calculator . run ()","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityPwlImpactFunction","text":"ActivityPwlImpactFunction () Bases: QgsScopedExpressionFunction Calculates the PWL impact an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def __init__ ( self ): arg_name = \"custom_impact\" example_intro = ( f \"For an activity with an area of 20,000 ha, \" f \" { FUNC_PWL_IMPACT } (1.5) will return\" ) help_html = function_help_to_html ( FUNC_PWL_IMPACT , tr ( PWL_IMPACT_EXPRESSION_DESCRIPTION ), [ ( arg_name , tr ( \"An integer or float representing the \" \"number of jobs created per hectare.\" ), False , ) ], [( tr ( example_intro ), \"30,000\" )], ) super () . __init__ ( FUNC_PWL_IMPACT , 1 , BASE_PLUGIN_NAME , help_html , isContextual = True )","title":"ActivityPwlImpactFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityPwlImpactFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityPwlImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 242 243 244 245 246 247 248 def clone ( self ) -> \"ActivityPwlImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityPwlImpactFunction \"\"\" return ActivityPwlImpactFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityPwlImpactFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if len ( values ) == 0 : return - 1.0 if not context . hasVariable ( VAR_ACTIVITY_ID ) or not context . hasVariable ( VAR_ACTIVITY_AREA ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) num_jobs = values [ 0 ] if not isinstance ( num_jobs , ( float , int )): return - 1.0 return calculate_activity_pwl_impact ( activity_id , num_jobs )","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityRestoreCarbonImpactFunction","text":"ActivityRestoreCarbonImpactFunction () Bases: QgsScopedExpressionFunction Calculates the carbon impact of restore NCS pathways in an activity. Source code in src/cplus_plugin/lib/reports/metrics.py 368 369 370 371 372 373 374 375 376 377 378 379 380 def __init__ ( self ): help_html = function_help_to_html ( FUNC_CARBON_IMPACT_RESTORE , tr ( RESTORE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), examples = [( f \" { FUNC_CARBON_IMPACT_RESTORE } ()\" , \"4,500\" )], ) super () . __init__ ( FUNC_CARBON_IMPACT_RESTORE , 0 , BASE_PLUGIN_NAME , help_html , isContextual = True , )","title":"ActivityRestoreCarbonImpactFunction"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityRestoreCarbonImpactFunction.clone","text":"clone () Gets a clone of this function. Returns: Type Description ActivityRestoreCarbonImpactFunction A clone of this function. Source code in src/cplus_plugin/lib/reports/metrics.py 414 415 416 417 418 419 420 def clone ( self ) -> \"ActivityRestoreCarbonImpactFunction\" : \"\"\"Gets a clone of this function. :returns: A clone of this function. :rtype: ActivityRestoreCarbonImpactFunction \"\"\" return ActivityRestoreCarbonImpactFunction ()","title":"clone"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.ActivityRestoreCarbonImpactFunction.func","text":"func ( values , context , parent , node ) Returns the result of evaluating the function. Parameters: Name Type Description Default values List [ Any ] List of values passed to the function required context QgsExpressionContext Context expression is being evaluated against required parent QgsExpression Parent expression required node QgsExpressionNodeFunction Expression node required Returns: Type Description typing.Any The result of the function. Source code in src/cplus_plugin/lib/reports/metrics.py 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def func ( self , values : typing . List [ typing . Any ], context : QgsExpressionContext , parent : QgsExpression , node : QgsExpressionNodeFunction , ) -> typing . Any : \"\"\"Returns the result of evaluating the function. :param values: List of values passed to the function :type values: typing.Iterable[typing.Any] :param context: Context expression is being evaluated against :type context: QgsExpressionContext :param parent: Parent expression :type parent: QgsExpression :param node: Expression node :type node: QgsExpressionNodeFunction :returns: The result of the function. :rtype: typing.Any \"\"\" if not context . hasVariable ( VAR_ACTIVITY_ID ): return - 1.0 activity_id = context . variable ( VAR_ACTIVITY_ID ) restore_carbon_calculator = CarbonImpactRestoreCalculator ( activity_id ) return restore_carbon_calculator . run ()","title":"func"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.MetricsExpressionContextGenerator","text":"Bases: QgsExpressionContextGenerator Helper class that generates the metrics expression context for use in QGIS objects that expect an expression context generator.","title":"MetricsExpressionContextGenerator"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.MetricsExpressionContextGenerator.createExpressionContext","text":"createExpressionContext () Returns a metrics expression context. Returns: Type Description QgsExpressionContext Metrics expression context with CPLUS-specific functions and variables. Source code in src/cplus_plugin/lib/reports/metrics.py 629 630 631 632 633 634 635 636 def createExpressionContext ( self ) -> QgsExpressionContext : \"\"\"Returns a metrics expression context. :returns: Metrics expression context with CPLUS-specific functions and variables. :rtype: QgsExpressionContext \"\"\" return create_metrics_expression_context ()","title":"createExpressionContext"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.calculate_activity_pwl_impact","text":"calculate_activity_pwl_impact ( activity_id , number_jobs ) Calculates the PWL impact an activity. It sums up the result of the number of jobs multiplied by the area of each NCS pathway that constitutes the activity. Parameters: Name Type Description Default activity_id str The ID of the specific activity. required number_jobs float Number of jobs for the activity. required Returns: Type Description float Returns the total pwl impact of the activity, or -1.0 if the activity does not exist or if found, lacks pathways or if the area of all pathways could not be computed. Source code in src/cplus_plugin/lib/reports/metrics.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 def calculate_activity_pwl_impact ( activity_id : str , number_jobs : float ) -> float : \"\"\"Calculates the PWL impact an activity. It sums up the result of the number of jobs multiplied by the area of each NCS pathway that constitutes the activity. :param activity_id: The ID of the specific activity. :type activity_id: str :param number_jobs: Number of jobs for the activity. :type number_jobs: float :returns: Returns the total pwl impact of the activity, or -1.0 if the activity does not exist or if found, lacks pathways or if the area of all pathways could not be computed. :rtype: float \"\"\" activity = settings_manager . get_activity ( activity_id ) if activity is None or len ( activity . pathways ) == 0 : return - 1.0 pathway_areas = [] for pathway in activity . pathways : pathway_layer = pathway . to_map_layer () if pathway_layer is None : continue area = calculate_raster_area ( pathway_layer , 1 ) if area == - 1.0 : log ( f \"Could not compute the area for { pathway . name } \" f \"pathway in PWL impact assessment for { activity . name } \" f \"activity.\" , info = False , ) continue pathway_areas . append ( area ) if len ( pathway_areas ) == 0 : return - 1.0 return float ( sum ( pathway_areas )) * number_jobs","title":"calculate_activity_pwl_impact"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.create_metrics_expression_context","text":"create_metrics_expression_context ( project = None ) Gets the expression context to use in the initial set up (e.g. expression builder) as well as computation stage of activity metrics. It includes the global and project scopes. Parameters: Name Type Description Default project QgsProject The QGIS project whose functions and variables will be included in the expression context. If not specified, the current project will be used. None Returns: Type Description QgsExpressionContext The expression to use in the customization of activity metrics. Source code in src/cplus_plugin/lib/reports/metrics.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 def create_metrics_expression_context ( project : QgsProject = None , ) -> QgsExpressionContext : \"\"\"Gets the expression context to use in the initial set up (e.g. expression builder) as well as computation stage of activity metrics. It includes the global and project scopes. :param project: The QGIS project whose functions and variables will be included in the expression context. If not specified, the current project will be used. :type project: QgsProject :returns: The expression to use in the customization of activity metrics. :rtype: QgsExpressionContext \"\"\" if project is None : project = QgsProject . instance () metric_expression_context = QgsExpressionContext () metric_expression_context . appendScope ( QgsExpressionContextUtils . globalScope ()) metric_expression_context . appendScope ( QgsExpressionContextUtils . projectScope ( project ) ) metric_expression_context . appendScope ( create_metrics_expression_scope ()) # Highlight some key variables metric_expression_context . setHighlightedVariables ([ VAR_ACTIVITY_AREA ]) return metric_expression_context","title":"create_metrics_expression_context"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.create_metrics_expression_scope","text":"create_metrics_expression_scope () Creates the expression context scope for activity metrics. The initial variable values will be arbitrary and will only be updated just prior to the evaluation of the expression in a separate function. Returns: Type Description QgsExpressionContextScope The expression scope for activity metrics. Source code in src/cplus_plugin/lib/reports/metrics.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 def create_metrics_expression_scope () -> QgsExpressionContextScope : \"\"\"Creates the expression context scope for activity metrics. The initial variable values will be arbitrary and will only be updated just prior to the evaluation of the expression in a separate function. :returns: The expression scope for activity metrics. :rtype: QgsExpressionContextScope \"\"\" expression_scope = QgsExpressionContextScope ( BASE_PLUGIN_NAME ) # Activity area expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_AREA , 1 , description = tr ( \"The total area, in hectares, of the activity being evaluated.\" ), ) ) # Activity name expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_NAME , \"\" , description = tr ( \"The name of the activity being evaluated.\" ), ) ) # Activity total naturebase data carbon impact expression_scope . addVariable ( QgsExpressionContextScope . StaticVariable ( VAR_ACTIVITY_NATUREBASE_CARBON_IMPACT , - 1 , description = tr ( NATUREBASE_CARBON_IMPACT_EXPRESSION_DESCRIPTION ), ) ) # Add functions expression_scope . addFunction ( FUNC_PWL_IMPACT , ActivityPwlImpactFunction ()) expression_scope . addFunction ( FUNC_ACTIVITY_NPV , ActivityNpvFunction ()) expression_scope . addFunction ( FUNC_MEAN_BASED_IC , ActivityIrrecoverableCarbonFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_PROTECT , ActivityProtectCarbonImpactFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_MANAGE , ActivityManageCarbonImpactFunction () ) expression_scope . addFunction ( FUNC_CARBON_IMPACT_RESTORE , ActivityRestoreCarbonImpactFunction () ) return expression_scope","title":"create_metrics_expression_scope"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.evaluate_activity_metric","text":"evaluate_activity_metric ( context , activity_info , expression_str ) Calculates the metrics for an activity using the information in the expression context and for an activity in the info object. The context will first be updated with the latest activity information in the info object before the expression is evaluated. Parameters: Name Type Description Default context QgsExpressionContext Expression context containing the global, project and metrics scopes respectively. required activity_info ActivityContextInfo Contains information about an activity whose attribute values will be used to evaluate the expression. required expression_str str Expression to be evaluated. required Returns: Type Description MetricEvalResult The result of the activity's metric calculation. Source code in src/cplus_plugin/lib/reports/metrics.py 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 def evaluate_activity_metric ( context : QgsExpressionContext , activity_info : ActivityContextInfo , expression_str : str , ) -> MetricEvalResult : \"\"\"Calculates the metrics for an activity using the information in the expression context and for an activity in the info object. The context will first be updated with the latest activity information in the info object before the expression is evaluated. :param context: Expression context containing the global, project and metrics scopes respectively. :type context: QgsExpressionContext :param activity_info: Contains information about an activity whose attribute values will be used to evaluate the expression. :type activity_info: ActivityContextInfo :param expression_str: Expression to be evaluated. :type expression_str: str :returns: The result of the activity's metric calculation. :rtype: MetricEvalResult \"\"\" # Update context with activity information metrics_scope = context . activeScopeForVariable ( VAR_ACTIVITY_AREA ) if metrics_scope is None : return MetricEvalResult ( False , None ) # Update context metrics_scope . setVariable ( VAR_ACTIVITY_ID , str ( activity_info . activity . uuid )) metrics_scope . setVariable ( VAR_ACTIVITY_NAME , activity_info . activity . name ) metrics_scope . setVariable ( VAR_ACTIVITY_AREA , activity_info . area ) metrics_scope . setVariable ( VAR_ACTIVITY_NATUREBASE_CARBON_IMPACT , activity_info . total_naturebase_carbon ) expression = QgsExpression ( expression_str ) expression . prepare ( context ) result = expression . evaluate ( context ) if expression . hasEvalError () or expression . hasParserError (): if expression . hasEvalError (): exp_error = expression . evalErrorString () else : exp_error = expression . parserErrorString () log ( f \"Error evaluating activity metric: { exp_error } \" , info = False ) return MetricEvalResult ( False , None ) return MetricEvalResult ( True , result )","title":"evaluate_activity_metric"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.metric_function_by_name","text":"metric_function_by_name ( name ) Gets a metric function in the library based on the name. Returns: Type Description QgsScopedExpressionFunction Corresponding function in the metrics library or None if not found. Source code in src/cplus_plugin/lib/reports/metrics.py 523 524 525 526 527 528 529 530 531 532 def metric_function_by_name ( name : str ) -> typing . Optional [ QgsScopedExpressionFunction ]: \"\"\"Gets a metric function in the library based on the name. :returns: Corresponding function in the metrics library or None if not found. :rtype: QgsScopedExpressionFunction \"\"\" matching_func = [ func for func in METRICS_LIBRARY if func . name () == name ] return matching_func [ 0 ] if len ( matching_func ) > 0 else None","title":"metric_function_by_name"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.register_metric_functions","text":"register_metric_functions () Register our custom functions with the expression engine. Source code in src/cplus_plugin/lib/reports/metrics.py 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def register_metric_functions (): \"\"\"Register our custom functions with the expression engine.\"\"\" # Irrecoverable carbon mean_based_irrecoverable_carbon_function = ActivityIrrecoverableCarbonFunction () METRICS_LIBRARY . append ( mean_based_irrecoverable_carbon_function ) # Activity NPV activity_npv_function = ActivityNpvFunction () METRICS_LIBRARY . append ( activity_npv_function ) # PWL impact activity_pwl_impact_function = ActivityPwlImpactFunction () METRICS_LIBRARY . append ( activity_pwl_impact_function ) # Protect carbon impact protect_carbon_function = ActivityProtectCarbonImpactFunction () METRICS_LIBRARY . append ( protect_carbon_function ) # Manage carbon impact manage_carbon_function = ActivityManageCarbonImpactFunction () METRICS_LIBRARY . append ( manage_carbon_function ) # Restore carbon impact restore_carbon_function = ActivityRestoreCarbonImpactFunction () METRICS_LIBRARY . append ( restore_carbon_function ) for func in METRICS_LIBRARY : QgsExpression . registerFunction ( func )","title":"register_metric_functions"},{"location":"developer/api/core/api_reports_metrics/#src.cplus_plugin.lib.reports.metrics.unregister_metric_functions","text":"unregister_metric_functions () Unregister the custom metric functions from the expression engine. Source code in src/cplus_plugin/lib/reports/metrics.py 513 514 515 516 517 518 519 520 def unregister_metric_functions (): \"\"\"Unregister the custom metric functions from the expression engine. \"\"\" func_names = [ func . name () for func in METRICS_LIBRARY ] for fn in func_names : QgsExpression . unregisterFunction ( fn )","title":"unregister_metric_functions"},{"location":"developer/api/core/api_reports_variables/","text":"Variable Register \u00b6 Manages custom variable data for report design and generation. CplusVariableInfo dataclass \u00b6 CplusVariableInfo ( name , init_value , default_value , final_value ) Contains information about a CPLUS variable within a layout scope. update_final_value \u00b6 update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass LayoutVariableRegister \u00b6 LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 153 154 155 def __init__ ( self ): self . _var_infos = {} self . _init_vars () var_name_init_values property \u00b6 var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values. variable_names property \u00b6 variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names. is_analysis_report \u00b6 is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 314 315 316 317 318 319 320 321 322 323 324 325 326 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False ) register_variables \u00b6 register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) remove_var_name_in_collection classmethod \u00b6 remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx ) remove_variables \u00b6 remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values set_report_flag \u00b6 set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 353 354 355 356 357 358 359 360 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True ) update_variables \u00b6 update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context BaseReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def update_variables ( self , layout : QgsPrintLayout , context : BaseReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh () NoneValueSettingsVariableInfo dataclass \u00b6 NoneValueSettingsVariableInfo ( name , init_value , default_value , final_value , settings_type ) Bases: SettingsVariableInfo Sets final value as \"N/A\" if there is no text specified in the settings. update_final_value \u00b6 update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 83 84 85 86 87 88 89 90 91 92 93 94 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" settings_value = self . _get_setting_value () self . final_value = settings_value if settings_value else tr ( \"N/A\" ) ScenarioDescriptionVariableInfo dataclass \u00b6 ScenarioDescriptionVariableInfo ( name , init_value , default_value , final_value ) Bases: CplusVariableInfo Metadata for a scenario description variable. update_final_value \u00b6 update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 137 138 139 140 def update_final_value ( self , context : BaseReportContext ): \"\"\"Set the scenario description.\"\"\" if hasattr ( context , \"scenario\" ): self . final_value = context . scenario . name ScenarioNameVariableInfo dataclass \u00b6 ScenarioNameVariableInfo ( name , init_value , default_value , final_value ) Bases: CplusVariableInfo Metadata for a scenario name variable. update_final_value \u00b6 update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 114 115 116 117 def update_final_value ( self , context : BaseReportContext ): \"\"\"Set the scenario name.\"\"\" if hasattr ( context , \"scenario\" ): self . final_value = context . scenario . name SettingsVariableInfo dataclass \u00b6 SettingsVariableInfo ( name , init_value , default_value , final_value , settings_type ) Bases: CplusVariableInfo Metadata for a settings-related variable. update_final_value \u00b6 update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value () create_bulleted_text \u00b6 create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"Variables"},{"location":"developer/api/core/api_reports_variables/#variable-register","text":"Manages custom variable data for report design and generation.","title":"Variable Register"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo","text":"CplusVariableInfo ( name , init_value , default_value , final_value ) Contains information about a CPLUS variable within a layout scope.","title":"CplusVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.CplusVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Default implementation does nothing. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 28 29 30 31 32 33 34 35 36 37 38 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Default implementation does nothing. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" pass","title":"update_final_value"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister","text":"LayoutVariableRegister () Manages variables and their corresponding values for use in layout design and report generation. Source code in src/cplus_plugin/lib/reports/variables.py 153 154 155 def __init__ ( self ): self . _var_infos = {} self . _init_vars ()","title":"LayoutVariableRegister"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.var_name_init_values","text":"var_name_init_values Creates a collection of variable names and their corresponding initial values. Returns: Type Description dict Collection of variable names and corresponding initial values.","title":"var_name_init_values"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.variable_names","text":"variable_names Gets the names of the registered variables. Returns: Type Description list A collection of registered variable names.","title":"variable_names"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.is_analysis_report","text":"is_analysis_report ( layout ) Checks whether the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to check whether its from a report generation process. required Returns: Type Description bool True if the layout is from a report generation process, else False. Source code in src/cplus_plugin/lib/reports/variables.py 314 315 316 317 318 319 320 321 322 323 324 325 326 def is_analysis_report ( self , layout : QgsPrintLayout ) -> bool : \"\"\"Checks whether the layout has been produced from a report generation process. :param layout: Layout to check whether its from a report generation process. :type layout: QgsPrintLayout :returns: True if the layout is from a report generation process, else False. :rtype: bool \"\"\" return layout . customProperty ( self . VAR_CPLUS_REPORT_PROPERTY , False )","title":"is_analysis_report"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.register_variables","text":"register_variables ( layout ) Registers custom variables and their corresponding initial values in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object where the custom variables will be registered. required Source code in src/cplus_plugin/lib/reports/variables.py 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def register_variables ( self , layout : QgsPrintLayout ): \"\"\"Registers custom variables and their corresponding initial values in the layout. :param layout: Layout object where the custom variables will be registered. :type layout: QgsPrintLayout \"\"\" # If layout from analysis process, do not register # the variables. if self . is_analysis_report ( layout ): return # Remove any duplicate cplus variable names and values var_names , var_values = self . remove_variables ( layout ) # Get cplus variable names and corresponding initial values var_name_init_values = self . var_name_init_values for var_name , init_value in var_name_init_values . items (): var_names . append ( var_name ) var_values . append ( init_value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values )","title":"register_variables"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_var_name_in_collection","text":"remove_var_name_in_collection ( cplus_var_name , layout_var_names , layout_var_values ) Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. Source code in src/cplus_plugin/lib/reports/variables.py 276 277 278 279 280 281 282 283 284 285 286 287 288 289 @classmethod def remove_var_name_in_collection ( cls , cplus_var_name : str , layout_var_names : typing . List [ str ], layout_var_values : typing . List [ str ], ): \"\"\"Remove cplus variable name matches and corresponding values in the layout variable name/value mapping. \"\"\" while cplus_var_name in layout_var_names : idx = layout_var_names . index ( cplus_var_name ) _ = layout_var_names . pop ( idx ) _ = layout_var_values . pop ( idx )","title":"remove_var_name_in_collection"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.remove_variables","text":"remove_variables ( layout ) Removes duplicate variable names from the layout, this is done prior to registering new ones. Parameters: Name Type Description Default layout QgsPrintLayout Layout whose cplus variables are to be removed. required Returns: Type Description tuple Tuple only containing non-cplus variable names and corresponding values respectively. Source code in src/cplus_plugin/lib/reports/variables.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def remove_variables ( self , layout : QgsPrintLayout ) -> typing . Tuple [ typing . List , typing . List ]: \"\"\"Removes duplicate variable names from the layout, this is done prior to registering new ones. :param layout: Layout whose cplus variables are to be removed. :type layout: QgsPrintLayout :returns: Tuple only containing non-cplus variable names and corresponding values respectively. :rtype: tuple \"\"\" cplus_var_names = self . variable_names var_names = layout . customProperty ( self . VAR_NAMES_PROPERTY , list ()) var_values = layout . customProperty ( self . VAR_VALUES_PROPERTY , list ()) # Remove only cplus variable names and values for cvn in cplus_var_names : self . remove_var_name_in_collection ( cvn , var_names , var_values ) return var_names , var_values","title":"remove_variables"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.set_report_flag","text":"set_report_flag ( layout ) Set a flag indicating that the layout has been produced from a report generation process. Parameters: Name Type Description Default layout QgsPrintLayout Layout to add the flag as a custom property. required Source code in src/cplus_plugin/lib/reports/variables.py 353 354 355 356 357 358 359 360 def set_report_flag ( self , layout : QgsPrintLayout ): \"\"\"Set a flag indicating that the layout has been produced from a report generation process. :param layout: Layout to add the flag as a custom property. :type layout: QgsPrintLayout \"\"\" layout . setCustomProperty ( self . VAR_CPLUS_REPORT_PROPERTY , True )","title":"set_report_flag"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.LayoutVariableRegister.update_variables","text":"update_variables ( layout , context ) Update the values for the CPLUS variables in the layout. Parameters: Name Type Description Default layout QgsPrintLayout Layout object whose CPLUS variable values will be updated. required context BaseReportContext Context object containing the report information that will be used for computing the final value of the variable during the report generation process. required Source code in src/cplus_plugin/lib/reports/variables.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def update_variables ( self , layout : QgsPrintLayout , context : BaseReportContext ): \"\"\"Update the values for the CPLUS variables in the layout. :param layout: Layout object whose CPLUS variable values will be updated. :type layout: QgsPrintLayout :param context: Context object containing the report information that will be used for computing the final value of the variable during the report generation process. :type context: ReportContext \"\"\" exp_scope = QgsExpressionContextUtils . layoutScope ( layout ) var_names = exp_scope . variableNames () var_values = [] vn = list ( self . _var_infos . keys ()) for name in var_names : if name in self . _var_infos : var_info = self . _var_infos [ name ] var_info . update_final_value ( context ) var_values . append ( var_info . final_value ) else : if not exp_scope . hasVariable ( name ): continue value = exp_scope . variable ( name ) var_values . append ( value ) layout . setCustomProperty ( self . VAR_NAMES_PROPERTY , var_names ) layout . setCustomProperty ( self . VAR_VALUES_PROPERTY , var_values ) layout . refresh ()","title":"update_variables"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.NoneValueSettingsVariableInfo","text":"NoneValueSettingsVariableInfo ( name , init_value , default_value , final_value , settings_type ) Bases: SettingsVariableInfo Sets final value as \"N/A\" if there is no text specified in the settings.","title":"NoneValueSettingsVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.NoneValueSettingsVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 83 84 85 86 87 88 89 90 91 92 93 94 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" settings_value = self . _get_setting_value () self . final_value = settings_value if settings_value else tr ( \"N/A\" )","title":"update_final_value"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo","text":"ScenarioDescriptionVariableInfo ( name , init_value , default_value , final_value ) Bases: CplusVariableInfo Metadata for a scenario description variable.","title":"ScenarioDescriptionVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioDescriptionVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario description. Source code in src/cplus_plugin/lib/reports/variables.py 137 138 139 140 def update_final_value ( self , context : BaseReportContext ): \"\"\"Set the scenario description.\"\"\" if hasattr ( context , \"scenario\" ): self . final_value = context . scenario . name","title":"update_final_value"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo","text":"ScenarioNameVariableInfo ( name , init_value , default_value , final_value ) Bases: CplusVariableInfo Metadata for a scenario name variable.","title":"ScenarioNameVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.ScenarioNameVariableInfo.update_final_value","text":"update_final_value ( context ) Set the scenario name. Source code in src/cplus_plugin/lib/reports/variables.py 114 115 116 117 def update_final_value ( self , context : BaseReportContext ): \"\"\"Set the scenario name.\"\"\" if hasattr ( context , \"scenario\" ): self . final_value = context . scenario . name","title":"update_final_value"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo","text":"SettingsVariableInfo ( name , init_value , default_value , final_value , settings_type ) Bases: CplusVariableInfo Metadata for a settings-related variable.","title":"SettingsVariableInfo"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.SettingsVariableInfo.update_final_value","text":"update_final_value ( context ) Computes the final value of the variable to be used in the layout. Fetches the latest settings value. Parameters: Name Type Description Default context BaseReportContext Report context object used to compute the final variable value. required Source code in src/cplus_plugin/lib/reports/variables.py 64 65 66 67 68 69 70 71 72 73 74 def update_final_value ( self , context : BaseReportContext ): \"\"\"Computes the final value of the variable to be used in the layout. Fetches the latest settings value. :param context: Report context object used to compute the final variable value. :type context: ReportContext \"\"\" self . final_value = self . _get_setting_value ()","title":"update_final_value"},{"location":"developer/api/core/api_reports_variables/#src.cplus_plugin.lib.reports.variables.create_bulleted_text","text":"create_bulleted_text ( main_text , bulleted_items ) Returns string containing text and bulleted/dashed text below it. Parameters: Name Type Description Default main_text str Primary non-bulleted text. required bulleted_items List [ str ] List containing bulleted items that will be rendered below the main text. required Returns: Type Description str Text containing primary text with bulleted items below it. Source code in src/cplus_plugin/lib/reports/variables.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def create_bulleted_text ( main_text : str , bulleted_items : typing . List [ str ]) -> str : \"\"\"Returns string containing text and bulleted/dashed text below it. :param main_text: Primary non-bulleted text. :type main_text: str :param bulleted_items: List containing bulleted items that will be rendered below the main text. :type bulleted_items: list :returns: Text containing primary text with bulleted items below it. :rtype: str \"\"\" bulleted_items = \" \\n - \" . join ( bulleted_items ) if not main_text : return f \"- { bulleted_items } \" return f \" { main_text } \\n - { bulleted_items } \"","title":"create_bulleted_text"},{"location":"developer/api/core/api_settings/","text":"Settings \u00b6","title":"Settings"},{"location":"developer/api/core/api_settings/#settings","text":"","title":"Settings"},{"location":"developer/api/core/api_tasks/","text":"Processing Tasks \u00b6 Plugin tasks related to the scenario analysis ScenarioAnalysisTask \u00b6 ScenarioAnalysisTask ( analysis_scenario_name , analysis_scenario_description , analysis_activities , analysis_priority_layers_groups , analysis_extent , scenario , clip_to_studyarea = False , studyarea_path = None ) Bases: QgsTask Prepares and runs the scenario analysis Source code in src/cplus_plugin/tasks.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , analysis_scenario_name , analysis_scenario_description , analysis_activities , analysis_priority_layers_groups , analysis_extent , scenario , clip_to_studyarea : bool = False , studyarea_path : str = None , ): super () . __init__ () self . analysis_scenario_name = analysis_scenario_name self . analysis_scenario_description = analysis_scenario_description self . analysis_activities = analysis_activities self . analysis_priority_layers_groups = analysis_priority_layers_groups self . analysis_extent = analysis_extent self . analysis_extent_string = None self . clip_to_studyarea = clip_to_studyarea self . studyarea_path = studyarea_path self . scenario_result = None self . scenario_directory = None self . success = True self . output = None self . error = None self . status_message = None self . info_message = None self . processing_cancelled = False self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario = scenario self . no_data_value = settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ) align_extent \u00b6 align_extent ( raster_layer , target_extent ) Snaps the passed extent to the activities pathway layer pixel bounds Parameters: Name Type Description Default raster_layer QgsRasterLayer The target layer that the passed extent will be aligned with required target_extent QgsRectangle Spatial extent that will be used a target extent when doing alignment. required Source code in src/cplus_plugin/tasks.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def align_extent ( self , raster_layer , target_extent ): \"\"\"Snaps the passed extent to the activities pathway layer pixel bounds :param raster_layer: The target layer that the passed extent will be aligned with :type raster_layer: QgsRasterLayer :param target_extent: Spatial extent that will be used a target extent when doing alignment. :type target_extent: QgsRectangle \"\"\" try : raster_extent = raster_layer . extent () x_res = raster_layer . rasterUnitsPerPixelX () y_res = raster_layer . rasterUnitsPerPixelY () left = raster_extent . xMinimum () + x_res * math . floor ( ( target_extent . xMinimum () - raster_extent . xMinimum ()) / x_res ) right = raster_extent . xMinimum () + x_res * math . ceil ( ( target_extent . xMaximum () - raster_extent . xMinimum ()) / x_res ) bottom = raster_extent . yMinimum () + y_res * math . floor ( ( target_extent . yMinimum () - raster_extent . yMinimum ()) / y_res ) top = raster_extent . yMaximum () - y_res * math . floor ( ( raster_extent . yMaximum () - target_extent . yMaximum ()) / y_res ) return QgsRectangle ( left , bottom , right , top ) except Exception as e : self . log_message ( tr ( f \"Problem snapping area of \" f \"interest extent, using the original extent,\" f \" { str ( e ) } \" ) ) return target_extent cancel_task \u00b6 cancel_task ( exception = None ) Cancel current task. Parameters: Name Type Description Default exception ( Any , optional ) Exception if stopped with error, defaults to None None Source code in src/cplus_plugin/tasks.py 197 198 199 200 201 202 203 204 def cancel_task ( self , exception = None ): \"\"\"Cancel current task. :param exception: Exception if stopped with error, defaults to None :type exception: Any, optional \"\"\" self . error = exception self . cancel () clip_analysis_data \u00b6 clip_analysis_data ( studyarea_path ) Clips the activity pathways and priority layers by the given study area. Parameters: Name Type Description Default studyarea_path str The path to the study area layer required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def clip_analysis_data ( self , studyarea_path : str ) -> bool : \"\"\"Clips the activity pathways and priority layers by the given study area. :param studyarea_path: The path to the study area layer :type studyarea_path: str :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False mask_layer = QgsVectorLayer ( studyarea_path , \"mask_layer\" ) if not mask_layer . isValid (): self . log_message ( f \"Invalid mask layer: { studyarea_path } \" f \"Skipping clipping of activity pathways and priority layers \\n \" ) return False self . set_status_message ( tr ( \"Clipping the activity pathways and priority layers by the study area layer\" ) ) clipped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"clipped\" ) FileUtils . create_new_dir ( clipped_pathways_directory ) clipped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"clipped\" ) FileUtils . create_new_dir ( clipped_priority_directory ) pathways : typing . List [ NcsPathway ] = [] try : for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or \" f \" activity layers for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or \" f \"activity layers for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Clipping the PWLs # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping clipping layer.\" ) continue if not self . _can_clip_raster_by_mask ( layer , mask_layer ): continue self . log_message ( f \"Clipping the { priority_layer . get ( 'name' ) } priority layer \" f \"by study area layer \\n \" ) output_file = os . path . join ( clipped_priority_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . clip_raster_by_mask ( priority_layer_path , studyarea_path , output_file ) if result : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_file if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping clipping the layer.\" ) continue self . log_message ( f \"Clipping the { pathway . name } pathway layer by \" f \"the study area layer \\n \" ) if not self . _can_clip_raster_by_mask ( pathway_layer , mask_layer ): continue output_file = os . path . join ( clipped_pathways_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . clip_raster_by_mask ( pathway . path , studyarea_path , output_file ) if result : pathway . path = output_file if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem clipping the layers, { e } \\n \" ) self . cancel_task ( e ) return False return True clip_raster_by_mask \u00b6 clip_raster_by_mask ( input_raster_path , mask_layer_path , output_path ) Clip a given raster by the specified mask layer. Parameters: Name Type Description Default input_raster_path str Input raster path required mask_layer_path str Path to the masking layer required output_path str Output layer path required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 def clip_raster_by_mask ( self , input_raster_path : str , mask_layer_path : str , output_path : str ) -> bool : \"\"\"Clip a given raster by the specified mask layer. :param input_raster_path: Input raster path :type input_raster_path: str :param mask_layer_path: Path to the masking layer :type mask_layer_path: str :param output_path: Output layer path :type output_path: str :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" raster_layer = QgsRasterLayer ( input_raster_path , \"raster_layer\" ) mask_layer = QgsVectorLayer ( mask_layer_path , \"mask_layer\" ) if not raster_layer . isValid (): self . log_message ( f \"Invalid raster layer: { input_raster_path } \\n \" ) return False if not mask_layer . isValid (): self . log_message ( f \"Invalid mask layer: { mask_layer_path } \\n \" ) return False try : alg_params = { \"INPUT\" : input_raster_path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : raster_layer . crs (), \"DESTINATION_CRS\" : raster_layer . crs (), \"OUTPUT\" : output_path , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"CROP_TO_CUTLINE\" : True , } self . log_message ( f \"Used parameters for clipping the raster: { input_raster_path } \" f \" using mask layer: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False result = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): return True except Exception as e : self . log_message ( f \"Problem clipping the layer { e } \\n \" ) return False create_activity_connectivity_layer \u00b6 create_activity_connectivity_layer ( activity ) Create an activity connectivity layer for investability analysis Parameters: Name Type Description Default activity Activity Activity required Returns: Type Description str | None The path to the connectivity layer or None if the process failed Source code in src/cplus_plugin/tasks.py 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 def create_activity_connectivity_layer ( self , activity : Activity ): \"\"\"Create an activity connectivity layer for investability analysis :param activity: Activity :type activity: Activity :returns: The path to the connectivity layer or None if the process failed :rtype: str | None \"\"\" if not activity . path : self . log_message ( f \"Problem when creating the connectivity layer, \" f \"there is no map layer for the activity { activity . name } \" ) return None if not os . path . exists ( activity . path ): self . log_message ( f \"Problem when creating the connectivity layer, \" f \"the map layer for the activity { activity . name } does not exist\" ) return None self . set_status_message ( tr ( f \"Creating connectivity layer for the activity: { activity . name } \" ) ) output_directory = os . path . join ( self . scenario_directory , \"investable_activities\" ) FileUtils . create_new_dir ( output_directory ) output_path = os . path . join ( f \" { output_directory } \" , f \" { Path ( activity . path ) . stem } _connectivity_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) try : if self . processing_cancelled : return None self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) # 1. Creating a binary raster binary = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path ], \"CRS\" : None , \"EXPRESSION\" : f \" { Path ( activity . path ) . stem } @1 > 0\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # 2. Polygonize the binary to get polygon clusters binary_polygonize = processing . run ( \"gdal:polygonize\" , { \"INPUT\" : binary , \"BAND\" : 1 , \"FIELD\" : \"DN\" , \"EIGHT_CONNECTEDNESS\" : True , \"EXTRA\" : \"\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if self . processing_cancelled : return None # 3. Create a zonal statistics to find the number of pixels in each cluster zonal_statistics = processing . run ( \"native:zonalstatisticsfb\" , { \"INPUT\" : QgsProcessingFeatureSourceDefinition ( binary_polygonize , selectedFeaturesOnly = False , featureLimit =- 1 , flags = QgsProcessingFeatureSourceDefinition . Flag . FlagOverrideDefaultGeometryCheck | QgsProcessingFeatureSourceDefinition . Flag . FlagCreateIndividualOutputPerInputFeature , geometryCheck = QgsFeatureRequest . InvalidGeometryCheck . GeometryNoCheck , ), \"INPUT_RASTER\" : binary , \"RASTER_BAND\" : 1 , \"COLUMN_PREFIX\" : \"_\" , \"STATISTICS\" : [ 1 ], # sum \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # 4. Caculate connectivity score = count of pixels in cluster * compactness score = processing . run ( \"native:fieldcalculator\" , { \"INPUT\" : zonal_statistics , \"FIELD_NAME\" : \"score\" , \"FIELD_TYPE\" : 0 , \"FIELD_LENGTH\" : 0 , \"FIELD_PRECISION\" : 0 , \"FORMULA\" : '\"_sum\" * 4* pi() * $area /($perimeter * $perimeter)' , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if self . processing_cancelled : return None # 5. Rasterize the score vector processing . run ( \"gdal:rasterize_over\" , { \"INPUT\" : score , \"INPUT_RASTER\" : binary , \"FIELD\" : \"score\" , \"ADD\" : True , \"EXTRA\" : \"\" , }, context = self . processing_context , feedback = self . feedback , ) # 6. Normalize the raster ok , message = normalize_raster ( binary , output_path , self . processing_context , self . feedback ) self . log_message ( message ) if ok and os . path . exists ( output_path ): return output_path self . log_message ( f \" Error creating the connectivity layer for activity { activity . name } , \" ) return None except Exception as e : self . log_message ( f \"Problem creating connectivity layer for activity, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return None finished \u00b6 finished ( result ) Calls the handler responsible for doing post analysis workflow. Parameters: Name Type Description Default result bool Whether the run() operation finished successfully required Source code in src/cplus_plugin/tasks.py 438 439 440 441 442 443 444 445 446 447 def finished ( self , result : bool ): \"\"\"Calls the handler responsible for doing post analysis workflow. :param result: Whether the run() operation finished successfully :type result: bool \"\"\" if result : self . log_message ( \"Finished from the main task \\n \" ) else : self . log_message ( f \"Error from task scenario task { self . error } \" ) get_activity \u00b6 get_activity ( activity_uuid ) Gets an activity object matching the given unique identifier. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity object. required Returns: Type Description Activity Returns the activity object matching the given identifier else None if not found. Source code in src/cplus_plugin/tasks.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_activity ( self , activity_uuid ) -> typing . Union [ Activity , None ]: \"\"\"Gets an activity object matching the given unique identifier. :param activity_uuid: Unique identifier of the activity object. :type activity_uuid: str :returns: Returns the activity object matching the given identifier else None if not found. :rtype: Activity \"\"\" return settings_manager . get_activity ( activity_uuid ) get_masking_layers \u00b6 get_masking_layers () Gets all the masking layers. Returns: Type Description list List of masking layer paths Source code in src/cplus_plugin/tasks.py 166 167 168 169 170 171 172 173 174 175 176 177 def get_masking_layers ( self ) -> typing . List : \"\"\"Gets all the masking layers. :return: List of masking layer paths :rtype: list \"\"\" masking_layers_paths = self . get_settings_value ( Settings . MASK_LAYERS_PATHS , default = None ) masking_layers = masking_layers_paths . split ( \",\" ) if masking_layers_paths else [] masking_layers . remove ( \"\" ) if \"\" in masking_layers else None return masking_layers get_priority_layer \u00b6 get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier UUID Priority layers identifier required Returns: Type Description dict Priority layer dict Source code in src/cplus_plugin/tasks.py 133 134 135 136 137 138 139 140 141 142 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict :rtype: dict \"\"\" return settings_manager . get_priority_layer ( identifier ) get_priority_layers \u00b6 get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/tasks.py 158 159 160 161 162 163 164 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" return settings_manager . get_priority_layers () get_reference_layer \u00b6 get_reference_layer () Get the path of the reference layer Returns: str|None: Return the path of the reference layer or None is it doesn't exist Source code in src/cplus_plugin/tasks.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def get_reference_layer ( self ): \"\"\"Get the path of the reference layer Returns: str|None: Return the path of the reference layer or None is it doesn't exist \"\"\" snapping_enabled = self . get_settings_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = self . get_settings_value ( Settings . SNAP_LAYER , default = \"\" ) reference_layer_path = Path ( reference_layer ) if ( snapping_enabled and os . path . exists ( reference_layer ) and reference_layer_path . is_file () ): return reference_layer get_scenario_directory \u00b6 get_scenario_directory () Generate scenario directory for current task. Returns: Type Description str Path to scenario directory Source code in src/cplus_plugin/tasks.py 121 122 123 124 125 126 127 128 129 130 131 def get_scenario_directory ( self ) -> str : \"\"\"Generate scenario directory for current task. :return: Path to scenario directory :rtype: str \"\"\" base_dir = self . get_settings_value ( Settings . BASE_DIR ) return os . path . join ( f \" { base_dir } \" , \"scenario_\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' , ) get_settings_value \u00b6 get_settings_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/tasks.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_settings_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" return settings_manager . get_value ( name , default , setting_type ) layer_extent \u00b6 layer_extent ( extent ) Creates a new vector layer contains has a feature with geometry matching an extent parameter. Parameters: Name Type Description Default extent str Extent parameter required Returns: Type Description QgsVectorLayer Vector layer Source code in src/cplus_plugin/tasks.py 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 def layer_extent ( self , extent ): \"\"\"Creates a new vector layer contains has a feature with geometry matching an extent parameter. :param extent: Extent parameter :type extent: str :returns: Vector layer :rtype: QgsVectorLayer \"\"\" alg_params = { \"INPUT\" : extent , \"CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } results = processing . run ( \"native:extenttolayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ] log_message \u00b6 log_message ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/tasks.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def log_message ( self , message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" if not isinstance ( message , str ): if isinstance ( message , dict ): message = json . dumps ( message , cls = CustomJsonEncoder ) else : message = json . dumps ( todict ( message ), cls = CustomJsonEncoder ) log ( message , name = name , info = info , notify = notify ) mask_layer_difference \u00b6 mask_layer_difference ( input_layer , overlay_layer ) Creates a new vector layer that contains difference of features between the two passed layers. Parameters: Name Type Description Default input_layer QgsVectorLayer Input layer required overlay_layer QgsVectorLayer Target overlay layer required Returns: Type Description QgsVectorLayer Vector layer Source code in src/cplus_plugin/tasks.py 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 def mask_layer_difference ( self , input_layer , overlay_layer ): \"\"\"Creates a new vector layer that contains difference of features between the two passed layers. :param input_layer: Input layer :type input_layer: QgsVectorLayer :param overlay_layer: Target overlay layer :type overlay_layer: QgsVectorLayer :returns: Vector layer :rtype: QgsVectorLayer \"\"\" alg_params = { \"INPUT\" : input_layer , \"OVERLAY\" : overlay_layer , \"OVERLAY_FIELDS_PREFIX\" : \"\" , \"GRID_SIZE\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } results = processing . run ( \"native:symmetricaldifference\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ] merge_vector_layers \u00b6 merge_vector_layers ( layers ) Merges the passed vector layers into a single layer Parameters: Name Type Description Default layers List [ str ] List of the vector layers paths required Returns: Type Description QgsMapLayer Merged vector layer Source code in src/cplus_plugin/tasks.py 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 def merge_vector_layers ( self , layers ): \"\"\"Merges the passed vector layers into a single layer :param layers: List of the vector layers paths :type layers: typing.List[str] :return: Merged vector layer :rtype: QgsMapLayer \"\"\" input_map_layers = [] for layer_path in layers : layer = QgsVectorLayer ( layer_path , \"mask\" , \"ogr\" ) if layer . isValid (): input_map_layers . append ( layer ) else : self . log_message ( f \"Skipping invalid mask layer { layer_path } from masking.\" ) if len ( input_map_layers ) == 0 : return None if len ( input_map_layers ) == 1 : return input_map_layers [ 0 ] . source () self . set_status_message ( tr ( \"Merging mask layers\" )) # Actual processing calculation alg_params = { \"LAYERS\" : input_map_layers , \"CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } self . log_message ( f \"Used parameters for merging mask layers: { alg_params } \\n \" ) results = processing . run ( \"native:mergevectorlayers\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ] on_terminated \u00b6 on_terminated ( hide = False ) Called when the task is terminated. Source code in src/cplus_plugin/tasks.py 237 238 239 240 241 242 243 244 245 246 def on_terminated ( self , hide = False ): \"\"\"Called when the task is terminated.\"\"\" if hide : message = \"Processing has been minimized by the user.\" else : message = \"Processing has been cancelled by the user.\" if self . error : message = f \"Problem in running scenario analysis: { self . error } \" self . set_status_message ( tr ( message )) self . log_message ( message ) replace_nodata \u00b6 replace_nodata ( layer_path , output_path , nodata_value =- 9999.0 ) Adds nodata value info into the layer available in the passed layer_path and saves the layer in the passed output_path. The addition will replace any current nodata value available in the input layer. Parameters: Name Type Description Default layer_path str Input layer path. Must be a valid file path to a raster layer. required output_path str Output layer path. Must be a valid file path where the modified raster will be saved. required nodata_value float No data value to be set in the output layer. Defaults to -9999.0 -9999.0 Returns: Type Description bool Whether the task operations were successful Source code in src/cplus_plugin/tasks.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def replace_nodata ( self , layer_path : str , output_path : str , nodata_value : float = - 9999.0 ): \"\"\"Adds nodata value info into the layer available in the passed layer_path and saves the layer in the passed output_path. The addition will replace any current nodata value available in the input layer. :param layer_path: Input layer path. Must be a valid file path to a raster layer. :type layer_path: str :param output_path: Output layer path. Must be a valid file path where the modified raster will be saved. :type output_path: str :param nodata_value: No data value to be set in the output layer. Defaults to -9999.0 :type nodata_value: float :returns: Whether the task operations were successful :rtype: bool \"\"\" self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) try : alg_params = { \"COPY_SUBDATASETS\" : False , \"DATA_TYPE\" : 6 , # Float32 \"EXTRA\" : \"\" , \"INPUT\" : layer_path , \"NODATA\" : None , \"OPTIONS\" : \"\" , \"TARGET_CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } translate_output = processing . run ( \"gdal:translate\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) alg_params = { \"DATA_TYPE\" : 0 , # Use Input Layer Data Type \"EXTRA\" : \"\" , \"INPUT\" : translate_output [ \"OUTPUT\" ], \"MULTITHREADING\" : False , \"NODATA\" : nodata_value , \"OPTIONS\" : \"\" , \"RESAMPLING\" : 0 , # Nearest Neighbour \"SOURCE_CRS\" : None , \"TARGET_CRS\" : None , \"TARGET_EXTENT\" : None , \"TARGET_EXTENT_CRS\" : None , \"TARGET_RESOLUTION\" : None , \"OUTPUT\" : output_path , } outputs = processing . run ( \"gdal:warpreproject\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) return outputs is not None except Exception as e : log ( f \"Problem replacing no data value from a snapping output, { e } \" ) return False reproject_layer \u00b6 reproject_layer ( input_path , target_crs , output_directory = None , target_extent = None , is_raster = True ) Reprojects the input layer to the target CRS and saves it in the specified output directory. Parameters: Name Type Description Default input_path str Input layer path required target_crs QgsCoordinateReferenceSystem Target CRS to reproject the layer to required output_directory str Directory to save the reprojected layer, defaults to None None target_extent str Target extent, defaults to None None is_raster bool Check if layer is raster, defaults to True True Returns: Type Description str Path to the reprojected layer Source code in src/cplus_plugin/tasks.py 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 def reproject_layer ( self , input_path : str , target_crs : QgsCoordinateReferenceSystem , output_directory : str = None , target_extent : str = None , is_raster : bool = True , ) -> str : \"\"\"Reprojects the input layer to the target CRS and saves it in the specified output directory. :param input_path: Input layer path :type input_path: str :param target_crs: Target CRS to reproject the layer to :type target_crs: QgsCoordinateReferenceSystem :param output_directory: Directory to save the reprojected layer, defaults to None :type output_directory: str, optional :param target_extent: Target extent, defaults to None :type target_extent: str, optional :param is_raster: Check if layer is raster, defaults to True :type is_raster: bool, optional :returns: Path to the reprojected layer :rtype: str \"\"\" if self . processing_cancelled : return False if not os . path . exists ( input_path ): self . log_message ( f \"Input layer { input_path } does not exist, \" f \"skipping the layer reprojection.\" ) return None try : if output_directory is None : output_directory = Path ( input_path ) . parent ext = \"tif\" if is_raster else \"shp\" output_file = os . path . join ( output_directory , f \" { Path ( input_path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } . { ext } \" , ) alg_params = { \"INPUT\" : input_path , \"TARGET_CRS\" : target_crs , \"OUTPUT\" : output_file , } if target_extent is not None and target_extent != \"\" : alg_params [ \"TARGET_EXTENT\" ] = target_extent self . log_message ( f \"Used parameters for layer reprojection: \" f \" { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return None results = processing . run ( \"gdal:warpreproject\" if is_raster else \"native:reprojectlayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem reprojecting layer, { e } \\n \" ) return None reproject_pathways \u00b6 reproject_pathways ( target_crs , target_extent = None ) Reprojects the activity pathways and priority layers to the target CRS. Parameters: Name Type Description Default target_crs QgsCoordinateReferenceSystem Target CRS to reproject the layers to required target_extent str Target extent, defaults to None None Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 def reproject_pathways ( self , target_crs : QgsCoordinateReferenceSystem , target_extent : str = None , ): \"\"\" Reprojects the activity pathways and priority layers to the target CRS. :param target_crs: Target CRS to reproject the layers to :type target_crs: QgsCoordinateReferenceSystem :param target_extent: Target extent, defaults to None :type target_extent: str, optional :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False if target_crs is None or not target_crs . isValid (): self . set_info_message ( tr ( \"Invalid target CRS for reprojecting pathways.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( \"Invalid target CRS for reprojecting pathways.\" ) return False self . set_status_message ( tr ( \"Reprojecting the activity pathways and priority layers\" ) ) pathways : typing . List [ NcsPathway ] = [] try : # Create directories for storing reprojected pathways and priority layers reprojected_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"reprojected\" ) FileUtils . create_new_dir ( reprojected_pathways_directory ) reprojected_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"reprojected\" ) FileUtils . create_new_dir ( reprojected_priority_directory ) for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or a \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Reproject priority layers # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping layer reprojection.\" ) continue if layer . crs () == target_crs : self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } \" f \"is already in the target CRS \" f \" { target_crs . authid () } , skipping layer reprojection.\" ) continue output_path = self . reproject_layer ( priority_layer_path , target_crs , reprojected_priority_directory , target_extent , ) if output_path : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_path if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping layer reprojection.\" ) continue if pathway_layer . crs () == target_crs : self . log_message ( f \"Pathway layer { pathway . name } is already in the target CRS \" f \" { target_crs . authid () } , skipping layer reprojection.\" ) else : self . log_message ( f \"Reprojecting { pathway . name } pathway layer to { target_crs . authid () } \\n \" ) output_path = self . reproject_layer ( pathway . path , target_crs , reprojected_pathways_directory , target_extent , ) if output_path : pathway . path = output_path self . log_message ( f \"Reprojecting { len ( pathway . priority_layers ) } \" f \"priority weighting layers from pathway { pathway . name } \\n \" ) if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem reprojecting layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run \u00b6 run () Runs the main scenario analysis task operations Source code in src/cplus_plugin/tasks.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def run ( self ): \"\"\"Runs the main scenario analysis task operations\"\"\" try : self . scenario_directory = self . get_scenario_directory () FileUtils . create_new_dir ( self . scenario_directory ) selected_pathway = None pathway_found = False for activity in self . analysis_activities : if pathway_found : break for pathway in activity . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break target_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) self . analysis_crs = self . analysis_extent . crs if self . analysis_crs is not None : # Use the CRS of the analysis if it is provided dest_crs = QgsCoordinateReferenceSystem ( self . analysis_crs ) else : # Use the CRS of the target layer if it exists # or use EPSG:4326 as a default CRS dest_crs = ( target_layer . crs () if selected_pathway and selected_pathway . path else QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) ) processing_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) snapped_extent = self . align_extent ( target_layer , processing_extent ) extent_string = ( f \" { snapped_extent . xMinimum () } , { snapped_extent . xMaximum () } ,\" f \" { snapped_extent . yMinimum () } , { snapped_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) self . log_message ( \"Original area of interest extent: \" f \" { processing_extent . asWktPolygon () } \\n \" ) self . log_message ( \"Snapped area of interest extent \" f \" { snapped_extent . asWktPolygon () } \\n \" ) # Run pathways layers snapping using a specified reference layer snapping_enabled = self . get_settings_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = self . get_reference_layer () if snapping_enabled and reference_layer : self . snap_analysis_data ( self . analysis_activities , extent_string , ) # Clip to StudyArea if self . clip_to_studyarea and os . path . exists ( self . studyarea_path ): # Reproject the study area to the EPSG:4326 # The validate_vector_layer is successful when the layer is in EPSG:4326 studyarea_path = self . reproject_layer ( input_path = self . studyarea_path , target_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), is_raster = False , ) # Validate layer geometries validated_path = self . validate_vector_layer ( studyarea_path ) if not validated_path : self . log_message ( f \"Invalid studyarea layer: { studyarea_path } \" ) else : self . studyarea_path = validated_path self . clip_analysis_data ( self . studyarea_path ) # Reproject the pathways and priority layers to the # scenario CRS if it is not the same as the pathways CRS if self . analysis_crs is not None : self . reproject_pathways ( target_extent = extent_string , target_crs = QgsCoordinateReferenceSystem ( self . analysis_crs ), ) # Replace no data value for the pathways and priority layers nodata_value = float ( self . get_settings_value ( Settings . NCS_NO_DATA_VALUE , default = NO_DATA_VALUE , setting_type = float , ) ) self . log_message ( f \"Replacing nodata value for the pathways and priority layers to { nodata_value } \" ) self . run_pathways_replace_nodata ( nodata_value = nodata_value ) # Calculate total carbon mitigation values for the Naturebase pathways self . run_pathways_carbon_summation () # Weight the pathways using the pathway suitability index # and priority group coefficients for the PWLs save_output = self . get_settings_value ( Settings . NCS_WEIGHTED , default = True , setting_type = bool ) self . run_pathways_weighting ( self . analysis_activities , self . analysis_priority_layers_groups , extent_string , temporary_output = not save_output , ) # Creating activities from the weighted pathways save_output = self . get_settings_value ( Settings . LANDUSE_PROJECT , default = True , setting_type = bool ) self . run_activities_analysis ( self . analysis_activities , extent_string , temporary_output = not save_output , ) # Normalize the activities. # This is useful when weighting pathways with relative impact matrix # Activities created in previous step may have values greater than 1 self . run_activity_normalization () # Run masking of the activities layers masking_layers = self . get_masking_layers () if masking_layers : self . run_activities_masking ( self . analysis_activities , masking_layers , extent_string , ) # Run internal masking of the activities layers self . run_internal_activities_masking ( self . analysis_activities , extent_string , ) # Run sieve if enabled sieve_enabled = self . get_settings_value ( Settings . SIEVE_ENABLED , default = False , setting_type = bool ) if sieve_enabled : self . run_activities_sieve ( self . analysis_activities , ) # After creating activities, we normalize them using the # suitability index save_output = self . get_settings_value ( Settings . LANDUSE_NORMALIZED , default = True , setting_type = bool ) # Clean up activities self . run_activities_cleaning ( self . analysis_activities , extent_string , temporary_output = not save_output , ) # Investability analysis self . run_investability_analysis () # The highest position tool analysis save_output = self . get_settings_value ( Settings . HIGHEST_POSITION , default = True , setting_type = bool ) self . run_highest_position_analysis ( temporary_output = not save_output ) return True except Exception as e : self . log_message ( f \"Analysis failed with error { e } \" ) self . log_message ( traceback . format_exc ()) return False run_activities_analysis \u00b6 run_activities_analysis ( activities , extent , temporary_output = False ) Runs the required activity analysis on the passed activities pathways. The analysis is responsible for creating activities layers from their respective pathways layers. Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent SpatialExtent selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 def run_activities_analysis ( self , activities , extent , temporary_output = False ): \"\"\"Runs the required activity analysis on the passed activities pathways. The analysis is responsible for creating activities layers from their respective pathways layers. :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: selected extent from user :type extent: SpatialExtent :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Creating activity layers from pathways\" )) try : for activity in activities : activities_directory = os . path . join ( self . scenario_directory , \"activities\" ) FileUtils . create_new_dir ( activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) layers = [] if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or an \" f \"activity layer for the activity { activity . name } \" ) return False output_file = os . path . join ( activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) # Due to the activities base class # activity only one of the following blocks will be executed, # the activity either contain a path or # pathways if activity . path is not None and activity . path != \"\" : layers = [ activity . path ] for pathway in activity . pathways : layers . append ( pathway . path ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) reference_layer = self . get_reference_layer () if ( reference_layer is None or reference_layer == \"\" ) and len ( layers ) > 0 : reference_layer = layers [ 0 ] # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"REFERENCE_LAYER\" : reference_layer , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output , } self . log_message ( f \"Used parameters for \" f \"activities generation: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem creating activity layers, { e } \" ) self . cancel_task ( e ) return False return True run_activities_cleaning \u00b6 run_activities_cleaning ( activities , extent = None , temporary_output = False ) Cleans the weighted activities replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. Parameters: Name Type Description Default activities List [ Activity ] Activities to be cleaned up. required extent str Selected extent from user None temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 def run_activities_cleaning ( self , activities , extent = None , temporary_output = False ): \"\"\"Cleans the weighted activities replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. :param activities: Activities to be cleaned up. :type activities: typing.List[Activity] :param extent: Selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Updating activity values\" )) try : for activity in activities : if activity . path is None or activity . path == \"\" : self . set_info_message ( tr ( f \"Problem when running activity updates, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when running activity updates, \" f \"there is no map layer for the activity { activity . name } \" ) return False layers = [ activity . path ] file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) weighted_pathways_dir = os . path . join ( self . scenario_directory , \"weighted_pathways\" ) FileUtils . create_new_dir ( weighted_pathways_dir ) output_file = os . path . join ( weighted_pathways_dir , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } _cleaned.tif\" , ) # Actual processing calculation # The aim is to convert pixels values to no data, that is why we are # using the sum operation with only one layer. output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : 0 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output , } self . log_message ( f \"Used parameters for \" f \"updates on the cleaned activities: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem cleaning activities, { e } \" ) self . cancel_task ( e ) return False return True run_activities_masking \u00b6 run_activities_masking ( activities , masking_layers , extent , temporary_output = False ) Applies the mask layers into the passed activities Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required masking_layers dict Paths to the mask layers to be used required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 def run_activities_masking ( self , activities , masking_layers , extent , temporary_output = False ): \"\"\"Applies the mask layers into the passed activities :param activities: List of the selected activities :type activities: typing.List[Activity] :param masking_layers: Paths to the mask layers to be used :type masking_layers: dict :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Masking activities using the saved masked layers\" )) try : if len ( masking_layers ) < 1 : return False if len ( masking_layers ) > 1 : initial_mask_layer = self . merge_vector_layers ( masking_layers ) else : mask_layer_path = masking_layers [ 0 ] initial_mask_layer = QgsVectorLayer ( mask_layer_path , \"mask\" , \"ogr\" ) if not initial_mask_layer . isValid (): self . log_message ( f \"Skipping activities masking \" f \"using layer { mask_layer_path } , not a valid layer.\" ) return False # see https://qgis.org/pyqgis/master/core/Qgis.html#qgis.core.Qgis.GeometryType if Qgis . versionInt () < 33000 : layer_check = ( initial_mask_layer . geometryType () == QgsWkbTypes . GeometryType . PolygonGeometry ) else : layer_check = ( initial_mask_layer . geometryType () == Qgis . GeometryType . Polygon ) if not layer_check : self . log_message ( f \"Skipping activities masking \" f \"using layer { mask_layer_path } , not a polygon layer.\" ) return False extent_layer = self . layer_extent ( extent ) mask_layer = self . mask_layer_difference ( initial_mask_layer , extent_layer ) if isinstance ( mask_layer , str ): mask_layer = QgsVectorLayer ( mask_layer , \"ogr\" ) if not mask_layer . isValid (): self . log_message ( f \"Skipping activities masking \" f \"the created difference mask layer { mask_layer . source () } ,\" f \" not a valid layer.\" ) return False for activity in activities : if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when masking activities, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when masking activities, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) return False masked_activities_directory = os . path . join ( self . scenario_directory , \"masked_activities\" ) FileUtils . create_new_dir ( masked_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( masked_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) activity_layer = QgsRasterLayer ( activity . path , \"activity_layer\" ) if activity_layer . crs () != mask_layer . crs (): self . log_message ( f \"Skipping masking, activity layer and\" f \" mask layer(s) have different CRS\" ) continue if not activity_layer . extent () . intersects ( mask_layer . extent ()): self . log_message ( \"Skipping masking, the extents of the activity layer \" \"and mask layer(s) do not overlap.\" ) continue # Actual processing calculation alg_params = { \"INPUT\" : activity . path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : activity_layer . crs (), \"DESTINATION_CRS\" : activity_layer . crs (), \"TARGET_EXTENT\" : extent , \"OUTPUT\" : output , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), } self . log_message ( f \"Used parameters for masking activity { activity . name } \" f \"using project mask layers: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem masking activities layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run_activities_sieve \u00b6 run_activities_sieve ( activities , temporary_output = False ) Runs the sieve functionality analysis on the passed activities layers, removing the activities layer polygons that are smaller than the provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbour polygon. Parameters: Name Type Description Default activities List [ Activity ] List of the analyzed activities. required extent str Selected area of interest extent required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 def run_activities_sieve ( self , activities , temporary_output = False ): \"\"\"Runs the sieve functionality analysis on the passed activities layers, removing the activities layer polygons that are smaller than the provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbour polygon. :param activities: List of the analyzed activities. :type activities: typing.List[Activity] :param extent: Selected area of interest extent :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Applying sieve function to the activities\" )) try : for activity in activities : if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when running sieve function on activities, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when running sieve function on activities, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) return False sieved_activities_directory = os . path . join ( self . scenario_directory , \"sieved_activities\" ) FileUtils . create_new_dir ( sieved_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( sieved_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) threshold_value = float ( self . get_settings_value ( Settings . SIEVE_THRESHOLD , default = 10 ) ) mask_layer = self . get_settings_value ( Settings . SIEVE_MASK_PATH , default = \"\" ) no_mask = not ( mask_layer and os . path . exists ( mask_layer )) mask_layer_ref = mask_layer if not no_mask else None output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) input_name = os . path . splitext ( os . path . basename ( activity . path ))[ 0 ] # Step 1: Create a binary mask from the original raster binary_mask = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path ], \"CRS\" : None , \"EXPRESSION\" : f \" { input_name } @1 > 0\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, )[ \"OUTPUT\" ] sieve_alg_params = { \"INPUT\" : binary_mask , \"THRESHOLD\" : threshold_value , \"EIGHT_CONNECTEDNESS\" : True , \"NO_MASK\" : no_mask , \"MASK_LAYER\" : mask_layer_ref , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , } self . log_message ( f \"Used parameters for sieving: { sieve_alg_params } \\n \" ) # Step 2: Run sieve analysis from the output of the binary mask sieved_mask = processing . run ( \"gdal:sieve\" , sieve_alg_params , context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] expr = f \"( { os . path . splitext ( os . path . basename ( sieved_mask ))[ 0 ] } @1 > 0) * { os . path . splitext ( os . path . basename ( sieved_mask ))[ 0 ] } @1\" # Step 3: Remove and convert any no data value to 0 sieved_mask_clean = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ sieved_mask ], \"CRS\" : None , \"EXPRESSION\" : expr , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] expr_2 = f \" { input_name } @1 * { os . path . splitext ( os . path . basename ( sieved_mask_clean ))[ 0 ] } @1\" # Step 4: Join the sieved mask with the original input layer to filter out the small areas sieve_output = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path , sieved_mask_clean ], \"CRS\" : None , \"EXPRESSION\" : expr_2 , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # Step 5. Replace all 0 with NO_DATA_VALUE using if # (\"combined@1\" <= 0, NO_DATA_VALUE, \"combined@1\") no_data_replace_exp = ( f \"(A > 0)*A + (A <= 0)* { float ( self . no_data_value ) } \" ) sieve_output_updated = processing . run ( \"gdal:rastercalculator\" , { \"INPUT_A\" : f \" { sieve_output } \" , \"BAND_A\" : 1 , \"FORMULA\" : no_data_replace_exp , \"NO_DATA\" : None , \"EXTENT_OPT\" : 0 , \"RTYPE\" : 5 , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if not os . path . exists ( sieve_output_updated ): self . log_message ( f \"Problem running sieve function \" f \"on activity layers, sieve intermediate layer not found\" f \" \\n \" ) self . cancel_task () return False self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False # Step 6. Run sum statistics with ignore no data values set to false # and no data value results = processing . run ( \"native:cellstatistics\" , { \"INPUT\" : [ sieve_output_updated ], \"STATISTIC\" : 0 , \"IGNORE_NODATA\" : False , \"REFERENCE_LAYER\" : sieve_output_updated , \"OUTPUT_NODATA_VALUE\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"OUTPUT\" : output , }, context = self . processing_context , feedback = self . feedback , ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem running sieve function on activity layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run_activity_normalization \u00b6 run_activity_normalization () Runs normalization analysis on the activities. The formula is: (activity - min) / (max - min) Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 def run_activity_normalization ( self , ) -> bool : \"\"\"Runs normalization analysis on the activities. The formula is: (activity - min) / (max - min) :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Normalization of activities\" )) normalized_activities_directory = os . path . join ( self . scenario_directory , \"normalized_activities\" ) FileUtils . create_new_dir ( normalized_activities_directory ) try : for activity in self . analysis_activities : if not activity . path : msg = f \"No defined activity layer for the activity { activity . name } \" self . set_info_message ( tr ( msg ), level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False if self . processing_cancelled : return False activity_layer = QgsRasterLayer ( activity . path , activity . name ) if not activity_layer . isValid (): self . log_message ( f \"Activity layer { activity . name } is not valid, \" f \"skipping the layer from normalization.\" ) continue provider = activity_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue if min_value is None or max_value is None : self . log_message ( f \"Activity layer { activity . name } has no valid \" f \"statistics, skipping the layer from normalization.\" ) continue if min_value == 0 and max_value == 1 : new_path = FileUtils . copy_file ( activity . path , normalized_activities_directory ) if new_path and os . path . exists ( new_path ): activity . path = new_path self . log_message ( f \"Activity layer { activity . name } is already normalized (min= { min_value } , max= { max_value } ), \" f \"skipping the layer from normalization.\" ) continue self . log_message ( f \"Normalizing { activity . name } activity layer \\n \" ) expression = f \"(A - { min_value } ) / ( { max_value } - { min_value } )\" output_path = os . path . join ( f \" { normalized_activities_directory } \" , f \" { Path ( activity . path ) . stem } _norm_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) alg_params = { \"INPUT_A\" : activity . path , \"BAND_A\" : 1 , \"FORMULA\" : expression , \"OPTIONS\" : \"COMPRESS=DEFLATE|ZLEVEL=6|TILED=YES\" , # Compress the layer \"OUTPUT\" : output_path , } self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False result = processing . run ( \"gdal:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): activity . path = result . get ( \"OUTPUT\" ) else : self . log_message ( f \"Problem normalizing activity layer { activity . name } , \" f \"skipping the layer from normalization.\" ) return True except Exception as e : self . log_message ( f \"Problem normalizing activities, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False run_highest_position_analysis \u00b6 run_highest_position_analysis ( temporary_output = False ) Runs the highest position analysis which is last step in scenario analysis. Uses the activities set by the current ongoing analysis. Parameters: Name Type Description Default temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 def run_highest_position_analysis ( self , temporary_output = False ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the activities set by the current ongoing analysis. :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) # We explicitly set the created_date since the current implementation # of the data model means that the attribute value is set only once when # the class is loaded hence subsequent instances will have the same value. self . scenario_result = ScenarioResult ( scenario = self . scenario , scenario_directory = self . scenario_directory , created_date = datetime . datetime . now (), ) try : layers = {} self . set_status_message ( tr ( \"Calculating the highest position\" )) for activity in self . analysis_activities : if activity . path is not None and activity . path != \"\" : raster_layer = QgsRasterLayer ( activity . path , activity . name ) layers [ activity . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in activity . pathways : layers [ activity . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs extent_string = ( f \" { passed_extent . xMinimum () } , { passed_extent . xMaximum () } ,\" f \" { passed_extent . yMinimum () } , { passed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = os . path . join ( self . scenario_directory , f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) # Preparing the input rasters for the highest position # analysis in a correct order activity_names = [ activity . name for activity in self . analysis_activities ] all_activities = sorted ( self . analysis_activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 all_activity_names = [ activity . name for activity in all_activities ] sources = [] for activity_name in all_activity_names : if activity_name in activity_names : sources . append ( layers [ activity_name ] . source ()) self . log_message ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) output_file = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : self . no_data_value , \"REFERENCE_LAYER\" : ( list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None ), \"OUTPUT\" : output_file , } self . log_message ( f \"Used parameters for highest position analysis { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False self . output = processing . run ( \"native:highestpositioninrasterstack\" , alg_params , context = self . processing_context , feedback = self . feedback , ) except Exception as err : self . log_message ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) ) self . cancel_task ( err ) return False return True run_internal_activities_masking \u00b6 run_internal_activities_masking ( activities , extent , temporary_output = False ) Applies the mask layers into the passed activities Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 def run_internal_activities_masking ( self , activities , extent , temporary_output = False ): \"\"\"Applies the mask layers into the passed activities :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Masking activities using their respective mask layers.\" ) ) try : for activity in activities : masking_layers = activity . mask_paths if len ( masking_layers ) < 1 : self . log_message ( f \"Skipping activity masking \" f \"No mask layer(s) for activity { activity . name } \" ) continue if len ( masking_layers ) > 1 : initial_mask_layer = self . merge_vector_layers ( masking_layers ) else : mask_layer_path = masking_layers [ 0 ] initial_mask_layer = QgsVectorLayer ( mask_layer_path , \"mask\" , \"ogr\" ) if not initial_mask_layer . isValid (): self . log_message ( f \"Skipping activity masking \" f \"using layer { mask_layer_path } , not a valid layer.\" ) continue # see https://qgis.org/pyqgis/master/core/Qgis.html#qgis.core.Qgis.GeometryType if Qgis . versionInt () < 33000 : layer_check = ( initial_mask_layer . geometryType () == QgsWkbTypes . GeometryType . PolygonGeometry ) else : layer_check = ( initial_mask_layer . geometryType () == Qgis . GeometryType . Polygon ) if not layer_check : self . log_message ( f \"Skipping activity masking \" f \"using layer { mask_layer_path } , not a polygon layer.\" ) continue extent_layer = self . layer_extent ( extent ) if extent_layer . crs () != initial_mask_layer . crs (): self . log_message ( \"Skipping masking, the mask layers crs\" \" do not match the scenario crs.\" ) continue if not extent_layer . extent () . intersects ( initial_mask_layer . extent ()): self . log_message ( \"Skipping masking, the mask layers extent\" \" and the scenario extent do not overlap.\" ) continue mask_layer = self . mask_layer_difference ( initial_mask_layer , extent_layer ) if isinstance ( mask_layer , str ): mask_layer = QgsVectorLayer ( mask_layer , \"ogr\" ) if not mask_layer . isValid (): self . log_message ( f \"Skipping activity masking \" f \"the created difference mask layer { mask_layer . source () } ,\" f \"is not a valid layer.\" ) continue if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when masking activity, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when masking activity, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) continue masked_activities_directory = os . path . join ( self . scenario_directory , \"final_masked_activities\" ) FileUtils . create_new_dir ( masked_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( masked_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) activity_layer = QgsRasterLayer ( activity . path , \"activity_layer\" ) if activity_layer . crs () != mask_layer . crs (): self . log_message ( f \"Skipping masking, activity layer and\" f \" mask layer(s) have different CRS\" ) continue if not activity_layer . extent () . intersects ( mask_layer . extent ()): self . log_message ( \"Skipping masking, the extents of the activity layer \" \"and mask layers do not overlap.\" ) continue # Actual processing calculation alg_params = { \"INPUT\" : activity . path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : activity_layer . crs (), \"DESTINATION_CRS\" : activity_layer . crs (), \"TARGET_EXTENT\" : extent , \"OUTPUT\" : output , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), } self . log_message ( f \"Used parameters for masking the activity { activity . name } \" f \" using activity respective mask layer(s): { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem masking activities layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run_investability_analysis \u00b6 run_investability_analysis () Run activity investability analysis Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 def run_investability_analysis ( self ) -> bool : \"\"\"Run activity investability analysis :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Calculating investability of the activities\" )) investable_activities = os . path . join ( self . scenario_directory , \"investable_activities\" ) FileUtils . create_new_dir ( investable_activities ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) try : for activity in self . analysis_activities : if activity . path is None or activity . path == \"\" : self . log_message ( f \"Problem when running activity investability, \" f \"there is no map layer for the activity { activity . name } \" ) return False if not os . path . exists ( activity . path ): self . log_message ( f \"Problem when running activity investability, \" f \"the map layer for the activity { activity . name } does not exist\" ) return False layers = [ activity . path ] activity_basename = Path ( activity . path ) . stem expression_items = [ f '(\" { activity_basename } @1\")' ] constant_raster_components = ( constant_raster_registry . activity_components ( activity_identifier = str ( activity . uuid ) ) ) # Serialize the constant rasters constant_rasters = [ { \"name\" : component . base_name , \"uuid\" : component . component_id , \"absolute\" : component . value_info . absolute , \"normalized\" : component . value_info . normalized , \"path\" : component . path , \"skip_raster\" : ( component . skip_raster if os . path . exists ( component . path ) else True ), } for component in constant_raster_components ] if constant_rasters is None : constant_rasters = [] if self . processing_cancelled : return False if self . get_settings_value ( Settings . PIXEL_CONNECTIVITY_ENABLED , default = True , setting_type = bool ): # Add connectivity layer connectivity_path = self . create_activity_connectivity_layer ( activity = activity ) if connectivity_path and os . path . exists ( connectivity_path ): constant_rasters . append ( { \"path\" : connectivity_path , \"name\" : \"Connectivity layer\" , \"skip_raster\" : False , } ) else : self . log_message ( f \"Invalid path for connectivity layer of activity { activity . name } \" ) nr_constant_rasters = len ( constant_rasters ) if nr_constant_rasters == 0 : self . log_message ( f \"No defined constant rasters, \" f \"Skipping investability analysis for the activity { activity . name } \" ) continue for constant_raster in constant_rasters : if \"normalized\" in constant_raster : expression_items . append ( str ( constant_raster . get ( \"normalized\" ) / nr_constant_rasters ) ) else : path = constant_raster . get ( \"path\" , \"\" ) if not os . path . exists ( path ): self . log_message ( f \"Invalid constant raster path { path } ,\" f \"Skipping from the investability analysis for the activity { activity . name } \" ) continue normalized_path = os . path . join ( f \" { investable_activities } \" , f \" { Path ( path ) . stem } _norm_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) if self . processing_cancelled : return False ok , log = normalize_raster ( input_raster_path = path , output_raster_path = normalized_path , processing_context = self . processing_context , feedback = self . feedback , ) self . log_message ( log ) if not ok : self . log_message ( f \"Skipping { path } from the investability analysis for the activity { activity . name } \" ) continue if os . path . exists ( normalized_path ): path = normalized_path layers . append ( path ) expression_items . append ( f '(\" { Path ( path ) . stem } @1\" / { nr_constant_rasters } )' ) output_path = os . path . join ( f \" { investable_activities } \" , f \" { Path ( activity . path ) . stem } _invest_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : \" + \" . join ( expression_items ), \"LAYERS\" : layers , \"OUTPUT\" : output_path , } self . log_message ( f \" Used parameters for calculating investability for activity { activity . name } , \" f \" { alg_params } \\n \" ) if self . processing_cancelled : return False result = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): activity . path = result . get ( \"OUTPUT\" ) else : self . log_message ( f \"Problem calculating investability for activity { activity . name } \" ) except Exception as e : self . log_message ( f \"Problem calculating activity investability, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False return True run_normalize_pathways_carbon_impact \u00b6 run_normalize_pathways_carbon_impact ( pathways ) Normalizes the total carbon impact for the pathways grouped by the pathway type Parameters: Name Type Description Default pathways List [ NcsPathway ] List of the pathways required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 def run_normalize_pathways_carbon_impact ( self , pathways : typing . List [ NcsPathway ] ) -> bool : \"\"\"Normalizes the total carbon impact for the pathways grouped by the pathway type :param pathways: List of the pathways :type pathways: typing.List[NcsPathway] :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . log_message ( tr ( f \"Normalizing Total Carbon Impact for Pathways\" )) if len ( pathways ) == 0 : msg = tr ( f \"No defined pathways for running normalize total carbon impact.\" ) self . set_info_message ( msg , level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False try : pathways_carbon_value = [ p . type_options . get ( \"carbon_impact\" , 0 ) for p in pathways if p . pathway_type in ( NcsPathwayType . MANAGE , NcsPathwayType . RESTORE ) ] pathways_carbon_value = [ v for v in pathways_carbon_value if v is not None ] if len ( pathways_carbon_value ) == 0 : self . log_message ( \"No manage or restore pathways\" ) return False # Calculate min/max for each pathway type carbon_stats = { \"min\" : min ( pathways_carbon_value ), \"max\" : max ( pathways_carbon_value ), \"range\" : max ( pathways_carbon_value ) - min ( pathways_carbon_value ), } # Normalize carbon impact for each pathway for pathway in pathways : # Ignore protect pathways if pathway . pathway_type not in ( NcsPathwayType . MANAGE , NcsPathwayType . RESTORE , ): continue carbon_impact = pathway . type_options . get ( \"carbon_impact\" ) if carbon_impact is None : continue if carbon_stats [ \"range\" ] == 0 : # All values are the same carbon impact norm_carbon_impact = 1 / len ( pathways_carbon_value ) else : norm_carbon_impact = ( carbon_impact - carbon_stats [ \"min\" ] ) / carbon_stats [ \"range\" ] pathway . type_options . update ({ \"norm_carbon_impact\" : norm_carbon_impact }) return True except Exception as e : self . log_message ( f \"Problem normalizing pathways carbon impact, { e } \\n \" ) self . cancel_task ( e ) return False run_pathways_carbon_summation \u00b6 run_pathways_carbon_summation () Calculates total carbon mitigation values for the Naturebase pathways. Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 def run_pathways_carbon_summation ( self ) -> bool : \"\"\"Calculates total carbon mitigation values for the Naturebase pathways. :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Calculating total carbon mitigation values for the Naturebase pathways\" ) ) pathways : typing . List [ NcsPathway ] = [] try : for activity in self . analysis_activities : if not activity . pathways and not activity . path : msg = f \"\"\"No defined activity pathways or activity layers for the activity { activity . name } \"\"\" self . log_message ( msg ) return False for pathway in activity . pathways : if ( pathway . name . startswith ( \"Naturebase:\" ) and pathway not in pathways ): pathways . append ( pathway ) if len ( pathways ) == 0 : self . log_message ( \"No Naturebase pathways found in any activity.\" ) return False for pathway in pathways : if self . processing_cancelled : return False pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping calculating total carbon value for layer.\" ) continue raster_provider = pathway_layer . dataProvider () stats = raster_provider . bandStatistics ( 1 , QgsRasterBandStats . Stats . Sum ) if stats is None or stats . sum is None : self . log_message ( f \"Could not calculate statistics for { pathway . name } , skipping.\" ) continue pathway . carbon_impact_value = stats . sum except Exception as e : self . log_message ( f \"Problem calculating total carbon values for layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run_pathways_replace_nodata \u00b6 run_pathways_replace_nodata ( nodata_value =- 9999.0 ) Replace the nodata value for activity pathways and priority layers. Parameters: Name Type Description Default nodata_value float The nodata value to replace in the pathways and priority layers -9999.0 Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def run_pathways_replace_nodata ( self , nodata_value : float = - 9999.0 ) -> bool : \"\"\"Replace the nodata value for activity pathways and priority layers. :param nodata_value: The nodata value to replace in the pathways and priority layers :type nodata_value: float :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Replacing the nodata value for the activity pathways and priority layers\" ) ) pathways : typing . List [ NcsPathway ] = [] try : # Create directories for replaced nodata pathways and priority layers replaced_nodata_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"replaced_nodata\" ) FileUtils . create_new_dir ( replaced_nodata_pathways_directory ) replaced_nodata_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"replaced_nodata\" ) FileUtils . create_new_dir ( replaced_nodata_priority_directory ) for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or \" f \" activity layers for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or \" f \"activity layers for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Replace the no data value for priority layers # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping replacing nodata value for layer.\" ) continue raster_provider = layer . dataProvider () raster_no_data_value = raster_provider . sourceNoDataValue ( 1 ) if raster_no_data_value == nodata_value : self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } already has the nodata value \" f \" { nodata_value } , skipping replacing nodata value for layer.\" ) continue self . log_message ( f \"Replacing nodata value for { priority_layer . get ( 'name' ) } priority layer \" f \"to { nodata_value } \\n \" ) output_file = os . path . join ( replaced_nodata_priority_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . replace_nodata ( priority_layer_path , output_file , nodata_value ) if result : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_file if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping replacing nodata value for layer.\" ) continue raster_provider = pathway_layer . dataProvider () raster_no_data_value = raster_provider . sourceNoDataValue ( 1 ) if raster_no_data_value == nodata_value : self . log_message ( f \"Pathway layer { pathway . name } already has the nodata value \" f \" { nodata_value } , skipping replacing nodata value for layer.\" ) else : self . log_message ( f \"Replacing nodata value for { pathway . name } pathway layer \" f \"from { raster_no_data_value } to { nodata_value } \\n \" ) output_file = os . path . join ( replaced_nodata_pathways_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . replace_nodata ( pathway . path , output_file , nodata_value ) if result : pathway . path = output_file if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem replacing nodata value for layers, { e } \\n \" ) self . cancel_task ( e ) return False return True run_pathways_weighting \u00b6 run_pathways_weighting ( activities , priority_layers_groups , extent , temporary_output = False ) Runs weighting analysis on the pathways in the activities using the corresponding NCS PWLs. The formula is: (suitability_index * pathway) * ((priority group coefficient 1 * impact weight * PWL 1) + (priority group coefficient 2 * impact weight * PWL 2) ...) Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 def run_pathways_weighting ( self , activities : typing . List [ Activity ], priority_layers_groups , extent , temporary_output = False , ) -> bool : \"\"\"Runs weighting analysis on the pathways in the activities using the corresponding NCS PWLs. The formula is: (suitability_index * pathway) * ((priority group coefficient 1 * impact weight * PWL 1) + (priority group coefficient 2 * impact weight * PWL 2) ...) :param activities: List of the selected activities :type activities: typing.List[Activity] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( f \"Weighting of pathways\" )) if len ( activities ) == 0 : msg = tr ( f \"No defined activities for running pathways weighting.\" ) self . set_info_message ( msg , level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False # Get the relative impact matrix relative_impact_matrix = dict () impact_matrix = settings_manager . get_value ( Settings . SCENARIO_IMPACT_MATRIX , dict () ) if len ( impact_matrix ) > 0 : relative_impact_matrix = json . loads ( impact_matrix ) pathway_uuids = relative_impact_matrix . get ( \"pathway_uuids\" , []) priority_layer_uuids = relative_impact_matrix . get ( \"priority_layer_uuids\" , []) relative_impact_values = relative_impact_matrix . get ( \"values\" , []) # Get valid pathways pathways : typing . List [ NcsPathway ] = [] activities_paths = [] try : # Validate activities and corresponding pathways for activity in activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or an\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or an \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if pathway not in pathways : pathways . append ( pathway ) if activity . path is not None and activity . path != \"\" : activities_paths . append ( activity . path ) if not pathways and len ( activities_paths ) > 0 : self . run_activities_analysis ( activities , extent ) return False self . run_normalize_pathways_carbon_impact ( pathways ) settings_priority_layers = self . get_priority_layers () weighted_pathways_directory = os . path . join ( self . scenario_directory , \"weighted_pathways\" ) FileUtils . create_new_dir ( weighted_pathways_directory ) for pathway in pathways : # Skip processing if cancelled if self . processing_cancelled : return False base_names = [] layers = [ pathway . path ] run_calculation = False # Include suitability index if not zero pathway_basename = Path ( pathway . path ) . stem if pathway . suitability_index > 0 : base_names . append ( f '( { pathway . suitability_index } *\" { pathway_basename } @1\")' ) run_calculation = True else : base_names . append ( f '(\" { pathway_basename } @1\")' ) for layer in pathway . priority_layers : if not any ( priority_layers_groups ): self . log_message ( f \"There are no defined priority layers in groups,\" f \" skipping the inclusion of PWLs in pathways \" f \"weighting.\" ) break if layer is None : continue settings_layer = self . get_priority_layer ( layer . get ( \"uuid\" )) if settings_layer is None : continue pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the pathway { pathway . name } weighting.\" ) if pwl is None : self . log_message ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): self . log_message ( missing_pwl_message ) continue pwl_path_basename = pwl_path . stem for priority_layer in settings_priority_layers : if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): impact_value = None try : row = pathway_uuids . index ( str ( pathway . uuid )) col = priority_layer_uuids . index ( layer [ \"uuid\" ]) except ValueError : self . log_message ( f \"Could not find pathway uuid { pathway . uuid } or \" f \"priority layer uuid { layer [ 'uuid' ] } in the relative impact matrix.\" ) else : if row < len ( relative_impact_values ) and col < len ( relative_impact_values [ row ] ): impact_value = relative_impact_values [ row ][ col ] else : self . log_message ( f \"Index out of range for relative impact \" f \"matrix: row= { row } , col= { col } .\" ) value = group . get ( \"value\" ) priority_group_coefficient = float ( value ) if priority_group_coefficient > 0 : if pwl not in layers : layers . append ( pwl ) pwl_expression = ( f \"( { priority_group_coefficient } *\" f '\" { pwl_path_basename } @1\")' ) if impact_value is not None and impact_value < 0 : # Inverse the PWL pwl_expression = ( f \"( { priority_group_coefficient } *\" f '(\" { pwl_path_basename } @1\" - 1) * -1)' ) norm_carbon_impact = pathway . type_options . get ( \"norm_carbon_impact\" ) if ( layer . get ( \"is_carbon\" ) and norm_carbon_impact is not None ): # For restore and manage pathways, multiply by normalized carbon impact pwl_expression += f \" * { abs ( int ( impact_value )) * norm_carbon_impact } \" elif impact_value is not None : # For non-carbon PWLS and and protect pathways, pwl_expression += f \"* { abs ( int ( impact_value )) } \" base_names . append ( pwl_expression ) if not run_calculation : run_calculation = True # No need to run the calculation if suitability index is # zero or there are no PWLs in the activity. if not run_calculation : continue file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( weighted_pathways_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) expression = f \" { base_names [ 0 ] } \" if len ( base_names ) > 1 : pwl_calc_expression = \" + \" . join ( base_names [ 1 :]) expression += f \" * ( { pwl_calc_expression } )\" # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } self . log_message ( f \" Used parameters for calculating weighting pathways { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) pathway . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem weighting pathways, { e } \\n \" ) self . cancel_task ( e ) return False return True set_custom_progress \u00b6 set_custom_progress ( value ) Set task progress value. Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 469 470 471 472 473 474 475 476 def set_custom_progress ( self , value : float ): \"\"\"Set task progress value. :param value: Value to be set on the progress bar :type value: float \"\"\" self . custom_progress = value self . custom_progress_changed . emit ( self . custom_progress ) set_info_message \u00b6 set_info_message ( message , level = Qgis . MessageLevel . Info ) Set info message. Parameters: Name Type Description Default message str Message required level ( int , optional ) log level, defaults to Qgis.Info Info Source code in src/cplus_plugin/tasks.py 458 459 460 461 462 463 464 465 466 467 def set_info_message ( self , message : str , level = Qgis . MessageLevel . Info ): \"\"\"Set info message. :param message: Message :type message: str :param level: log level, defaults to Qgis.Info :type level: int, optional \"\"\" self . info_message = message self . info_message_changed . emit ( self . info_message , level ) set_status_message \u00b6 set_status_message ( message ) Set status message in progress dialog Parameters: Name Type Description Default message str Message to be displayed required Source code in src/cplus_plugin/tasks.py 449 450 451 452 453 454 455 456 def set_status_message ( self , message : str ): \"\"\"Set status message in progress dialog :param message: Message to be displayed :type message: str \"\"\" self . status_message = message self . status_message_changed . emit ( self . status_message ) snap_analysis_data \u00b6 snap_analysis_data ( activities , extent ) Snaps the passed activities pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent list The selected extent from user required Source code in src/cplus_plugin/tasks.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 def snap_analysis_data ( self , activities , extent ): \"\"\"Snaps the passed activities pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: The selected extent from user :type extent: list \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Snapping the selected activity pathways, \" \"carbon layers and priority layers\" ) ) pathways = [] try : for activity in activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or a \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) reference_layer_path = self . get_settings_value ( Settings . SNAP_LAYER ) rescale_values = self . get_settings_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) resampling_method = self . get_settings_value ( Settings . RESAMPLING_METHOD , default = 0 ) if pathways is not None and len ( pathways ) > 0 : snapped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" ) FileUtils . create_new_dir ( snapped_pathways_directory ) for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) nodata_value = pathway_layer . dataProvider () . sourceNoDataValue ( 1 ) if self . processing_cancelled : return False # carbon layer snapping self . log_message ( f \"Snapping carbon layers from { pathway . name } pathway\" ) if ( pathway . carbon_paths is not None and len ( pathway . carbon_paths ) > 0 ): snapped_carbon_directory = os . path . join ( self . scenario_directory , \"carbon_layers\" ) FileUtils . create_new_dir ( snapped_carbon_directory ) snapped_carbon_paths = [] for carbon_path in pathway . carbon_paths : carbon_layer = QgsRasterLayer ( carbon_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_carbon = ( carbon_layer . dataProvider () . sourceNoDataValue ( 1 ) ) carbon_output_path = self . snap_layer ( carbon_path , reference_layer_path , extent , snapped_carbon_directory , rescale_values , resampling_method , nodata_value_carbon , ) if carbon_output_path : snapped_carbon_paths . append ( carbon_output_path ) else : snapped_carbon_paths . append ( carbon_path ) pathway . carbon_paths = snapped_carbon_paths self . log_message ( f \"Snapping { pathway . name } pathway layer \\n \" ) # Pathway snapping output_path = self . snap_layer ( pathway . path , reference_layer_path , extent , snapped_pathways_directory , rescale_values , resampling_method , nodata_value , ) if output_path : pathway . path = output_path for pwl_pathway in pathways : self . log_message ( f \"Snapping { len ( pwl_pathway . priority_layers ) } \" f \"priority weighting layers from pathway { pwl_pathway . name } with layers \\n \" ) if ( pwl_pathway . priority_layers is not None and len ( pwl_pathway . priority_layers ) > 0 ): snapped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layers\" ) FileUtils . create_new_dir ( snapped_priority_directory ) priority_layers = [] for priority_layer in pwl_pathway . priority_layers : if priority_layer is None : continue priority_layer_settings = self . get_priority_layer ( priority_layer . get ( \"uuid\" ) ) if priority_layer_settings is None : continue priority_layer_path = priority_layer_settings . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): priority_layers . append ( priority_layer ) continue layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_priority = layer . dataProvider () . sourceNoDataValue ( 1 ) priority_output_path = self . snap_layer ( priority_layer_path , reference_layer_path , extent , snapped_priority_directory , rescale_values , resampling_method , nodata_value_priority , ) if priority_output_path : priority_layer [ \"path\" ] = priority_output_path priority_layers . append ( priority_layer ) pwl_pathway . priority_layers = priority_layers except Exception as e : self . log_message ( f \"Problem snapping layers, { e } \\n \" ) self . cancel_task ( e ) return False return True snap_layer \u00b6 snap_layer ( input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value ) Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. Parameters: Name Type Description Default input_path str Input layer source required reference_path str Reference layer source required extent list Clip extent required directory str Absolute path of the output directory for the snapped layers required rescale_values bool Whether to rescale pixel values required resample_method ResampleAlg Method to use when resampling required nodata_value float Original no data value of the input layer required Source code in src/cplus_plugin/tasks.py 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 def snap_layer ( self , input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value , ): \"\"\"Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. :param input_path: Input layer source :type input_path: str :param reference_path: Reference layer source :type reference_path: str :param extent: Clip extent :type extent: list :param directory: Absolute path of the output directory for the snapped layers :type directory: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg :param nodata_value: Original no data value of the input layer :type nodata_value: float \"\"\" input_result_path , reference_result_path = align_rasters ( input_path , reference_path , extent , directory , rescale_values , resampling_method , ) if input_result_path is not None : result_path = Path ( input_result_path ) directory = result_path . parent name = result_path . stem output_path = os . path . join ( directory , f \" { name } _final.tif\" ) self . replace_nodata ( input_result_path , output_path , nodata_value ) return output_path update_progress \u00b6 update_progress ( value ) Sets the value of the task progress Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 478 479 480 481 482 483 484 485 486 487 488 def update_progress ( self , value ): \"\"\"Sets the value of the task progress :param value: Value to be set on the progress bar :type value: float \"\"\" if not self . processing_cancelled : self . set_custom_progress ( value ) else : self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () validate_vector_layer \u00b6 validate_vector_layer ( source_path ) Create a valid representation of a given vector layer without losing any of the input vertices. Parameters: Name Type Description Default source_path str Path to vector layer. The native:fixgeometries requires the layer in EPSG:4326 required Returns: Type Description str | bool Path to the validated vector layer else False. Source code in src/cplus_plugin/tasks.py 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def validate_vector_layer ( self , source_path ) -> str : \"\"\"Create a valid representation of a given vector layer without losing any of the input vertices. :param source_path: Path to vector layer. The native:fixgeometries requires the layer in EPSG:4326 :type source_path: str :returns: Path to the validated vector layer else False. :rtype: str | bool \"\"\" self . log_message ( f \"Validating the vector layer { source_path } \" ) layer = QgsVectorLayer ( source_path , \"input_layer\" ) if not layer . isValid (): return False try : validated_directory = Path ( source_path ) . parent self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False output_file = os . path . join ( validated_directory , f \"validated_ { str ( uuid . uuid4 ())[: 4 ] } .shp\" , ) alg_params = { \"INPUT\" : source_path , \"METHOD\" : 1 , \"OUTPUT\" : output_file } self . log_message ( f \"Used parameters for validating the vector: { source_path } \" f \" { alg_params } \\n \" ) result = processing . run ( \"native:fixgeometries\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return result . get ( \"OUTPUT\" ) except Exception as e : self . log_message ( f \"Problem validating the vector, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False","title":"Processing"},{"location":"developer/api/core/api_tasks/#processing-tasks","text":"Plugin tasks related to the scenario analysis","title":"Processing Tasks"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask","text":"ScenarioAnalysisTask ( analysis_scenario_name , analysis_scenario_description , analysis_activities , analysis_priority_layers_groups , analysis_extent , scenario , clip_to_studyarea = False , studyarea_path = None ) Bases: QgsTask Prepares and runs the scenario analysis Source code in src/cplus_plugin/tasks.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def __init__ ( self , analysis_scenario_name , analysis_scenario_description , analysis_activities , analysis_priority_layers_groups , analysis_extent , scenario , clip_to_studyarea : bool = False , studyarea_path : str = None , ): super () . __init__ () self . analysis_scenario_name = analysis_scenario_name self . analysis_scenario_description = analysis_scenario_description self . analysis_activities = analysis_activities self . analysis_priority_layers_groups = analysis_priority_layers_groups self . analysis_extent = analysis_extent self . analysis_extent_string = None self . clip_to_studyarea = clip_to_studyarea self . studyarea_path = studyarea_path self . scenario_result = None self . scenario_directory = None self . success = True self . output = None self . error = None self . status_message = None self . info_message = None self . processing_cancelled = False self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario = scenario self . no_data_value = settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE )","title":"ScenarioAnalysisTask"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.align_extent","text":"align_extent ( raster_layer , target_extent ) Snaps the passed extent to the activities pathway layer pixel bounds Parameters: Name Type Description Default raster_layer QgsRasterLayer The target layer that the passed extent will be aligned with required target_extent QgsRectangle Spatial extent that will be used a target extent when doing alignment. required Source code in src/cplus_plugin/tasks.py 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def align_extent ( self , raster_layer , target_extent ): \"\"\"Snaps the passed extent to the activities pathway layer pixel bounds :param raster_layer: The target layer that the passed extent will be aligned with :type raster_layer: QgsRasterLayer :param target_extent: Spatial extent that will be used a target extent when doing alignment. :type target_extent: QgsRectangle \"\"\" try : raster_extent = raster_layer . extent () x_res = raster_layer . rasterUnitsPerPixelX () y_res = raster_layer . rasterUnitsPerPixelY () left = raster_extent . xMinimum () + x_res * math . floor ( ( target_extent . xMinimum () - raster_extent . xMinimum ()) / x_res ) right = raster_extent . xMinimum () + x_res * math . ceil ( ( target_extent . xMaximum () - raster_extent . xMinimum ()) / x_res ) bottom = raster_extent . yMinimum () + y_res * math . floor ( ( target_extent . yMinimum () - raster_extent . yMinimum ()) / y_res ) top = raster_extent . yMaximum () - y_res * math . floor ( ( raster_extent . yMaximum () - target_extent . yMaximum ()) / y_res ) return QgsRectangle ( left , bottom , right , top ) except Exception as e : self . log_message ( tr ( f \"Problem snapping area of \" f \"interest extent, using the original extent,\" f \" { str ( e ) } \" ) ) return target_extent","title":"align_extent"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.cancel_task","text":"cancel_task ( exception = None ) Cancel current task. Parameters: Name Type Description Default exception ( Any , optional ) Exception if stopped with error, defaults to None None Source code in src/cplus_plugin/tasks.py 197 198 199 200 201 202 203 204 def cancel_task ( self , exception = None ): \"\"\"Cancel current task. :param exception: Exception if stopped with error, defaults to None :type exception: Any, optional \"\"\" self . error = exception self . cancel ()","title":"cancel_task"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.clip_analysis_data","text":"clip_analysis_data ( studyarea_path ) Clips the activity pathways and priority layers by the given study area. Parameters: Name Type Description Default studyarea_path str The path to the study area layer required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 def clip_analysis_data ( self , studyarea_path : str ) -> bool : \"\"\"Clips the activity pathways and priority layers by the given study area. :param studyarea_path: The path to the study area layer :type studyarea_path: str :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False mask_layer = QgsVectorLayer ( studyarea_path , \"mask_layer\" ) if not mask_layer . isValid (): self . log_message ( f \"Invalid mask layer: { studyarea_path } \" f \"Skipping clipping of activity pathways and priority layers \\n \" ) return False self . set_status_message ( tr ( \"Clipping the activity pathways and priority layers by the study area layer\" ) ) clipped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"clipped\" ) FileUtils . create_new_dir ( clipped_pathways_directory ) clipped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"clipped\" ) FileUtils . create_new_dir ( clipped_priority_directory ) pathways : typing . List [ NcsPathway ] = [] try : for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or \" f \" activity layers for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or \" f \"activity layers for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Clipping the PWLs # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping clipping layer.\" ) continue if not self . _can_clip_raster_by_mask ( layer , mask_layer ): continue self . log_message ( f \"Clipping the { priority_layer . get ( 'name' ) } priority layer \" f \"by study area layer \\n \" ) output_file = os . path . join ( clipped_priority_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . clip_raster_by_mask ( priority_layer_path , studyarea_path , output_file ) if result : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_file if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping clipping the layer.\" ) continue self . log_message ( f \"Clipping the { pathway . name } pathway layer by \" f \"the study area layer \\n \" ) if not self . _can_clip_raster_by_mask ( pathway_layer , mask_layer ): continue output_file = os . path . join ( clipped_pathways_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . clip_raster_by_mask ( pathway . path , studyarea_path , output_file ) if result : pathway . path = output_file if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem clipping the layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"clip_analysis_data"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.clip_raster_by_mask","text":"clip_raster_by_mask ( input_raster_path , mask_layer_path , output_path ) Clip a given raster by the specified mask layer. Parameters: Name Type Description Default input_raster_path str Input raster path required mask_layer_path str Path to the masking layer required output_path str Output layer path required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 def clip_raster_by_mask ( self , input_raster_path : str , mask_layer_path : str , output_path : str ) -> bool : \"\"\"Clip a given raster by the specified mask layer. :param input_raster_path: Input raster path :type input_raster_path: str :param mask_layer_path: Path to the masking layer :type mask_layer_path: str :param output_path: Output layer path :type output_path: str :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" raster_layer = QgsRasterLayer ( input_raster_path , \"raster_layer\" ) mask_layer = QgsVectorLayer ( mask_layer_path , \"mask_layer\" ) if not raster_layer . isValid (): self . log_message ( f \"Invalid raster layer: { input_raster_path } \\n \" ) return False if not mask_layer . isValid (): self . log_message ( f \"Invalid mask layer: { mask_layer_path } \\n \" ) return False try : alg_params = { \"INPUT\" : input_raster_path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : raster_layer . crs (), \"DESTINATION_CRS\" : raster_layer . crs (), \"OUTPUT\" : output_path , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"CROP_TO_CUTLINE\" : True , } self . log_message ( f \"Used parameters for clipping the raster: { input_raster_path } \" f \" using mask layer: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False result = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): return True except Exception as e : self . log_message ( f \"Problem clipping the layer { e } \\n \" ) return False","title":"clip_raster_by_mask"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.create_activity_connectivity_layer","text":"create_activity_connectivity_layer ( activity ) Create an activity connectivity layer for investability analysis Parameters: Name Type Description Default activity Activity Activity required Returns: Type Description str | None The path to the connectivity layer or None if the process failed Source code in src/cplus_plugin/tasks.py 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 def create_activity_connectivity_layer ( self , activity : Activity ): \"\"\"Create an activity connectivity layer for investability analysis :param activity: Activity :type activity: Activity :returns: The path to the connectivity layer or None if the process failed :rtype: str | None \"\"\" if not activity . path : self . log_message ( f \"Problem when creating the connectivity layer, \" f \"there is no map layer for the activity { activity . name } \" ) return None if not os . path . exists ( activity . path ): self . log_message ( f \"Problem when creating the connectivity layer, \" f \"the map layer for the activity { activity . name } does not exist\" ) return None self . set_status_message ( tr ( f \"Creating connectivity layer for the activity: { activity . name } \" ) ) output_directory = os . path . join ( self . scenario_directory , \"investable_activities\" ) FileUtils . create_new_dir ( output_directory ) output_path = os . path . join ( f \" { output_directory } \" , f \" { Path ( activity . path ) . stem } _connectivity_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) try : if self . processing_cancelled : return None self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) # 1. Creating a binary raster binary = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path ], \"CRS\" : None , \"EXPRESSION\" : f \" { Path ( activity . path ) . stem } @1 > 0\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # 2. Polygonize the binary to get polygon clusters binary_polygonize = processing . run ( \"gdal:polygonize\" , { \"INPUT\" : binary , \"BAND\" : 1 , \"FIELD\" : \"DN\" , \"EIGHT_CONNECTEDNESS\" : True , \"EXTRA\" : \"\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if self . processing_cancelled : return None # 3. Create a zonal statistics to find the number of pixels in each cluster zonal_statistics = processing . run ( \"native:zonalstatisticsfb\" , { \"INPUT\" : QgsProcessingFeatureSourceDefinition ( binary_polygonize , selectedFeaturesOnly = False , featureLimit =- 1 , flags = QgsProcessingFeatureSourceDefinition . Flag . FlagOverrideDefaultGeometryCheck | QgsProcessingFeatureSourceDefinition . Flag . FlagCreateIndividualOutputPerInputFeature , geometryCheck = QgsFeatureRequest . InvalidGeometryCheck . GeometryNoCheck , ), \"INPUT_RASTER\" : binary , \"RASTER_BAND\" : 1 , \"COLUMN_PREFIX\" : \"_\" , \"STATISTICS\" : [ 1 ], # sum \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # 4. Caculate connectivity score = count of pixels in cluster * compactness score = processing . run ( \"native:fieldcalculator\" , { \"INPUT\" : zonal_statistics , \"FIELD_NAME\" : \"score\" , \"FIELD_TYPE\" : 0 , \"FIELD_LENGTH\" : 0 , \"FIELD_PRECISION\" : 0 , \"FORMULA\" : '\"_sum\" * 4* pi() * $area /($perimeter * $perimeter)' , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if self . processing_cancelled : return None # 5. Rasterize the score vector processing . run ( \"gdal:rasterize_over\" , { \"INPUT\" : score , \"INPUT_RASTER\" : binary , \"FIELD\" : \"score\" , \"ADD\" : True , \"EXTRA\" : \"\" , }, context = self . processing_context , feedback = self . feedback , ) # 6. Normalize the raster ok , message = normalize_raster ( binary , output_path , self . processing_context , self . feedback ) self . log_message ( message ) if ok and os . path . exists ( output_path ): return output_path self . log_message ( f \" Error creating the connectivity layer for activity { activity . name } , \" ) return None except Exception as e : self . log_message ( f \"Problem creating connectivity layer for activity, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return None","title":"create_activity_connectivity_layer"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.finished","text":"finished ( result ) Calls the handler responsible for doing post analysis workflow. Parameters: Name Type Description Default result bool Whether the run() operation finished successfully required Source code in src/cplus_plugin/tasks.py 438 439 440 441 442 443 444 445 446 447 def finished ( self , result : bool ): \"\"\"Calls the handler responsible for doing post analysis workflow. :param result: Whether the run() operation finished successfully :type result: bool \"\"\" if result : self . log_message ( \"Finished from the main task \\n \" ) else : self . log_message ( f \"Error from task scenario task { self . error } \" )","title":"finished"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_activity","text":"get_activity ( activity_uuid ) Gets an activity object matching the given unique identifier. Parameters: Name Type Description Default activity_uuid str Unique identifier of the activity object. required Returns: Type Description Activity Returns the activity object matching the given identifier else None if not found. Source code in src/cplus_plugin/tasks.py 144 145 146 147 148 149 150 151 152 153 154 155 156 def get_activity ( self , activity_uuid ) -> typing . Union [ Activity , None ]: \"\"\"Gets an activity object matching the given unique identifier. :param activity_uuid: Unique identifier of the activity object. :type activity_uuid: str :returns: Returns the activity object matching the given identifier else None if not found. :rtype: Activity \"\"\" return settings_manager . get_activity ( activity_uuid )","title":"get_activity"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_masking_layers","text":"get_masking_layers () Gets all the masking layers. Returns: Type Description list List of masking layer paths Source code in src/cplus_plugin/tasks.py 166 167 168 169 170 171 172 173 174 175 176 177 def get_masking_layers ( self ) -> typing . List : \"\"\"Gets all the masking layers. :return: List of masking layer paths :rtype: list \"\"\" masking_layers_paths = self . get_settings_value ( Settings . MASK_LAYERS_PATHS , default = None ) masking_layers = masking_layers_paths . split ( \",\" ) if masking_layers_paths else [] masking_layers . remove ( \"\" ) if \"\" in masking_layers else None return masking_layers","title":"get_masking_layers"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_priority_layer","text":"get_priority_layer ( identifier ) Retrieves the priority layer that matches the passed identifier. Parameters: Name Type Description Default identifier UUID Priority layers identifier required Returns: Type Description dict Priority layer dict Source code in src/cplus_plugin/tasks.py 133 134 135 136 137 138 139 140 141 142 def get_priority_layer ( self , identifier ) -> typing . Dict : \"\"\"Retrieves the priority layer that matches the passed identifier. :param identifier: Priority layers identifier :type identifier: uuid.UUID :returns: Priority layer dict :rtype: dict \"\"\" return settings_manager . get_priority_layer ( identifier )","title":"get_priority_layer"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_priority_layers","text":"get_priority_layers () Gets all the available priority layers in the plugin. Returns: Type Description list Priority layers list Source code in src/cplus_plugin/tasks.py 158 159 160 161 162 163 164 def get_priority_layers ( self ) -> typing . List : \"\"\"Gets all the available priority layers in the plugin. :returns: Priority layers list :rtype: list \"\"\" return settings_manager . get_priority_layers ()","title":"get_priority_layers"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_reference_layer","text":"get_reference_layer () Get the path of the reference layer Returns: str|None: Return the path of the reference layer or None is it doesn't exist Source code in src/cplus_plugin/tasks.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def get_reference_layer ( self ): \"\"\"Get the path of the reference layer Returns: str|None: Return the path of the reference layer or None is it doesn't exist \"\"\" snapping_enabled = self . get_settings_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = self . get_settings_value ( Settings . SNAP_LAYER , default = \"\" ) reference_layer_path = Path ( reference_layer ) if ( snapping_enabled and os . path . exists ( reference_layer ) and reference_layer_path . is_file () ): return reference_layer","title":"get_reference_layer"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_scenario_directory","text":"get_scenario_directory () Generate scenario directory for current task. Returns: Type Description str Path to scenario directory Source code in src/cplus_plugin/tasks.py 121 122 123 124 125 126 127 128 129 130 131 def get_scenario_directory ( self ) -> str : \"\"\"Generate scenario directory for current task. :return: Path to scenario directory :rtype: str \"\"\" base_dir = self . get_settings_value ( Settings . BASE_DIR ) return os . path . join ( f \" { base_dir } \" , \"scenario_\" f ' { datetime . datetime . now () . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' , )","title":"get_scenario_directory"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.get_settings_value","text":"get_settings_value ( name , default = None , setting_type = None ) Gets value of the setting with the passed name. Parameters: Name Type Description Default name str Name of setting key required default Any Default value returned when the setting key does not exist None setting_type Any Type of the store setting None Returns: Type Description Any Value of the setting Source code in src/cplus_plugin/tasks.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def get_settings_value ( self , name : str , default = None , setting_type = None ): \"\"\"Gets value of the setting with the passed name. :param name: Name of setting key :type name: str :param default: Default value returned when the setting key does not exist :type default: Any :param setting_type: Type of the store setting :type setting_type: Any :returns: Value of the setting :rtype: Any \"\"\" return settings_manager . get_value ( name , default , setting_type )","title":"get_settings_value"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.layer_extent","text":"layer_extent ( extent ) Creates a new vector layer contains has a feature with geometry matching an extent parameter. Parameters: Name Type Description Default extent str Extent parameter required Returns: Type Description QgsVectorLayer Vector layer Source code in src/cplus_plugin/tasks.py 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 def layer_extent ( self , extent ): \"\"\"Creates a new vector layer contains has a feature with geometry matching an extent parameter. :param extent: Extent parameter :type extent: str :returns: Vector layer :rtype: QgsVectorLayer \"\"\" alg_params = { \"INPUT\" : extent , \"CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } results = processing . run ( \"native:extenttolayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ]","title":"layer_extent"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.log_message","text":"log_message ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/tasks.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 def log_message ( self , message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" if not isinstance ( message , str ): if isinstance ( message , dict ): message = json . dumps ( message , cls = CustomJsonEncoder ) else : message = json . dumps ( todict ( message ), cls = CustomJsonEncoder ) log ( message , name = name , info = info , notify = notify )","title":"log_message"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.mask_layer_difference","text":"mask_layer_difference ( input_layer , overlay_layer ) Creates a new vector layer that contains difference of features between the two passed layers. Parameters: Name Type Description Default input_layer QgsVectorLayer Input layer required overlay_layer QgsVectorLayer Target overlay layer required Returns: Type Description QgsVectorLayer Vector layer Source code in src/cplus_plugin/tasks.py 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 def mask_layer_difference ( self , input_layer , overlay_layer ): \"\"\"Creates a new vector layer that contains difference of features between the two passed layers. :param input_layer: Input layer :type input_layer: QgsVectorLayer :param overlay_layer: Target overlay layer :type overlay_layer: QgsVectorLayer :returns: Vector layer :rtype: QgsVectorLayer \"\"\" alg_params = { \"INPUT\" : input_layer , \"OVERLAY\" : overlay_layer , \"OVERLAY_FIELDS_PREFIX\" : \"\" , \"GRID_SIZE\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } results = processing . run ( \"native:symmetricaldifference\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ]","title":"mask_layer_difference"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.merge_vector_layers","text":"merge_vector_layers ( layers ) Merges the passed vector layers into a single layer Parameters: Name Type Description Default layers List [ str ] List of the vector layers paths required Returns: Type Description QgsMapLayer Merged vector layer Source code in src/cplus_plugin/tasks.py 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 def merge_vector_layers ( self , layers ): \"\"\"Merges the passed vector layers into a single layer :param layers: List of the vector layers paths :type layers: typing.List[str] :return: Merged vector layer :rtype: QgsMapLayer \"\"\" input_map_layers = [] for layer_path in layers : layer = QgsVectorLayer ( layer_path , \"mask\" , \"ogr\" ) if layer . isValid (): input_map_layers . append ( layer ) else : self . log_message ( f \"Skipping invalid mask layer { layer_path } from masking.\" ) if len ( input_map_layers ) == 0 : return None if len ( input_map_layers ) == 1 : return input_map_layers [ 0 ] . source () self . set_status_message ( tr ( \"Merging mask layers\" )) # Actual processing calculation alg_params = { \"LAYERS\" : input_map_layers , \"CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } self . log_message ( f \"Used parameters for merging mask layers: { alg_params } \\n \" ) results = processing . run ( \"native:mergevectorlayers\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ]","title":"merge_vector_layers"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.on_terminated","text":"on_terminated ( hide = False ) Called when the task is terminated. Source code in src/cplus_plugin/tasks.py 237 238 239 240 241 242 243 244 245 246 def on_terminated ( self , hide = False ): \"\"\"Called when the task is terminated.\"\"\" if hide : message = \"Processing has been minimized by the user.\" else : message = \"Processing has been cancelled by the user.\" if self . error : message = f \"Problem in running scenario analysis: { self . error } \" self . set_status_message ( tr ( message )) self . log_message ( message )","title":"on_terminated"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.replace_nodata","text":"replace_nodata ( layer_path , output_path , nodata_value =- 9999.0 ) Adds nodata value info into the layer available in the passed layer_path and saves the layer in the passed output_path. The addition will replace any current nodata value available in the input layer. Parameters: Name Type Description Default layer_path str Input layer path. Must be a valid file path to a raster layer. required output_path str Output layer path. Must be a valid file path where the modified raster will be saved. required nodata_value float No data value to be set in the output layer. Defaults to -9999.0 -9999.0 Returns: Type Description bool Whether the task operations were successful Source code in src/cplus_plugin/tasks.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 def replace_nodata ( self , layer_path : str , output_path : str , nodata_value : float = - 9999.0 ): \"\"\"Adds nodata value info into the layer available in the passed layer_path and saves the layer in the passed output_path. The addition will replace any current nodata value available in the input layer. :param layer_path: Input layer path. Must be a valid file path to a raster layer. :type layer_path: str :param output_path: Output layer path. Must be a valid file path where the modified raster will be saved. :type output_path: str :param nodata_value: No data value to be set in the output layer. Defaults to -9999.0 :type nodata_value: float :returns: Whether the task operations were successful :rtype: bool \"\"\" self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) try : alg_params = { \"COPY_SUBDATASETS\" : False , \"DATA_TYPE\" : 6 , # Float32 \"EXTRA\" : \"\" , \"INPUT\" : layer_path , \"NODATA\" : None , \"OPTIONS\" : \"\" , \"TARGET_CRS\" : None , \"OUTPUT\" : QgsProcessing . TEMPORARY_OUTPUT , } translate_output = processing . run ( \"gdal:translate\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) alg_params = { \"DATA_TYPE\" : 0 , # Use Input Layer Data Type \"EXTRA\" : \"\" , \"INPUT\" : translate_output [ \"OUTPUT\" ], \"MULTITHREADING\" : False , \"NODATA\" : nodata_value , \"OPTIONS\" : \"\" , \"RESAMPLING\" : 0 , # Nearest Neighbour \"SOURCE_CRS\" : None , \"TARGET_CRS\" : None , \"TARGET_EXTENT\" : None , \"TARGET_EXTENT_CRS\" : None , \"TARGET_RESOLUTION\" : None , \"OUTPUT\" : output_path , } outputs = processing . run ( \"gdal:warpreproject\" , alg_params , context = self . processing_context , feedback = self . feedback , is_child_algorithm = True , ) return outputs is not None except Exception as e : log ( f \"Problem replacing no data value from a snapping output, { e } \" ) return False","title":"replace_nodata"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.reproject_layer","text":"reproject_layer ( input_path , target_crs , output_directory = None , target_extent = None , is_raster = True ) Reprojects the input layer to the target CRS and saves it in the specified output directory. Parameters: Name Type Description Default input_path str Input layer path required target_crs QgsCoordinateReferenceSystem Target CRS to reproject the layer to required output_directory str Directory to save the reprojected layer, defaults to None None target_extent str Target extent, defaults to None None is_raster bool Check if layer is raster, defaults to True True Returns: Type Description str Path to the reprojected layer Source code in src/cplus_plugin/tasks.py 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 def reproject_layer ( self , input_path : str , target_crs : QgsCoordinateReferenceSystem , output_directory : str = None , target_extent : str = None , is_raster : bool = True , ) -> str : \"\"\"Reprojects the input layer to the target CRS and saves it in the specified output directory. :param input_path: Input layer path :type input_path: str :param target_crs: Target CRS to reproject the layer to :type target_crs: QgsCoordinateReferenceSystem :param output_directory: Directory to save the reprojected layer, defaults to None :type output_directory: str, optional :param target_extent: Target extent, defaults to None :type target_extent: str, optional :param is_raster: Check if layer is raster, defaults to True :type is_raster: bool, optional :returns: Path to the reprojected layer :rtype: str \"\"\" if self . processing_cancelled : return False if not os . path . exists ( input_path ): self . log_message ( f \"Input layer { input_path } does not exist, \" f \"skipping the layer reprojection.\" ) return None try : if output_directory is None : output_directory = Path ( input_path ) . parent ext = \"tif\" if is_raster else \"shp\" output_file = os . path . join ( output_directory , f \" { Path ( input_path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } . { ext } \" , ) alg_params = { \"INPUT\" : input_path , \"TARGET_CRS\" : target_crs , \"OUTPUT\" : output_file , } if target_extent is not None and target_extent != \"\" : alg_params [ \"TARGET_EXTENT\" ] = target_extent self . log_message ( f \"Used parameters for layer reprojection: \" f \" { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return None results = processing . run ( \"gdal:warpreproject\" if is_raster else \"native:reprojectlayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem reprojecting layer, { e } \\n \" ) return None","title":"reproject_layer"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.reproject_pathways","text":"reproject_pathways ( target_crs , target_extent = None ) Reprojects the activity pathways and priority layers to the target CRS. Parameters: Name Type Description Default target_crs QgsCoordinateReferenceSystem Target CRS to reproject the layers to required target_extent str Target extent, defaults to None None Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 def reproject_pathways ( self , target_crs : QgsCoordinateReferenceSystem , target_extent : str = None , ): \"\"\" Reprojects the activity pathways and priority layers to the target CRS. :param target_crs: Target CRS to reproject the layers to :type target_crs: QgsCoordinateReferenceSystem :param target_extent: Target extent, defaults to None :type target_extent: str, optional :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False if target_crs is None or not target_crs . isValid (): self . set_info_message ( tr ( \"Invalid target CRS for reprojecting pathways.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( \"Invalid target CRS for reprojecting pathways.\" ) return False self . set_status_message ( tr ( \"Reprojecting the activity pathways and priority layers\" ) ) pathways : typing . List [ NcsPathway ] = [] try : # Create directories for storing reprojected pathways and priority layers reprojected_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"reprojected\" ) FileUtils . create_new_dir ( reprojected_pathways_directory ) reprojected_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"reprojected\" ) FileUtils . create_new_dir ( reprojected_priority_directory ) for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or a \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Reproject priority layers # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping layer reprojection.\" ) continue if layer . crs () == target_crs : self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } \" f \"is already in the target CRS \" f \" { target_crs . authid () } , skipping layer reprojection.\" ) continue output_path = self . reproject_layer ( priority_layer_path , target_crs , reprojected_priority_directory , target_extent , ) if output_path : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_path if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping layer reprojection.\" ) continue if pathway_layer . crs () == target_crs : self . log_message ( f \"Pathway layer { pathway . name } is already in the target CRS \" f \" { target_crs . authid () } , skipping layer reprojection.\" ) else : self . log_message ( f \"Reprojecting { pathway . name } pathway layer to { target_crs . authid () } \\n \" ) output_path = self . reproject_layer ( pathway . path , target_crs , reprojected_pathways_directory , target_extent , ) if output_path : pathway . path = output_path self . log_message ( f \"Reprojecting { len ( pathway . priority_layers ) } \" f \"priority weighting layers from pathway { pathway . name } \\n \" ) if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem reprojecting layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"reproject_pathways"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run","text":"run () Runs the main scenario analysis task operations Source code in src/cplus_plugin/tasks.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def run ( self ): \"\"\"Runs the main scenario analysis task operations\"\"\" try : self . scenario_directory = self . get_scenario_directory () FileUtils . create_new_dir ( self . scenario_directory ) selected_pathway = None pathway_found = False for activity in self . analysis_activities : if pathway_found : break for pathway in activity . pathways : if pathway is not None : pathway_found = True selected_pathway = pathway break target_layer = QgsRasterLayer ( selected_pathway . path , selected_pathway . name ) self . analysis_crs = self . analysis_extent . crs if self . analysis_crs is not None : # Use the CRS of the analysis if it is provided dest_crs = QgsCoordinateReferenceSystem ( self . analysis_crs ) else : # Use the CRS of the target layer if it exists # or use EPSG:4326 as a default CRS dest_crs = ( target_layer . crs () if selected_pathway and selected_pathway . path else QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) ) processing_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) snapped_extent = self . align_extent ( target_layer , processing_extent ) extent_string = ( f \" { snapped_extent . xMinimum () } , { snapped_extent . xMaximum () } ,\" f \" { snapped_extent . yMinimum () } , { snapped_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) self . log_message ( \"Original area of interest extent: \" f \" { processing_extent . asWktPolygon () } \\n \" ) self . log_message ( \"Snapped area of interest extent \" f \" { snapped_extent . asWktPolygon () } \\n \" ) # Run pathways layers snapping using a specified reference layer snapping_enabled = self . get_settings_value ( Settings . SNAPPING_ENABLED , default = False , setting_type = bool ) reference_layer = self . get_reference_layer () if snapping_enabled and reference_layer : self . snap_analysis_data ( self . analysis_activities , extent_string , ) # Clip to StudyArea if self . clip_to_studyarea and os . path . exists ( self . studyarea_path ): # Reproject the study area to the EPSG:4326 # The validate_vector_layer is successful when the layer is in EPSG:4326 studyarea_path = self . reproject_layer ( input_path = self . studyarea_path , target_crs = QgsCoordinateReferenceSystem ( \"EPSG:4326\" ), is_raster = False , ) # Validate layer geometries validated_path = self . validate_vector_layer ( studyarea_path ) if not validated_path : self . log_message ( f \"Invalid studyarea layer: { studyarea_path } \" ) else : self . studyarea_path = validated_path self . clip_analysis_data ( self . studyarea_path ) # Reproject the pathways and priority layers to the # scenario CRS if it is not the same as the pathways CRS if self . analysis_crs is not None : self . reproject_pathways ( target_extent = extent_string , target_crs = QgsCoordinateReferenceSystem ( self . analysis_crs ), ) # Replace no data value for the pathways and priority layers nodata_value = float ( self . get_settings_value ( Settings . NCS_NO_DATA_VALUE , default = NO_DATA_VALUE , setting_type = float , ) ) self . log_message ( f \"Replacing nodata value for the pathways and priority layers to { nodata_value } \" ) self . run_pathways_replace_nodata ( nodata_value = nodata_value ) # Calculate total carbon mitigation values for the Naturebase pathways self . run_pathways_carbon_summation () # Weight the pathways using the pathway suitability index # and priority group coefficients for the PWLs save_output = self . get_settings_value ( Settings . NCS_WEIGHTED , default = True , setting_type = bool ) self . run_pathways_weighting ( self . analysis_activities , self . analysis_priority_layers_groups , extent_string , temporary_output = not save_output , ) # Creating activities from the weighted pathways save_output = self . get_settings_value ( Settings . LANDUSE_PROJECT , default = True , setting_type = bool ) self . run_activities_analysis ( self . analysis_activities , extent_string , temporary_output = not save_output , ) # Normalize the activities. # This is useful when weighting pathways with relative impact matrix # Activities created in previous step may have values greater than 1 self . run_activity_normalization () # Run masking of the activities layers masking_layers = self . get_masking_layers () if masking_layers : self . run_activities_masking ( self . analysis_activities , masking_layers , extent_string , ) # Run internal masking of the activities layers self . run_internal_activities_masking ( self . analysis_activities , extent_string , ) # Run sieve if enabled sieve_enabled = self . get_settings_value ( Settings . SIEVE_ENABLED , default = False , setting_type = bool ) if sieve_enabled : self . run_activities_sieve ( self . analysis_activities , ) # After creating activities, we normalize them using the # suitability index save_output = self . get_settings_value ( Settings . LANDUSE_NORMALIZED , default = True , setting_type = bool ) # Clean up activities self . run_activities_cleaning ( self . analysis_activities , extent_string , temporary_output = not save_output , ) # Investability analysis self . run_investability_analysis () # The highest position tool analysis save_output = self . get_settings_value ( Settings . HIGHEST_POSITION , default = True , setting_type = bool ) self . run_highest_position_analysis ( temporary_output = not save_output ) return True except Exception as e : self . log_message ( f \"Analysis failed with error { e } \" ) self . log_message ( traceback . format_exc ()) return False","title":"run"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_activities_analysis","text":"run_activities_analysis ( activities , extent , temporary_output = False ) Runs the required activity analysis on the passed activities pathways. The analysis is responsible for creating activities layers from their respective pathways layers. Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent SpatialExtent selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 def run_activities_analysis ( self , activities , extent , temporary_output = False ): \"\"\"Runs the required activity analysis on the passed activities pathways. The analysis is responsible for creating activities layers from their respective pathways layers. :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: selected extent from user :type extent: SpatialExtent :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Creating activity layers from pathways\" )) try : for activity in activities : activities_directory = os . path . join ( self . scenario_directory , \"activities\" ) FileUtils . create_new_dir ( activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) layers = [] if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or an \" f \"activity layer for the activity { activity . name } \" ) return False output_file = os . path . join ( activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) # Due to the activities base class # activity only one of the following blocks will be executed, # the activity either contain a path or # pathways if activity . path is not None and activity . path != \"\" : layers = [ activity . path ] for pathway in activity . pathways : layers . append ( pathway . path ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) reference_layer = self . get_reference_layer () if ( reference_layer is None or reference_layer == \"\" ) and len ( layers ) > 0 : reference_layer = layers [ 0 ] # Actual processing calculation alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"REFERENCE_LAYER\" : reference_layer , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output , } self . log_message ( f \"Used parameters for \" f \"activities generation: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem creating activity layers, { e } \" ) self . cancel_task ( e ) return False return True","title":"run_activities_analysis"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_activities_cleaning","text":"run_activities_cleaning ( activities , extent = None , temporary_output = False ) Cleans the weighted activities replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. Parameters: Name Type Description Default activities List [ Activity ] Activities to be cleaned up. required extent str Selected extent from user None temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 def run_activities_cleaning ( self , activities , extent = None , temporary_output = False ): \"\"\"Cleans the weighted activities replacing zero values with no-data as they are not statistical meaningful for the scenario analysis. :param activities: Activities to be cleaned up. :type activities: typing.List[Activity] :param extent: Selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Updating activity values\" )) try : for activity in activities : if activity . path is None or activity . path == \"\" : self . set_info_message ( tr ( f \"Problem when running activity updates, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when running activity updates, \" f \"there is no map layer for the activity { activity . name } \" ) return False layers = [ activity . path ] file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) weighted_pathways_dir = os . path . join ( self . scenario_directory , \"weighted_pathways\" ) FileUtils . create_new_dir ( weighted_pathways_dir ) output_file = os . path . join ( weighted_pathways_dir , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } _cleaned.tif\" , ) # Actual processing calculation # The aim is to convert pixels values to no data, that is why we are # using the sum operation with only one layer. output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT\" : layers , \"EXTENT\" : extent , \"OUTPUT_NODATA_VALUE\" : 0 , \"REFERENCE_LAYER\" : layers [ 0 ] if len ( layers ) > 0 else None , \"STATISTIC\" : 0 , # Sum \"OUTPUT\" : output , } self . log_message ( f \"Used parameters for \" f \"updates on the cleaned activities: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"native:cellstatistics\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem cleaning activities, { e } \" ) self . cancel_task ( e ) return False return True","title":"run_activities_cleaning"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_activities_masking","text":"run_activities_masking ( activities , masking_layers , extent , temporary_output = False ) Applies the mask layers into the passed activities Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required masking_layers dict Paths to the mask layers to be used required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 def run_activities_masking ( self , activities , masking_layers , extent , temporary_output = False ): \"\"\"Applies the mask layers into the passed activities :param activities: List of the selected activities :type activities: typing.List[Activity] :param masking_layers: Paths to the mask layers to be used :type masking_layers: dict :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Masking activities using the saved masked layers\" )) try : if len ( masking_layers ) < 1 : return False if len ( masking_layers ) > 1 : initial_mask_layer = self . merge_vector_layers ( masking_layers ) else : mask_layer_path = masking_layers [ 0 ] initial_mask_layer = QgsVectorLayer ( mask_layer_path , \"mask\" , \"ogr\" ) if not initial_mask_layer . isValid (): self . log_message ( f \"Skipping activities masking \" f \"using layer { mask_layer_path } , not a valid layer.\" ) return False # see https://qgis.org/pyqgis/master/core/Qgis.html#qgis.core.Qgis.GeometryType if Qgis . versionInt () < 33000 : layer_check = ( initial_mask_layer . geometryType () == QgsWkbTypes . GeometryType . PolygonGeometry ) else : layer_check = ( initial_mask_layer . geometryType () == Qgis . GeometryType . Polygon ) if not layer_check : self . log_message ( f \"Skipping activities masking \" f \"using layer { mask_layer_path } , not a polygon layer.\" ) return False extent_layer = self . layer_extent ( extent ) mask_layer = self . mask_layer_difference ( initial_mask_layer , extent_layer ) if isinstance ( mask_layer , str ): mask_layer = QgsVectorLayer ( mask_layer , \"ogr\" ) if not mask_layer . isValid (): self . log_message ( f \"Skipping activities masking \" f \"the created difference mask layer { mask_layer . source () } ,\" f \" not a valid layer.\" ) return False for activity in activities : if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when masking activities, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when masking activities, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) return False masked_activities_directory = os . path . join ( self . scenario_directory , \"masked_activities\" ) FileUtils . create_new_dir ( masked_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( masked_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) activity_layer = QgsRasterLayer ( activity . path , \"activity_layer\" ) if activity_layer . crs () != mask_layer . crs (): self . log_message ( f \"Skipping masking, activity layer and\" f \" mask layer(s) have different CRS\" ) continue if not activity_layer . extent () . intersects ( mask_layer . extent ()): self . log_message ( \"Skipping masking, the extents of the activity layer \" \"and mask layer(s) do not overlap.\" ) continue # Actual processing calculation alg_params = { \"INPUT\" : activity . path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : activity_layer . crs (), \"DESTINATION_CRS\" : activity_layer . crs (), \"TARGET_EXTENT\" : extent , \"OUTPUT\" : output , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), } self . log_message ( f \"Used parameters for masking activity { activity . name } \" f \"using project mask layers: { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem masking activities layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_activities_masking"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_activities_sieve","text":"run_activities_sieve ( activities , temporary_output = False ) Runs the sieve functionality analysis on the passed activities layers, removing the activities layer polygons that are smaller than the provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbour polygon. Parameters: Name Type Description Default activities List [ Activity ] List of the analyzed activities. required extent str Selected area of interest extent required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 def run_activities_sieve ( self , activities , temporary_output = False ): \"\"\"Runs the sieve functionality analysis on the passed activities layers, removing the activities layer polygons that are smaller than the provided threshold size (in pixels) and replaces them with the pixel value of the largest neighbour polygon. :param activities: List of the analyzed activities. :type activities: typing.List[Activity] :param extent: Selected area of interest extent :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Applying sieve function to the activities\" )) try : for activity in activities : if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when running sieve function on activities, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when running sieve function on activities, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) return False sieved_activities_directory = os . path . join ( self . scenario_directory , \"sieved_activities\" ) FileUtils . create_new_dir ( sieved_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( sieved_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) threshold_value = float ( self . get_settings_value ( Settings . SIEVE_THRESHOLD , default = 10 ) ) mask_layer = self . get_settings_value ( Settings . SIEVE_MASK_PATH , default = \"\" ) no_mask = not ( mask_layer and os . path . exists ( mask_layer )) mask_layer_ref = mask_layer if not no_mask else None output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) input_name = os . path . splitext ( os . path . basename ( activity . path ))[ 0 ] # Step 1: Create a binary mask from the original raster binary_mask = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path ], \"CRS\" : None , \"EXPRESSION\" : f \" { input_name } @1 > 0\" , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, )[ \"OUTPUT\" ] sieve_alg_params = { \"INPUT\" : binary_mask , \"THRESHOLD\" : threshold_value , \"EIGHT_CONNECTEDNESS\" : True , \"NO_MASK\" : no_mask , \"MASK_LAYER\" : mask_layer_ref , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , } self . log_message ( f \"Used parameters for sieving: { sieve_alg_params } \\n \" ) # Step 2: Run sieve analysis from the output of the binary mask sieved_mask = processing . run ( \"gdal:sieve\" , sieve_alg_params , context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] expr = f \"( { os . path . splitext ( os . path . basename ( sieved_mask ))[ 0 ] } @1 > 0) * { os . path . splitext ( os . path . basename ( sieved_mask ))[ 0 ] } @1\" # Step 3: Remove and convert any no data value to 0 sieved_mask_clean = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ sieved_mask ], \"CRS\" : None , \"EXPRESSION\" : expr , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] expr_2 = f \" { input_name } @1 * { os . path . splitext ( os . path . basename ( sieved_mask_clean ))[ 0 ] } @1\" # Step 4: Join the sieved mask with the original input layer to filter out the small areas sieve_output = processing . run ( \"qgis:rastercalculator\" , { \"CELLSIZE\" : 0 , \"LAYERS\" : [ activity . path , sieved_mask_clean ], \"CRS\" : None , \"EXPRESSION\" : expr_2 , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] # Step 5. Replace all 0 with NO_DATA_VALUE using if # (\"combined@1\" <= 0, NO_DATA_VALUE, \"combined@1\") no_data_replace_exp = ( f \"(A > 0)*A + (A <= 0)* { float ( self . no_data_value ) } \" ) sieve_output_updated = processing . run ( \"gdal:rastercalculator\" , { \"INPUT_A\" : f \" { sieve_output } \" , \"BAND_A\" : 1 , \"FORMULA\" : no_data_replace_exp , \"NO_DATA\" : None , \"EXTENT_OPT\" : 0 , \"RTYPE\" : 5 , \"OUTPUT\" : \"TEMPORARY_OUTPUT\" , }, context = self . processing_context , feedback = self . feedback , )[ \"OUTPUT\" ] if not os . path . exists ( sieve_output_updated ): self . log_message ( f \"Problem running sieve function \" f \"on activity layers, sieve intermediate layer not found\" f \" \\n \" ) self . cancel_task () return False self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False # Step 6. Run sum statistics with ignore no data values set to false # and no data value results = processing . run ( \"native:cellstatistics\" , { \"INPUT\" : [ sieve_output_updated ], \"STATISTIC\" : 0 , \"IGNORE_NODATA\" : False , \"REFERENCE_LAYER\" : sieve_output_updated , \"OUTPUT_NODATA_VALUE\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), \"OUTPUT\" : output , }, context = self . processing_context , feedback = self . feedback , ) feedback = QgsProcessingFeedback () feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem running sieve function on activity layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_activities_sieve"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_activity_normalization","text":"run_activity_normalization () Runs normalization analysis on the activities. The formula is: (activity - min) / (max - min) Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 def run_activity_normalization ( self , ) -> bool : \"\"\"Runs normalization analysis on the activities. The formula is: (activity - min) / (max - min) :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Normalization of activities\" )) normalized_activities_directory = os . path . join ( self . scenario_directory , \"normalized_activities\" ) FileUtils . create_new_dir ( normalized_activities_directory ) try : for activity in self . analysis_activities : if not activity . path : msg = f \"No defined activity layer for the activity { activity . name } \" self . set_info_message ( tr ( msg ), level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False if self . processing_cancelled : return False activity_layer = QgsRasterLayer ( activity . path , activity . name ) if not activity_layer . isValid (): self . log_message ( f \"Activity layer { activity . name } is not valid, \" f \"skipping the layer from normalization.\" ) continue provider = activity_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue if min_value is None or max_value is None : self . log_message ( f \"Activity layer { activity . name } has no valid \" f \"statistics, skipping the layer from normalization.\" ) continue if min_value == 0 and max_value == 1 : new_path = FileUtils . copy_file ( activity . path , normalized_activities_directory ) if new_path and os . path . exists ( new_path ): activity . path = new_path self . log_message ( f \"Activity layer { activity . name } is already normalized (min= { min_value } , max= { max_value } ), \" f \"skipping the layer from normalization.\" ) continue self . log_message ( f \"Normalizing { activity . name } activity layer \\n \" ) expression = f \"(A - { min_value } ) / ( { max_value } - { min_value } )\" output_path = os . path . join ( f \" { normalized_activities_directory } \" , f \" { Path ( activity . path ) . stem } _norm_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) alg_params = { \"INPUT_A\" : activity . path , \"BAND_A\" : 1 , \"FORMULA\" : expression , \"OPTIONS\" : \"COMPRESS=DEFLATE|ZLEVEL=6|TILED=YES\" , # Compress the layer \"OUTPUT\" : output_path , } self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False result = processing . run ( \"gdal:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): activity . path = result . get ( \"OUTPUT\" ) else : self . log_message ( f \"Problem normalizing activity layer { activity . name } , \" f \"skipping the layer from normalization.\" ) return True except Exception as e : self . log_message ( f \"Problem normalizing activities, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False","title":"run_activity_normalization"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_highest_position_analysis","text":"run_highest_position_analysis ( temporary_output = False ) Runs the highest position analysis which is last step in scenario analysis. Uses the activities set by the current ongoing analysis. Parameters: Name Type Description Default temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 def run_highest_position_analysis ( self , temporary_output = False ): \"\"\"Runs the highest position analysis which is last step in scenario analysis. Uses the activities set by the current ongoing analysis. :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False passed_extent_box = self . analysis_extent . bbox passed_extent = QgsRectangle ( passed_extent_box [ 0 ], passed_extent_box [ 2 ], passed_extent_box [ 1 ], passed_extent_box [ 3 ], ) # We explicitly set the created_date since the current implementation # of the data model means that the attribute value is set only once when # the class is loaded hence subsequent instances will have the same value. self . scenario_result = ScenarioResult ( scenario = self . scenario , scenario_directory = self . scenario_directory , created_date = datetime . datetime . now (), ) try : layers = {} self . set_status_message ( tr ( \"Calculating the highest position\" )) for activity in self . analysis_activities : if activity . path is not None and activity . path != \"\" : raster_layer = QgsRasterLayer ( activity . path , activity . name ) layers [ activity . name ] = ( raster_layer if raster_layer is not None else None ) else : for pathway in activity . pathways : layers [ activity . name ] = QgsRasterLayer ( pathway . path ) source_crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) dest_crs = list ( layers . values ())[ 0 ] . crs () if len ( layers ) > 0 else source_crs extent_string = ( f \" { passed_extent . xMinimum () } , { passed_extent . xMaximum () } ,\" f \" { passed_extent . yMinimum () } , { passed_extent . yMaximum () } \" f \" [ { dest_crs . authid () } ]\" ) output_file = os . path . join ( self . scenario_directory , f \" { SCENARIO_OUTPUT_FILE_NAME } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) # Preparing the input rasters for the highest position # analysis in a correct order activity_names = [ activity . name for activity in self . analysis_activities ] all_activities = sorted ( self . analysis_activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 all_activity_names = [ activity . name for activity in all_activities ] sources = [] for activity_name in all_activity_names : if activity_name in activity_names : sources . append ( layers [ activity_name ] . source ()) self . log_message ( f \"Layers sources { [ Path ( source ) . stem for source in sources ] } \" ) output_file = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) alg_params = { \"IGNORE_NODATA\" : True , \"INPUT_RASTERS\" : sources , \"EXTENT\" : extent_string , \"OUTPUT_NODATA_VALUE\" : self . no_data_value , \"REFERENCE_LAYER\" : ( list ( layers . values ())[ 0 ] if len ( layers ) >= 1 else None ), \"OUTPUT\" : output_file , } self . log_message ( f \"Used parameters for highest position analysis { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False self . output = processing . run ( \"native:highestpositioninrasterstack\" , alg_params , context = self . processing_context , feedback = self . feedback , ) except Exception as err : self . log_message ( tr ( \"An error occurred when running task for \" 'scenario analysis, error message \" {} \"' . format ( str ( err )) ) ) self . cancel_task ( err ) return False return True","title":"run_highest_position_analysis"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_internal_activities_masking","text":"run_internal_activities_masking ( activities , extent , temporary_output = False ) Applies the mask layers into the passed activities Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool Whether the task operations was successful Source code in src/cplus_plugin/tasks.py 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 def run_internal_activities_masking ( self , activities , extent , temporary_output = False ): \"\"\"Applies the mask layers into the passed activities :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: Whether the task operations was successful :rtype: bool \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Masking activities using their respective mask layers.\" ) ) try : for activity in activities : masking_layers = activity . mask_paths if len ( masking_layers ) < 1 : self . log_message ( f \"Skipping activity masking \" f \"No mask layer(s) for activity { activity . name } \" ) continue if len ( masking_layers ) > 1 : initial_mask_layer = self . merge_vector_layers ( masking_layers ) else : mask_layer_path = masking_layers [ 0 ] initial_mask_layer = QgsVectorLayer ( mask_layer_path , \"mask\" , \"ogr\" ) if not initial_mask_layer . isValid (): self . log_message ( f \"Skipping activity masking \" f \"using layer { mask_layer_path } , not a valid layer.\" ) continue # see https://qgis.org/pyqgis/master/core/Qgis.html#qgis.core.Qgis.GeometryType if Qgis . versionInt () < 33000 : layer_check = ( initial_mask_layer . geometryType () == QgsWkbTypes . GeometryType . PolygonGeometry ) else : layer_check = ( initial_mask_layer . geometryType () == Qgis . GeometryType . Polygon ) if not layer_check : self . log_message ( f \"Skipping activity masking \" f \"using layer { mask_layer_path } , not a polygon layer.\" ) continue extent_layer = self . layer_extent ( extent ) if extent_layer . crs () != initial_mask_layer . crs (): self . log_message ( \"Skipping masking, the mask layers crs\" \" do not match the scenario crs.\" ) continue if not extent_layer . extent () . intersects ( initial_mask_layer . extent ()): self . log_message ( \"Skipping masking, the mask layers extent\" \" and the scenario extent do not overlap.\" ) continue mask_layer = self . mask_layer_difference ( initial_mask_layer , extent_layer ) if isinstance ( mask_layer , str ): mask_layer = QgsVectorLayer ( mask_layer , \"ogr\" ) if not mask_layer . isValid (): self . log_message ( f \"Skipping activity masking \" f \"the created difference mask layer { mask_layer . source () } ,\" f \"is not a valid layer.\" ) continue if activity . path is None or activity . path == \"\" : if not self . processing_cancelled : self . set_info_message ( tr ( f \"Problem when masking activity, \" f \"there is no map layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Problem when masking activity, \" f \"there is no map layer for the activity { activity . name } \" ) else : # If the user cancelled the processing self . set_info_message ( tr ( f \"Processing has been cancelled by the user.\" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"Processing has been cancelled by the user.\" ) continue masked_activities_directory = os . path . join ( self . scenario_directory , \"final_masked_activities\" ) FileUtils . create_new_dir ( masked_activities_directory ) file_name = clean_filename ( activity . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( masked_activities_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) output = ( QgsProcessing . TEMPORARY_OUTPUT if temporary_output else output_file ) activity_layer = QgsRasterLayer ( activity . path , \"activity_layer\" ) if activity_layer . crs () != mask_layer . crs (): self . log_message ( f \"Skipping masking, activity layer and\" f \" mask layer(s) have different CRS\" ) continue if not activity_layer . extent () . intersects ( mask_layer . extent ()): self . log_message ( \"Skipping masking, the extents of the activity layer \" \"and mask layers do not overlap.\" ) continue # Actual processing calculation alg_params = { \"INPUT\" : activity . path , \"MASK\" : mask_layer , \"SOURCE_CRS\" : activity_layer . crs (), \"DESTINATION_CRS\" : activity_layer . crs (), \"TARGET_EXTENT\" : extent , \"OUTPUT\" : output , \"NO_DATA\" : settings_manager . get_value ( Settings . NCS_NO_DATA_VALUE , NO_DATA_VALUE ), } self . log_message ( f \"Used parameters for masking the activity { activity . name } \" f \" using activity respective mask layer(s): { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"gdal:cliprasterbymasklayer\" , alg_params , context = self . processing_context , feedback = self . feedback , ) activity . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem masking activities layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_internal_activities_masking"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_investability_analysis","text":"run_investability_analysis () Run activity investability analysis Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 def run_investability_analysis ( self ) -> bool : \"\"\"Run activity investability analysis :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Calculating investability of the activities\" )) investable_activities = os . path . join ( self . scenario_directory , \"investable_activities\" ) FileUtils . create_new_dir ( investable_activities ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) try : for activity in self . analysis_activities : if activity . path is None or activity . path == \"\" : self . log_message ( f \"Problem when running activity investability, \" f \"there is no map layer for the activity { activity . name } \" ) return False if not os . path . exists ( activity . path ): self . log_message ( f \"Problem when running activity investability, \" f \"the map layer for the activity { activity . name } does not exist\" ) return False layers = [ activity . path ] activity_basename = Path ( activity . path ) . stem expression_items = [ f '(\" { activity_basename } @1\")' ] constant_raster_components = ( constant_raster_registry . activity_components ( activity_identifier = str ( activity . uuid ) ) ) # Serialize the constant rasters constant_rasters = [ { \"name\" : component . base_name , \"uuid\" : component . component_id , \"absolute\" : component . value_info . absolute , \"normalized\" : component . value_info . normalized , \"path\" : component . path , \"skip_raster\" : ( component . skip_raster if os . path . exists ( component . path ) else True ), } for component in constant_raster_components ] if constant_rasters is None : constant_rasters = [] if self . processing_cancelled : return False if self . get_settings_value ( Settings . PIXEL_CONNECTIVITY_ENABLED , default = True , setting_type = bool ): # Add connectivity layer connectivity_path = self . create_activity_connectivity_layer ( activity = activity ) if connectivity_path and os . path . exists ( connectivity_path ): constant_rasters . append ( { \"path\" : connectivity_path , \"name\" : \"Connectivity layer\" , \"skip_raster\" : False , } ) else : self . log_message ( f \"Invalid path for connectivity layer of activity { activity . name } \" ) nr_constant_rasters = len ( constant_rasters ) if nr_constant_rasters == 0 : self . log_message ( f \"No defined constant rasters, \" f \"Skipping investability analysis for the activity { activity . name } \" ) continue for constant_raster in constant_rasters : if \"normalized\" in constant_raster : expression_items . append ( str ( constant_raster . get ( \"normalized\" ) / nr_constant_rasters ) ) else : path = constant_raster . get ( \"path\" , \"\" ) if not os . path . exists ( path ): self . log_message ( f \"Invalid constant raster path { path } ,\" f \"Skipping from the investability analysis for the activity { activity . name } \" ) continue normalized_path = os . path . join ( f \" { investable_activities } \" , f \" { Path ( path ) . stem } _norm_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) if self . processing_cancelled : return False ok , log = normalize_raster ( input_raster_path = path , output_raster_path = normalized_path , processing_context = self . processing_context , feedback = self . feedback , ) self . log_message ( log ) if not ok : self . log_message ( f \"Skipping { path } from the investability analysis for the activity { activity . name } \" ) continue if os . path . exists ( normalized_path ): path = normalized_path layers . append ( path ) expression_items . append ( f '(\" { Path ( path ) . stem } @1\" / { nr_constant_rasters } )' ) output_path = os . path . join ( f \" { investable_activities } \" , f \" { Path ( activity . path ) . stem } _invest_ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : \" + \" . join ( expression_items ), \"LAYERS\" : layers , \"OUTPUT\" : output_path , } self . log_message ( f \" Used parameters for calculating investability for activity { activity . name } , \" f \" { alg_params } \\n \" ) if self . processing_cancelled : return False result = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) if result . get ( \"OUTPUT\" ): activity . path = result . get ( \"OUTPUT\" ) else : self . log_message ( f \"Problem calculating investability for activity { activity . name } \" ) except Exception as e : self . log_message ( f \"Problem calculating activity investability, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False return True","title":"run_investability_analysis"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_normalize_pathways_carbon_impact","text":"run_normalize_pathways_carbon_impact ( pathways ) Normalizes the total carbon impact for the pathways grouped by the pathway type Parameters: Name Type Description Default pathways List [ NcsPathway ] List of the pathways required Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 def run_normalize_pathways_carbon_impact ( self , pathways : typing . List [ NcsPathway ] ) -> bool : \"\"\"Normalizes the total carbon impact for the pathways grouped by the pathway type :param pathways: List of the pathways :type pathways: typing.List[NcsPathway] :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . log_message ( tr ( f \"Normalizing Total Carbon Impact for Pathways\" )) if len ( pathways ) == 0 : msg = tr ( f \"No defined pathways for running normalize total carbon impact.\" ) self . set_info_message ( msg , level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False try : pathways_carbon_value = [ p . type_options . get ( \"carbon_impact\" , 0 ) for p in pathways if p . pathway_type in ( NcsPathwayType . MANAGE , NcsPathwayType . RESTORE ) ] pathways_carbon_value = [ v for v in pathways_carbon_value if v is not None ] if len ( pathways_carbon_value ) == 0 : self . log_message ( \"No manage or restore pathways\" ) return False # Calculate min/max for each pathway type carbon_stats = { \"min\" : min ( pathways_carbon_value ), \"max\" : max ( pathways_carbon_value ), \"range\" : max ( pathways_carbon_value ) - min ( pathways_carbon_value ), } # Normalize carbon impact for each pathway for pathway in pathways : # Ignore protect pathways if pathway . pathway_type not in ( NcsPathwayType . MANAGE , NcsPathwayType . RESTORE , ): continue carbon_impact = pathway . type_options . get ( \"carbon_impact\" ) if carbon_impact is None : continue if carbon_stats [ \"range\" ] == 0 : # All values are the same carbon impact norm_carbon_impact = 1 / len ( pathways_carbon_value ) else : norm_carbon_impact = ( carbon_impact - carbon_stats [ \"min\" ] ) / carbon_stats [ \"range\" ] pathway . type_options . update ({ \"norm_carbon_impact\" : norm_carbon_impact }) return True except Exception as e : self . log_message ( f \"Problem normalizing pathways carbon impact, { e } \\n \" ) self . cancel_task ( e ) return False","title":"run_normalize_pathways_carbon_impact"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_pathways_carbon_summation","text":"run_pathways_carbon_summation () Calculates total carbon mitigation values for the Naturebase pathways. Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 def run_pathways_carbon_summation ( self ) -> bool : \"\"\"Calculates total carbon mitigation values for the Naturebase pathways. :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Calculating total carbon mitigation values for the Naturebase pathways\" ) ) pathways : typing . List [ NcsPathway ] = [] try : for activity in self . analysis_activities : if not activity . pathways and not activity . path : msg = f \"\"\"No defined activity pathways or activity layers for the activity { activity . name } \"\"\" self . log_message ( msg ) return False for pathway in activity . pathways : if ( pathway . name . startswith ( \"Naturebase:\" ) and pathway not in pathways ): pathways . append ( pathway ) if len ( pathways ) == 0 : self . log_message ( \"No Naturebase pathways found in any activity.\" ) return False for pathway in pathways : if self . processing_cancelled : return False pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping calculating total carbon value for layer.\" ) continue raster_provider = pathway_layer . dataProvider () stats = raster_provider . bandStatistics ( 1 , QgsRasterBandStats . Stats . Sum ) if stats is None or stats . sum is None : self . log_message ( f \"Could not calculate statistics for { pathway . name } , skipping.\" ) continue pathway . carbon_impact_value = stats . sum except Exception as e : self . log_message ( f \"Problem calculating total carbon values for layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_pathways_carbon_summation"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_pathways_replace_nodata","text":"run_pathways_replace_nodata ( nodata_value =- 9999.0 ) Replace the nodata value for activity pathways and priority layers. Parameters: Name Type Description Default nodata_value float The nodata value to replace in the pathways and priority layers -9999.0 Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 def run_pathways_replace_nodata ( self , nodata_value : float = - 9999.0 ) -> bool : \"\"\"Replace the nodata value for activity pathways and priority layers. :param nodata_value: The nodata value to replace in the pathways and priority layers :type nodata_value: float :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( \"Replacing the nodata value for the activity pathways and priority layers\" ) ) pathways : typing . List [ NcsPathway ] = [] try : # Create directories for replaced nodata pathways and priority layers replaced_nodata_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" , \"replaced_nodata\" ) FileUtils . create_new_dir ( replaced_nodata_pathways_directory ) replaced_nodata_priority_directory = os . path . join ( self . scenario_directory , \"priority_layer\" , \"replaced_nodata\" ) FileUtils . create_new_dir ( replaced_nodata_priority_directory ) for activity in self . analysis_activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or \" f \" activity layers for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or \" f \"activity layers for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) # Replace the no data value for priority layers # Dict with PWL uuid as key and path as value priority_layers_paths = {} for priority_layer in self . get_priority_layers (): if priority_layer is None : continue if self . processing_cancelled : return False priority_layer_path = priority_layer . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): continue priority_layers_paths [ priority_layer . get ( \"uuid\" )] = priority_layer_path layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) if not layer . isValid (): self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } is not valid, \" f \"skipping replacing nodata value for layer.\" ) continue raster_provider = layer . dataProvider () raster_no_data_value = raster_provider . sourceNoDataValue ( 1 ) if raster_no_data_value == nodata_value : self . log_message ( f \"Priority layer { priority_layer . get ( 'name' ) } already has the nodata value \" f \" { nodata_value } , skipping replacing nodata value for layer.\" ) continue self . log_message ( f \"Replacing nodata value for { priority_layer . get ( 'name' ) } priority layer \" f \"to { nodata_value } \\n \" ) output_file = os . path . join ( replaced_nodata_priority_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . replace_nodata ( priority_layer_path , output_file , nodata_value ) if result : priority_layers_paths [ priority_layer . get ( \"uuid\" )] = output_file if pathways is not None and len ( pathways ) > 0 : for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) if self . processing_cancelled : return False if not pathway_layer . isValid (): self . log_message ( f \"Pathway layer { pathway . name } is not valid, \" f \"skipping replacing nodata value for layer.\" ) continue raster_provider = pathway_layer . dataProvider () raster_no_data_value = raster_provider . sourceNoDataValue ( 1 ) if raster_no_data_value == nodata_value : self . log_message ( f \"Pathway layer { pathway . name } already has the nodata value \" f \" { nodata_value } , skipping replacing nodata value for layer.\" ) else : self . log_message ( f \"Replacing nodata value for { pathway . name } pathway layer \" f \"from { raster_no_data_value } to { nodata_value } \\n \" ) output_file = os . path . join ( replaced_nodata_pathways_directory , f \" { Path ( pathway . path ) . stem } _ { str ( self . scenario . uuid )[: 4 ] } .tif\" , ) result = self . replace_nodata ( pathway . path , output_file , nodata_value ) if result : pathway . path = output_file if ( pathway . priority_layers is not None and len ( pathway . priority_layers ) > 0 ): pathway_priority_layers = [] for priority_layer in pathway . priority_layers : pwl_uuid = priority_layer . get ( \"uuid\" ) if pwl_uuid in priority_layers_paths : priority_layer [ \"path\" ] = priority_layers_paths . get ( pwl_uuid , \"\" ) pathway_priority_layers . append ( priority_layer ) pathway . priority_layers = pathway_priority_layers except Exception as e : self . log_message ( f \"Problem replacing nodata value for layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_pathways_replace_nodata"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.run_pathways_weighting","text":"run_pathways_weighting ( activities , priority_layers_groups , extent , temporary_output = False ) Runs weighting analysis on the pathways in the activities using the corresponding NCS PWLs. The formula is: (suitability_index * pathway) * ((priority group coefficient 1 * impact weight * PWL 1) + (priority group coefficient 2 * impact weight * PWL 2) ...) Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required priority_layers_groups dict Used priority layers groups and their values required extent str selected extent from user required temporary_output bool Whether to save the processing outputs as temporary files False Returns: Type Description bool True if the task operation was successfully completed else False. Source code in src/cplus_plugin/tasks.py 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 def run_pathways_weighting ( self , activities : typing . List [ Activity ], priority_layers_groups , extent , temporary_output = False , ) -> bool : \"\"\"Runs weighting analysis on the pathways in the activities using the corresponding NCS PWLs. The formula is: (suitability_index * pathway) * ((priority group coefficient 1 * impact weight * PWL 1) + (priority group coefficient 2 * impact weight * PWL 2) ...) :param activities: List of the selected activities :type activities: typing.List[Activity] :param priority_layers_groups: Used priority layers groups and their values :type priority_layers_groups: dict :param extent: selected extent from user :type extent: str :param temporary_output: Whether to save the processing outputs as temporary files :type temporary_output: bool :returns: True if the task operation was successfully completed else False. :rtype: bool \"\"\" if self . processing_cancelled : return False self . set_status_message ( tr ( f \"Weighting of pathways\" )) if len ( activities ) == 0 : msg = tr ( f \"No defined activities for running pathways weighting.\" ) self . set_info_message ( msg , level = Qgis . MessageLevel . Critical , ) self . log_message ( msg ) return False # Get the relative impact matrix relative_impact_matrix = dict () impact_matrix = settings_manager . get_value ( Settings . SCENARIO_IMPACT_MATRIX , dict () ) if len ( impact_matrix ) > 0 : relative_impact_matrix = json . loads ( impact_matrix ) pathway_uuids = relative_impact_matrix . get ( \"pathway_uuids\" , []) priority_layer_uuids = relative_impact_matrix . get ( \"priority_layer_uuids\" , []) relative_impact_values = relative_impact_matrix . get ( \"values\" , []) # Get valid pathways pathways : typing . List [ NcsPathway ] = [] activities_paths = [] try : # Validate activities and corresponding pathways for activity in activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or an\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or an \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if pathway not in pathways : pathways . append ( pathway ) if activity . path is not None and activity . path != \"\" : activities_paths . append ( activity . path ) if not pathways and len ( activities_paths ) > 0 : self . run_activities_analysis ( activities , extent ) return False self . run_normalize_pathways_carbon_impact ( pathways ) settings_priority_layers = self . get_priority_layers () weighted_pathways_directory = os . path . join ( self . scenario_directory , \"weighted_pathways\" ) FileUtils . create_new_dir ( weighted_pathways_directory ) for pathway in pathways : # Skip processing if cancelled if self . processing_cancelled : return False base_names = [] layers = [ pathway . path ] run_calculation = False # Include suitability index if not zero pathway_basename = Path ( pathway . path ) . stem if pathway . suitability_index > 0 : base_names . append ( f '( { pathway . suitability_index } *\" { pathway_basename } @1\")' ) run_calculation = True else : base_names . append ( f '(\" { pathway_basename } @1\")' ) for layer in pathway . priority_layers : if not any ( priority_layers_groups ): self . log_message ( f \"There are no defined priority layers in groups,\" f \" skipping the inclusion of PWLs in pathways \" f \"weighting.\" ) break if layer is None : continue settings_layer = self . get_priority_layer ( layer . get ( \"uuid\" )) if settings_layer is None : continue pwl = settings_layer . get ( \"path\" ) missing_pwl_message = ( f \"Path { pwl } for priority \" f \"weighting layer { layer . get ( 'name' ) } \" f \"doesn't exist, skipping the layer \" f \"from the pathway { pathway . name } weighting.\" ) if pwl is None : self . log_message ( missing_pwl_message ) continue pwl_path = Path ( pwl ) if not pwl_path . exists (): self . log_message ( missing_pwl_message ) continue pwl_path_basename = pwl_path . stem for priority_layer in settings_priority_layers : if priority_layer . get ( \"name\" ) == layer . get ( \"name\" ): for group in priority_layer . get ( \"groups\" , []): impact_value = None try : row = pathway_uuids . index ( str ( pathway . uuid )) col = priority_layer_uuids . index ( layer [ \"uuid\" ]) except ValueError : self . log_message ( f \"Could not find pathway uuid { pathway . uuid } or \" f \"priority layer uuid { layer [ 'uuid' ] } in the relative impact matrix.\" ) else : if row < len ( relative_impact_values ) and col < len ( relative_impact_values [ row ] ): impact_value = relative_impact_values [ row ][ col ] else : self . log_message ( f \"Index out of range for relative impact \" f \"matrix: row= { row } , col= { col } .\" ) value = group . get ( \"value\" ) priority_group_coefficient = float ( value ) if priority_group_coefficient > 0 : if pwl not in layers : layers . append ( pwl ) pwl_expression = ( f \"( { priority_group_coefficient } *\" f '\" { pwl_path_basename } @1\")' ) if impact_value is not None and impact_value < 0 : # Inverse the PWL pwl_expression = ( f \"( { priority_group_coefficient } *\" f '(\" { pwl_path_basename } @1\" - 1) * -1)' ) norm_carbon_impact = pathway . type_options . get ( \"norm_carbon_impact\" ) if ( layer . get ( \"is_carbon\" ) and norm_carbon_impact is not None ): # For restore and manage pathways, multiply by normalized carbon impact pwl_expression += f \" * { abs ( int ( impact_value )) * norm_carbon_impact } \" elif impact_value is not None : # For non-carbon PWLS and and protect pathways, pwl_expression += f \"* { abs ( int ( impact_value )) } \" base_names . append ( pwl_expression ) if not run_calculation : run_calculation = True # No need to run the calculation if suitability index is # zero or there are no PWLs in the activity. if not run_calculation : continue file_name = clean_filename ( pathway . name . replace ( \" \" , \"_\" )) output_file = os . path . join ( weighted_pathways_directory , f \" { file_name } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" , ) expression = f \" { base_names [ 0 ] } \" if len ( base_names ) > 1 : pwl_calc_expression = \" + \" . join ( base_names [ 1 :]) expression += f \" * ( { pwl_calc_expression } )\" # Actual processing calculation alg_params = { \"CELLSIZE\" : 0 , \"CRS\" : None , \"EXPRESSION\" : expression , \"EXTENT\" : extent , \"LAYERS\" : layers , \"OUTPUT\" : output_file , } self . log_message ( f \" Used parameters for calculating weighting pathways { alg_params } \\n \" ) self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False results = processing . run ( \"qgis:rastercalculator\" , alg_params , context = self . processing_context , feedback = self . feedback , ) pathway . path = results [ \"OUTPUT\" ] except Exception as e : self . log_message ( f \"Problem weighting pathways, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"run_pathways_weighting"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.set_custom_progress","text":"set_custom_progress ( value ) Set task progress value. Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 469 470 471 472 473 474 475 476 def set_custom_progress ( self , value : float ): \"\"\"Set task progress value. :param value: Value to be set on the progress bar :type value: float \"\"\" self . custom_progress = value self . custom_progress_changed . emit ( self . custom_progress )","title":"set_custom_progress"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.set_info_message","text":"set_info_message ( message , level = Qgis . MessageLevel . Info ) Set info message. Parameters: Name Type Description Default message str Message required level ( int , optional ) log level, defaults to Qgis.Info Info Source code in src/cplus_plugin/tasks.py 458 459 460 461 462 463 464 465 466 467 def set_info_message ( self , message : str , level = Qgis . MessageLevel . Info ): \"\"\"Set info message. :param message: Message :type message: str :param level: log level, defaults to Qgis.Info :type level: int, optional \"\"\" self . info_message = message self . info_message_changed . emit ( self . info_message , level )","title":"set_info_message"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.set_status_message","text":"set_status_message ( message ) Set status message in progress dialog Parameters: Name Type Description Default message str Message to be displayed required Source code in src/cplus_plugin/tasks.py 449 450 451 452 453 454 455 456 def set_status_message ( self , message : str ): \"\"\"Set status message in progress dialog :param message: Message to be displayed :type message: str \"\"\" self . status_message = message self . status_message_changed . emit ( self . status_message )","title":"set_status_message"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.snap_analysis_data","text":"snap_analysis_data ( activities , extent ) Snaps the passed activities pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. Parameters: Name Type Description Default activities List [ Activity ] List of the selected activities required extent list The selected extent from user required Source code in src/cplus_plugin/tasks.py 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 def snap_analysis_data ( self , activities , extent ): \"\"\"Snaps the passed activities pathways, carbon layers and priority layers to align with the reference layer set on the settings manager. :param activities: List of the selected activities :type activities: typing.List[Activity] :param extent: The selected extent from user :type extent: list \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return False self . set_status_message ( tr ( \"Snapping the selected activity pathways, \" \"carbon layers and priority layers\" ) ) pathways = [] try : for activity in activities : if not activity . pathways and ( activity . path is None or activity . path == \"\" ): self . set_info_message ( tr ( f \"No defined activity pathways or a\" f \" activity layer for the activity { activity . name } \" ), level = Qgis . MessageLevel . Critical , ) self . log_message ( f \"No defined activity pathways or a \" f \"activity layer for the activity { activity . name } \" ) return False for pathway in activity . pathways : if not ( pathway in pathways ): pathways . append ( pathway ) reference_layer_path = self . get_settings_value ( Settings . SNAP_LAYER ) rescale_values = self . get_settings_value ( Settings . RESCALE_VALUES , default = False , setting_type = bool ) resampling_method = self . get_settings_value ( Settings . RESAMPLING_METHOD , default = 0 ) if pathways is not None and len ( pathways ) > 0 : snapped_pathways_directory = os . path . join ( self . scenario_directory , \"pathways\" ) FileUtils . create_new_dir ( snapped_pathways_directory ) for pathway in pathways : pathway_layer = QgsRasterLayer ( pathway . path , pathway . name ) nodata_value = pathway_layer . dataProvider () . sourceNoDataValue ( 1 ) if self . processing_cancelled : return False # carbon layer snapping self . log_message ( f \"Snapping carbon layers from { pathway . name } pathway\" ) if ( pathway . carbon_paths is not None and len ( pathway . carbon_paths ) > 0 ): snapped_carbon_directory = os . path . join ( self . scenario_directory , \"carbon_layers\" ) FileUtils . create_new_dir ( snapped_carbon_directory ) snapped_carbon_paths = [] for carbon_path in pathway . carbon_paths : carbon_layer = QgsRasterLayer ( carbon_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_carbon = ( carbon_layer . dataProvider () . sourceNoDataValue ( 1 ) ) carbon_output_path = self . snap_layer ( carbon_path , reference_layer_path , extent , snapped_carbon_directory , rescale_values , resampling_method , nodata_value_carbon , ) if carbon_output_path : snapped_carbon_paths . append ( carbon_output_path ) else : snapped_carbon_paths . append ( carbon_path ) pathway . carbon_paths = snapped_carbon_paths self . log_message ( f \"Snapping { pathway . name } pathway layer \\n \" ) # Pathway snapping output_path = self . snap_layer ( pathway . path , reference_layer_path , extent , snapped_pathways_directory , rescale_values , resampling_method , nodata_value , ) if output_path : pathway . path = output_path for pwl_pathway in pathways : self . log_message ( f \"Snapping { len ( pwl_pathway . priority_layers ) } \" f \"priority weighting layers from pathway { pwl_pathway . name } with layers \\n \" ) if ( pwl_pathway . priority_layers is not None and len ( pwl_pathway . priority_layers ) > 0 ): snapped_priority_directory = os . path . join ( self . scenario_directory , \"priority_layers\" ) FileUtils . create_new_dir ( snapped_priority_directory ) priority_layers = [] for priority_layer in pwl_pathway . priority_layers : if priority_layer is None : continue priority_layer_settings = self . get_priority_layer ( priority_layer . get ( \"uuid\" ) ) if priority_layer_settings is None : continue priority_layer_path = priority_layer_settings . get ( \"path\" ) if not Path ( priority_layer_path ) . exists (): priority_layers . append ( priority_layer ) continue layer = QgsRasterLayer ( priority_layer_path , f \" { str ( uuid . uuid4 ())[: 4 ] } \" ) nodata_value_priority = layer . dataProvider () . sourceNoDataValue ( 1 ) priority_output_path = self . snap_layer ( priority_layer_path , reference_layer_path , extent , snapped_priority_directory , rescale_values , resampling_method , nodata_value_priority , ) if priority_output_path : priority_layer [ \"path\" ] = priority_output_path priority_layers . append ( priority_layer ) pwl_pathway . priority_layers = priority_layers except Exception as e : self . log_message ( f \"Problem snapping layers, { e } \\n \" ) self . cancel_task ( e ) return False return True","title":"snap_analysis_data"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.snap_layer","text":"snap_layer ( input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value ) Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. Parameters: Name Type Description Default input_path str Input layer source required reference_path str Reference layer source required extent list Clip extent required directory str Absolute path of the output directory for the snapped layers required rescale_values bool Whether to rescale pixel values required resample_method ResampleAlg Method to use when resampling required nodata_value float Original no data value of the input layer required Source code in src/cplus_plugin/tasks.py 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 def snap_layer ( self , input_path , reference_path , extent , directory , rescale_values , resampling_method , nodata_value , ): \"\"\"Snaps the passed input layer using the reference layer and updates the snap output no data value to be the same as the original input layer no data value. :param input_path: Input layer source :type input_path: str :param reference_path: Reference layer source :type reference_path: str :param extent: Clip extent :type extent: list :param directory: Absolute path of the output directory for the snapped layers :type directory: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg :param nodata_value: Original no data value of the input layer :type nodata_value: float \"\"\" input_result_path , reference_result_path = align_rasters ( input_path , reference_path , extent , directory , rescale_values , resampling_method , ) if input_result_path is not None : result_path = Path ( input_result_path ) directory = result_path . parent name = result_path . stem output_path = os . path . join ( directory , f \" { name } _final.tif\" ) self . replace_nodata ( input_result_path , output_path , nodata_value ) return output_path","title":"snap_layer"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.update_progress","text":"update_progress ( value ) Sets the value of the task progress Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/tasks.py 478 479 480 481 482 483 484 485 486 487 488 def update_progress ( self , value ): \"\"\"Sets the value of the task progress :param value: Value to be set on the progress bar :type value: float \"\"\" if not self . processing_cancelled : self . set_custom_progress ( value ) else : self . feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"update_progress"},{"location":"developer/api/core/api_tasks/#src.cplus_plugin.tasks.ScenarioAnalysisTask.validate_vector_layer","text":"validate_vector_layer ( source_path ) Create a valid representation of a given vector layer without losing any of the input vertices. Parameters: Name Type Description Default source_path str Path to vector layer. The native:fixgeometries requires the layer in EPSG:4326 required Returns: Type Description str | bool Path to the validated vector layer else False. Source code in src/cplus_plugin/tasks.py 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 def validate_vector_layer ( self , source_path ) -> str : \"\"\"Create a valid representation of a given vector layer without losing any of the input vertices. :param source_path: Path to vector layer. The native:fixgeometries requires the layer in EPSG:4326 :type source_path: str :returns: Path to the validated vector layer else False. :rtype: str | bool \"\"\" self . log_message ( f \"Validating the vector layer { source_path } \" ) layer = QgsVectorLayer ( source_path , \"input_layer\" ) if not layer . isValid (): return False try : validated_directory = Path ( source_path ) . parent self . feedback = QgsProcessingFeedback () self . feedback . progressChanged . connect ( self . update_progress ) if self . processing_cancelled : return False output_file = os . path . join ( validated_directory , f \"validated_ { str ( uuid . uuid4 ())[: 4 ] } .shp\" , ) alg_params = { \"INPUT\" : source_path , \"METHOD\" : 1 , \"OUTPUT\" : output_file } self . log_message ( f \"Used parameters for validating the vector: { source_path } \" f \" { alg_params } \\n \" ) result = processing . run ( \"native:fixgeometries\" , alg_params , context = self . processing_context , feedback = self . feedback , ) return result . get ( \"OUTPUT\" ) except Exception as e : self . log_message ( f \"Problem validating the vector, { e } \\n \" ) self . log_message ( traceback . format_exc ()) self . cancel_task ( e ) return False","title":"validate_vector_layer"},{"location":"developer/api/core/api_utils/","text":"Utilities \u00b6 Plugin utilities CustomJsonEncoder \u00b6 Bases: JSONEncoder Custom JSON encoder which handles UUID and datetime FileUtils \u00b6 Provides functionality for commonly used file-related operations. copy_file staticmethod \u00b6 copy_file ( file_path , target_dir , log_message = '' ) Copies file to the target directory Source code in src/cplus_plugin/utils.py 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 @staticmethod def copy_file ( file_path : str , target_dir : str , log_message : str = \"\" ): \"\"\"Copies file to the target directory\"\"\" p = Path ( file_path ) if not p . exists (): raise FileNotFoundError ( f \"File { file_path } does not exist\" ) target_path = Path ( target_dir ) / p . name if not target_path . parent . exists (): target_path . parent . mkdir ( parents = True ) shutil . copy ( p , target_path ) if not target_path . exists (): raise FileNotFoundError ( f \"Failed to copy file to { target_dir } \" ) return str ( target_path ) create_comparison_reports_dir staticmethod \u00b6 create_comparison_reports_dir ( base_dir ) Creates a comparison reports subdirectory under the base directory. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 769 770 771 772 773 774 775 776 777 778 779 780 781 @staticmethod def create_comparison_reports_dir ( base_dir : str ): \"\"\"Creates a comparison reports subdirectory under the base directory. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return comparison_reports_dir = f \" { base_dir } / { COMPARISON_REPORT_SEGMENT } \" message = tr ( \"Missing parent directory when creating comparison reports subdirectory.\" ) FileUtils . create_new_dir ( comparison_reports_dir , message ) create_ncs_carbon_dir staticmethod \u00b6 create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 783 784 785 786 787 788 789 790 791 792 793 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message ) create_ncs_pathways_dir staticmethod \u00b6 create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 740 741 742 743 744 745 746 747 748 749 750 751 752 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message ) create_new_dir staticmethod \u00b6 create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 808 809 810 811 812 813 814 815 816 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir ( parents = True , exist_ok = True ) except ( FileNotFoundError , OSError ): log ( log_message ) create_new_file staticmethod \u00b6 create_new_file ( file_path , log_message = '' ) Creates new file Source code in src/cplus_plugin/utils.py 818 819 820 821 822 823 824 825 826 827 @staticmethod def create_new_file ( file_path : str , log_message : str = \"\" ): \"\"\"Creates new file\"\"\" p = Path ( file_path ) if not p . exists (): try : p . touch ( exist_ok = True ) except FileNotFoundError : log ( log_message ) create_npv_pwls_dir staticmethod \u00b6 create_npv_pwls_dir ( base_dir ) Creates an NPV PWL subdirectory under PWL child directory in the base directory. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 754 755 756 757 758 759 760 761 762 763 764 765 766 767 @staticmethod def create_npv_pwls_dir ( base_dir : str ): \"\"\"Creates an NPV PWL subdirectory under PWL child directory in the base directory. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return npv_pwl_dir = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { NPV_PRIORITY_LAYERS_SEGMENT } \" ) message = tr ( \"Missing parent directory when creating NPV PWLs subdirectory.\" ) FileUtils . create_new_dir ( npv_pwl_dir , message ) create_pwls_dir \u00b6 create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 795 796 797 798 799 800 801 802 803 804 805 806 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message ) get_fonts_dir staticmethod \u00b6 get_fonts_dir () Returns the fonts directory in the plugin. Returns: Type Description str Fonts directory. Source code in src/cplus_plugin/utils.py 665 666 667 668 669 670 671 672 @staticmethod def get_fonts_dir () -> str : \"\"\"Returns the fonts directory in the plugin. :returns: Fonts directory. :rtype: str \"\"\" return f \" { FileUtils . plugin_dir () } /data/fonts\" get_icon staticmethod \u00b6 get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = FileUtils . get_icon_path ( file_name ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path ) get_icon_path staticmethod \u00b6 get_icon_path ( file_name ) Gets the full path of the icon with the given name. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description str The full path to the icon in the plugin. Source code in src/cplus_plugin/utils.py 674 675 676 677 678 679 680 681 682 683 684 @staticmethod def get_icon_path ( file_name : str ) -> str : \"\"\"Gets the full path of the icon with the given name. :param file_name: File name which should include the extension. :type file_name: str :returns: The full path to the icon in the plugin. :rtype: str \"\"\" return os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) get_pixmap staticmethod \u00b6 get_pixmap ( file_name ) Creates a pixmap based on the file name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QPixmap Pixmap object matching the file name. Source code in src/cplus_plugin/utils.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 @staticmethod def get_pixmap ( file_name : str ) -> QtGui . QPixmap : \"\"\"Creates a pixmap based on the file name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Pixmap object matching the file name. :rtype: QtGui.QPixmap \"\"\" pixmap_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( pixmap_path ): return QtGui . QPixmap () return QtGui . QPixmap ( pixmap_path ) plugin_dir staticmethod \u00b6 plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 656 657 658 659 660 661 662 663 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ))) report_template_path staticmethod \u00b6 report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use scenario_analysis_default.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `scenario_analysis_default.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = SCENARIO_ANALYSIS_TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /data/report_templates/ { file_name } \" return os . path . normpath ( absolute_path ) align_rasters \u00b6 align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 ) Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. Parameters: Name Type Description Default input_raster_source str Input layer source required reference_raster_source str Reference layer source required extent list Clip extent None output_dir str Absolute path of the output directory for the snapped layers None rescale_values bool Whether to rescale pixel values False resample_method ResampleAlg Method to use when resampling 0 Source code in src/cplus_plugin/utils.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 def align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 , ): \"\"\" Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. :param input_raster_source: Input layer source :type input_raster_source: str :param reference_raster_source: Reference layer source :type reference_raster_source: str :param extent: Clip extent :type extent: list :param output_dir: Absolute path of the output directory for the snapped layers :type output_dir: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg \"\"\" try : snap_directory = os . path . join ( output_dir , \"snap_layers\" ) FileUtils . create_new_dir ( snap_directory ) input_path = Path ( input_raster_source ) input_layer_output = os . path . join ( f \" { snap_directory } \" , f \" { input_path . stem } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) FileUtils . create_new_file ( input_layer_output ) align = QgsAlignRaster () lst = [ QgsAlignRaster . Item ( input_raster_source , input_layer_output ), ] resample_method_value = QgsAlignRaster . ResampleAlg . RA_NearestNeighbour try : resample_method_value = QgsAlignRaster . ResampleAlg ( int ( resample_method )) except Exception as e : log ( f \"Problem creating a resample value when snapping, { e } \" ) if rescale_values : lst [ 0 ] . rescaleValues = rescale_values lst [ 0 ] . resample_method = resample_method_value align . setRasters ( lst ) align . setParametersFromRaster ( reference_raster_source ) layer = QgsRasterLayer ( input_raster_source , \"input_layer\" ) extent = transform_extent ( layer . extent (), QgsCoordinateReferenceSystem ( layer . crs ()), QgsCoordinateReferenceSystem ( align . destinationCrs ()), ) align . setClipExtent ( extent ) log ( f \"Snapping clip extent { layer . extent () . asWktPolygon () } \\n \" ) if not align . run (): log ( f \"Problem during snapping for { input_raster_source } and \" f \" { reference_raster_source } , { align . errorMessage () } \" ) raise Exception ( align . errorMessage ()) except Exception as e : log ( f \"Problem occured when snapping, { str ( e ) } .\" f \" Update snap settings and re-run the analysis\" ) return None , None log ( f \"Finished snapping\" f \" original layer - { input_raster_source } ,\" f \"snapped output - { input_layer_output } \\n \" ) return input_layer_output , None calculate_raster_area \u00b6 calculate_raster_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. This varies from 'calculate_raster_area_by_pixel_value' in that it gives the total area instead of grouping by pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float The total area of value pixels of the raster else -1 if the raster is invalid or if it is empty. Pixels with NoData value are not included in the computation. Source code in src/cplus_plugin/utils.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def calculate_raster_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> float : \"\"\"Calculates the area of value pixels for the given band in a raster layer. This varies from 'calculate_raster_area_by_pixel_value' in that it gives the total area instead of grouping by pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: The total area of value pixels of the raster else -1 if the raster is invalid or if it is empty. Pixels with NoData value are not included in the computation. :rtype: float \"\"\" area_by_pixel_value = calculate_raster_area_by_pixel_value ( layer , band_number , feedback ) if len ( area_by_pixel_value ) == 0 : return - 1.0 # Remove NoData pixels from the computation, just in case the process # calculation might have sneaked it in. if layer . dataProvider () . sourceHasNoDataValue ( band_number ): no_data_value = layer . dataProvider () . sourceNoDataValue ( band_number ) if no_data_value in area_by_pixel_value : del area_by_pixel_value [ no_data_value ] return float ( sum ( area_by_pixel_value . values ())) calculate_raster_area_by_pixel_value \u00b6 calculate_raster_area_by_pixel_value ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels in hectares for the given band in a raster layer and groups the area by the pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def calculate_raster_area_by_pixel_value ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels in hectares for the given band in a raster layer and groups the area by the pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : QgsProcessing . TEMPORARY_OUTPUT , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ pixel_value ] = pixel_value_area return pixel_areas clean_filename \u00b6 clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename compress_raster \u00b6 compress_raster ( input_path , output_path = None , compression_type = 'DEFLATE' , compress_level = 6 , nodata_value = None , output_format = 'GTiff' , create_options = None , additional_options = None ) Compresses a raster file using GDAL and optionally replace old NoData pixel values with a new one. Parameters: Name Type Description Default input_path str Path to the input raster file required output_path str Path to the input raster file. If none the ouput will saved to a temporary file None compression_type str Compression algorithm (e.g., 'DEFLATE', 'LZW', 'PACKBITS', 'JPEG', 'NONE') 'DEFLATE' compress_level int Compression level (1-9 for DEFLATE/LZW, 1-100 for JPEG) 6 nodata_value float Value to set as nodata (default: None). If None, retain the input nodatavalue None output_format str Output format (default: 'GTiff' for GeoTIFF) 'GTiff' create_options list Additional GDAL creation options as a list None additional_options list dditional GDAL options as a list None Returns: Type Description str | None Path to the temporary file if successful, None if failed Source code in src/cplus_plugin/utils.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def compress_raster ( input_path : str , output_path : str = None , compression_type : str = \"DEFLATE\" , compress_level : int = 6 , nodata_value : float = None , output_format : str = \"GTiff\" , create_options : list = None , additional_options : list = None , ): \"\"\" Compresses a raster file using GDAL and optionally replace old NoData pixel values with a new one. :param input_path: Path to the input raster file :type input_path: str :param output_path: Path to the input raster file. If none the ouput will saved to a temporary file :type output_path: str :param compression_type: Compression algorithm (e.g., 'DEFLATE', 'LZW', 'PACKBITS', 'JPEG', 'NONE') :type compression_type: str :param compress_level: Compression level (1-9 for DEFLATE/LZW, 1-100 for JPEG) :type compress_level: int :param nodata_value: Value to set as nodata (default: None). If None, retain the input nodatavalue :type nodata_value: float :param output_format: Output format (default: 'GTiff' for GeoTIFF) :type output_format: str :param create_options: Additional GDAL creation options as a list :type create_options: list :param additional_options: dditional GDAL options as a list :type additional_options: list :return: Path to the temporary file if successful, None if failed :rtype: str or None \"\"\" if not os . path . isfile ( input_path ): raise FileNotFoundError ( f \"Input raster file not found: { input_path } \" ) # Create a temporary file if output_path is None: if not output_path : unique_id = str ( uuid . uuid4 ())[: 8 ] temp_file = QtCore . QTemporaryFile ( os . path . join ( QgsProject . instance () . homePath (), f \"temp_compressed_ { unique_id } .tif\" ) ) if not temp_file . open (): log ( \"Error: Could not create temporary file\" ) return None base , ext = os . path . splitext ( input_path ) output_path = temp_file . fileName () + ext or \".tif\" temp_file . close () try : # Load the input raster layer using GDAL src_ds = gdal . Open ( input_path , gdal . GA_ReadOnly ) if src_ds is None : raise ValueError ( \"Unable to open raster with GDAL\" ) band_count = src_ds . RasterCount xsize = src_ds . RasterXSize ysize = src_ds . RasterYSize dtype = src_ds . GetRasterBand ( 1 ) . DataType compression = src_ds . GetMetadataItem ( \"COMPRESSION\" , \"IMAGE_STRUCTURE\" ) if compression . lower () == \"deflate\" : log ( f \"Raster { input_path } is already compressed with DEFLATE.\" ) return input_path # Add any additional create options if not create_options : create_options = [] # Ensure standard options are included create_options . extend ( [ f \"COMPRESS= { compression_type } \" , f \"ZLEVEL= { compress_level } \" , f \"JPEG_QUALITY= { compress_level } \" , f \"NUM_THREADS=ALL_CPUS\" , \"BIGTIFF=IF_SAFER\" , \"TILED=YES\" , ] ) # Set additional options if provided if additional_options : create_options . extend ( additional_options ) # Create compressed output raster driver = gdal . GetDriverByName ( output_format ) out_ds = driver . Create ( output_path , xsize , ysize , band_count , dtype , create_options ) out_ds . SetGeoTransform ( src_ds . GetGeoTransform ()) out_ds . SetProjection ( src_ds . GetProjection ()) for i in range ( 1 , band_count + 1 ): band = src_ds . GetRasterBand ( i ) data = band . ReadAsArray () old_nodata = band . GetNoDataValue () # Replace pixel values if old NoData exists if nodata_value is not None and old_nodata is not None : data = np . where ( data == old_nodata , nodata_value , data ) out_band = out_ds . GetRasterBand ( i ) out_band . WriteArray ( data ) out_band . SetNoDataValue ( nodata_value ) out_band . FlushCache () # Close datasets src_ds = None # if os.path.exists(output_path): log ( f \"Successfully compressed raster saved to temporary file: { output_path } \" ) return output_path except Exception as error : log ( f \"Error occurred during raster compression. Error code: { error } \" ) return None contains_font_family \u00b6 contains_font_family ( font_family ) Checks if the specified font family exists in the font database. Parameters: Name Type Description Default font_family str Name of the font family to check. required Returns: Type Description bool True if the font family exists, else False. Source code in src/cplus_plugin/utils.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def contains_font_family ( font_family : str ) -> bool : \"\"\"Checks if the specified font family exists in the font database. :param font_family: Name of the font family to check. :type font_family: str :returns: True if the font family exists, else False. :rtype: bool \"\"\" # Qt6 uses static method, some Qt5 versions use instance method try : font_families = QtGui . QFontDatabase . families () except TypeError : # Fallback for versions where families() is an instance method font_families = QtGui . QFontDatabase () . families () matching_fonts = [ family for family in font_families if font_family in family ] return True if len ( matching_fonts ) > 0 else False convert_size \u00b6 convert_size ( size_bytes ) Convert byte size to human readable text. Parameters: Name Type Description Default size_bytes int byte sizse required Returns: Type Description str human readable text Source code in src/cplus_plugin/utils.py 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 def convert_size ( size_bytes ): \"\"\"Convert byte size to human readable text. :param size_bytes: byte sizse :type size_bytes: int :return: human readable text :rtype: str \"\"\" if size_bytes == 0 : return \"0B\" size_name = ( \"B\" , \"KB\" , \"MB\" , \"GB\" , \"TB\" , \"PB\" , \"EB\" , \"ZB\" , \"YB\" ) i = int ( math . floor ( math . log ( size_bytes , 1024 ))) p = math . pow ( 1024 , i ) s = round ( size_bytes / p , 2 ) return \" %s %s \" % ( s , size_name [ i ]) format_value_with_unit \u00b6 format_value_with_unit ( value , metadata_id ) Format a value with an appropriate unit suffix for filename. The unit is determined based on the metadata_id. Common patterns: - Years/experience: \"5years\", \"10years\" - Percentage: \"25pct\", \"50pct\" - Weight: \"10kg\", \"25kg\" - Default: \"12p50\" (12.50 with decimal point as 'p') Parameters: Name Type Description Default value float The numeric value required metadata_id str Metadata ID to determine the appropriate unit required Returns: Type Description str Formatted string like \"5years\", \"10pct\", \"25kg\" Source code in src/cplus_plugin/utils.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def format_value_with_unit ( value : float , metadata_id : str ) -> str : \"\"\"Format a value with an appropriate unit suffix for filename. The unit is determined based on the metadata_id. Common patterns: - Years/experience: \"5years\", \"10years\" - Percentage: \"25pct\", \"50pct\" - Weight: \"10kg\", \"25kg\" - Default: \"12p50\" (12.50 with decimal point as 'p') :param value: The numeric value :type value: float :param metadata_id: Metadata ID to determine the appropriate unit :type metadata_id: str :returns: Formatted string like \"5years\", \"10pct\", \"25kg\" :rtype: str \"\"\" if \"year\" in metadata_id . lower () or \"experience\" in metadata_id . lower (): return f \" { int ( value ) } years\" elif \"percent\" in metadata_id . lower () or \"pct\" in metadata_id . lower (): return f \" { int ( value ) } pct\" elif \"weight\" in metadata_id . lower () or \"kg\" in metadata_id . lower (): return f \" { int ( value ) } kg\" else : return f \" { value : .2f } \" . replace ( \".\" , \"p\" ) function_help_to_html \u00b6 function_help_to_html ( function_name , description , arguments = None , examples = None ) Creates a HTML string containing the detailed help of an expression function. The specific HTML formatting is deduced from the code here: https://github.com/qgis/QGIS/blob/master/src/core/expression/qgsexpression.cpp#L565 Parameters: Name Type Description Default function_name str Name of the expression function. required description str Detailed description of the function. required arguments List [ tuple ] List containing the arguments. Each argument should consist of a tuple containing three elements i.e. argument name, description and bool where True will indicate the argument is optional. Take note of the order as mandatory arguments should be first in the list. None examples List [ tuple ] Examples of using the function. Each item in the list should be a tuple containing an example expression and the corresponding return value. None Returns: Type Description str The expression function's help in HTML for use in, for example, an expression builder. Source code in src/cplus_plugin/utils.py 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 def function_help_to_html ( function_name : str , description : str , arguments : typing . List [ tuple ] = None , examples : typing . List [ tuple ] = None , ) -> str : \"\"\"Creates a HTML string containing the detailed help of an expression function. The specific HTML formatting is deduced from the code here: https://github.com/qgis/QGIS/blob/master/src/core/expression/qgsexpression.cpp#L565 :param function_name: Name of the expression function. :type function_name: str :param description: Detailed description of the function. :type description: str :param arguments: List containing the arguments. Each argument should consist of a tuple containing three elements i.e. argument name, description and bool where True will indicate the argument is optional. Take note of the order as mandatory arguments should be first in the list. :type arguments: typing.List[tuple] :param examples: Examples of using the function. Each item in the list should be a tuple containing an example expression and the corresponding return value. :type examples: typing.List[tuple] :returns: The expression function's help in HTML for use in, for example, an expression builder. :rtype: str \"\"\" if arguments is None : arguments = [] if examples is None : examples = [] html_segments = [] # Title html_segments . append ( f \"<h3>function { function_name } </h3> \\n \" ) # Description html_segments . append ( f '<div class=\"description\"><p> { description } </p></div>' ) # Syntax html_segments . append ( f '<h4>Syntax</h4> \\n <div class=\"syntax\"> \\n <code>' f '<span class=\"functionname\"> { function_name } </span>' f \"(\" ) has_optional = False separator = \"\" for arg in arguments : arg_name = arg [ 0 ] arg_mandatory = arg [ 2 ] if not has_optional and arg_mandatory : html_segments . append ( \"[\" ) has_optional = True html_segments . append ( separator ) html_segments . append ( f '<span class=\"argument\"> { arg_name } </span>' ) if arg_mandatory : html_segments . append ( \"]\" ) separator = \",\" html_segments . append ( \")</code>\" ) if has_optional : html_segments . append ( \"<br/><br/>[ ] marks optional components\" ) # Arguments if len ( arguments ) > 0 : html_segments . append ( '<h4>Arguments</h4> \\n <div class=\"arguments\"> \\n <table>' ) for arg in arguments : arg_name = arg [ 0 ] arg_description = arg [ 1 ] html_segments . append ( f '<tr><td class=\"argument\"> { arg_name } </td><td> { arg_description } </td></tr>' ) html_segments . append ( \"</table> \\n </div> \\n \" ) # Examples if len ( examples ) > 0 : html_segments . append ( '<h4>Examples</h4> \\n <div class=\"examples\"> \\n <ul> \\n ' ) for example in examples : expression = example [ 0 ] return_value = example [ 1 ] html_segments . append ( f \"<li><code> { expression } </code> &rarr; <code> { return_value } </code>\" ) html_segments . append ( \"</ul> \\n </div> \\n \" ) return \"\" . join ( html_segments ) generate_constant_raster_filename \u00b6 generate_constant_raster_filename ( component_name , value , metadata_id ) Generate a descriptive filename for a constant raster. Follows the pattern: {sanitized_component_name}_{value_with_unit}.tif Example outputs: - \"agroforestry_5years.tif\" - \"corn_production_25pct.tif\" - \"animal_management_10kg.tif\" Parameters: Name Type Description Default component_name str Name of the pathway/activity required value float The constant value for this raster required metadata_id str Metadata ID to determine the value unit required Returns: Type Description str Safe filename with extension Source code in src/cplus_plugin/utils.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def generate_constant_raster_filename ( component_name : str , value : float , metadata_id : str ) -> str : \"\"\"Generate a descriptive filename for a constant raster. Follows the pattern: {sanitized_component_name}_{value_with_unit}.tif Example outputs: - \"agroforestry_5years.tif\" - \"corn_production_25pct.tif\" - \"animal_management_10kg.tif\" :param component_name: Name of the pathway/activity :type component_name: str :param value: The constant value for this raster :type value: float :param metadata_id: Metadata ID to determine the value unit :type metadata_id: str :returns: Safe filename with extension :rtype: str \"\"\" safe_name = clean_filename ( component_name ) value_str = format_value_with_unit ( value , metadata_id ) return f \" { safe_name } _ { value_str } .tif\" generate_random_color \u00b6 generate_random_color () Generate a random color object using a system-seeded deterministic approach. Returns: Type Description QColor A random generated color. Source code in src/cplus_plugin/utils.py 465 466 467 468 469 470 471 472 def generate_random_color () -> QtGui . QColor : \"\"\"Generate a random color object using a system-seeded deterministic approach. :returns: A random generated color. :rtype: QColor \"\"\" return QtGui . QColor . fromRgb ( QtCore . QRandomGenerator . global_ () . generate ()) get_constant_raster_dir \u00b6 get_constant_raster_dir ( base_dir , component_type , metadata_id ) Get the directory path for constant rasters. Creates a hierarchical directory structure: {base_dir}/{component_type}/{raster_type}/ Parameters: Name Type Description Default base_dir str Base directory (e.g., \"BASE_DIR/constant_rasters\") required component_type ModelComponentType Type of model component (NCS_PATHWAY or ACTIVITY) required metadata_id str Raster type ID (e.g., \"years_experience_pathway\") required Returns: Type Description str Full path to the constant raster directory Source code in src/cplus_plugin/utils.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def get_constant_raster_dir ( base_dir : str , component_type : ModelComponentType , metadata_id : str ) -> str : \"\"\"Get the directory path for constant rasters. Creates a hierarchical directory structure: {base_dir}/{component_type}/{raster_type}/ :param base_dir: Base directory (e.g., \"BASE_DIR/constant_rasters\") :type base_dir: str :param component_type: Type of model component (NCS_PATHWAY or ACTIVITY) :type component_type: ModelComponentType :param metadata_id: Raster type ID (e.g., \"years_experience_pathway\") :type metadata_id: str :returns: Full path to the constant raster directory :rtype: str \"\"\" if component_type == ModelComponentType . NCS_PATHWAY : type_dir = \"ncs_pathway\" elif component_type == ModelComponentType . ACTIVITY : type_dir = \"activity\" else : type_dir = \"unknown\" raster_type = metadata_id if raster_type . endswith ( \"_pathway\" ) or raster_type . endswith ( \"_activity\" ): raster_type = \"_\" . join ( raster_type . split ( \"_\" )[: - 1 ]) return os . path . join ( base_dir , type_dir , raster_type ) get_layer_type \u00b6 get_layer_type ( file_path ) Get layer type code from file path Source code in src/cplus_plugin/utils.py 903 904 905 906 907 908 909 910 911 912 913 def get_layer_type ( file_path : str ): \"\"\" Get layer type code from file path \"\"\" file_name , file_extension = os . path . splitext ( file_path ) if file_extension . lower () in [ \".tif\" , \".tiff\" ]: return 0 elif file_extension . lower () in [ \".geojson\" , \".zip\" , \".shp\" ]: return 1 else : return - 1 get_plugin_version \u00b6 get_plugin_version () Returns the current plugin version as saved in the metadata.txt plugin file. Returns: Type Description str Plugin version Source code in src/cplus_plugin/utils.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_plugin_version () -> [ str , None ]: \"\"\"Returns the current plugin version as saved in the metadata.txt plugin file. :returns version: Plugin version :rtype version: str \"\"\" metadata_file = Path ( __file__ ) . parent . resolve () / \"metadata.txt\" with open ( metadata_file , \"r\" ) as f : for line in f . readlines (): if line . startswith ( \"version\" ): version = line . strip () . split ( \"=\" )[ 1 ] return version return None get_report_font \u00b6 get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic ) install_font \u00b6 install_font ( dir_name ) Installs the font families in the specified folder name under the plugin's 'fonts' folder. Parameters: Name Type Description Default dir_name str Directory name, under the 'fonts' folder, which contains the font families to be installed. required Returns: Type Description bool True if the font(s) were successfully installed, else False if the directory name does not exist or if the given font families already exist in the application's font database. Source code in src/cplus_plugin/utils.py 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def install_font ( dir_name : str ) -> bool : \"\"\"Installs the font families in the specified folder name under the plugin's 'fonts' folder. :param dir_name: Directory name, under the 'fonts' folder, which contains the font families to be installed. :type dir_name: str :returns: True if the font(s) were successfully installed, else False if the directory name does not exist or if the given font families already exist in the application's font database. :rtype: bool \"\"\" font_family_dir = os . path . normpath ( f \" { FileUtils . get_fonts_dir () } / { dir_name } \" ) if not os . path . exists ( font_family_dir ): tr_msg = tr ( \"font directory does not exist.\" ) log ( message = f \"' { dir_name } ' { tr_msg } \" , info = False ) return False status = True font_paths = Path ( font_family_dir ) . glob ( \"**/*\" ) font_extensions = [ \".otf\" , \".ttf\" ] for font_path in font_paths : if font_path . suffix not in font_extensions : continue font_id = QtGui . QFontDatabase . addApplicationFont ( font_path . as_posix ()) if font_id == - 1 and status : tr_msg = \"font could not be installed.\" log ( message = f \"' { font_path } ' { tr_msg } \" , info = False ) status = False return status item_user_type \u00b6 item_user_type () Get QStandardItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QStandardItem Source code in src/cplus_plugin/utils.py 59 60 61 62 63 64 65 66 67 68 def item_user_type (): \"\"\"Get QStandardItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QStandardItem \"\"\" user_type = QtGui . QStandardItem . ItemType . UserType return user_type . value if hasattr ( user_type , \"value\" ) else int ( user_type ) log \u00b6 log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . MessageLevel . Info if info else Qgis . MessageLevel . Warning if not isinstance ( message , str ): message = json . dumps ( todict ( message ), cls = CustomJsonEncoder ) QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , ) md5 \u00b6 md5 ( fname ) Get md5 checksum off a file Source code in src/cplus_plugin/utils.py 892 893 894 895 896 897 898 899 900 def md5 ( fname ): \"\"\" Get md5 checksum off a file \"\"\" hash_md5 = hashlib . md5 () with open ( fname , \"rb\" ) as f : for chunk in iter ( lambda : f . read ( 4096 ), b \"\" ): hash_md5 . update ( chunk ) return hash_md5 . hexdigest () normalize_raster \u00b6 normalize_raster ( input_raster_path , output_raster_path , processing_context = None , feedback = None ) Create a normalized input raster Parameters: Name Type Description Default input_raster_path str Input layer path required output_raster_path str Output layer path required processing_context QgsProcessingContext Qgis processing context None feedback QgsProcessingFeedback Qgis processing feedback None Source code in src/cplus_plugin/utils.py 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 def normalize_raster ( input_raster_path : str , output_raster_path : str , processing_context : QgsProcessingContext = None , feedback : QgsProcessingFeedback = None , ): \"\"\" Create a normalized input raster :param input_raster_path: Input layer path :type input_raster_path: str :param output_raster_path: Output layer path :type output_raster_path: str :param processing_context: Qgis processing context :type processing_context: QgsProcessingContext, default None :param feedback: Qgis processing feedback :type feedback: QgsProcessingFeedback \"\"\" try : input_raster_layer = QgsRasterLayer ( input_raster_path , \"Input Raster\" ) if not input_raster_layer . isValid (): return False , f \"Invalid raster layer { input_raster_path } \" provider = input_raster_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue if min_value is None or max_value is None : return False , f \"Raster layer has no valid statistics, { input_raster_path } \" if max_value < min_value : return ( False , f \"Layer cannot be normalized, min value { min_value } is greater than max value { max_value } \" , ) if min_value == 0 and max_value == 1 : return ( True , f \"Layer { input_raster_path } is already normalized (min= { min_value } , max= { max_value } )\" , ) expression = f \"(A - { min_value } ) / ( { max_value } - { min_value } )\" if min_value == max_value : # Treat layer as a constant raster when min and max value is equal expression = f \"(A / { min_value } )\" alg_params = { \"INPUT_A\" : input_raster_path , \"BAND_A\" : 1 , \"FORMULA\" : expression , \"OPTIONS\" : \"COMPRESS=DEFLATE|ZLEVEL=6|TILED=YES\" , \"OUTPUT\" : output_raster_path , } result = processing . run ( \"gdal:rastercalculator\" , alg_params , context = processing_context , feedback = feedback , ) if result . get ( \"OUTPUT\" ): return True , f \"Normalized raster saved to : { output_raster_path } \" except Exception as e : return False , f \"Problem normalizing raster, { e } \\n \" open_documentation \u00b6 open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 136 137 138 139 140 141 142 143 144 145 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result save_constant_raster_metadata \u00b6 save_constant_raster_metadata ( metadata , raster_dir ) Save metadata for a constant raster to a text file. Creates a .meta.txt file alongside the raster with information about how it was created. Parameters: Name Type Description Default metadata ConstantRasterFileMetadata ConstantRasterFileMetadata with all metadata information required raster_dir str Directory where the raster file is located required Returns: Type Description str Path to the metadata file Source code in src/cplus_plugin/utils.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def save_constant_raster_metadata ( metadata : ConstantRasterFileMetadata , raster_dir : str ) -> str : \"\"\"Save metadata for a constant raster to a text file. Creates a .meta.txt file alongside the raster with information about how it was created. :param metadata: ConstantRasterFileMetadata with all metadata information :type metadata: ConstantRasterFileMetadata :param raster_dir: Directory where the raster file is located :type raster_dir: str :returns: Path to the metadata file :rtype: str \"\"\" # Use raster_path from metadata if available, otherwise use component_name if metadata . raster_path : raster_basename = os . path . splitext ( os . path . basename ( metadata . raster_path ))[ 0 ] else : # When skip_raster=True, use component_name for metadata filename raster_basename = clean_filename ( metadata . component_name ) metadata_subfolder = os . path . join ( raster_dir , \"metadata\" ) os . makedirs ( metadata_subfolder , exist_ok = True ) meta_path = os . path . join ( metadata_subfolder , f \" { raster_basename } .txt\" ) return write_constant_raster_metadata_file ( metadata , meta_path ) todict \u00b6 todict ( obj , classkey = None ) Convert any object to dictionary Source code in src/cplus_plugin/utils.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def todict ( obj , classkey = None ): \"\"\" Convert any object to dictionary \"\"\" if isinstance ( obj , Enum ): return obj . value elif isinstance ( obj , dict ): data = {} for k , v in obj . items (): data [ k ] = todict ( v , classkey ) return data elif hasattr ( obj , \"_ast\" ): return todict ( obj . _ast ()) elif hasattr ( obj , \"__iter__\" ) and not isinstance ( obj , str ): return [ todict ( v , classkey ) for v in obj ] elif hasattr ( obj , \"__dict__\" ): data = dict ( [ ( key , todict ( value , classkey )) for key , value in obj . __dict__ . items () if not callable ( value ) and not key . startswith ( \"_\" ) ] ) if classkey is not None and hasattr ( obj , \"__class__\" ): data [ classkey ] = obj . __class__ . __name__ return data else : return obj tr \u00b6 tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message ( str , QString ) String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 83 84 85 86 87 88 89 90 91 92 93 94 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message ) transform_extent \u00b6 transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/utils.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def transform_extent ( extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent tree_item_user_type \u00b6 tree_item_user_type () Get QTreeWidgetItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QTreeWidgetItem Source code in src/cplus_plugin/utils.py 71 72 73 74 75 76 77 78 79 80 def tree_item_user_type (): \"\"\"Get QTreeWidgetItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QTreeWidgetItem \"\"\" user_type = QtWidgets . QTreeWidgetItem . ItemType . UserType return user_type . value if hasattr ( user_type , \"value\" ) else int ( user_type ) write_constant_raster_metadata_file \u00b6 write_constant_raster_metadata_file ( metadata , file_path ) Write constant raster metadata to a text file. Parameters: Name Type Description Default metadata ConstantRasterFileMetadata ConstantRasterFileMetadata instance with all metadata information required file_path str Path where the metadata file should be written required Returns: Type Description str Path to the metadata file that was written Source code in src/cplus_plugin/utils.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def write_constant_raster_metadata_file ( metadata : ConstantRasterFileMetadata , file_path : str ) -> str : \"\"\"Write constant raster metadata to a text file. :param metadata: ConstantRasterFileMetadata instance with all metadata information :type metadata: ConstantRasterFileMetadata :param file_path: Path where the metadata file should be written :type file_path: str :returns: Path to the metadata file that was written :rtype: str \"\"\" with open ( file_path , \"w\" ) as f : f . write ( metadata . to_text ()) return file_path zip_shapefile \u00b6 zip_shapefile ( shapefile_path ) Zip shapefile to an object with same name. For example, the .shp filename is test_file.shp , then the zip file name would be test_file.zip Parameters: Name Type Description Default shapefile_path str Path of the shapefile required Returns: Type Description str Zip file path if the specified shapefile_path ends with .shp, return shapefile_path otherwise Source code in src/cplus_plugin/utils.py 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 def zip_shapefile ( shapefile_path : str ) -> str : \"\"\"Zip shapefile to an object with same name. For example, the .shp filename is `test_file.shp`, then the zip file name would be `test_file.zip` :param shapefile_path: Path of the shapefile :type shapefile_path: str :return: Zip file path if the specified `shapefile_path` ends with .shp, return shapefile_path otherwise :rtype: str \"\"\" if shapefile_path . endswith ( \".shp\" ): output_dir = os . path . dirname ( shapefile_path ) filename_without_ext = os . path . splitext ( os . path . basename ( shapefile_path ))[ 0 ] zip_name = shapefile_path . replace ( \".shp\" , \".zip\" ) with ZipFile ( zip_name , \"w\" ) as zip : # writing each file one by one for file in [ f for f in os . listdir ( output_dir ) if filename_without_ext in f and not f . endswith ( \"zip\" ) ]: zip . write ( os . path . join ( output_dir , file ), file ) return zip_name return shapefile_path","title":"Utilities"},{"location":"developer/api/core/api_utils/#utilities","text":"Plugin utilities","title":"Utilities"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.CustomJsonEncoder","text":"Bases: JSONEncoder Custom JSON encoder which handles UUID and datetime","title":"CustomJsonEncoder"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils","text":"Provides functionality for commonly used file-related operations.","title":"FileUtils"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.copy_file","text":"copy_file ( file_path , target_dir , log_message = '' ) Copies file to the target directory Source code in src/cplus_plugin/utils.py 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 @staticmethod def copy_file ( file_path : str , target_dir : str , log_message : str = \"\" ): \"\"\"Copies file to the target directory\"\"\" p = Path ( file_path ) if not p . exists (): raise FileNotFoundError ( f \"File { file_path } does not exist\" ) target_path = Path ( target_dir ) / p . name if not target_path . parent . exists (): target_path . parent . mkdir ( parents = True ) shutil . copy ( p , target_path ) if not target_path . exists (): raise FileNotFoundError ( f \"Failed to copy file to { target_dir } \" ) return str ( target_path )","title":"copy_file"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_comparison_reports_dir","text":"create_comparison_reports_dir ( base_dir ) Creates a comparison reports subdirectory under the base directory. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 769 770 771 772 773 774 775 776 777 778 779 780 781 @staticmethod def create_comparison_reports_dir ( base_dir : str ): \"\"\"Creates a comparison reports subdirectory under the base directory. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return comparison_reports_dir = f \" { base_dir } / { COMPARISON_REPORT_SEGMENT } \" message = tr ( \"Missing parent directory when creating comparison reports subdirectory.\" ) FileUtils . create_new_dir ( comparison_reports_dir , message )","title":"create_comparison_reports_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_carbon_dir","text":"create_ncs_carbon_dir ( base_dir ) Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 783 784 785 786 787 788 789 790 791 792 793 @staticmethod def create_ncs_carbon_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory for carbon layers under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_carbon_dir = f \" { base_dir } / { NCS_CARBON_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS carbon subdirectory.\" ) FileUtils . create_new_dir ( ncs_carbon_dir , message )","title":"create_ncs_carbon_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_ncs_pathways_dir","text":"create_ncs_pathways_dir ( base_dir ) Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 740 741 742 743 744 745 746 747 748 749 750 751 752 @staticmethod def create_ncs_pathways_dir ( base_dir : str ): \"\"\"Creates an NCS subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return ncs_pathway_dir = f \" { base_dir } / { NCS_PATHWAY_SEGMENT } \" message = tr ( \"Missing parent directory when creating NCS pathways subdirectory.\" ) FileUtils . create_new_dir ( ncs_pathway_dir , message )","title":"create_ncs_pathways_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_new_dir","text":"create_new_dir ( directory , log_message = '' ) Creates new file directory if it doesn't exist Source code in src/cplus_plugin/utils.py 808 809 810 811 812 813 814 815 816 @staticmethod def create_new_dir ( directory : str , log_message : str = \"\" ): \"\"\"Creates new file directory if it doesn't exist\"\"\" p = Path ( directory ) if not p . exists (): try : p . mkdir ( parents = True , exist_ok = True ) except ( FileNotFoundError , OSError ): log ( log_message )","title":"create_new_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_new_file","text":"create_new_file ( file_path , log_message = '' ) Creates new file Source code in src/cplus_plugin/utils.py 818 819 820 821 822 823 824 825 826 827 @staticmethod def create_new_file ( file_path : str , log_message : str = \"\" ): \"\"\"Creates new file\"\"\" p = Path ( file_path ) if not p . exists (): try : p . touch ( exist_ok = True ) except FileNotFoundError : log ( log_message )","title":"create_new_file"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_npv_pwls_dir","text":"create_npv_pwls_dir ( base_dir ) Creates an NPV PWL subdirectory under PWL child directory in the base directory. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 754 755 756 757 758 759 760 761 762 763 764 765 766 767 @staticmethod def create_npv_pwls_dir ( base_dir : str ): \"\"\"Creates an NPV PWL subdirectory under PWL child directory in the base directory. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return npv_pwl_dir = ( f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { NPV_PRIORITY_LAYERS_SEGMENT } \" ) message = tr ( \"Missing parent directory when creating NPV PWLs subdirectory.\" ) FileUtils . create_new_dir ( npv_pwl_dir , message )","title":"create_npv_pwls_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.create_pwls_dir","text":"create_pwls_dir ( base_dir ) Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. Source code in src/cplus_plugin/utils.py 795 796 797 798 799 800 801 802 803 804 805 806 def create_pwls_dir ( base_dir : str ): \"\"\"Creates priority weighting layers subdirectory under BASE_DIR. Skips creation of the subdirectory if it already exists. \"\"\" if not Path ( base_dir ) . is_dir (): return pwl_dir = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } \" message = tr ( \"Missing parent directory when creating priority weighting layers subdirectory.\" ) FileUtils . create_new_dir ( pwl_dir , message )","title":"create_pwls_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_fonts_dir","text":"get_fonts_dir () Returns the fonts directory in the plugin. Returns: Type Description str Fonts directory. Source code in src/cplus_plugin/utils.py 665 666 667 668 669 670 671 672 @staticmethod def get_fonts_dir () -> str : \"\"\"Returns the fonts directory in the plugin. :returns: Fonts directory. :rtype: str \"\"\" return f \" { FileUtils . plugin_dir () } /data/fonts\"","title":"get_fonts_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_icon","text":"get_icon ( file_name ) Creates an icon based on the icon name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QIcon Icon object matching the file name. Source code in src/cplus_plugin/utils.py 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 @staticmethod def get_icon ( file_name : str ) -> QtGui . QIcon : \"\"\"Creates an icon based on the icon name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Icon object matching the file name. :rtype: QtGui.QIcon \"\"\" icon_path = FileUtils . get_icon_path ( file_name ) if not os . path . exists ( icon_path ): return QtGui . QIcon () return QtGui . QIcon ( icon_path )","title":"get_icon"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_icon_path","text":"get_icon_path ( file_name ) Gets the full path of the icon with the given name. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description str The full path to the icon in the plugin. Source code in src/cplus_plugin/utils.py 674 675 676 677 678 679 680 681 682 683 684 @staticmethod def get_icon_path ( file_name : str ) -> str : \"\"\"Gets the full path of the icon with the given name. :param file_name: File name which should include the extension. :type file_name: str :returns: The full path to the icon in the plugin. :rtype: str \"\"\" return os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" )","title":"get_icon_path"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.get_pixmap","text":"get_pixmap ( file_name ) Creates a pixmap based on the file name in the 'icons' folder. Parameters: Name Type Description Default file_name str File name which should include the extension. required Returns: Type Description QtGui.QPixmap Pixmap object matching the file name. Source code in src/cplus_plugin/utils.py 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 @staticmethod def get_pixmap ( file_name : str ) -> QtGui . QPixmap : \"\"\"Creates a pixmap based on the file name in the 'icons' folder. :param file_name: File name which should include the extension. :type file_name: str :returns: Pixmap object matching the file name. :rtype: QtGui.QPixmap \"\"\" pixmap_path = os . path . normpath ( f \" { FileUtils . plugin_dir () } /icons/ { file_name } \" ) if not os . path . exists ( pixmap_path ): return QtGui . QPixmap () return QtGui . QPixmap ( pixmap_path )","title":"get_pixmap"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.plugin_dir","text":"plugin_dir () Returns the root directory of the plugin. Returns: Type Description str Root directory of the plugin. Source code in src/cplus_plugin/utils.py 656 657 658 659 660 661 662 663 @staticmethod def plugin_dir () -> str : \"\"\"Returns the root directory of the plugin. :returns: Root directory of the plugin. :rtype: str \"\"\" return os . path . join ( os . path . dirname ( os . path . realpath ( __file__ )))","title":"plugin_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.FileUtils.report_template_path","text":"report_template_path ( file_name = None ) Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. Parameters: Name Type Description Default file_name str Template file name including the extension. If none is specified then it will use scenario_analysis_default.qpt as the default template name. None Returns: Type Description str The absolute path to the template file with the given name. Source code in src/cplus_plugin/utils.py 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 @staticmethod def report_template_path ( file_name = None ) -> str : \"\"\"Get the absolute path to the template file with the given name. Caller needs to verify that the file actually exists. :param file_name: Template file name including the extension. If none is specified then it will use `scenario_analysis_default.qpt` as the default template name. :type file_name: str :returns: The absolute path to the template file with the given name. :rtype: str \"\"\" if file_name is None : file_name = SCENARIO_ANALYSIS_TEMPLATE_NAME absolute_path = f \" { FileUtils . plugin_dir () } /data/report_templates/ { file_name } \" return os . path . normpath ( absolute_path )","title":"report_template_path"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.align_rasters","text":"align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 ) Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. Parameters: Name Type Description Default input_raster_source str Input layer source required reference_raster_source str Reference layer source required extent list Clip extent None output_dir str Absolute path of the output directory for the snapped layers None rescale_values bool Whether to rescale pixel values False resample_method ResampleAlg Method to use when resampling 0 Source code in src/cplus_plugin/utils.py 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 def align_rasters ( input_raster_source , reference_raster_source , extent = None , output_dir = None , rescale_values = False , resample_method = 0 , ): \"\"\" Based from work on https://github.com/inasafe/inasafe/pull/2070 Aligns the passed raster files source and save the results into new files. :param input_raster_source: Input layer source :type input_raster_source: str :param reference_raster_source: Reference layer source :type reference_raster_source: str :param extent: Clip extent :type extent: list :param output_dir: Absolute path of the output directory for the snapped layers :type output_dir: str :param rescale_values: Whether to rescale pixel values :type rescale_values: bool :param resample_method: Method to use when resampling :type resample_method: QgsAlignRaster.ResampleAlg \"\"\" try : snap_directory = os . path . join ( output_dir , \"snap_layers\" ) FileUtils . create_new_dir ( snap_directory ) input_path = Path ( input_raster_source ) input_layer_output = os . path . join ( f \" { snap_directory } \" , f \" { input_path . stem } _ { str ( uuid . uuid4 ())[: 4 ] } .tif\" ) FileUtils . create_new_file ( input_layer_output ) align = QgsAlignRaster () lst = [ QgsAlignRaster . Item ( input_raster_source , input_layer_output ), ] resample_method_value = QgsAlignRaster . ResampleAlg . RA_NearestNeighbour try : resample_method_value = QgsAlignRaster . ResampleAlg ( int ( resample_method )) except Exception as e : log ( f \"Problem creating a resample value when snapping, { e } \" ) if rescale_values : lst [ 0 ] . rescaleValues = rescale_values lst [ 0 ] . resample_method = resample_method_value align . setRasters ( lst ) align . setParametersFromRaster ( reference_raster_source ) layer = QgsRasterLayer ( input_raster_source , \"input_layer\" ) extent = transform_extent ( layer . extent (), QgsCoordinateReferenceSystem ( layer . crs ()), QgsCoordinateReferenceSystem ( align . destinationCrs ()), ) align . setClipExtent ( extent ) log ( f \"Snapping clip extent { layer . extent () . asWktPolygon () } \\n \" ) if not align . run (): log ( f \"Problem during snapping for { input_raster_source } and \" f \" { reference_raster_source } , { align . errorMessage () } \" ) raise Exception ( align . errorMessage ()) except Exception as e : log ( f \"Problem occured when snapping, { str ( e ) } .\" f \" Update snap settings and re-run the analysis\" ) return None , None log ( f \"Finished snapping\" f \" original layer - { input_raster_source } ,\" f \"snapped output - { input_layer_output } \\n \" ) return input_layer_output , None","title":"align_rasters"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.calculate_raster_area","text":"calculate_raster_area ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels for the given band in a raster layer. This varies from 'calculate_raster_area_by_pixel_value' in that it gives the total area instead of grouping by pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float The total area of value pixels of the raster else -1 if the raster is invalid or if it is empty. Pixels with NoData value are not included in the computation. Source code in src/cplus_plugin/utils.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def calculate_raster_area ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> float : \"\"\"Calculates the area of value pixels for the given band in a raster layer. This varies from 'calculate_raster_area_by_pixel_value' in that it gives the total area instead of grouping by pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: The total area of value pixels of the raster else -1 if the raster is invalid or if it is empty. Pixels with NoData value are not included in the computation. :rtype: float \"\"\" area_by_pixel_value = calculate_raster_area_by_pixel_value ( layer , band_number , feedback ) if len ( area_by_pixel_value ) == 0 : return - 1.0 # Remove NoData pixels from the computation, just in case the process # calculation might have sneaked it in. if layer . dataProvider () . sourceHasNoDataValue ( band_number ): no_data_value = layer . dataProvider () . sourceNoDataValue ( band_number ) if no_data_value in area_by_pixel_value : del area_by_pixel_value [ no_data_value ] return float ( sum ( area_by_pixel_value . values ()))","title":"calculate_raster_area"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.calculate_raster_area_by_pixel_value","text":"calculate_raster_area_by_pixel_value ( layer , band_number = 1 , feedback = None ) Calculates the area of value pixels in hectares for the given band in a raster layer and groups the area by the pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. Parameters: Name Type Description Default layer QgsRasterLayer Input layer whose area for value pixels is to be calculated. required band_number int Band number to compute area, default is band one. 1 feedback QgsProcessingFeedback Feedback object for progress during area calculation. None Returns: Type Description float A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. Source code in src/cplus_plugin/utils.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 def calculate_raster_area_by_pixel_value ( layer : QgsRasterLayer , band_number : int = 1 , feedback : QgsProcessingFeedback = None ) -> dict : \"\"\"Calculates the area of value pixels in hectares for the given band in a raster layer and groups the area by the pixel value. Please note that this function will run in the main application thread hence for best results, it is recommended to execute it in a background process if part of a bigger workflow. :param layer: Input layer whose area for value pixels is to be calculated. :type layer: QgsRasterLayer :param band_number: Band number to compute area, default is band one. :type band_number: int :param feedback: Feedback object for progress during area calculation. :type feedback: QgsProcessingFeedback :returns: A dictionary containing the pixel value as the key and the corresponding area in hectares as the value for all the pixels in the raster otherwise returns a empty dictionary if the raster is invalid or if it is empty. :rtype: float \"\"\" if not layer . isValid (): log ( \"Invalid layer for raster area calculation.\" , info = False ) return {} algorithm_name = \"native:rasterlayeruniquevaluesreport\" params = { \"INPUT\" : layer , \"BAND\" : band_number , \"OUTPUT_TABLE\" : \"TEMPORARY_OUTPUT\" , \"OUTPUT_HTML_FILE\" : QgsProcessing . TEMPORARY_OUTPUT , } algorithm_result = processing . run ( algorithm_name , params , feedback = feedback ) # Get number of pixels with values total_pixel_count = algorithm_result [ \"TOTAL_PIXEL_COUNT\" ] if total_pixel_count == 0 : log ( \"Input layer for raster area calculation is empty.\" , info = False ) return {} output_table = algorithm_result [ \"OUTPUT_TABLE\" ] if output_table is None : log ( \"Unique values raster table could not be retrieved.\" , info = False ) return {} area_calc = QgsDistanceArea () crs = layer . crs () area_calc . setSourceCrs ( crs , QgsCoordinateTransformContext ()) if crs is not None : # Use ellipsoid calculation if available area_calc . setEllipsoid ( crs . ellipsoidAcronym ()) version = Qgis . versionInt () if version < 33000 : unit_type = QgsUnitTypes . AreaUnit . AreaHectares else : unit_type = Qgis . AreaUnit . Hectares pixel_areas = {} features = output_table . getFeatures () for f in features : pixel_value = f . attribute ( 0 ) area = f . attribute ( 2 ) pixel_value_area = area_calc . convertAreaMeasurement ( area , unit_type ) pixel_areas [ pixel_value ] = pixel_value_area return pixel_areas","title":"calculate_raster_area_by_pixel_value"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.clean_filename","text":"clean_filename ( filename ) Creates a safe filename by removing operating system invalid filename characters. Parameters: Name Type Description Default filename str File name required Source code in src/cplus_plugin/utils.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def clean_filename ( filename ): \"\"\"Creates a safe filename by removing operating system invalid filename characters. :param filename: File name :type filename: str :returns A clean file name :rtype str \"\"\" characters = \" %:/,\\[]<>*?\" for character in characters : if character in filename : filename = filename . replace ( character , \"_\" ) return filename","title":"clean_filename"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.compress_raster","text":"compress_raster ( input_path , output_path = None , compression_type = 'DEFLATE' , compress_level = 6 , nodata_value = None , output_format = 'GTiff' , create_options = None , additional_options = None ) Compresses a raster file using GDAL and optionally replace old NoData pixel values with a new one. Parameters: Name Type Description Default input_path str Path to the input raster file required output_path str Path to the input raster file. If none the ouput will saved to a temporary file None compression_type str Compression algorithm (e.g., 'DEFLATE', 'LZW', 'PACKBITS', 'JPEG', 'NONE') 'DEFLATE' compress_level int Compression level (1-9 for DEFLATE/LZW, 1-100 for JPEG) 6 nodata_value float Value to set as nodata (default: None). If None, retain the input nodatavalue None output_format str Output format (default: 'GTiff' for GeoTIFF) 'GTiff' create_options list Additional GDAL creation options as a list None additional_options list dditional GDAL options as a list None Returns: Type Description str | None Path to the temporary file if successful, None if failed Source code in src/cplus_plugin/utils.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 def compress_raster ( input_path : str , output_path : str = None , compression_type : str = \"DEFLATE\" , compress_level : int = 6 , nodata_value : float = None , output_format : str = \"GTiff\" , create_options : list = None , additional_options : list = None , ): \"\"\" Compresses a raster file using GDAL and optionally replace old NoData pixel values with a new one. :param input_path: Path to the input raster file :type input_path: str :param output_path: Path to the input raster file. If none the ouput will saved to a temporary file :type output_path: str :param compression_type: Compression algorithm (e.g., 'DEFLATE', 'LZW', 'PACKBITS', 'JPEG', 'NONE') :type compression_type: str :param compress_level: Compression level (1-9 for DEFLATE/LZW, 1-100 for JPEG) :type compress_level: int :param nodata_value: Value to set as nodata (default: None). If None, retain the input nodatavalue :type nodata_value: float :param output_format: Output format (default: 'GTiff' for GeoTIFF) :type output_format: str :param create_options: Additional GDAL creation options as a list :type create_options: list :param additional_options: dditional GDAL options as a list :type additional_options: list :return: Path to the temporary file if successful, None if failed :rtype: str or None \"\"\" if not os . path . isfile ( input_path ): raise FileNotFoundError ( f \"Input raster file not found: { input_path } \" ) # Create a temporary file if output_path is None: if not output_path : unique_id = str ( uuid . uuid4 ())[: 8 ] temp_file = QtCore . QTemporaryFile ( os . path . join ( QgsProject . instance () . homePath (), f \"temp_compressed_ { unique_id } .tif\" ) ) if not temp_file . open (): log ( \"Error: Could not create temporary file\" ) return None base , ext = os . path . splitext ( input_path ) output_path = temp_file . fileName () + ext or \".tif\" temp_file . close () try : # Load the input raster layer using GDAL src_ds = gdal . Open ( input_path , gdal . GA_ReadOnly ) if src_ds is None : raise ValueError ( \"Unable to open raster with GDAL\" ) band_count = src_ds . RasterCount xsize = src_ds . RasterXSize ysize = src_ds . RasterYSize dtype = src_ds . GetRasterBand ( 1 ) . DataType compression = src_ds . GetMetadataItem ( \"COMPRESSION\" , \"IMAGE_STRUCTURE\" ) if compression . lower () == \"deflate\" : log ( f \"Raster { input_path } is already compressed with DEFLATE.\" ) return input_path # Add any additional create options if not create_options : create_options = [] # Ensure standard options are included create_options . extend ( [ f \"COMPRESS= { compression_type } \" , f \"ZLEVEL= { compress_level } \" , f \"JPEG_QUALITY= { compress_level } \" , f \"NUM_THREADS=ALL_CPUS\" , \"BIGTIFF=IF_SAFER\" , \"TILED=YES\" , ] ) # Set additional options if provided if additional_options : create_options . extend ( additional_options ) # Create compressed output raster driver = gdal . GetDriverByName ( output_format ) out_ds = driver . Create ( output_path , xsize , ysize , band_count , dtype , create_options ) out_ds . SetGeoTransform ( src_ds . GetGeoTransform ()) out_ds . SetProjection ( src_ds . GetProjection ()) for i in range ( 1 , band_count + 1 ): band = src_ds . GetRasterBand ( i ) data = band . ReadAsArray () old_nodata = band . GetNoDataValue () # Replace pixel values if old NoData exists if nodata_value is not None and old_nodata is not None : data = np . where ( data == old_nodata , nodata_value , data ) out_band = out_ds . GetRasterBand ( i ) out_band . WriteArray ( data ) out_band . SetNoDataValue ( nodata_value ) out_band . FlushCache () # Close datasets src_ds = None # if os.path.exists(output_path): log ( f \"Successfully compressed raster saved to temporary file: { output_path } \" ) return output_path except Exception as error : log ( f \"Error occurred during raster compression. Error code: { error } \" ) return None","title":"compress_raster"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.contains_font_family","text":"contains_font_family ( font_family ) Checks if the specified font family exists in the font database. Parameters: Name Type Description Default font_family str Name of the font family to check. required Returns: Type Description bool True if the font family exists, else False. Source code in src/cplus_plugin/utils.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def contains_font_family ( font_family : str ) -> bool : \"\"\"Checks if the specified font family exists in the font database. :param font_family: Name of the font family to check. :type font_family: str :returns: True if the font family exists, else False. :rtype: bool \"\"\" # Qt6 uses static method, some Qt5 versions use instance method try : font_families = QtGui . QFontDatabase . families () except TypeError : # Fallback for versions where families() is an instance method font_families = QtGui . QFontDatabase () . families () matching_fonts = [ family for family in font_families if font_family in family ] return True if len ( matching_fonts ) > 0 else False","title":"contains_font_family"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.convert_size","text":"convert_size ( size_bytes ) Convert byte size to human readable text. Parameters: Name Type Description Default size_bytes int byte sizse required Returns: Type Description str human readable text Source code in src/cplus_plugin/utils.py 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 def convert_size ( size_bytes ): \"\"\"Convert byte size to human readable text. :param size_bytes: byte sizse :type size_bytes: int :return: human readable text :rtype: str \"\"\" if size_bytes == 0 : return \"0B\" size_name = ( \"B\" , \"KB\" , \"MB\" , \"GB\" , \"TB\" , \"PB\" , \"EB\" , \"ZB\" , \"YB\" ) i = int ( math . floor ( math . log ( size_bytes , 1024 ))) p = math . pow ( 1024 , i ) s = round ( size_bytes / p , 2 ) return \" %s %s \" % ( s , size_name [ i ])","title":"convert_size"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.format_value_with_unit","text":"format_value_with_unit ( value , metadata_id ) Format a value with an appropriate unit suffix for filename. The unit is determined based on the metadata_id. Common patterns: - Years/experience: \"5years\", \"10years\" - Percentage: \"25pct\", \"50pct\" - Weight: \"10kg\", \"25kg\" - Default: \"12p50\" (12.50 with decimal point as 'p') Parameters: Name Type Description Default value float The numeric value required metadata_id str Metadata ID to determine the appropriate unit required Returns: Type Description str Formatted string like \"5years\", \"10pct\", \"25kg\" Source code in src/cplus_plugin/utils.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def format_value_with_unit ( value : float , metadata_id : str ) -> str : \"\"\"Format a value with an appropriate unit suffix for filename. The unit is determined based on the metadata_id. Common patterns: - Years/experience: \"5years\", \"10years\" - Percentage: \"25pct\", \"50pct\" - Weight: \"10kg\", \"25kg\" - Default: \"12p50\" (12.50 with decimal point as 'p') :param value: The numeric value :type value: float :param metadata_id: Metadata ID to determine the appropriate unit :type metadata_id: str :returns: Formatted string like \"5years\", \"10pct\", \"25kg\" :rtype: str \"\"\" if \"year\" in metadata_id . lower () or \"experience\" in metadata_id . lower (): return f \" { int ( value ) } years\" elif \"percent\" in metadata_id . lower () or \"pct\" in metadata_id . lower (): return f \" { int ( value ) } pct\" elif \"weight\" in metadata_id . lower () or \"kg\" in metadata_id . lower (): return f \" { int ( value ) } kg\" else : return f \" { value : .2f } \" . replace ( \".\" , \"p\" )","title":"format_value_with_unit"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.function_help_to_html","text":"function_help_to_html ( function_name , description , arguments = None , examples = None ) Creates a HTML string containing the detailed help of an expression function. The specific HTML formatting is deduced from the code here: https://github.com/qgis/QGIS/blob/master/src/core/expression/qgsexpression.cpp#L565 Parameters: Name Type Description Default function_name str Name of the expression function. required description str Detailed description of the function. required arguments List [ tuple ] List containing the arguments. Each argument should consist of a tuple containing three elements i.e. argument name, description and bool where True will indicate the argument is optional. Take note of the order as mandatory arguments should be first in the list. None examples List [ tuple ] Examples of using the function. Each item in the list should be a tuple containing an example expression and the corresponding return value. None Returns: Type Description str The expression function's help in HTML for use in, for example, an expression builder. Source code in src/cplus_plugin/utils.py 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 def function_help_to_html ( function_name : str , description : str , arguments : typing . List [ tuple ] = None , examples : typing . List [ tuple ] = None , ) -> str : \"\"\"Creates a HTML string containing the detailed help of an expression function. The specific HTML formatting is deduced from the code here: https://github.com/qgis/QGIS/blob/master/src/core/expression/qgsexpression.cpp#L565 :param function_name: Name of the expression function. :type function_name: str :param description: Detailed description of the function. :type description: str :param arguments: List containing the arguments. Each argument should consist of a tuple containing three elements i.e. argument name, description and bool where True will indicate the argument is optional. Take note of the order as mandatory arguments should be first in the list. :type arguments: typing.List[tuple] :param examples: Examples of using the function. Each item in the list should be a tuple containing an example expression and the corresponding return value. :type examples: typing.List[tuple] :returns: The expression function's help in HTML for use in, for example, an expression builder. :rtype: str \"\"\" if arguments is None : arguments = [] if examples is None : examples = [] html_segments = [] # Title html_segments . append ( f \"<h3>function { function_name } </h3> \\n \" ) # Description html_segments . append ( f '<div class=\"description\"><p> { description } </p></div>' ) # Syntax html_segments . append ( f '<h4>Syntax</h4> \\n <div class=\"syntax\"> \\n <code>' f '<span class=\"functionname\"> { function_name } </span>' f \"(\" ) has_optional = False separator = \"\" for arg in arguments : arg_name = arg [ 0 ] arg_mandatory = arg [ 2 ] if not has_optional and arg_mandatory : html_segments . append ( \"[\" ) has_optional = True html_segments . append ( separator ) html_segments . append ( f '<span class=\"argument\"> { arg_name } </span>' ) if arg_mandatory : html_segments . append ( \"]\" ) separator = \",\" html_segments . append ( \")</code>\" ) if has_optional : html_segments . append ( \"<br/><br/>[ ] marks optional components\" ) # Arguments if len ( arguments ) > 0 : html_segments . append ( '<h4>Arguments</h4> \\n <div class=\"arguments\"> \\n <table>' ) for arg in arguments : arg_name = arg [ 0 ] arg_description = arg [ 1 ] html_segments . append ( f '<tr><td class=\"argument\"> { arg_name } </td><td> { arg_description } </td></tr>' ) html_segments . append ( \"</table> \\n </div> \\n \" ) # Examples if len ( examples ) > 0 : html_segments . append ( '<h4>Examples</h4> \\n <div class=\"examples\"> \\n <ul> \\n ' ) for example in examples : expression = example [ 0 ] return_value = example [ 1 ] html_segments . append ( f \"<li><code> { expression } </code> &rarr; <code> { return_value } </code>\" ) html_segments . append ( \"</ul> \\n </div> \\n \" ) return \"\" . join ( html_segments )","title":"function_help_to_html"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.generate_constant_raster_filename","text":"generate_constant_raster_filename ( component_name , value , metadata_id ) Generate a descriptive filename for a constant raster. Follows the pattern: {sanitized_component_name}_{value_with_unit}.tif Example outputs: - \"agroforestry_5years.tif\" - \"corn_production_25pct.tif\" - \"animal_management_10kg.tif\" Parameters: Name Type Description Default component_name str Name of the pathway/activity required value float The constant value for this raster required metadata_id str Metadata ID to determine the value unit required Returns: Type Description str Safe filename with extension Source code in src/cplus_plugin/utils.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def generate_constant_raster_filename ( component_name : str , value : float , metadata_id : str ) -> str : \"\"\"Generate a descriptive filename for a constant raster. Follows the pattern: {sanitized_component_name}_{value_with_unit}.tif Example outputs: - \"agroforestry_5years.tif\" - \"corn_production_25pct.tif\" - \"animal_management_10kg.tif\" :param component_name: Name of the pathway/activity :type component_name: str :param value: The constant value for this raster :type value: float :param metadata_id: Metadata ID to determine the value unit :type metadata_id: str :returns: Safe filename with extension :rtype: str \"\"\" safe_name = clean_filename ( component_name ) value_str = format_value_with_unit ( value , metadata_id ) return f \" { safe_name } _ { value_str } .tif\"","title":"generate_constant_raster_filename"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.generate_random_color","text":"generate_random_color () Generate a random color object using a system-seeded deterministic approach. Returns: Type Description QColor A random generated color. Source code in src/cplus_plugin/utils.py 465 466 467 468 469 470 471 472 def generate_random_color () -> QtGui . QColor : \"\"\"Generate a random color object using a system-seeded deterministic approach. :returns: A random generated color. :rtype: QColor \"\"\" return QtGui . QColor . fromRgb ( QtCore . QRandomGenerator . global_ () . generate ())","title":"generate_random_color"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_constant_raster_dir","text":"get_constant_raster_dir ( base_dir , component_type , metadata_id ) Get the directory path for constant rasters. Creates a hierarchical directory structure: {base_dir}/{component_type}/{raster_type}/ Parameters: Name Type Description Default base_dir str Base directory (e.g., \"BASE_DIR/constant_rasters\") required component_type ModelComponentType Type of model component (NCS_PATHWAY or ACTIVITY) required metadata_id str Raster type ID (e.g., \"years_experience_pathway\") required Returns: Type Description str Full path to the constant raster directory Source code in src/cplus_plugin/utils.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def get_constant_raster_dir ( base_dir : str , component_type : ModelComponentType , metadata_id : str ) -> str : \"\"\"Get the directory path for constant rasters. Creates a hierarchical directory structure: {base_dir}/{component_type}/{raster_type}/ :param base_dir: Base directory (e.g., \"BASE_DIR/constant_rasters\") :type base_dir: str :param component_type: Type of model component (NCS_PATHWAY or ACTIVITY) :type component_type: ModelComponentType :param metadata_id: Raster type ID (e.g., \"years_experience_pathway\") :type metadata_id: str :returns: Full path to the constant raster directory :rtype: str \"\"\" if component_type == ModelComponentType . NCS_PATHWAY : type_dir = \"ncs_pathway\" elif component_type == ModelComponentType . ACTIVITY : type_dir = \"activity\" else : type_dir = \"unknown\" raster_type = metadata_id if raster_type . endswith ( \"_pathway\" ) or raster_type . endswith ( \"_activity\" ): raster_type = \"_\" . join ( raster_type . split ( \"_\" )[: - 1 ]) return os . path . join ( base_dir , type_dir , raster_type )","title":"get_constant_raster_dir"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_layer_type","text":"get_layer_type ( file_path ) Get layer type code from file path Source code in src/cplus_plugin/utils.py 903 904 905 906 907 908 909 910 911 912 913 def get_layer_type ( file_path : str ): \"\"\" Get layer type code from file path \"\"\" file_name , file_extension = os . path . splitext ( file_path ) if file_extension . lower () in [ \".tif\" , \".tiff\" ]: return 0 elif file_extension . lower () in [ \".geojson\" , \".zip\" , \".shp\" ]: return 1 else : return - 1","title":"get_layer_type"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_plugin_version","text":"get_plugin_version () Returns the current plugin version as saved in the metadata.txt plugin file. Returns: Type Description str Plugin version Source code in src/cplus_plugin/utils.py 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_plugin_version () -> [ str , None ]: \"\"\"Returns the current plugin version as saved in the metadata.txt plugin file. :returns version: Plugin version :rtype version: str \"\"\" metadata_file = Path ( __file__ ) . parent . resolve () / \"metadata.txt\" with open ( metadata_file , \"r\" ) as f : for line in f . readlines (): if line . startswith ( \"version\" ): version = line . strip () . split ( \"=\" )[ 1 ] return version return None","title":"get_plugin_version"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.get_report_font","text":"get_report_font ( size = 11.0 , bold = False , italic = False ) Uses the default font family name to create a font for use in the report. Parameters: Name Type Description Default size float The font point size, default is 11. 11.0 bold bool True for bold font else False which is the default. False italic bool True for font to be in italics else False which is the default. False Returns: Type Description QtGui.QFont Font to use in a report. Source code in src/cplus_plugin/utils.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def get_report_font ( size = 11.0 , bold = False , italic = False ) -> QtGui . QFont : \"\"\"Uses the default font family name to create a font for use in the report. :param size: The font point size, default is 11. :type size: float :param bold: True for bold font else False which is the default. :type bold: bool :param italic: True for font to be in italics else False which is the default. :type italic: bool :returns: Font to use in a report. :rtype: QtGui.QFont \"\"\" font_weight = 50 if bold is True : font_weight = 75 return QtGui . QFont ( REPORT_FONT_NAME , int ( size ), font_weight , italic )","title":"get_report_font"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.install_font","text":"install_font ( dir_name ) Installs the font families in the specified folder name under the plugin's 'fonts' folder. Parameters: Name Type Description Default dir_name str Directory name, under the 'fonts' folder, which contains the font families to be installed. required Returns: Type Description bool True if the font(s) were successfully installed, else False if the directory name does not exist or if the given font families already exist in the application's font database. Source code in src/cplus_plugin/utils.py 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 def install_font ( dir_name : str ) -> bool : \"\"\"Installs the font families in the specified folder name under the plugin's 'fonts' folder. :param dir_name: Directory name, under the 'fonts' folder, which contains the font families to be installed. :type dir_name: str :returns: True if the font(s) were successfully installed, else False if the directory name does not exist or if the given font families already exist in the application's font database. :rtype: bool \"\"\" font_family_dir = os . path . normpath ( f \" { FileUtils . get_fonts_dir () } / { dir_name } \" ) if not os . path . exists ( font_family_dir ): tr_msg = tr ( \"font directory does not exist.\" ) log ( message = f \"' { dir_name } ' { tr_msg } \" , info = False ) return False status = True font_paths = Path ( font_family_dir ) . glob ( \"**/*\" ) font_extensions = [ \".otf\" , \".ttf\" ] for font_path in font_paths : if font_path . suffix not in font_extensions : continue font_id = QtGui . QFontDatabase . addApplicationFont ( font_path . as_posix ()) if font_id == - 1 and status : tr_msg = \"font could not be installed.\" log ( message = f \"' { font_path } ' { tr_msg } \" , info = False ) status = False return status","title":"install_font"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.item_user_type","text":"item_user_type () Get QStandardItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QStandardItem Source code in src/cplus_plugin/utils.py 59 60 61 62 63 64 65 66 67 68 def item_user_type (): \"\"\"Get QStandardItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QStandardItem \"\"\" user_type = QtGui . QStandardItem . ItemType . UserType return user_type . value if hasattr ( user_type , \"value\" ) else int ( user_type )","title":"item_user_type"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.log","text":"log ( message , name = 'qgis_cplus' , info = True , notify = True ) Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. Parameters: Name Type Description Default message str The log message required name str Name of te log instance, qgis_cplus is the default 'qgis_cplus' info bool Whether the message is about info or a warning True notify bool Whether to notify user about the log True Source code in src/cplus_plugin/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def log ( message : str , name : str = \"qgis_cplus\" , info : bool = True , notify : bool = True , ): \"\"\"Logs the message into QGIS logs using qgis_cplus as the default log instance. If notify_user is True, user will be notified about the log. :param message: The log message :type message: str :param name: Name of te log instance, qgis_cplus is the default :type message: str :param info: Whether the message is about info or a warning :type info: bool :param notify: Whether to notify user about the log :type notify: bool \"\"\" level = Qgis . MessageLevel . Info if info else Qgis . MessageLevel . Warning if not isinstance ( message , str ): message = json . dumps ( todict ( message ), cls = CustomJsonEncoder ) QgsMessageLog . logMessage ( message , name , level = level , notifyUser = notify , )","title":"log"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.md5","text":"md5 ( fname ) Get md5 checksum off a file Source code in src/cplus_plugin/utils.py 892 893 894 895 896 897 898 899 900 def md5 ( fname ): \"\"\" Get md5 checksum off a file \"\"\" hash_md5 = hashlib . md5 () with open ( fname , \"rb\" ) as f : for chunk in iter ( lambda : f . read ( 4096 ), b \"\" ): hash_md5 . update ( chunk ) return hash_md5 . hexdigest ()","title":"md5"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.normalize_raster","text":"normalize_raster ( input_raster_path , output_raster_path , processing_context = None , feedback = None ) Create a normalized input raster Parameters: Name Type Description Default input_raster_path str Input layer path required output_raster_path str Output layer path required processing_context QgsProcessingContext Qgis processing context None feedback QgsProcessingFeedback Qgis processing feedback None Source code in src/cplus_plugin/utils.py 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 def normalize_raster ( input_raster_path : str , output_raster_path : str , processing_context : QgsProcessingContext = None , feedback : QgsProcessingFeedback = None , ): \"\"\" Create a normalized input raster :param input_raster_path: Input layer path :type input_raster_path: str :param output_raster_path: Output layer path :type output_raster_path: str :param processing_context: Qgis processing context :type processing_context: QgsProcessingContext, default None :param feedback: Qgis processing feedback :type feedback: QgsProcessingFeedback \"\"\" try : input_raster_layer = QgsRasterLayer ( input_raster_path , \"Input Raster\" ) if not input_raster_layer . isValid (): return False , f \"Invalid raster layer { input_raster_path } \" provider = input_raster_layer . dataProvider () band_statistics = provider . bandStatistics ( 1 ) min_value = band_statistics . minimumValue max_value = band_statistics . maximumValue if min_value is None or max_value is None : return False , f \"Raster layer has no valid statistics, { input_raster_path } \" if max_value < min_value : return ( False , f \"Layer cannot be normalized, min value { min_value } is greater than max value { max_value } \" , ) if min_value == 0 and max_value == 1 : return ( True , f \"Layer { input_raster_path } is already normalized (min= { min_value } , max= { max_value } )\" , ) expression = f \"(A - { min_value } ) / ( { max_value } - { min_value } )\" if min_value == max_value : # Treat layer as a constant raster when min and max value is equal expression = f \"(A / { min_value } )\" alg_params = { \"INPUT_A\" : input_raster_path , \"BAND_A\" : 1 , \"FORMULA\" : expression , \"OPTIONS\" : \"COMPRESS=DEFLATE|ZLEVEL=6|TILED=YES\" , \"OUTPUT\" : output_raster_path , } result = processing . run ( \"gdal:rastercalculator\" , alg_params , context = processing_context , feedback = feedback , ) if result . get ( \"OUTPUT\" ): return True , f \"Normalized raster saved to : { output_raster_path } \" except Exception as e : return False , f \"Problem normalizing raster, { e } \\n \"","title":"normalize_raster"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.open_documentation","text":"open_documentation ( url = None ) Opens documentation website in the default browser Parameters: Name Type Description Default url str URL link to documentation site (e.g. gh pages site) None Source code in src/cplus_plugin/utils.py 136 137 138 139 140 141 142 143 144 145 def open_documentation ( url = None ): \"\"\"Opens documentation website in the default browser :param url: URL link to documentation site (e.g. gh pages site) :type url: str \"\"\" url = DOCUMENTATION_SITE if url is None else url result = QtGui . QDesktopServices . openUrl ( QtCore . QUrl ( url )) return result","title":"open_documentation"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.save_constant_raster_metadata","text":"save_constant_raster_metadata ( metadata , raster_dir ) Save metadata for a constant raster to a text file. Creates a .meta.txt file alongside the raster with information about how it was created. Parameters: Name Type Description Default metadata ConstantRasterFileMetadata ConstantRasterFileMetadata with all metadata information required raster_dir str Directory where the raster file is located required Returns: Type Description str Path to the metadata file Source code in src/cplus_plugin/utils.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def save_constant_raster_metadata ( metadata : ConstantRasterFileMetadata , raster_dir : str ) -> str : \"\"\"Save metadata for a constant raster to a text file. Creates a .meta.txt file alongside the raster with information about how it was created. :param metadata: ConstantRasterFileMetadata with all metadata information :type metadata: ConstantRasterFileMetadata :param raster_dir: Directory where the raster file is located :type raster_dir: str :returns: Path to the metadata file :rtype: str \"\"\" # Use raster_path from metadata if available, otherwise use component_name if metadata . raster_path : raster_basename = os . path . splitext ( os . path . basename ( metadata . raster_path ))[ 0 ] else : # When skip_raster=True, use component_name for metadata filename raster_basename = clean_filename ( metadata . component_name ) metadata_subfolder = os . path . join ( raster_dir , \"metadata\" ) os . makedirs ( metadata_subfolder , exist_ok = True ) meta_path = os . path . join ( metadata_subfolder , f \" { raster_basename } .txt\" ) return write_constant_raster_metadata_file ( metadata , meta_path )","title":"save_constant_raster_metadata"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.todict","text":"todict ( obj , classkey = None ) Convert any object to dictionary Source code in src/cplus_plugin/utils.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 def todict ( obj , classkey = None ): \"\"\" Convert any object to dictionary \"\"\" if isinstance ( obj , Enum ): return obj . value elif isinstance ( obj , dict ): data = {} for k , v in obj . items (): data [ k ] = todict ( v , classkey ) return data elif hasattr ( obj , \"_ast\" ): return todict ( obj . _ast ()) elif hasattr ( obj , \"__iter__\" ) and not isinstance ( obj , str ): return [ todict ( v , classkey ) for v in obj ] elif hasattr ( obj , \"__dict__\" ): data = dict ( [ ( key , todict ( value , classkey )) for key , value in obj . __dict__ . items () if not callable ( value ) and not key . startswith ( \"_\" ) ] ) if classkey is not None and hasattr ( obj , \"__class__\" ): data [ classkey ] = obj . __class__ . __name__ return data else : return obj","title":"todict"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.tr","text":"tr ( message ) Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. Parameters: Name Type Description Default message ( str , QString ) String for translation. required Returns: Type Description QString Translated version of message. Source code in src/cplus_plugin/utils.py 83 84 85 86 87 88 89 90 91 92 93 94 def tr ( message ): \"\"\"Get the translation for a string using Qt translation API. We implement this ourselves since we do not inherit QObject. :param message: String for translation. :type message: str, QString :returns: Translated version of message. :rtype: QString \"\"\" # noinspection PyTypeChecker,PyArgumentList,PyCallByClass return QtCore . QCoreApplication . translate ( \"QgisCplus\" , message )","title":"tr"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.transform_extent","text":"transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/utils.py 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 def transform_extent ( extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"transform_extent"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.tree_item_user_type","text":"tree_item_user_type () Get QTreeWidgetItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QTreeWidgetItem Source code in src/cplus_plugin/utils.py 71 72 73 74 75 76 77 78 79 80 def tree_item_user_type (): \"\"\"Get QTreeWidgetItem.UserType in Qt5/Qt6 compatible way. Uses Qt6-style ItemType.UserType which works in both Qt5 and Qt6. Returns: int: The user type value for QTreeWidgetItem \"\"\" user_type = QtWidgets . QTreeWidgetItem . ItemType . UserType return user_type . value if hasattr ( user_type , \"value\" ) else int ( user_type )","title":"tree_item_user_type"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.write_constant_raster_metadata_file","text":"write_constant_raster_metadata_file ( metadata , file_path ) Write constant raster metadata to a text file. Parameters: Name Type Description Default metadata ConstantRasterFileMetadata ConstantRasterFileMetadata instance with all metadata information required file_path str Path where the metadata file should be written required Returns: Type Description str Path to the metadata file that was written Source code in src/cplus_plugin/utils.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def write_constant_raster_metadata_file ( metadata : ConstantRasterFileMetadata , file_path : str ) -> str : \"\"\"Write constant raster metadata to a text file. :param metadata: ConstantRasterFileMetadata instance with all metadata information :type metadata: ConstantRasterFileMetadata :param file_path: Path where the metadata file should be written :type file_path: str :returns: Path to the metadata file that was written :rtype: str \"\"\" with open ( file_path , \"w\" ) as f : f . write ( metadata . to_text ()) return file_path","title":"write_constant_raster_metadata_file"},{"location":"developer/api/core/api_utils/#src.cplus_plugin.utils.zip_shapefile","text":"zip_shapefile ( shapefile_path ) Zip shapefile to an object with same name. For example, the .shp filename is test_file.shp , then the zip file name would be test_file.zip Parameters: Name Type Description Default shapefile_path str Path of the shapefile required Returns: Type Description str Zip file path if the specified shapefile_path ends with .shp, return shapefile_path otherwise Source code in src/cplus_plugin/utils.py 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 def zip_shapefile ( shapefile_path : str ) -> str : \"\"\"Zip shapefile to an object with same name. For example, the .shp filename is `test_file.shp`, then the zip file name would be `test_file.zip` :param shapefile_path: Path of the shapefile :type shapefile_path: str :return: Zip file path if the specified `shapefile_path` ends with .shp, return shapefile_path otherwise :rtype: str \"\"\" if shapefile_path . endswith ( \".shp\" ): output_dir = os . path . dirname ( shapefile_path ) filename_without_ext = os . path . splitext ( os . path . basename ( shapefile_path ))[ 0 ] zip_name = shapefile_path . replace ( \".shp\" , \".zip\" ) with ZipFile ( zip_name , \"w\" ) as zip : # writing each file one by one for file in [ f for f in os . listdir ( output_dir ) if filename_without_ext in f and not f . endswith ( \"zip\" ) ]: zip . write ( os . path . join ( output_dir , file ), file ) return zip_name return shapefile_path","title":"zip_shapefile"},{"location":"developer/api/core/api_validation_configs/","text":"Validation Configurations \u00b6 Configurations for validation rules.","title":"Configurations"},{"location":"developer/api/core/api_validation_configs/#validation-configurations","text":"Configurations for validation rules.","title":"Validation Configurations"},{"location":"developer/api/core/api_validation_feedback/","text":"Validation Feedback \u00b6 Feedback object that provides the ability to update on the rule validation process. ValidationFeedback \u00b6 ValidationFeedback ( * args , ** kwargs ) Bases: QgsFeedback Feedback object that provides the ability to update the rule validation process. Source code in src/cplus_plugin/lib/validation/feedback.py 26 27 28 29 30 31 32 33 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . progressChanged . connect ( self . _on_total_progress_changed ) self . _rule_info = None self . _rule_progress = - 1.0 self . _validation_complete = False current_rule property writable \u00b6 current_rule Gets the current rule info being executed. Returns: Type Description RuleInfo Returns the current rule being executed or None if the feedback object has not been activated. is_validation_complete property \u00b6 is_validation_complete Indicates whether the full validation (i.e. NOT rule validation) is complete. Returns: Type Description bool True if the full validation is complete, else False. rule_progress property writable \u00b6 rule_progress Gets the current progress of the rule validation being executed. Returns: Type Description float Percentage value between 0.0 and 100.0.","title":"Feedback"},{"location":"developer/api/core/api_validation_feedback/#validation-feedback","text":"Feedback object that provides the ability to update on the rule validation process.","title":"Validation Feedback"},{"location":"developer/api/core/api_validation_feedback/#src.cplus_plugin.lib.validation.feedback.ValidationFeedback","text":"ValidationFeedback ( * args , ** kwargs ) Bases: QgsFeedback Feedback object that provides the ability to update the rule validation process. Source code in src/cplus_plugin/lib/validation/feedback.py 26 27 28 29 30 31 32 33 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . progressChanged . connect ( self . _on_total_progress_changed ) self . _rule_info = None self . _rule_progress = - 1.0 self . _validation_complete = False","title":"ValidationFeedback"},{"location":"developer/api/core/api_validation_feedback/#src.cplus_plugin.lib.validation.feedback.ValidationFeedback.current_rule","text":"current_rule Gets the current rule info being executed. Returns: Type Description RuleInfo Returns the current rule being executed or None if the feedback object has not been activated.","title":"current_rule"},{"location":"developer/api/core/api_validation_feedback/#src.cplus_plugin.lib.validation.feedback.ValidationFeedback.is_validation_complete","text":"is_validation_complete Indicates whether the full validation (i.e. NOT rule validation) is complete. Returns: Type Description bool True if the full validation is complete, else False.","title":"is_validation_complete"},{"location":"developer/api/core/api_validation_feedback/#src.cplus_plugin.lib.validation.feedback.ValidationFeedback.rule_progress","text":"rule_progress Gets the current progress of the rule validation being executed. Returns: Type Description float Percentage value between 0.0 and 100.0.","title":"rule_progress"},{"location":"developer/api/core/api_validation_manager/","text":"Validation Manager \u00b6 Manager for data validation processes. ValidationManager \u00b6 ValidationManager ( parent = None ) Bases: QObject Manages the validation process including starting, cancelling or getting the status of running validation tasks. Source code in src/cplus_plugin/lib/validation/manager.py 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , parent = None ): super () . __init__ ( parent ) # Data validator (value) indexed by task id (key) self . _validation_tasks = {} # Validation results (value) indexed by task id (key) self . _validation_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_validation_status_changed ) cancel \u00b6 cancel ( result ) Cancels a validation process matching the result of the submission. Parameters: Name Type Description Default result SubmitResult Result of the validation submission. required Returns: Type Description bool True if the validation task was successfully cancelled else False if the submit results status was not successful or if the validation task was not found. Source code in src/cplus_plugin/lib/validation/manager.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def cancel ( self , result : SubmitResult ) -> bool : \"\"\"Cancels a validation process matching the result of the submission. :param result: Result of the validation submission. :type result: SubmitResult :returns: True if the validation task was successfully cancelled else False if the submit results status was not successful or if the validation task was not found. :rtype: bool \"\"\" if not result . success : return False if result . identifier not in self . _validation_tasks : return False validator = self . _validation_tasks [ result . identifier ] validator . cancel () del self . _validation_tasks [ result . identifier ] return True cancel_ncs_validation \u00b6 cancel_ncs_validation () Cancel all validation processes of NCS pathway datasets. Source code in src/cplus_plugin/lib/validation/manager.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def cancel_ncs_validation ( self ): \"\"\"Cancel all validation processes of NCS pathway datasets.\"\"\" for task_id in list ( self . _validation_tasks ): ncs_validator = self . _validation_tasks [ task_id ] # In some OSs, the underlying C++ task object is de-referenced # unexpectedly hence the need to check if it exists. if sip . isdeleted ( ncs_validator ): continue status = ncs_validator . status () if ( status == QgsTask . TaskStatus . Running or status == QgsTask . TaskStatus . Queued or status == QgsTask . TaskStatus . OnHold ): ncs_validator . cancel () del self . _validation_tasks [ task_id ] is_validation_complete \u00b6 is_validation_complete ( result ) Checks whether the validation process, based on the given submission result, is complete. Parameters: Name Type Description Default result SubmitResult Result of the request for validation. required Returns: Type Description bool True if the validation process is complete, else False if it is still in progress or has failed. Source code in src/cplus_plugin/lib/validation/manager.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def is_validation_complete ( self , result : SubmitResult ) -> bool : \"\"\"Checks whether the validation process, based on the given submission result, is complete. :param result: Result of the request for validation. :type result: SubmitResult :returns: True if the validation process is complete, else False if it is still in progress or has failed. :rtype: bool \"\"\" if not result . success : return False if result . identifier in self . _validation_results : return True return False last_ncs_result \u00b6 last_ncs_result () Gets the result of the last successful validation of NCS pathways. Returns: Type Description ValidationResult Result of the last successful NCS pathway validation. Source code in src/cplus_plugin/lib/validation/manager.py 222 223 224 225 226 227 228 229 230 231 232 def last_ncs_result ( self ) -> typing . Union [ ValidationResult , None ]: \"\"\"Gets the result of the last successful validation of NCS pathways. :returns: Result of the last successful NCS pathway validation. :rtype: ValidationResult \"\"\" ncs_results = self . ncs_results () if len ( ncs_results ) == 0 : return None return ncs_results [ len ( ncs_results ) - 1 ] ncs_results \u00b6 ncs_results () Gets the validation results for NCS pathways. Returns: Type Description list A list containing the validation results for NCS pathways or an empty list if no results are found. Source code in src/cplus_plugin/lib/validation/manager.py 213 214 215 216 217 218 219 220 def ncs_results ( self ) -> typing . List [ ValidationResult ]: \"\"\"Gets the validation results for NCS pathways. :returns: A list containing the validation results for NCS pathways or an empty list if no results are found. :rtype: list \"\"\" return self . results_by_component_type ( ModelComponentType . NCS_PATHWAY ) on_validation_status_changed \u00b6 on_validation_status_changed ( task_id , status ) Slot raised when the status of a validation task has changed. This function will emit when the validation task has started, when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/validation/manager.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def on_validation_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a validation task has changed. This function will emit when the validation task has started, when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" if status == QgsTask . TaskStatus . Running : self . validation_started . emit ( str ( task_id )) elif status == QgsTask . TaskStatus . Complete : if str ( task_id ) not in self . _validation_tasks : return # Get result validator = self . task_manager . task ( task_id ) result = validator . result if result is not None : self . _validation_results [ str ( task_id )] = result # Remove task if str ( task_id ) in self . _validation_tasks : del self . _validation_tasks [ str ( task_id )] self . validation_completed . emit ( str ( task_id )) results_by_component_type \u00b6 results_by_component_type ( component_type ) Gets the validation results based on the model component type of the validator. Parameters: Name Type Description Default component_type ModelComponentType Model component type e.g. NCS pathway. required Returns: Type Description list A list containing the validation results for the given model component type or an empty list if no results are found. Source code in src/cplus_plugin/lib/validation/manager.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def results_by_component_type ( self , component_type : ModelComponentType ) -> typing . List [ ValidationResult ]: \"\"\"Gets the validation results based on the model component type of the validator. :param component_type: Model component type e.g. NCS pathway. :type component_type: ModelComponentType :returns: A list containing the validation results for the given model component type or an empty list if no results are found. :rtype: list \"\"\" if component_type == ModelComponentType . UNKNOWN : return [] return [ result for result in self . _validation_results . values () if result . component_type == component_type ] validate_ncs_pathways \u00b6 validate_ncs_pathways ( pathways , cancel_running = True ) Validates a set of NcsPathway datasets and returns the status of the submission. Parameters: Name Type Description Default pathways List [ NcsPathway ] A list of NcsPathway objects to be validated. At least one NcsPathway is required for the validation process to be executed. required cancel_running bool True if any running validation processes are to be cancelled else False if multiple concurrent validation processes are to be executed. True Returns: Type Description SubmitResult Result object containing the task id and status of the submission. Source code in src/cplus_plugin/lib/validation/manager.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def validate_ncs_pathways ( self , pathways : typing . List [ NcsPathway ], cancel_running = True ) -> SubmitResult : \"\"\"Validates a set of NcsPathway datasets and returns the status of the submission. :param pathways: A list of NcsPathway objects to be validated. At least one NcsPathway is required for the validation process to be executed. :type pathways: list :param cancel_running: True if any running validation processes are to be cancelled else False if multiple concurrent validation processes are to be executed. :type cancel_running: bool :returns: Result object containing the task id and status of the submission. :rtype: SubmitResult \"\"\" if len ( pathways ) == 0 : return SubmitResult ( \"\" , False , None ) if cancel_running : self . cancel_ncs_validation () # Clone the pathways cloned_pathways = list ( map ( clone_ncs_pathway , pathways )) ncs_validator = NcsDataValidator () ncs_validator . model_components = cloned_pathways task_id = self . task_manager . addTask ( ncs_validator ) if task_id == 0 : return SubmitResult ( \"\" , False , None ) self . _validation_tasks [ str ( task_id )] = ncs_validator return SubmitResult ( str ( task_id ), True , ncs_validator . feedback ) validation_result \u00b6 validation_result ( result ) Gets the validation result based on the given submission result. Parameters: Name Type Description Default result SubmitResult Result of the request for validation. required Returns: Type Description ValidationResult Validation result if the process was complete else None if the submission or actual validation process failed. Source code in src/cplus_plugin/lib/validation/manager.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def validation_result ( self , result : SubmitResult ) -> typing . Union [ None , ValidationResult ]: \"\"\"Gets the validation result based on the given submission result. :param result: Result of the request for validation. :type result: SubmitResult :returns: Validation result if the process was complete else None if the submission or actual validation process failed. :rtype: ValidationResult \"\"\" if not result . success : return None if result . identifier not in self . _validation_results : return None return self . _validation_results [ result . identifier ]","title":"Manager"},{"location":"developer/api/core/api_validation_manager/#validation-manager","text":"Manager for data validation processes.","title":"Validation Manager"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager","text":"ValidationManager ( parent = None ) Bases: QObject Manages the validation process including starting, cancelling or getting the status of running validation tasks. Source code in src/cplus_plugin/lib/validation/manager.py 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , parent = None ): super () . __init__ ( parent ) # Data validator (value) indexed by task id (key) self . _validation_tasks = {} # Validation results (value) indexed by task id (key) self . _validation_results = {} self . task_manager = QgsApplication . instance () . taskManager () self . task_manager . statusChanged . connect ( self . on_validation_status_changed )","title":"ValidationManager"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.cancel","text":"cancel ( result ) Cancels a validation process matching the result of the submission. Parameters: Name Type Description Default result SubmitResult Result of the validation submission. required Returns: Type Description bool True if the validation task was successfully cancelled else False if the submit results status was not successful or if the validation task was not found. Source code in src/cplus_plugin/lib/validation/manager.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def cancel ( self , result : SubmitResult ) -> bool : \"\"\"Cancels a validation process matching the result of the submission. :param result: Result of the validation submission. :type result: SubmitResult :returns: True if the validation task was successfully cancelled else False if the submit results status was not successful or if the validation task was not found. :rtype: bool \"\"\" if not result . success : return False if result . identifier not in self . _validation_tasks : return False validator = self . _validation_tasks [ result . identifier ] validator . cancel () del self . _validation_tasks [ result . identifier ] return True","title":"cancel"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.cancel_ncs_validation","text":"cancel_ncs_validation () Cancel all validation processes of NCS pathway datasets. Source code in src/cplus_plugin/lib/validation/manager.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def cancel_ncs_validation ( self ): \"\"\"Cancel all validation processes of NCS pathway datasets.\"\"\" for task_id in list ( self . _validation_tasks ): ncs_validator = self . _validation_tasks [ task_id ] # In some OSs, the underlying C++ task object is de-referenced # unexpectedly hence the need to check if it exists. if sip . isdeleted ( ncs_validator ): continue status = ncs_validator . status () if ( status == QgsTask . TaskStatus . Running or status == QgsTask . TaskStatus . Queued or status == QgsTask . TaskStatus . OnHold ): ncs_validator . cancel () del self . _validation_tasks [ task_id ]","title":"cancel_ncs_validation"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.is_validation_complete","text":"is_validation_complete ( result ) Checks whether the validation process, based on the given submission result, is complete. Parameters: Name Type Description Default result SubmitResult Result of the request for validation. required Returns: Type Description bool True if the validation process is complete, else False if it is still in progress or has failed. Source code in src/cplus_plugin/lib/validation/manager.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 def is_validation_complete ( self , result : SubmitResult ) -> bool : \"\"\"Checks whether the validation process, based on the given submission result, is complete. :param result: Result of the request for validation. :type result: SubmitResult :returns: True if the validation process is complete, else False if it is still in progress or has failed. :rtype: bool \"\"\" if not result . success : return False if result . identifier in self . _validation_results : return True return False","title":"is_validation_complete"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.last_ncs_result","text":"last_ncs_result () Gets the result of the last successful validation of NCS pathways. Returns: Type Description ValidationResult Result of the last successful NCS pathway validation. Source code in src/cplus_plugin/lib/validation/manager.py 222 223 224 225 226 227 228 229 230 231 232 def last_ncs_result ( self ) -> typing . Union [ ValidationResult , None ]: \"\"\"Gets the result of the last successful validation of NCS pathways. :returns: Result of the last successful NCS pathway validation. :rtype: ValidationResult \"\"\" ncs_results = self . ncs_results () if len ( ncs_results ) == 0 : return None return ncs_results [ len ( ncs_results ) - 1 ]","title":"last_ncs_result"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.ncs_results","text":"ncs_results () Gets the validation results for NCS pathways. Returns: Type Description list A list containing the validation results for NCS pathways or an empty list if no results are found. Source code in src/cplus_plugin/lib/validation/manager.py 213 214 215 216 217 218 219 220 def ncs_results ( self ) -> typing . List [ ValidationResult ]: \"\"\"Gets the validation results for NCS pathways. :returns: A list containing the validation results for NCS pathways or an empty list if no results are found. :rtype: list \"\"\" return self . results_by_component_type ( ModelComponentType . NCS_PATHWAY )","title":"ncs_results"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.on_validation_status_changed","text":"on_validation_status_changed ( task_id , status ) Slot raised when the status of a validation task has changed. This function will emit when the validation task has started, when it has completed successfully or terminated due to an error. Parameters: Name Type Description Default task_id int ID of the task. required status TaskStatus New task status. required Source code in src/cplus_plugin/lib/validation/manager.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def on_validation_status_changed ( self , task_id : int , status : QgsTask . TaskStatus ): \"\"\"Slot raised when the status of a validation task has changed. This function will emit when the validation task has started, when it has completed successfully or terminated due to an error. :param task_id: ID of the task. :type task_id: int :param status: New task status. :type status: QgsTask.TaskStatus \"\"\" if status == QgsTask . TaskStatus . Running : self . validation_started . emit ( str ( task_id )) elif status == QgsTask . TaskStatus . Complete : if str ( task_id ) not in self . _validation_tasks : return # Get result validator = self . task_manager . task ( task_id ) result = validator . result if result is not None : self . _validation_results [ str ( task_id )] = result # Remove task if str ( task_id ) in self . _validation_tasks : del self . _validation_tasks [ str ( task_id )] self . validation_completed . emit ( str ( task_id ))","title":"on_validation_status_changed"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.results_by_component_type","text":"results_by_component_type ( component_type ) Gets the validation results based on the model component type of the validator. Parameters: Name Type Description Default component_type ModelComponentType Model component type e.g. NCS pathway. required Returns: Type Description list A list containing the validation results for the given model component type or an empty list if no results are found. Source code in src/cplus_plugin/lib/validation/manager.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def results_by_component_type ( self , component_type : ModelComponentType ) -> typing . List [ ValidationResult ]: \"\"\"Gets the validation results based on the model component type of the validator. :param component_type: Model component type e.g. NCS pathway. :type component_type: ModelComponentType :returns: A list containing the validation results for the given model component type or an empty list if no results are found. :rtype: list \"\"\" if component_type == ModelComponentType . UNKNOWN : return [] return [ result for result in self . _validation_results . values () if result . component_type == component_type ]","title":"results_by_component_type"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.validate_ncs_pathways","text":"validate_ncs_pathways ( pathways , cancel_running = True ) Validates a set of NcsPathway datasets and returns the status of the submission. Parameters: Name Type Description Default pathways List [ NcsPathway ] A list of NcsPathway objects to be validated. At least one NcsPathway is required for the validation process to be executed. required cancel_running bool True if any running validation processes are to be cancelled else False if multiple concurrent validation processes are to be executed. True Returns: Type Description SubmitResult Result object containing the task id and status of the submission. Source code in src/cplus_plugin/lib/validation/manager.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def validate_ncs_pathways ( self , pathways : typing . List [ NcsPathway ], cancel_running = True ) -> SubmitResult : \"\"\"Validates a set of NcsPathway datasets and returns the status of the submission. :param pathways: A list of NcsPathway objects to be validated. At least one NcsPathway is required for the validation process to be executed. :type pathways: list :param cancel_running: True if any running validation processes are to be cancelled else False if multiple concurrent validation processes are to be executed. :type cancel_running: bool :returns: Result object containing the task id and status of the submission. :rtype: SubmitResult \"\"\" if len ( pathways ) == 0 : return SubmitResult ( \"\" , False , None ) if cancel_running : self . cancel_ncs_validation () # Clone the pathways cloned_pathways = list ( map ( clone_ncs_pathway , pathways )) ncs_validator = NcsDataValidator () ncs_validator . model_components = cloned_pathways task_id = self . task_manager . addTask ( ncs_validator ) if task_id == 0 : return SubmitResult ( \"\" , False , None ) self . _validation_tasks [ str ( task_id )] = ncs_validator return SubmitResult ( str ( task_id ), True , ncs_validator . feedback )","title":"validate_ncs_pathways"},{"location":"developer/api/core/api_validation_manager/#src.cplus_plugin.lib.validation.manager.ValidationManager.validation_result","text":"validation_result ( result ) Gets the validation result based on the given submission result. Parameters: Name Type Description Default result SubmitResult Result of the request for validation. required Returns: Type Description ValidationResult Validation result if the process was complete else None if the submission or actual validation process failed. Source code in src/cplus_plugin/lib/validation/manager.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def validation_result ( self , result : SubmitResult ) -> typing . Union [ None , ValidationResult ]: \"\"\"Gets the validation result based on the given submission result. :param result: Result of the request for validation. :type result: SubmitResult :returns: Validation result if the process was complete else None if the submission or actual validation process failed. :rtype: ValidationResult \"\"\" if not result . success : return None if result . identifier not in self . _validation_results : return None return self . _validation_results [ result . identifier ]","title":"validation_result"},{"location":"developer/api/core/api_validation_validators/","text":"Data Validators \u00b6 Aggregated and individual rule validators. BaseRuleValidator \u00b6 BaseRuleValidator ( configuration , feedback ) Validator for an individual rule. This is an abstract class that needs to be subclassed with the specific validation implementation by overriding the validate protected function. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () feedback property \u00b6 feedback Returns the feedback object used in the validator for providing feedback on the validation process. Returns: Type Description ValidationFeedback Feedback object used in the validator for providing feedback on the validation process. result property \u00b6 result Returns the result of the validation process. Returns: Type Description RuleResult Result of the validation process. rule_configuration property \u00b6 rule_configuration Returns the rule configuration use in the validator. Returns: Type Description RuleConfiguration Rule configuration used in the validator. rule_type abstractmethod property \u00b6 rule_type Returns the type identifier of the rule validator. Returns: Type Description RuleType Type identifier of the rule validator. get_default_layer_metadata \u00b6 get_default_layer_metadata ( layer_uuid , layer_type = 'ncs_pathway' ) Get default layer metadata Parameters: Name Type Description Default layer_uuid str UUID of the layer required layer_type str Type of the layer e.g. ncs_pathway 'ncs_pathway' Returns: Type Description typing.Dict Layer metadata Source code in src/cplus_plugin/lib/validation/validators.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def get_default_layer_metadata ( self , layer_uuid : str , layer_type : str = \"ncs_pathway\" ) -> typing . Dict : \"\"\"Get default layer metadata :param layer_uuid: UUID of the layer :type layer_uuid: str :param layer_type: Type of the layer e.g. ncs_pathway :type layer_type: str :return: Layer metadata :rtype: typing.Dict \"\"\" layers = settings_manager . get_default_layers ( layer_type , as_dict = True ) layer = layers . get ( layer_uuid ) layer_metadata = layer . get ( \"metadata\" , {}) return layer_metadata is_comparative \u00b6 is_comparative () Indicate whether the validation check is comparative i.e. relative to the datasets or an absolute check. The former requires more than one dataset to execute the validation whereas the latter can be executed even for one dataset. Returns: Type Description bool True if the validator is comparative else False. Default is True. Source code in src/cplus_plugin/lib/validation/validators.py 124 125 126 127 128 129 130 131 132 133 134 def is_comparative ( self ) -> bool : \"\"\"Indicate whether the validation check is comparative i.e. relative to the datasets or an absolute check. The former requires more than one dataset to execute the validation whereas the latter can be executed even for one dataset. :returns: True if the validator is comparative else False. Default is True. :rtype: bool \"\"\" return True log \u00b6 log ( message , info = True ) Convenience function that logs the given messages by appending the information in the rule configuration. Parameters: Name Type Description Default message str Message to be logged. required info bool False if the message should be logged as a warning else True if information. True Source code in src/cplus_plugin/lib/validation/validators.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def log ( self , message : str , info : bool = True ): \"\"\"Convenience function that logs the given messages by appending the information in the rule configuration. :param message: Message to be logged. :type message: str :param info: False if the message should be logged as a warning else True if information. :type info: bool \"\"\" msg = f \" { self . _config . rule_name } - { message } \" log ( message = msg , info = info ) run \u00b6 run () Initiates the rule validation process and returns a result indicating whether the process succeeded or failed. A fail result would, for instance, be due to no layers, or only one layer, defined for validation. Returns: Type Description bool True if the validation process succeeded or False if it failed. Source code in src/cplus_plugin/lib/validation/validators.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def run ( self ) -> bool : \"\"\"Initiates the rule validation process and returns a result indicating whether the process succeeded or failed. A fail result would, for instance, be due to no layers, or only one layer, defined for validation. :returns: True if the validation process succeeded or False if it failed. :rtype: bool \"\"\" if len ( self . model_components ) == 0 : msg = tr ( \"No datasets for validation.\" ) self . log ( msg , False ) return False return self . _validate () CarbonLayerResolutionValidator \u00b6 CarbonLayerResolutionValidator ( configuration , feedback ) Bases: ResolutionValidator Checks if the resolution of the carbon layers matches that of the corresponding NCS pathways. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator. is_comparative \u00b6 is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 1043 1044 1045 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False CrsValidator \u00b6 CrsValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets have the same CRS. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the CRS rule validator. Returns: Type Description RuleType CRS rule validator. DataValidator \u00b6 DataValidator ( model_components = None ) Bases: QgsTask Abstract runner for checking a set of datasets against specific validation rules. Rule validators need to be added manually in the sub-class implementation and set the model component type of the result. Source code in src/cplus_plugin/lib/validation/validators.py 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def __init__ ( self , model_components = None ): super () . __init__ ( tr ( self . NAME )) self . model_components = [] if model_components is not None : self . model_components = model_components self . _result : ValidationResult = None self . _rule_validators = [] self . _applicable_rule_validators = [] self . _feedback = ValidationFeedback () self . _feedback . rule_progress_changed . connect ( self . _on_rule_progress_changed ) self . _feedback . rule_validation_completed . connect ( self . _on_rule_validation_completed ) # Used to calculate the overall progress self . _rule_reference_progress = 0 feedback property \u00b6 feedback Returns the feedback object used in the validator for providing feedback on the validation process. Returns: Type Description ValidationFeedback Feedback object used in the validator for providing feedback on the validation process. result property \u00b6 result Returns the result of the validation process. Returns: Type Description ValidationResult Result of the validation process. add_rule_validator \u00b6 add_rule_validator ( rule_validator ) Add a rule validator for validating the input model components. Parameters: Name Type Description Default rule_validator BaseRuleValidator Validator for checking the input model components based on the specific validation rule. required Source code in src/cplus_plugin/lib/validation/validators.py 1388 1389 1390 1391 1392 1393 1394 1395 def add_rule_validator ( self , rule_validator : BaseRuleValidator ): \"\"\"Add a rule validator for validating the input model components. :param rule_validator: Validator for checking the input model components based on the specific validation rule. :type rule_validator: BaseRuleValidator \"\"\" self . _rule_validators . append ( rule_validator ) cancel \u00b6 cancel () Cancel the validation process. Source code in src/cplus_plugin/lib/validation/validators.py 1291 1292 1293 1294 1295 1296 1297 def cancel ( self ): \"\"\"Cancel the validation process.\"\"\" self . log ( tr ( \"Validation process has been cancelled.\" )) self . _feedback . cancel () super () . cancel () create_rule_validator staticmethod \u00b6 create_rule_validator ( rule_type , config , feedback ) Factory method for creating a rule validator object. Parameters: Name Type Description Default rule_type RuleType The type of the validator rule. required config RuleConfiguration The context information for configuring the rule validator. required feedback ValidationFeedback Feedback object for reporting progress. required Returns: Type Description BaseRuleValidator An instance of the specific rule validator. Source code in src/cplus_plugin/lib/validation/validators.py 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 @staticmethod def create_rule_validator ( rule_type : RuleType , config : RuleConfiguration , feedback : ValidationFeedback ) -> BaseRuleValidator : \"\"\"Factory method for creating a rule validator object. :param rule_type: The type of the validator rule. :type rule_type: RuleType :param config: The context information for configuring the rule validator. :type rule_type: RuleConfiguration :param feedback: Feedback object for reporting progress. :type feedback: ValidationFeedback :returns: An instance of the specific rule validator. :rtype: BaseRuleValidator \"\"\" validator_cls = DataValidator . validator_cls_by_type ( rule_type ) return validator_cls ( config , feedback ) finished \u00b6 finished ( result ) Depending on the outcome of the validation process, validation_completed signal will be emitted only if the validation was successful. The result attribute will also contain the validation result object. If an error occurred during the validation process, the validation result object will be None. Parameters: Name Type Description Default result bool True if the validation process was successful, else False. required Source code in src/cplus_plugin/lib/validation/validators.py 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 def finished ( self , result : bool ): \"\"\"Depending on the outcome of the validation process, `validation_completed` signal will be emitted only if the validation was successful. The `result` attribute will also contain the validation result object. If an error occurred during the validation process, the validation result object will be None. :param result: True if the validation process was successful, else False. :type result: bool \"\"\" if result : rule_results = [ rule_validator . result for rule_validator in self . _applicable_rule_validators ] self . _result = ValidationResult ( rule_results , self . MODEL_COMPONENT_TYPE ) self . _feedback . validation_completed . emit ( self . _result ) self . log ( \"Validation complete.\" ) log \u00b6 log ( message , info = True ) Convenience function that logs the given messages by appending the information for the validator. Parameters: Name Type Description Default message str Message to be logged. required info bool False if the message should be logged as a warning else True if information. True Source code in src/cplus_plugin/lib/validation/validators.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 def log ( self , message : str , info : bool = True ): \"\"\"Convenience function that logs the given messages by appending the information for the validator. :param message: Message to be logged. :type message: str :param info: False if the message should be logged as a warning else True if information. :type info: bool \"\"\" msg = f \" { self . NAME } - { message } \" log ( message = msg , info = info ) rule_validators staticmethod \u00b6 rule_validators () Returns all the rule validator classes, any new validator type needs to be added here. The validator classes are indexed by their corresponding rule type enum. Returns: Type Description dict Collection containing rule validator classes indexed by their corresponding rule types. Source code in src/cplus_plugin/lib/validation/validators.py 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @staticmethod def rule_validators () -> typing . Dict [ RuleType , typing . Type [ BaseRuleValidator ]]: \"\"\"Returns all the rule validator classes, any new validator type needs to be added here. The validator classes are indexed by their corresponding rule type enum. :returns: Collection containing rule validator classes indexed by their corresponding rule types. :rtype: dict \"\"\" return { RuleType . DATA_TYPE : RasterValidator , RuleType . CRS : CrsValidator , RuleType . NO_DATA_VALUE : NoDataValueValidator , RuleType . RESOLUTION : ResolutionValidator , RuleType . PROJECTED_CRS : ProjectedCrsValidator , RuleType . NORMALIZED : NormalizedValidator , } run \u00b6 run () Initiates the validation process based on the specified validators and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the validation process succeeded or False if it failed. Source code in src/cplus_plugin/lib/validation/validators.py 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 def run ( self ) -> bool : \"\"\"Initiates the validation process based on the specified validators and returns a result indicating whether the process succeeded or failed. :returns: True if the validation process succeeded or False if it failed. :rtype: bool \"\"\" if len ( self . _rule_validators ) == 0 : msg = tr ( \"No rule validators specified.\" ) self . log ( msg , False ) return False if len ( self . model_components ) == 0 : msg = tr ( \"At least one dataset is required for the validation process.\" ) self . log ( msg , False ) return False status = True try : status = self . _validate () except Exception as ex : exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . log ( exc_info , False ) status = False return status validator_cls_by_type staticmethod \u00b6 validator_cls_by_type ( rule_type ) Gets the rule validator class based on the corresponding rule type. Parameters: Name Type Description Default rule_type RuleType The type of the validator rule. required Returns: Type Description BaseRuleValidator The rule validator class corresponding to the given rule type. Source code in src/cplus_plugin/lib/validation/validators.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 @staticmethod def validator_cls_by_type ( rule_type : RuleType ) -> typing . Type [ BaseRuleValidator ]: \"\"\"Gets the rule validator class based on the corresponding rule type. :param rule_type: The type of the validator rule. :type rule_type: RuleType :returns: The rule validator class corresponding to the given rule type. :rtype: BaseRuleValidator \"\"\" return DataValidator . rule_validators ()[ rule_type ] NcsDataValidator \u00b6 NcsDataValidator ( * args , ** kwargs ) Bases: DataValidator Validates both NCS pathway and carbon layer datasets. The resolution check for carbon layers is tagged as a warning rather than an error. Source code in src/cplus_plugin/lib/validation/validators.py 1425 1426 1427 1428 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . model_components = kwargs . pop ( \"ncs_pathways\" , list ) self . _initialize_rule_validators () NoDataValueValidator \u00b6 NoDataValueValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if applicable input datasets have the same no data value. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator. is_comparative \u00b6 is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 696 697 698 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False NormalizedValidator \u00b6 NormalizedValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the values of input datasets are between the range 0 - 1. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the normalized value rule validator. Returns: Type Description RuleType Normalized value rule validator. is_comparative \u00b6 is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 1156 1157 1158 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False ProjectedCrsValidator \u00b6 ProjectedCrsValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets have a projected CRS. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the projected CRS rule validator. Returns: Type Description RuleType Projected CRS rule validator. is_comparative \u00b6 is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 569 570 571 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False RasterValidator \u00b6 RasterValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets are raster layers. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the raster type rule validator. Returns: Type Description RuleType Raster type rule validator. is_comparative \u00b6 is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 260 261 262 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False ResolutionValidator \u00b6 ResolutionValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if datasets have the same spatial resolution. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list () rule_type property \u00b6 rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator. create_resolution_definition classmethod \u00b6 create_resolution_definition ( layer ) Creates a resolution definition tuple from a layer. Parameters: Name Type Description Default layer QgsRasterLayer Input layer. required Returns: Type Description tuple Tuple containing x and y resolutions as well as the units. Source code in src/cplus_plugin/lib/validation/validators.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 @classmethod def create_resolution_definition ( cls , layer : QgsRasterLayer ): \"\"\"Creates a resolution definition tuple from a layer. :param layer: Input layer. :type layer: QgsRasterLayer :returns: Tuple containing x and y resolutions as well as the units. :rtype: tuple \"\"\" crs = layer . crs () if crs is None : crs_unit_str = tr ( \"unknown\" ) else : crs_unit_str = QgsUnitTypes . toAbbreviatedString ( crs . mapUnits ()) # Tuple containing x, y (truncated to given decimal places) and units resolution_definition = ( round ( layer . rasterUnitsPerPixelX (), cls . DECIMAL_PLACES ), round ( layer . rasterUnitsPerPixelY (), cls . DECIMAL_PLACES ), crs_unit_str , ) return resolution_definition resolution_definition_to_str classmethod \u00b6 resolution_definition_to_str ( resolution_definition ) Formats the resolution definition to a friendly-display string. Parameters: Name Type Description Default resolution_definition tuple Tuple containing x and y resolutions as well as the units. required Returns: Type Description str Friendly display string. Source code in src/cplus_plugin/lib/validation/validators.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 @classmethod def resolution_definition_to_str ( cls , resolution_definition : tuple ) -> str : \"\"\"Formats the resolution definition to a friendly-display string. :param resolution_definition: Tuple containing x and y resolutions as well as the units. :type resolution_definition: tuple :returns: Friendly display string. :rtype: str \"\"\" if len ( resolution_definition ) < 3 : return \"\" unit_str = ( tr ( \"unknown units\" ) if not resolution_definition [ 2 ] else resolution_definition [ 2 ] ) return f \"X: { resolution_definition [ 0 ] !s} { unit_str } , Y: { resolution_definition [ 1 ] !s} { unit_str } \"","title":"Validators"},{"location":"developer/api/core/api_validation_validators/#data-validators","text":"Aggregated and individual rule validators.","title":"Data Validators"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator","text":"BaseRuleValidator ( configuration , feedback ) Validator for an individual rule. This is an abstract class that needs to be subclassed with the specific validation implementation by overriding the validate protected function. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"BaseRuleValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.feedback","text":"feedback Returns the feedback object used in the validator for providing feedback on the validation process. Returns: Type Description ValidationFeedback Feedback object used in the validator for providing feedback on the validation process.","title":"feedback"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.result","text":"result Returns the result of the validation process. Returns: Type Description RuleResult Result of the validation process.","title":"result"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.rule_configuration","text":"rule_configuration Returns the rule configuration use in the validator. Returns: Type Description RuleConfiguration Rule configuration used in the validator.","title":"rule_configuration"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.rule_type","text":"rule_type Returns the type identifier of the rule validator. Returns: Type Description RuleType Type identifier of the rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.get_default_layer_metadata","text":"get_default_layer_metadata ( layer_uuid , layer_type = 'ncs_pathway' ) Get default layer metadata Parameters: Name Type Description Default layer_uuid str UUID of the layer required layer_type str Type of the layer e.g. ncs_pathway 'ncs_pathway' Returns: Type Description typing.Dict Layer metadata Source code in src/cplus_plugin/lib/validation/validators.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def get_default_layer_metadata ( self , layer_uuid : str , layer_type : str = \"ncs_pathway\" ) -> typing . Dict : \"\"\"Get default layer metadata :param layer_uuid: UUID of the layer :type layer_uuid: str :param layer_type: Type of the layer e.g. ncs_pathway :type layer_type: str :return: Layer metadata :rtype: typing.Dict \"\"\" layers = settings_manager . get_default_layers ( layer_type , as_dict = True ) layer = layers . get ( layer_uuid ) layer_metadata = layer . get ( \"metadata\" , {}) return layer_metadata","title":"get_default_layer_metadata"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.is_comparative","text":"is_comparative () Indicate whether the validation check is comparative i.e. relative to the datasets or an absolute check. The former requires more than one dataset to execute the validation whereas the latter can be executed even for one dataset. Returns: Type Description bool True if the validator is comparative else False. Default is True. Source code in src/cplus_plugin/lib/validation/validators.py 124 125 126 127 128 129 130 131 132 133 134 def is_comparative ( self ) -> bool : \"\"\"Indicate whether the validation check is comparative i.e. relative to the datasets or an absolute check. The former requires more than one dataset to execute the validation whereas the latter can be executed even for one dataset. :returns: True if the validator is comparative else False. Default is True. :rtype: bool \"\"\" return True","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.log","text":"log ( message , info = True ) Convenience function that logs the given messages by appending the information in the rule configuration. Parameters: Name Type Description Default message str Message to be logged. required info bool False if the message should be logged as a warning else True if information. True Source code in src/cplus_plugin/lib/validation/validators.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def log ( self , message : str , info : bool = True ): \"\"\"Convenience function that logs the given messages by appending the information in the rule configuration. :param message: Message to be logged. :type message: str :param info: False if the message should be logged as a warning else True if information. :type info: bool \"\"\" msg = f \" { self . _config . rule_name } - { message } \" log ( message = msg , info = info )","title":"log"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.BaseRuleValidator.run","text":"run () Initiates the rule validation process and returns a result indicating whether the process succeeded or failed. A fail result would, for instance, be due to no layers, or only one layer, defined for validation. Returns: Type Description bool True if the validation process succeeded or False if it failed. Source code in src/cplus_plugin/lib/validation/validators.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 def run ( self ) -> bool : \"\"\"Initiates the rule validation process and returns a result indicating whether the process succeeded or failed. A fail result would, for instance, be due to no layers, or only one layer, defined for validation. :returns: True if the validation process succeeded or False if it failed. :rtype: bool \"\"\" if len ( self . model_components ) == 0 : msg = tr ( \"No datasets for validation.\" ) self . log ( msg , False ) return False return self . _validate ()","title":"run"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.CarbonLayerResolutionValidator","text":"CarbonLayerResolutionValidator ( configuration , feedback ) Bases: ResolutionValidator Checks if the resolution of the carbon layers matches that of the corresponding NCS pathways. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"CarbonLayerResolutionValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.CarbonLayerResolutionValidator.rule_type","text":"rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.CarbonLayerResolutionValidator.is_comparative","text":"is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 1043 1044 1045 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.CrsValidator","text":"CrsValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets have the same CRS. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"CrsValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.CrsValidator.rule_type","text":"rule_type Returns the CRS rule validator. Returns: Type Description RuleType CRS rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator","text":"DataValidator ( model_components = None ) Bases: QgsTask Abstract runner for checking a set of datasets against specific validation rules. Rule validators need to be added manually in the sub-class implementation and set the model component type of the result. Source code in src/cplus_plugin/lib/validation/validators.py 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 def __init__ ( self , model_components = None ): super () . __init__ ( tr ( self . NAME )) self . model_components = [] if model_components is not None : self . model_components = model_components self . _result : ValidationResult = None self . _rule_validators = [] self . _applicable_rule_validators = [] self . _feedback = ValidationFeedback () self . _feedback . rule_progress_changed . connect ( self . _on_rule_progress_changed ) self . _feedback . rule_validation_completed . connect ( self . _on_rule_validation_completed ) # Used to calculate the overall progress self . _rule_reference_progress = 0","title":"DataValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.feedback","text":"feedback Returns the feedback object used in the validator for providing feedback on the validation process. Returns: Type Description ValidationFeedback Feedback object used in the validator for providing feedback on the validation process.","title":"feedback"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.result","text":"result Returns the result of the validation process. Returns: Type Description ValidationResult Result of the validation process.","title":"result"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.add_rule_validator","text":"add_rule_validator ( rule_validator ) Add a rule validator for validating the input model components. Parameters: Name Type Description Default rule_validator BaseRuleValidator Validator for checking the input model components based on the specific validation rule. required Source code in src/cplus_plugin/lib/validation/validators.py 1388 1389 1390 1391 1392 1393 1394 1395 def add_rule_validator ( self , rule_validator : BaseRuleValidator ): \"\"\"Add a rule validator for validating the input model components. :param rule_validator: Validator for checking the input model components based on the specific validation rule. :type rule_validator: BaseRuleValidator \"\"\" self . _rule_validators . append ( rule_validator )","title":"add_rule_validator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.cancel","text":"cancel () Cancel the validation process. Source code in src/cplus_plugin/lib/validation/validators.py 1291 1292 1293 1294 1295 1296 1297 def cancel ( self ): \"\"\"Cancel the validation process.\"\"\" self . log ( tr ( \"Validation process has been cancelled.\" )) self . _feedback . cancel () super () . cancel ()","title":"cancel"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.create_rule_validator","text":"create_rule_validator ( rule_type , config , feedback ) Factory method for creating a rule validator object. Parameters: Name Type Description Default rule_type RuleType The type of the validator rule. required config RuleConfiguration The context information for configuring the rule validator. required feedback ValidationFeedback Feedback object for reporting progress. required Returns: Type Description BaseRuleValidator An instance of the specific rule validator. Source code in src/cplus_plugin/lib/validation/validators.py 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 @staticmethod def create_rule_validator ( rule_type : RuleType , config : RuleConfiguration , feedback : ValidationFeedback ) -> BaseRuleValidator : \"\"\"Factory method for creating a rule validator object. :param rule_type: The type of the validator rule. :type rule_type: RuleType :param config: The context information for configuring the rule validator. :type rule_type: RuleConfiguration :param feedback: Feedback object for reporting progress. :type feedback: ValidationFeedback :returns: An instance of the specific rule validator. :rtype: BaseRuleValidator \"\"\" validator_cls = DataValidator . validator_cls_by_type ( rule_type ) return validator_cls ( config , feedback )","title":"create_rule_validator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.finished","text":"finished ( result ) Depending on the outcome of the validation process, validation_completed signal will be emitted only if the validation was successful. The result attribute will also contain the validation result object. If an error occurred during the validation process, the validation result object will be None. Parameters: Name Type Description Default result bool True if the validation process was successful, else False. required Source code in src/cplus_plugin/lib/validation/validators.py 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 def finished ( self , result : bool ): \"\"\"Depending on the outcome of the validation process, `validation_completed` signal will be emitted only if the validation was successful. The `result` attribute will also contain the validation result object. If an error occurred during the validation process, the validation result object will be None. :param result: True if the validation process was successful, else False. :type result: bool \"\"\" if result : rule_results = [ rule_validator . result for rule_validator in self . _applicable_rule_validators ] self . _result = ValidationResult ( rule_results , self . MODEL_COMPONENT_TYPE ) self . _feedback . validation_completed . emit ( self . _result ) self . log ( \"Validation complete.\" )","title":"finished"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.log","text":"log ( message , info = True ) Convenience function that logs the given messages by appending the information for the validator. Parameters: Name Type Description Default message str Message to be logged. required info bool False if the message should be logged as a warning else True if information. True Source code in src/cplus_plugin/lib/validation/validators.py 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 def log ( self , message : str , info : bool = True ): \"\"\"Convenience function that logs the given messages by appending the information for the validator. :param message: Message to be logged. :type message: str :param info: False if the message should be logged as a warning else True if information. :type info: bool \"\"\" msg = f \" { self . NAME } - { message } \" log ( message = msg , info = info )","title":"log"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.rule_validators","text":"rule_validators () Returns all the rule validator classes, any new validator type needs to be added here. The validator classes are indexed by their corresponding rule type enum. Returns: Type Description dict Collection containing rule validator classes indexed by their corresponding rule types. Source code in src/cplus_plugin/lib/validation/validators.py 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 @staticmethod def rule_validators () -> typing . Dict [ RuleType , typing . Type [ BaseRuleValidator ]]: \"\"\"Returns all the rule validator classes, any new validator type needs to be added here. The validator classes are indexed by their corresponding rule type enum. :returns: Collection containing rule validator classes indexed by their corresponding rule types. :rtype: dict \"\"\" return { RuleType . DATA_TYPE : RasterValidator , RuleType . CRS : CrsValidator , RuleType . NO_DATA_VALUE : NoDataValueValidator , RuleType . RESOLUTION : ResolutionValidator , RuleType . PROJECTED_CRS : ProjectedCrsValidator , RuleType . NORMALIZED : NormalizedValidator , }","title":"rule_validators"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.run","text":"run () Initiates the validation process based on the specified validators and returns a result indicating whether the process succeeded or failed. Returns: Type Description bool True if the validation process succeeded or False if it failed. Source code in src/cplus_plugin/lib/validation/validators.py 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 def run ( self ) -> bool : \"\"\"Initiates the validation process based on the specified validators and returns a result indicating whether the process succeeded or failed. :returns: True if the validation process succeeded or False if it failed. :rtype: bool \"\"\" if len ( self . _rule_validators ) == 0 : msg = tr ( \"No rule validators specified.\" ) self . log ( msg , False ) return False if len ( self . model_components ) == 0 : msg = tr ( \"At least one dataset is required for the validation process.\" ) self . log ( msg , False ) return False status = True try : status = self . _validate () except Exception as ex : exc_info = \"\" . join ( traceback . TracebackException . from_exception ( ex ) . format ()) self . log ( exc_info , False ) status = False return status","title":"run"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.DataValidator.validator_cls_by_type","text":"validator_cls_by_type ( rule_type ) Gets the rule validator class based on the corresponding rule type. Parameters: Name Type Description Default rule_type RuleType The type of the validator rule. required Returns: Type Description BaseRuleValidator The rule validator class corresponding to the given rule type. Source code in src/cplus_plugin/lib/validation/validators.py 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 @staticmethod def validator_cls_by_type ( rule_type : RuleType ) -> typing . Type [ BaseRuleValidator ]: \"\"\"Gets the rule validator class based on the corresponding rule type. :param rule_type: The type of the validator rule. :type rule_type: RuleType :returns: The rule validator class corresponding to the given rule type. :rtype: BaseRuleValidator \"\"\" return DataValidator . rule_validators ()[ rule_type ]","title":"validator_cls_by_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NcsDataValidator","text":"NcsDataValidator ( * args , ** kwargs ) Bases: DataValidator Validates both NCS pathway and carbon layer datasets. The resolution check for carbon layers is tagged as a warning rather than an error. Source code in src/cplus_plugin/lib/validation/validators.py 1425 1426 1427 1428 def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . model_components = kwargs . pop ( \"ncs_pathways\" , list ) self . _initialize_rule_validators ()","title":"NcsDataValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NoDataValueValidator","text":"NoDataValueValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if applicable input datasets have the same no data value. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"NoDataValueValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NoDataValueValidator.rule_type","text":"rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NoDataValueValidator.is_comparative","text":"is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 696 697 698 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NormalizedValidator","text":"NormalizedValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the values of input datasets are between the range 0 - 1. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"NormalizedValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NormalizedValidator.rule_type","text":"rule_type Returns the normalized value rule validator. Returns: Type Description RuleType Normalized value rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.NormalizedValidator.is_comparative","text":"is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 1156 1157 1158 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ProjectedCrsValidator","text":"ProjectedCrsValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets have a projected CRS. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"ProjectedCrsValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ProjectedCrsValidator.rule_type","text":"rule_type Returns the projected CRS rule validator. Returns: Type Description RuleType Projected CRS rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ProjectedCrsValidator.is_comparative","text":"is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 569 570 571 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.RasterValidator","text":"RasterValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if the input datasets are raster layers. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"RasterValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.RasterValidator.rule_type","text":"rule_type Returns the raster type rule validator. Returns: Type Description RuleType Raster type rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.RasterValidator.is_comparative","text":"is_comparative () Validator can be used for even one dataset. Source code in src/cplus_plugin/lib/validation/validators.py 260 261 262 def is_comparative ( self ) -> bool : \"\"\"Validator can be used for even one dataset.\"\"\" return False","title":"is_comparative"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ResolutionValidator","text":"ResolutionValidator ( configuration , feedback ) Bases: BaseRuleValidator Checks if datasets have the same spatial resolution. Source code in src/cplus_plugin/lib/validation/validators.py 51 52 53 54 55 def __init__ ( self , configuration : RuleConfiguration , feedback : ValidationFeedback ): self . _config = configuration self . _feedback = feedback self . _result : RuleResult = None self . model_components : typing . List [ LayerModelComponent ] = list ()","title":"ResolutionValidator"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ResolutionValidator.rule_type","text":"rule_type Returns the no data value rule validator. Returns: Type Description RuleType No data value rule validator.","title":"rule_type"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ResolutionValidator.create_resolution_definition","text":"create_resolution_definition ( layer ) Creates a resolution definition tuple from a layer. Parameters: Name Type Description Default layer QgsRasterLayer Input layer. required Returns: Type Description tuple Tuple containing x and y resolutions as well as the units. Source code in src/cplus_plugin/lib/validation/validators.py 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 @classmethod def create_resolution_definition ( cls , layer : QgsRasterLayer ): \"\"\"Creates a resolution definition tuple from a layer. :param layer: Input layer. :type layer: QgsRasterLayer :returns: Tuple containing x and y resolutions as well as the units. :rtype: tuple \"\"\" crs = layer . crs () if crs is None : crs_unit_str = tr ( \"unknown\" ) else : crs_unit_str = QgsUnitTypes . toAbbreviatedString ( crs . mapUnits ()) # Tuple containing x, y (truncated to given decimal places) and units resolution_definition = ( round ( layer . rasterUnitsPerPixelX (), cls . DECIMAL_PLACES ), round ( layer . rasterUnitsPerPixelY (), cls . DECIMAL_PLACES ), crs_unit_str , ) return resolution_definition","title":"create_resolution_definition"},{"location":"developer/api/core/api_validation_validators/#src.cplus_plugin.lib.validation.validators.ResolutionValidator.resolution_definition_to_str","text":"resolution_definition_to_str ( resolution_definition ) Formats the resolution definition to a friendly-display string. Parameters: Name Type Description Default resolution_definition tuple Tuple containing x and y resolutions as well as the units. required Returns: Type Description str Friendly display string. Source code in src/cplus_plugin/lib/validation/validators.py 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 @classmethod def resolution_definition_to_str ( cls , resolution_definition : tuple ) -> str : \"\"\"Formats the resolution definition to a friendly-display string. :param resolution_definition: Tuple containing x and y resolutions as well as the units. :type resolution_definition: tuple :returns: Friendly display string. :rtype: str \"\"\" if len ( resolution_definition ) < 3 : return \"\" unit_str = ( tr ( \"unknown units\" ) if not resolution_definition [ 2 ] else resolution_definition [ 2 ] ) return f \"X: { resolution_definition [ 0 ] !s} { unit_str } , Y: { resolution_definition [ 1 ] !s} { unit_str } \"","title":"resolution_definition_to_str"},{"location":"developer/api/gui/api_activity_editor_dialog/","text":"Activity editor \u00b6 Dialog for creating or editing an activity. ActivityEditorDialog \u00b6 ActivityEditorDialog ( parent = None , activity = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an activity. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , parent = None , activity = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . style_btn . setSymbolType ( Qgis . SymbolType . Fill ) self . btn_color_ramp . setShowNull ( False ) self . btn_color_ramp . setShowGradientOnly ( True ) self . btn_color_ramp . setColorRampDialogTitle ( self . tr ( \"Set Color Ramp for Output Activity\" ) ) # Default gradient colour which closely matches the color # for the activity in the scenario layer start_color = generate_random_color () stop_color = generate_random_color () self . btn_color_ramp . setColorRamp ( QgsGradientColorRamp ( start_color , stop_color )) self . style_btn . setColor ( start_color ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) self . btn_help . clicked . connect ( self . open_help ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _mask_layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _activity = activity if self . _activity is not None : self . _edit_mode = True self . _layer = self . _activity . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . txt_description . textChanged . connect ( self . description_changed ) # Hide map layer handling self . layer_gb . setVisible ( False ) # Mask layers add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_mask . setIcon ( add_icon ) self . btn_add_mask . clicked . connect ( self . _on_add_mask_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_mask . setIcon ( remove_icon ) self . btn_delete_mask . setEnabled ( False ) self . btn_delete_mask . clicked . connect ( self . _on_remove_mask_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_mask . setIcon ( edit_icon ) self . btn_edit_mask . setEnabled ( False ) self . btn_edit_mask . clicked . connect ( self . _on_edit_mask_layer ) if self . _activity is not None : mask_paths_list = self . _activity . mask_paths for mask_path in mask_paths_list or []: if mask_path == \"\" : continue item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , mask_path ) self . lst_mask_layers . addItem ( item ) self . mask_layers_changed () activity property \u00b6 activity Returns a reference to the activity object. Returns: Type Description Activity Reference to the activity object. edit_mode property \u00b6 edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing activity object, else False if its creating a new object. layer property \u00b6 layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. description_changed \u00b6 description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/activity_editor_dialog.py 155 156 157 158 159 160 161 162 163 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ]) open_help \u00b6 open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 446 447 448 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) output_layer_color_ramp \u00b6 output_layer_color_ramp () Returns the selected color ramp. Returns: Type Description QgsColorRamp The color ramp selected by the user. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 436 437 438 439 440 441 442 443 444 def output_layer_color_ramp ( self ) -> QgsColorRamp : \"\"\"Returns the selected color ramp. :returns: The color ramp selected by the user. :rtype: QgsColorRamp \"\"\" color_ramp = self . btn_color_ramp . colorRamp () return color_ramp scenario_fill_symbol_layer \u00b6 scenario_fill_symbol_layer () Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. Returns: Type Description QgsFillSymbolLayer Fill symbol layer to be used in the activity. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def scenario_fill_symbol_layer ( self ) -> QgsFillSymbolLayer : \"\"\"Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. :returns: Fill symbol layer to be used in the activity. :rtype: QgsFillSymbolLayer \"\"\" fill_symbol_layer = None btn_symbol = self . style_btn . symbol () for i in range ( btn_symbol . symbolLayerCount ()): symbol_layer = btn_symbol . symbolLayer ( i ) if isinstance ( symbol_layer , QgsFillSymbolLayer ): fill_symbol_layer = symbol_layer break return fill_symbol_layer validate \u00b6 validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Activity name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False fill_symbol_layer = self . scenario_fill_symbol_layer () if fill_symbol_layer is None : msg = tr ( \"No fill symbol defined for the scenario layer.\" ) self . _show_warning_message ( msg ) status = False if self . btn_color_ramp . colorRamp () is None or self . btn_color_ramp . isNull (): msg = tr ( \"No color ramp defined for the output activity layer.\" ) self . _show_warning_message ( msg ) status = False return status","title":"Implementation model editor"},{"location":"developer/api/gui/api_activity_editor_dialog/#activity-editor","text":"Dialog for creating or editing an activity.","title":"Activity editor"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog","text":"ActivityEditorDialog ( parent = None , activity = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an activity. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , parent = None , activity = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . style_btn . setSymbolType ( Qgis . SymbolType . Fill ) self . btn_color_ramp . setShowNull ( False ) self . btn_color_ramp . setShowGradientOnly ( True ) self . btn_color_ramp . setColorRampDialogTitle ( self . tr ( \"Set Color Ramp for Output Activity\" ) ) # Default gradient colour which closely matches the color # for the activity in the scenario layer start_color = generate_random_color () stop_color = generate_random_color () self . btn_color_ramp . setColorRamp ( QgsGradientColorRamp ( start_color , stop_color )) self . style_btn . setColor ( start_color ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_select_file . clicked . connect ( self . _on_select_file ) self . btn_help . clicked . connect ( self . open_help ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _edit_mode = False self . _layer = None self . _mask_layer = None self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _activity = activity if self . _activity is not None : self . _edit_mode = True self . _layer = self . _activity . to_map_layer () self . _update_controls () help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . txt_description . textChanged . connect ( self . description_changed ) # Hide map layer handling self . layer_gb . setVisible ( False ) # Mask layers add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_mask . setIcon ( add_icon ) self . btn_add_mask . clicked . connect ( self . _on_add_mask_layer ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_mask . setIcon ( remove_icon ) self . btn_delete_mask . setEnabled ( False ) self . btn_delete_mask . clicked . connect ( self . _on_remove_mask_layer ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit_mask . setIcon ( edit_icon ) self . btn_edit_mask . setEnabled ( False ) self . btn_edit_mask . clicked . connect ( self . _on_edit_mask_layer ) if self . _activity is not None : mask_paths_list = self . _activity . mask_paths for mask_path in mask_paths_list or []: if mask_path == \"\" : continue item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , mask_path ) self . lst_mask_layers . addItem ( item ) self . mask_layers_changed ()","title":"ActivityEditorDialog"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.activity","text":"activity Returns a reference to the activity object. Returns: Type Description Activity Reference to the activity object.","title":"activity"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing activity object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.description_changed","text":"description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/activity_editor_dialog.py 155 156 157 158 159 160 161 162 163 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ])","title":"description_changed"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 446 447 448 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.output_layer_color_ramp","text":"output_layer_color_ramp () Returns the selected color ramp. Returns: Type Description QgsColorRamp The color ramp selected by the user. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 436 437 438 439 440 441 442 443 444 def output_layer_color_ramp ( self ) -> QgsColorRamp : \"\"\"Returns the selected color ramp. :returns: The color ramp selected by the user. :rtype: QgsColorRamp \"\"\" color_ramp = self . btn_color_ramp . colorRamp () return color_ramp","title":"output_layer_color_ramp"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.scenario_fill_symbol_layer","text":"scenario_fill_symbol_layer () Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. Returns: Type Description QgsFillSymbolLayer Fill symbol layer to be used in the activity. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def scenario_fill_symbol_layer ( self ) -> QgsFillSymbolLayer : \"\"\"Gets the first fill symbol layer in the symbol as set in the button. It checks to ensure that there is at least one fill symbol layer contained in the symbol. :returns: Fill symbol layer to be used in the activity. :rtype: QgsFillSymbolLayer \"\"\" fill_symbol_layer = None btn_symbol = self . style_btn . symbol () for i in range ( btn_symbol . symbolLayerCount ()): symbol_layer = btn_symbol . symbolLayer ( i ) if isinstance ( symbol_layer , QgsFillSymbolLayer ): fill_symbol_layer = symbol_layer break return fill_symbol_layer","title":"scenario_fill_symbol_layer"},{"location":"developer/api/gui/api_activity_editor_dialog/#src.cplus_plugin.gui.activity_editor_dialog.ActivityEditorDialog.validate","text":"validate () Validates if name has been specified. Returns: Type Description True True if the name have been set. Source code in src/cplus_plugin/gui/activity_editor_dialog.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def validate ( self ) -> bool : \"\"\"Validates if name has been specified. :returns: True if the name have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"Activity name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () if layer and not layer . isValid (): msg = tr ( \"Map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False fill_symbol_layer = self . scenario_fill_symbol_layer () if fill_symbol_layer is None : msg = tr ( \"No fill symbol defined for the scenario layer.\" ) self . _show_warning_message ( msg ) status = False if self . btn_color_ramp . colorRamp () is None or self . btn_color_ramp . isNull (): msg = tr ( \"No color ramp defined for the output activity layer.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate"},{"location":"developer/api/gui/api_activity_widget/","text":"Activity widget \u00b6 Container widget for configuring the implementation widget. ActivityContainerWidget \u00b6 ActivityContainerWidget ( parent = None , message_bar = None ) Bases: QWidget , WidgetUi Widget for configuring an activity. Source code in src/cplus_plugin/gui/activity_widget.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , parent : QtWidgets . QWidget = None , message_bar : QgsMessageBar = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = message_bar self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # activity view self . activity_view = ActivityComponentWidget () self . activity_layout . addWidget ( self . activity_view ) self . activity_view . title = self . tr ( \"Activities\" ) settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . ncs_pathway_view . ncs_pathway_removed . connect ( self . on_ncs_pathway_removed ) self . ncs_pathway_view . items_reloaded . connect ( self . _on_ncs_pathways_reloaded ) self . load () items_loaded property \u00b6 items_loaded Check if ncs pathway and activity items have been loaded in their respective views. Returns: Type Description bool True if NCS pathway and activity items have been successfully loaded in the views. activities \u00b6 activities () Returns the user-defined activities in the activity view. Returns: Type Description list User-defined activities for the current scenario. Source code in src/cplus_plugin/gui/activity_widget.py 101 102 103 104 105 106 107 108 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns the user-defined activities in the activity view. :returns: User-defined activities for the current scenario. :rtype: list \"\"\" return self . activity_view . activities () is_activity_valid \u00b6 is_activity_valid () Check if the user input is valid. This checks if there is one activity defined with at least one NCS pathway under it. Returns: Type Description bool True if the activity configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/activity_widget.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def is_activity_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one activity defined with at least one NCS pathway under it. :returns: True if the activity configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" activities = self . activities () if len ( activities ) == 0 : return False status = False for activity in activities : if len ( activity . pathways ) > 0 or activity . to_map_layer () is not None : status = True break return status is_ncs_valid \u00b6 is_ncs_valid () Checks whether the NCS pathways are valid against a given set of validation rules. Returns: Type Description bool True if the NCS pathways are valid else False. Source code in src/cplus_plugin/gui/activity_widget.py 174 175 176 177 178 179 180 def is_ncs_valid ( self ) -> bool : \"\"\"Checks whether the NCS pathways are valid against a given set of validation rules. :returns: True if the NCS pathways are valid else False. :rtype: bool \"\"\" return self . ncs_pathway_view . is_valid () load \u00b6 load () Load NCS pathways and activities to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/activity_widget.py 82 83 84 85 86 87 88 89 90 91 def load ( self ): \"\"\"Load NCS pathways and activities to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . activity_view . load () self . _items_loaded = True ncs_pathways \u00b6 ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/activity_widget.py 93 94 95 96 97 98 99 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways () on_ncs_pathway_removed \u00b6 on_ncs_pathway_removed ( ncs_pathway_uuid ) Slot raised when an NCS pathway has been removed. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identified of the removed NCS pathway item. required Source code in src/cplus_plugin/gui/activity_widget.py 137 138 139 140 141 142 143 def on_ncs_pathway_removed ( self , ncs_pathway_uuid : str ): \"\"\"Slot raised when an NCS pathway has been removed. :param ncs_pathway_uuid: Unique identified of the removed NCS pathway item. :type ncs_pathway_uuid: str \"\"\" self . activity_view . remove_ncs_pathway_items ( ncs_pathway_uuid ) on_ncs_pathway_updated \u00b6 on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/activity_widget.py 133 134 135 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . activity_view . update_ncs_pathway_items ( ncs_pathway ) on_settings_changed \u00b6 on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/gui/activity_widget.py 160 161 162 163 164 165 166 167 168 169 170 171 172 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Update the NCS pathway and carbon layer paths when # BASE_DIR has been updated. if name == Settings . BASE_DIR . value : self . ncs_pathway_view . load () selected_activity_items \u00b6 selected_activity_items () Returns the currently selected instances of activity items. If an item is disabled then it will be excluded from the selection. Returns: Type Description list Currently selected instances of ActivityItem or an empty list if there is no selection of activity items. Source code in src/cplus_plugin/gui/activity_widget.py 230 231 232 233 234 235 236 237 238 239 240 241 def selected_activity_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns the currently selected instances of activity items. If an item is disabled then it will be excluded from the selection. :returns: Currently selected instances of ActivityItem or an empty list if there is no selection of activity items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ActivityItem ) ] selected_items \u00b6 selected_items () Returns the selected model component item types which could be NCS pathway or activity items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/activity_widget.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or activity items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . activity_view . selected_items () cloned_items = [] for ref_item in ref_items : if not ref_item . isEnabled (): continue clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items show_message \u00b6 show_message ( message , level = Qgis . MessageLevel . Warning ) Shows message if message bar has been specified. Parameters: Name Type Description Default message str Text to display in the message bar. required level MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/activity_widget.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def show_message ( self , message , level = Qgis . MessageLevel . Warning ): \"\"\"Shows message if message bar has been specified. :param message: Text to display in the message bar. :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" if self . _message_bar is None : return self . _message_bar . clearWidgets () self . _message_bar . pushMessage ( message , level = level )","title":"Implementation model widget"},{"location":"developer/api/gui/api_activity_widget/#activity-widget","text":"Container widget for configuring the implementation widget.","title":"Activity widget"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget","text":"ActivityContainerWidget ( parent = None , message_bar = None ) Bases: QWidget , WidgetUi Widget for configuring an activity. Source code in src/cplus_plugin/gui/activity_widget.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , parent : QtWidgets . QWidget = None , message_bar : QgsMessageBar = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _message_bar = message_bar self . _items_loaded = False self . btn_add_one . setIcon ( FileUtils . get_icon ( \"cplus_right_arrow.svg\" )) self . btn_add_one . setToolTip ( self . tr ( \"Add selected NCS pathway\" )) self . btn_add_one . clicked . connect ( self . _on_add_ncs_pathway ) self . btn_add_all . setIcon ( FileUtils . get_icon ( \"cplus_double_right_arrows.svg\" )) self . btn_add_all . setToolTip ( self . tr ( \"Add all NCS pathways\" )) self . btn_add_all . clicked . connect ( self . _on_add_all_ncs_pathways ) # NCS pathway view self . ncs_pathway_view = NcsComponentWidget () self . ncs_pathway_view . title = self . tr ( \"NCS Pathways\" ) self . ncs_layout . addWidget ( self . ncs_pathway_view ) # activity view self . activity_view = ActivityComponentWidget () self . activity_layout . addWidget ( self . activity_view ) self . activity_view . title = self . tr ( \"Activities\" ) settings_manager . settings_updated [ str , object ] . connect ( self . on_settings_changed ) self . ncs_pathway_view . ncs_pathway_updated . connect ( self . on_ncs_pathway_updated ) self . ncs_pathway_view . ncs_pathway_removed . connect ( self . on_ncs_pathway_removed ) self . ncs_pathway_view . items_reloaded . connect ( self . _on_ncs_pathways_reloaded ) self . load ()","title":"ActivityContainerWidget"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.items_loaded","text":"items_loaded Check if ncs pathway and activity items have been loaded in their respective views. Returns: Type Description bool True if NCS pathway and activity items have been successfully loaded in the views.","title":"items_loaded"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.activities","text":"activities () Returns the user-defined activities in the activity view. Returns: Type Description list User-defined activities for the current scenario. Source code in src/cplus_plugin/gui/activity_widget.py 101 102 103 104 105 106 107 108 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns the user-defined activities in the activity view. :returns: User-defined activities for the current scenario. :rtype: list \"\"\" return self . activity_view . activities ()","title":"activities"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.is_activity_valid","text":"is_activity_valid () Check if the user input is valid. This checks if there is one activity defined with at least one NCS pathway under it. Returns: Type Description bool True if the activity configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. Source code in src/cplus_plugin/gui/activity_widget.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def is_activity_valid ( self ) -> bool : \"\"\"Check if the user input is valid. This checks if there is one activity defined with at least one NCS pathway under it. :returns: True if the activity configuration is valid, else False at least until there is one implementation model defined with at least one NCS pathway under it. :rtype: bool \"\"\" activities = self . activities () if len ( activities ) == 0 : return False status = False for activity in activities : if len ( activity . pathways ) > 0 or activity . to_map_layer () is not None : status = True break return status","title":"is_activity_valid"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.is_ncs_valid","text":"is_ncs_valid () Checks whether the NCS pathways are valid against a given set of validation rules. Returns: Type Description bool True if the NCS pathways are valid else False. Source code in src/cplus_plugin/gui/activity_widget.py 174 175 176 177 178 179 180 def is_ncs_valid ( self ) -> bool : \"\"\"Checks whether the NCS pathways are valid against a given set of validation rules. :returns: True if the NCS pathways are valid else False. :rtype: bool \"\"\" return self . ncs_pathway_view . is_valid ()","title":"is_ncs_valid"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.load","text":"load () Load NCS pathways and activities to the views. This function is idempotent as items will only be loaded once on initial call. Source code in src/cplus_plugin/gui/activity_widget.py 82 83 84 85 86 87 88 89 90 91 def load ( self ): \"\"\"Load NCS pathways and activities to the views. This function is idempotent as items will only be loaded once on initial call. \"\"\" if not self . _items_loaded : self . ncs_pathway_view . load () self . activity_view . load () self . _items_loaded = True","title":"load"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.ncs_pathways","text":"ncs_pathways () Gets the NCS pathway objects in the NCS Pathways view. Returns: Type Description list NCS pathway objects, both default and user-defined. Source code in src/cplus_plugin/gui/activity_widget.py 93 94 95 96 97 98 99 def ncs_pathways ( self ) -> typing . List [ NcsPathway ]: \"\"\"Gets the NCS pathway objects in the NCS Pathways view. :returns: NCS pathway objects, both default and user-defined. :rtype: list \"\"\" return self . ncs_pathway_view . pathways ()","title":"ncs_pathways"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.on_ncs_pathway_removed","text":"on_ncs_pathway_removed ( ncs_pathway_uuid ) Slot raised when an NCS pathway has been removed. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identified of the removed NCS pathway item. required Source code in src/cplus_plugin/gui/activity_widget.py 137 138 139 140 141 142 143 def on_ncs_pathway_removed ( self , ncs_pathway_uuid : str ): \"\"\"Slot raised when an NCS pathway has been removed. :param ncs_pathway_uuid: Unique identified of the removed NCS pathway item. :type ncs_pathway_uuid: str \"\"\" self . activity_view . remove_ncs_pathway_items ( ncs_pathway_uuid )","title":"on_ncs_pathway_removed"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.on_ncs_pathway_updated","text":"on_ncs_pathway_updated ( ncs_pathway ) Slot raised when an NCS pathway has been updated. Source code in src/cplus_plugin/gui/activity_widget.py 133 134 135 def on_ncs_pathway_updated ( self , ncs_pathway : NcsPathway ): \"\"\"Slot raised when an NCS pathway has been updated.\"\"\" self . activity_view . update_ncs_pathway_items ( ncs_pathway )","title":"on_ncs_pathway_updated"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.on_settings_changed","text":"on_settings_changed ( name , value ) Slot raised when settings has been changed. Parameters: Name Type Description Default name str Name of the setting that has changed. required value Any New value for the given settings name. required Source code in src/cplus_plugin/gui/activity_widget.py 160 161 162 163 164 165 166 167 168 169 170 171 172 def on_settings_changed ( self , name : str , value : typing . Any ): \"\"\"Slot raised when settings has been changed. :param name: Name of the setting that has changed. :type name: str :param value: New value for the given settings name. :type value: Any \"\"\" # Update the NCS pathway and carbon layer paths when # BASE_DIR has been updated. if name == Settings . BASE_DIR . value : self . ncs_pathway_view . load ()","title":"on_settings_changed"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.selected_activity_items","text":"selected_activity_items () Returns the currently selected instances of activity items. If an item is disabled then it will be excluded from the selection. Returns: Type Description list Currently selected instances of ActivityItem or an empty list if there is no selection of activity items. Source code in src/cplus_plugin/gui/activity_widget.py 230 231 232 233 234 235 236 237 238 239 240 241 def selected_activity_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns the currently selected instances of activity items. If an item is disabled then it will be excluded from the selection. :returns: Currently selected instances of ActivityItem or an empty list if there is no selection of activity items. :rtype: list \"\"\" return [ item for item in self . selected_items () if isinstance ( item , ActivityItem ) ]","title":"selected_activity_items"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.selected_items","text":"selected_items () Returns the selected model component item types which could be NCS pathway or activity items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. Returns: Type Description list Selected model component items. Source code in src/cplus_plugin/gui/activity_widget.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected model component item types which could be NCS pathway or activity items. If an item is disabled then it will be excluded from the selection. These are cloned objects so as not to interfere with the underlying data models when used for scenario analysis. Otherwise, one can also use the data models from the MVC item model. :returns: Selected model component items. :rtype: list \"\"\" ref_items = self . activity_view . selected_items () cloned_items = [] for ref_item in ref_items : if not ref_item . isEnabled (): continue clone_item = ref_item . clone () cloned_items . append ( clone_item ) return cloned_items","title":"selected_items"},{"location":"developer/api/gui/api_activity_widget/#src.cplus_plugin.gui.activity_widget.ActivityContainerWidget.show_message","text":"show_message ( message , level = Qgis . MessageLevel . Warning ) Shows message if message bar has been specified. Parameters: Name Type Description Default message str Text to display in the message bar. required level MessageLevel Message level type Warning Source code in src/cplus_plugin/gui/activity_widget.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def show_message ( self , message , level = Qgis . MessageLevel . Warning ): \"\"\"Shows message if message bar has been specified. :param message: Text to display in the message bar. :type message: str :param level: Message level type :type level: Qgis.MessageLevel \"\"\" if self . _message_bar is None : return self . _message_bar . clearWidgets () self . _message_bar . pushMessage ( message , level = level )","title":"show_message"},{"location":"developer/api/gui/api_carbon_layer_model/","text":"Carbon Layer Model \u00b6 MVC model for carbon layer paths. CarbonLayerItem \u00b6 CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path ) is_valid property \u00b6 is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False. layer_path property \u00b6 layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer. type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 78 79 80 81 82 83 84 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return item_user_type () + 5 update \u00b6 update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" if self . _layer_path . startswith ( \"cplus://\" ): paths = self . _layer_path . split ( \"/\" ) self . setText ( f \"Online Default: { paths [ - 1 ] } \" ) self . setToolTip ( f \"Online Default: { paths [ - 1 ] } \" ) self . _is_valid = True self . setIcon ( QtGui . QIcon ()) return self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" )) CarbonLayerModel \u00b6 CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 90 91 92 93 94 95 96 97 98 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp ) add_carbon_layer \u00b6 add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True carbon_layer_index \u00b6 carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" if not layer_path . startswith ( \"cplus://\" ): norm_path = str ( os . path . normpath ( layer_path )) else : norm_path = layer_path matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index carbon_paths \u00b6 carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths contains_layer_path \u00b6 contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False update_carbon_path \u00b6 update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"Carbon item model"},{"location":"developer/api/gui/api_carbon_layer_model/#carbon-layer-model","text":"MVC model for carbon layer paths.","title":"Carbon Layer Model"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem","text":"CarbonLayerItem ( layer_path ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/carbon_item_model.py 19 20 21 22 23 24 def __init__ ( self , layer_path : str ): super () . __init__ () self . _layer_path = layer_path self . _is_valid = True self . update ( self . _layer_path )","title":"CarbonLayerItem"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.is_valid","text":"is_valid Returns the validity status of the carbon layer path. The path could be invalid if it does not exist or if the corresponding map layer is invalid. Returns: Type Description bool True if valid, else False.","title":"is_valid"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.layer_path","text":"layer_path Returns the path to the carbon layer. Returns: Type Description str Path to the carbon layer.","title":"layer_path"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the carbob item. Source code in src/cplus_plugin/gui/carbon_item_model.py 78 79 80 81 82 83 84 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the carbob item. :rtype: int \"\"\" return item_user_type () + 5","title":"type"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerItem.update","text":"update ( layer_path ) Update the UI properties. Source code in src/cplus_plugin/gui/carbon_item_model.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def update ( self , layer_path : str ): \"\"\"Update the UI properties.\"\"\" if self . _layer_path . startswith ( \"cplus://\" ): paths = self . _layer_path . split ( \"/\" ) self . setText ( f \"Online Default: { paths [ - 1 ] } \" ) self . setToolTip ( f \"Online Default: { paths [ - 1 ] } \" ) self . _is_valid = True self . setIcon ( QtGui . QIcon ()) return self . _layer_path = str ( os . path . normpath ( layer_path )) p = Path ( self . _layer_path ) self . setText ( p . name ) self . setToolTip ( self . _layer_path ) # Check validity if p . exists (): layer = QgsRasterLayer ( layer_path ) if layer . isValid (): self . _is_valid = True self . setIcon ( QtGui . QIcon ()) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"Carbon layer is not invalid.\" )) else : self . _is_valid = False error_icon = FileUtils . get_icon ( \"mIndicatorLayerError.svg\" ) self . setIcon ( error_icon ) self . setToolTip ( tr ( \"File path is invalid.\" ))","title":"update"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel","text":"CarbonLayerModel ( parent = None , carbon_paths = None ) Bases: QStandardItemModel View model for carbon layers. Source code in src/cplus_plugin/gui/carbon_item_model.py 90 91 92 93 94 95 96 97 98 def __init__ ( self , parent = None , carbon_paths : typing . Union [ typing . List [ str ], None ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) if carbon_paths is not None : for cp in carbon_paths : self . add_carbon_layer ( cp )","title":"CarbonLayerModel"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.add_carbon_layer","text":"add_carbon_layer ( layer_path ) Adds a carbon layer to the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the carbon layer was successfully added, else False if there is an existing item with the same path. Source code in src/cplus_plugin/gui/carbon_item_model.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def add_carbon_layer ( self , layer_path : str ) -> bool : \"\"\"Adds a carbon layer to the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the carbon layer was successfully added, else False if there is an existing item with the same path. \"\"\" if self . contains_layer_path ( layer_path ): return False carbon_item = CarbonLayerItem ( layer_path ) self . appendRow ( carbon_item ) return True","title":"add_carbon_layer"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_layer_index","text":"carbon_layer_index ( layer_path ) Get the model index for the given layer path. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description QtCore.QModelIndex The index corresponding to the given layer path else an invalid index if not found. Source code in src/cplus_plugin/gui/carbon_item_model.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def carbon_layer_index ( self , layer_path : str ) -> QtCore . QModelIndex : \"\"\"Get the model index for the given layer path. :param layer_path: Carbon layer path. :type layer_path: str :returns: The index corresponding to the given layer path else an invalid index if not found. :rtype: QtCore.QModelIndex \"\"\" if not layer_path . startswith ( \"cplus://\" ): norm_path = str ( os . path . normpath ( layer_path )) else : norm_path = layer_path matching_index = None for r in range ( self . rowCount ()): index = self . index ( r , 0 ) if not index . isValid (): continue item = self . itemFromIndex ( index ) if item . layer_path == norm_path : matching_index = index break if matching_index is None : return QtCore . QModelIndex () return matching_index","title":"carbon_layer_index"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.carbon_paths","text":"carbon_paths ( valid_only = False ) Gets all the carbon paths in the model. Parameters: Name Type Description Default valid_only bool Only return the carbon paths that are valid. False Returns: Type Description list A collection of carbon paths in the model. Source code in src/cplus_plugin/gui/carbon_item_model.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def carbon_paths ( self , valid_only : bool = False ) -> list : \"\"\"Gets all the carbon paths in the model. :param valid_only: Only return the carbon paths that are valid. :type valid_only: bool :returns: A collection of carbon paths in the model. :rtype: list \"\"\" carbon_paths = [] for r in range ( self . rowCount ()): index = self . index ( r , 0 ) item = self . itemFromIndex ( index ) if valid_only : if item . is_valid : carbon_paths . append ( item . layer_path ) else : carbon_paths . append ( item . layer_path ) return carbon_paths","title":"carbon_paths"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.contains_layer_path","text":"contains_layer_path ( layer_path ) Checks if the specified layer path exists in the model. Parameters: Name Type Description Default layer_path str Carbon layer path. required Returns: Type Description bool True if the path exists, else False. Source code in src/cplus_plugin/gui/carbon_item_model.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def contains_layer_path ( self , layer_path : str ) -> bool : \"\"\"Checks if the specified layer path exists in the model. :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path exists, else False. :rtype: bool \"\"\" carbon_idx = self . carbon_layer_index ( layer_path ) if carbon_idx . isValid (): return True return False","title":"contains_layer_path"},{"location":"developer/api/gui/api_carbon_layer_model/#src.cplus_plugin.gui.carbon_item_model.CarbonLayerModel.update_carbon_path","text":"update_carbon_path ( index , layer_path ) Update the carbon path at the given position specified by the index. Parameters: Name Type Description Default index QModelIndex Location to modify the carbon path. required layer_path str Carbon layer path. required Returns: Type Description bool True if the path was successfully updated else False if there is no carbon item at the given location. Source code in src/cplus_plugin/gui/carbon_item_model.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def update_carbon_path ( self , index : QtCore . QModelIndex , layer_path : str ) -> bool : \"\"\"Update the carbon path at the given position specified by the index. :param index: Location to modify the carbon path. :type index: QtCore.QModelIndex :param layer_path: Carbon layer path. :type layer_path: str :returns: True if the path was successfully updated else False if there is no carbon item at the given location. :rtype: bool \"\"\" if not index . isValid (): return False item = self . itemFromIndex ( index ) if item is None : return False item . update ( layer_path ) return True","title":"update_carbon_path"},{"location":"developer/api/gui/api_component_items/","text":"Component item model \u00b6 Contains item models for view widgets such as NCS pathway or IM views. ActivityItem \u00b6 ActivityItem ( activity , bold_text = True ) Bases: LayerComponentItem Standard item for an activity object. Source code in src/cplus_plugin/gui/component_item_model.py 323 324 325 326 327 328 329 330 331 332 333 def __init__ ( self , activity : Activity , bold_text : bool = True ): super () . __init__ ( activity ) self . _activity = activity self . set_bold_font ( bold_text ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each activity. self . _uuid_remap = {} activity property \u00b6 activity Returns an instance of the underlying activity object. Returns: Type Description Activity The underlying activity object. layer_item property \u00b6 layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else None if no layer has been specified for the model. ncs_items property \u00b6 ncs_items Returns a collection of NcsPathwayItem in this activity object. Returns: Type Description list Collection of NcsPathwayItem objects in this activity object. ncs_pathways property \u00b6 ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying activity object. original_ncs_pathways property \u00b6 original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying activity object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying activity object. add_ncs_pathway_item \u00b6 add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this activity item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this activity item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _activity . contains_pathway ( ncs_item . uuid ): return False if not self . _activity . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True bottom_ncs_item_index \u00b6 bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this activity item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 552 553 554 555 556 557 558 559 560 561 562 563 564 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this activity item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index () clear_layer \u00b6 clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 443 444 445 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _activity . clear_layer () clone \u00b6 clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the activity object will not change. Source code in src/cplus_plugin/gui/component_item_model.py 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def clone ( self ) -> \"ActivityItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the activity object will not change. \"\"\" activity = clone_activity ( self . activity , ) # Use NCS pathways with original UUIDs activity . pathways = self . original_ncs_pathways return ActivityItem ( activity ) contains_ncs_item \u00b6 contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True create staticmethod \u00b6 create ( activity ) Creates an instance of the activity item from the model object. Parameters: Name Type Description Default activity Activity Activity model object required Returns: Type Description Activity An instance of the activity item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 574 575 576 577 578 579 580 581 582 583 584 585 586 @staticmethod def create ( activity : Activity ) -> \"ActivityItem\" : \"\"\"Creates an instance of the activity item from the model object. :param activity: Activity model object :type activity: Activity :returns: An instance of the activity item to be used in a standard model. :rtype: Activity \"\"\" return ActivityItem ( activity ) enable_default_pathways \u00b6 enable_default_pathways ( state ) Enable or disable default NCS pathway items. Parameters: Name Type Description Default state bool True to enable default NCS pathways else False to disable them. required Source code in src/cplus_plugin/gui/component_item_model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 def enable_default_pathways ( self , state : bool ): \"\"\"Enable or disable default NCS pathway items. :param state: True to enable default NCS pathways else False to disable them. :type state: bool \"\"\" for ncs_item in self . _ncs_items : if ncs_item . user_defined : continue if ncs_item . isEnabled () != state : ncs_item . setEnabled ( state ) ncs_item_by_uuid \u00b6 ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ] ncs_item_from_original_pathway \u00b6 ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this activity item. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , str ] Original NCS pathway data model or unique identifier of the NCS pathway. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this activity item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def ncs_item_from_original_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , str ] ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this activity item. :param ncs_pathway: Original NCS pathway data model or unique identifier of the NCS pathway. :type ncs_pathway: NcsPathway, str :returns: The matching NCS pathway item in this activity item, else None if there is no matching item. \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_uuid = str ( ncs_pathway . uuid ) else : ncs_uuid = ncs_pathway if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid ) remove_ncs_pathway_item \u00b6 remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _activity . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True setEnabled \u00b6 setEnabled ( enabled ) Override for default implementation that also enables or disables NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 637 638 639 640 641 642 643 644 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables NCS pathway items. \"\"\" self . enable_default_pathways ( enabled ) self . _enable_layer_item ( enabled ) self . setSelectable ( enabled ) super () . setEnabled ( enabled ) set_bold_font \u00b6 set_bold_font ( bold ) Set the text to bold or normal. Parameters: Name Type Description Default bold bool True to set the text font to be bold, else False to normal. required Source code in src/cplus_plugin/gui/component_item_model.py 335 336 337 338 339 340 341 342 343 344 def set_bold_font ( self , bold : bool ): \"\"\"Set the text to bold or normal. :param bold: True to set the text font to be bold, else False to normal. :type bold: bool \"\"\" font = self . font () font . setBold ( bold ) self . setFont ( font ) type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 566 567 568 569 570 571 572 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return ACTIVITY_TYPE ActivityItemModel \u00b6 ActivityItemModel ( * args , ** kwargs ) Bases: ComponentItemModel View model for activity. Source code in src/cplus_plugin/gui/component_item_model.py 1006 1007 1008 def __init__ ( self , * args , ** kwargs ): self . _load_pathways = kwargs . pop ( \"load_pathways\" , True ) super () . __init__ ( * args , ** kwargs ) activities \u00b6 activities () Returns activity objects in the view model. Returns: Type Description list Activity objects in the view model. Source code in src/cplus_plugin/gui/component_item_model.py 1236 1237 1238 1239 1240 1241 1242 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns activity objects in the view model. :returns: Activity objects in the view model. :rtype: list \"\"\" return [ model_item . activity for model_item in self . activity_items ()] activity_items \u00b6 activity_items () Returns all activity item objects in the model. Returns: Type Description list Activity items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 def activity_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns all activity item objects in the model. :returns: Activity items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == ACTIVITY_TYPE ] add_activity \u00b6 add_activity ( activity , layer = None ) Add an activity object to the model. Parameters: Name Type Description Default activity Activity Activity object to be added to the view. required layer QgsMapLayer Map layer for the activity. None Returns: Type Description bool True if an activity object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 def add_activity ( self , activity : Activity , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an activity object to the model. :param activity: Activity object to be added to the view. :type activity: Activity :param layer: Map layer for the activity. :type layer: QgsMapLayer :returns: True if an activity object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if activity . path : layer = activity . to_map_layer () activity_item = ActivityItem . create ( activity ) if self . checkable_item : activity_item . setCheckable ( True ) if not self . _load_pathways : activity_item . set_bold_font ( False ) result = self . add_component_item ( activity_item ) # No need to load any additional information if not showing pathways if not self . _load_pathways : return result if layer : status = self . set_model_layer ( activity_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the activity item. if result : cloned_activity = clone_activity ( activity ) cloned_ncs_pathways = cloned_activity . pathways # Remove pathways in the IM activity . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , activity_item ) return result add_ncs_pathway \u00b6 add_ncs_pathway ( ncs_item , target_activity_item ) Adds an NCS pathway item to the activity. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_activity_item ActivityItem Target activity for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the activity. Source code in src/cplus_plugin/gui/component_item_model.py 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_activity_item : ActivityItem ) -> bool : \"\"\"Adds an NCS pathway item to the activity. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_activity_item: Target activity for the NCS item. :type target_activity_item: ActivityItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the activity. \"\"\" idx = target_activity_item . index () if not idx . isValid (): return False if not isinstance ( target_activity_item , LayerComponentItem ): return False # Do not add if the activity item has been disabled # (e.g. disabled default activities) if not target_activity_item . isEnabled (): return False # If there is an existing layer then return if target_activity_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_activity_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_activity_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . activity_pathways_updated . emit ( target_activity_item ) return True dropMimeData \u00b6 dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . OpenModeFlag . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference to activity item if parent . isValid (): activity_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () activity_item = self . item ( row_count - 1 ) if activity_item is None or isinstance ( activity_item , LayerItem ): return False if activity_item . type () == NCS_PATHWAY_TYPE : target_activity_item = activity_item . parent else : target_activity_item = activity_item # Add NCS items to the activity. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_activity_item ) return status remove_activity \u00b6 remove_activity ( uuid_str ) Remove an activity item from the view model. param uuid: UUID of the activity item to be removed. Returns: Type Description bool True if the activity item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 def remove_activity ( self , uuid_str : str ) -> bool : \"\"\"Remove an activity item from the view model. param uuid: UUID of the activity item to be removed. :type uuid_str: str :returns: True if the activity item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" activity_item = self . component_item_by_uuid ( uuid_str ) if activity_item is None : return False if len ( activity_item . ncs_items ) > 0 : ncs_items = activity_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( activity_item ) return self . remove_component_item ( uuid_str ) remove_layer \u00b6 remove_layer ( activity_item ) Removes the layer reference from the underlying activity. Parameters: Name Type Description Default activity_item ActivityItem activity item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 def remove_layer ( self , activity_item : ActivityItem ): \"\"\"Removes the layer reference from the underlying activity. :param activity_item: activity item whose layer is to be removed. :type activity_item: ActivityItem \"\"\" if activity_item . layer is None : return if not self . contains_item ( activity_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( activity_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) self . _re_index_rows () # Remove underlying layer reference activity_item . clear_layer () remove_ncs_pathway_item \u00b6 remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the activity. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ActivityItem Reference activity item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ActivityItem ) -> bool : \"\"\"Remove an NCS pathway item from the activity. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference activity item that is the parent to the NCS pathway item. :type parent: ActivityItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . activity_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid ) remove_ncs_pathway_items \u00b6 remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be deleted. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identifier of the NCS pathway object whose corresponding models are to be removed in the activities. required Source code in src/cplus_plugin/gui/component_item_model.py 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be deleted. :param ncs_pathway_uuid: Unique identifier of the NCS pathway object whose corresponding models are to be removed in the activities. :type ncs_pathway_uuid: str \"\"\" for im_item in self . activity_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway_uuid ) if ncs_item_for_original is None : continue status = self . remove_ncs_pathway_item ( ncs_item_for_original . uuid , im_item ) set_model_layer \u00b6 set_model_layer ( activity_item , layer , display_name = '' ) Set the layer for the given activity item. Parameters: Name Type Description Default activity_item ActivityItem activity item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the activity. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the activity, else False if the layer is invalid, if there are already existing NCS pathways in the activity or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 def set_model_layer ( self , activity_item : ActivityItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given activity item. :param activity_item: activity item whose layer is to be specified. :type activity_item: ActivityItem :param layer: Map layer to be set for the activity. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the activity, else False if the layer is invalid, if there are already existing NCS pathways in the activity or if the item is not in the model. :rtype: bool \"\"\" if len ( activity_item . ncs_items ) > 0 : return False if not self . contains_item ( activity_item . uuid ): return False if not activity_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( layer . source ()) item . setData ( activity_item ) item_idx = self . index_by_uuid ( activity_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) self . _re_index_rows () return True update_activity \u00b6 update_activity ( activity , layer = None ) Updates the activity item using the given activity. Parameters: Name Type Description Default activity Activity Activity object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the activity if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the activity. Source code in src/cplus_plugin/gui/component_item_model.py 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 def update_activity ( self , activity : Activity , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the activity item using the given activity. :param activity: Activity object whose corresponding item is to be updated. :type activity: Activity :param layer: Map layer to be updated for the activity if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the activity. \"\"\" item = self . component_item_by_uuid ( str ( activity . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True update_ncs_pathway_items \u00b6 update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be updated. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway object whose corresponding models are to be updated. required Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be updated. :param ncs_pathway: Original NCS pathway object whose corresponding models are to be updated. :type ncs_pathway: NcsPathway :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for activity_item in self . activity_items (): ncs_item_for_original = activity_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True ComponentItemModel \u00b6 ComponentItemModel ( parent = None , is_checkable = False ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 664 665 666 667 668 669 670 671 def __init__ ( self , parent = None , is_checkable = False ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Added in v1.1.18 self . checkable_item = is_checkable self . _uuid_row_idx = {} add_component_item \u00b6 add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True component_item_by_uuid \u00b6 component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row ) contains_item \u00b6 contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 702 703 704 705 706 707 708 709 710 711 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False disabled_items \u00b6 disabled_items () Gets the list of disabled items in the model. Returns: Type Description list Disabled items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 839 840 841 842 843 844 845 def disabled_items ( self ) -> typing . List [ LayerComponentItem ]: \"\"\"Gets the list of disabled items in the model. :returns: Disabled items in the model. :rtype: list \"\"\" return [ item for item in self . model_component_items () if not item . isEnabled ()] enable_default_items \u00b6 enable_default_items ( state ) Enable or disable items for default model components. Parameters: Name Type Description Default state bool True to enable or False to disable. required Source code in src/cplus_plugin/gui/component_item_model.py 826 827 828 829 830 831 832 833 834 835 836 837 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable items for default model components. :param state: True to enable or False to disable. :type state: bool \"\"\" for item in self . model_component_items (): if not isinstance ( item , LayerComponentItem ): continue if not item . user_defined : item . setEnabled ( state ) index_by_uuid \u00b6 index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 ) model_component_items \u00b6 model_component_items () Returns model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () items = [] for r in range ( rows ): item = self . item ( r ) items . append ( item ) return items model_components \u00b6 model_components () Returns a collection of model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 766 767 768 769 770 771 772 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" return [ item . model_component for item in self . model_component_items ()] remove_component_item \u00b6 remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True update_item \u00b6 update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True LayerComponentItem \u00b6 LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 140 141 142 143 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component ) layer property \u00b6 layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component. user_defined property \u00b6 user_defined Returns whether the model component is user-defined or default that is shipped together with the plugin. Returns: Type Description bool True if the model component is user-defined else False if its a default component. clone abstractmethod \u00b6 clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 214 215 216 217 218 219 220 221 222 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod \u00b6 create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass is_valid \u00b6 is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 145 146 147 148 149 150 151 152 153 154 155 156 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid () set_layer \u00b6 set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True LayerItem \u00b6 Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an activity. type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 652 653 654 655 656 657 658 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE ModelComponentItem \u00b6 ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 51 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component ) component_name property \u00b6 component_name Returns the name of the model component. Returns: Type Description str name of the model component. description property \u00b6 description Returns the description of the item. Returns: Type Description str Description of the item. model_component property \u00b6 model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object. uuid property \u00b6 uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item. clone abstractmethod \u00b6 clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 121 122 123 124 125 126 127 128 129 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass create abstractmethod staticmethod \u00b6 create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass update \u00b6 update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 53 54 55 56 57 58 59 60 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name ) NcsPathwayItem \u00b6 NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 239 240 241 242 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None ncs_pathway property \u00b6 ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object. parent property \u00b6 parent Returns the parent activity item if specified. Returns: Type Description ActivityItem Returns the parent item if set when this item is mapped to an ActivityItem. clone \u00b6 clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 284 285 286 287 288 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs ) create staticmethod \u00b6 create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Parameters: Name Type Description Default ncs NcsPathway NcsPathway model object required Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 271 272 273 274 275 276 277 278 279 280 281 282 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :param ncs: NcsPathway model object :type ncs: NcsPathway :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs ) is_carbon_valid \u00b6 is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 302 303 304 305 306 307 308 309 310 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid () json_data \u00b6 json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 290 291 292 293 294 295 296 297 298 299 300 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs ) setEnabled \u00b6 setEnabled ( enabled ) Override for default implementation that also enables or disables selection of the item. Source code in src/cplus_plugin/gui/component_item_model.py 312 313 314 315 316 317 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables selection of the item. \"\"\" self . setSelectable ( enabled ) super () . setEnabled ( enabled ) type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 263 264 265 266 267 268 269 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE NcsPathwayItemModel \u00b6 NcsPathwayItemModel ( parent = None , is_checkable = False ) Bases: ComponentItemModel View model for NCS pathways. Source code in src/cplus_plugin/gui/component_item_model.py 664 665 666 667 668 669 670 671 def __init__ ( self , parent = None , is_checkable = False ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Added in v1.1.18 self . checkable_item = is_checkable self . _uuid_row_idx = {} add_ncs_pathway \u00b6 add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) if self . checkable_item : ncs_item . setCheckable ( True ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status mimeData \u00b6 mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . OpenModeFlag . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue # Do not add disabled items (e.g. disabled default NCS pathway items) if not ncs_item . isEnabled (): continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data mimeTypes \u00b6 mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 953 954 955 956 957 958 959 960 961 962 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ] pathways \u00b6 pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways remove_ncs_pathway \u00b6 remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 931 932 933 934 935 936 937 938 939 940 941 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid ) supportedDropActions \u00b6 supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 943 944 945 946 947 948 949 950 951 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction update_ncs_pathway \u00b6 update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#component-item-model","text":"Contains item models for view widgets such as NCS pathway or IM views.","title":"Component item model"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem","text":"ActivityItem ( activity , bold_text = True ) Bases: LayerComponentItem Standard item for an activity object. Source code in src/cplus_plugin/gui/component_item_model.py 323 324 325 326 327 328 329 330 331 332 333 def __init__ ( self , activity : Activity , bold_text : bool = True ): super () . __init__ ( activity ) self . _activity = activity self . set_bold_font ( bold_text ) self . _ncs_items = [] # Remap pathway uuids so that there are no duplicate # pathways under each activity. self . _uuid_remap = {}","title":"ActivityItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.activity","text":"activity Returns an instance of the underlying activity object. Returns: Type Description Activity The underlying activity object.","title":"activity"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.layer_item","text":"layer_item Returns the view item for the layer. Returns: Type Description QtGui.QStandardItem Returns the view item for the map layer else None if no layer has been specified for the model.","title":"layer_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.ncs_items","text":"ncs_items Returns a collection of NcsPathwayItem in this activity object. Returns: Type Description list Collection of NcsPathwayItem objects in this activity object.","title":"ncs_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.ncs_pathways","text":"ncs_pathways Returns a collection of NcsPathway objects. Returns: Type Description list Collection of NcsPathway objects linked to the underlying activity object.","title":"ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.original_ncs_pathways","text":"original_ncs_pathways Returns a collection of NcsPathway objects but with their original UUIDs. These are used for persisting the NCsPathway objects related to the underlying activity object. Returns: Type Description list Collection of NcsPathway objects with their original UUIDs linked to the underlying activity object.","title":"original_ncs_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.add_ncs_pathway_item","text":"add_ncs_pathway_item ( ncs_item ) Adds an NCS pathway item to this activity item. If the item already contains a layer, then the add operation will not be successful. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. Source code in src/cplus_plugin/gui/component_item_model.py 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def add_ncs_pathway_item ( self , ncs_item : NcsPathwayItem ) -> bool : \"\"\"Adds an NCS pathway item to this activity item. If the item already contains a layer, then the add operation will not be successful. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if the layer property had already been set. \"\"\" if self . layer : return False old_uuid = ncs_item . uuid new_uuid = uuid4 () ncs_item . ncs_pathway . uuid = new_uuid if old_uuid in self . _uuid_remap : return False if self . contains_ncs_item ( ncs_item . uuid ): return False if not ncs_item . is_valid (): return False if self . _activity . contains_pathway ( ncs_item . uuid ): return False if not self . _activity . add_ncs_pathway ( ncs_item . ncs_pathway ): return False self . _ncs_items . append ( ncs_item ) ncs_item . _parent = self self . _uuid_remap [ old_uuid ] = str ( new_uuid ) return True","title":"add_ncs_pathway_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.bottom_ncs_item_index","text":"bottom_ncs_item_index () Returns the model index of the bottom-most NcsPathwayItem under this activity item. Returns: Type Description QModelIndex Model index of the bottom-most NcsPathwayItem. Source code in src/cplus_plugin/gui/component_item_model.py 552 553 554 555 556 557 558 559 560 561 562 563 564 def bottom_ncs_item_index ( self ) -> typing . Union [ QtCore . QModelIndex , None ]: \"\"\"Returns the model index of the bottom-most NcsPathwayItem under this activity item. :returns: Model index of the bottom-most NcsPathwayItem. :rtype: QModelIndex \"\"\" if len ( self . _ncs_items ) == 0 : return None bottom_ncs_item = max ( self . _ncs_items , key = lambda n : n . index () . row ()) return bottom_ncs_item . index ()","title":"bottom_ncs_item_index"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.clear_layer","text":"clear_layer () Clears the layer reference in the model component. Source code in src/cplus_plugin/gui/component_item_model.py 443 444 445 def clear_layer ( self ): \"\"\"Clears the layer reference in the model component.\"\"\" self . _activity . clear_layer ()","title":"clear_layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.clone","text":"clone () Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the activity object will not change. Source code in src/cplus_plugin/gui/component_item_model.py 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def clone ( self ) -> \"ActivityItem\" : \"\"\"Creates a cloned version of this item. The cloned IM will contain pathways with the original UUID. The UUID of the activity object will not change. \"\"\" activity = clone_activity ( self . activity , ) # Use NCS pathways with original UUIDs activity . pathways = self . original_ncs_pathways return ActivityItem ( activity )","title":"clone"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.contains_ncs_item","text":"contains_ncs_item ( item_uuid ) Checks whether this item contains an NcsPathway item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the NcsPathway item to search for. required Returns: Type Description bool True if there is an NcsPathwayItem matching the given UUID, else False. Source code in src/cplus_plugin/gui/component_item_model.py 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 def contains_ncs_item ( self , item_uuid : str ) -> bool : \"\"\"Checks whether this item contains an NcsPathway item with the given UUID. :param item_uuid: UUID of the NcsPathway item to search for. :type item_uuid: str :returns: True if there is an NcsPathwayItem matching the given UUID, else False. :rtype: bool \"\"\" if self . ncs_item_by_uuid ( item_uuid ) is None : return False return True","title":"contains_ncs_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.create","text":"create ( activity ) Creates an instance of the activity item from the model object. Parameters: Name Type Description Default activity Activity Activity model object required Returns: Type Description Activity An instance of the activity item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 574 575 576 577 578 579 580 581 582 583 584 585 586 @staticmethod def create ( activity : Activity ) -> \"ActivityItem\" : \"\"\"Creates an instance of the activity item from the model object. :param activity: Activity model object :type activity: Activity :returns: An instance of the activity item to be used in a standard model. :rtype: Activity \"\"\" return ActivityItem ( activity )","title":"create"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.enable_default_pathways","text":"enable_default_pathways ( state ) Enable or disable default NCS pathway items. Parameters: Name Type Description Default state bool True to enable default NCS pathways else False to disable them. required Source code in src/cplus_plugin/gui/component_item_model.py 603 604 605 606 607 608 609 610 611 612 613 614 615 def enable_default_pathways ( self , state : bool ): \"\"\"Enable or disable default NCS pathway items. :param state: True to enable default NCS pathways else False to disable them. :type state: bool \"\"\" for ncs_item in self . _ncs_items : if ncs_item . user_defined : continue if ncs_item . isEnabled () != state : ncs_item . setEnabled ( state )","title":"enable_default_pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.ncs_item_by_uuid","text":"ncs_item_by_uuid ( ncs_uuid ) Returns an NcsPathway item matching the given UUID. Parameters: Name Type Description Default ncs_uuid str UUID of the NcsPathway item to retrieve. required Returns: Type Description NcsPathwayItem NcsPathwayItem matching the given UUID, else None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def ncs_item_by_uuid ( self , ncs_uuid : str ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Returns an NcsPathway item matching the given UUID. :param ncs_uuid: UUID of the NcsPathway item to retrieve. :type ncs_uuid: str :returns: NcsPathwayItem matching the given UUID, else None if not found. :rtype: NcsPathwayItem \"\"\" ncs_items = [ n for n in self . _ncs_items if n . uuid == ncs_uuid ] if len ( ncs_items ) == 0 : return None return ncs_items [ 0 ]","title":"ncs_item_by_uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.ncs_item_from_original_pathway","text":"ncs_item_from_original_pathway ( ncs_pathway ) Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this activity item. Parameters: Name Type Description Default ncs_pathway Union [ NcsPathway , str ] Original NCS pathway data model or unique identifier of the NCS pathway. required Returns: Type Description Union [ NcsPathwayItem , None] The matching NCS pathway item in this activity item, else None if there is no matching item. Source code in src/cplus_plugin/gui/component_item_model.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def ncs_item_from_original_pathway ( self , ncs_pathway : typing . Union [ NcsPathway , str ] ) -> typing . Union [ NcsPathwayItem , None ]: \"\"\"Retrieves the NCS item corresponding to the original NCS pathway i.e. before it is added to this activity item. :param ncs_pathway: Original NCS pathway data model or unique identifier of the NCS pathway. :type ncs_pathway: NcsPathway, str :returns: The matching NCS pathway item in this activity item, else None if there is no matching item. \"\"\" if isinstance ( ncs_pathway , NcsPathway ): ncs_uuid = str ( ncs_pathway . uuid ) else : ncs_uuid = ncs_pathway if ncs_uuid not in self . _uuid_remap : return None new_uuid = self . _uuid_remap [ ncs_uuid ] return self . ncs_item_by_uuid ( new_uuid )","title":"ncs_item_from_original_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( item_uuid ) Removes the NcsPathwayItem matching the given UUID. Parameters: Name Type Description Default item_uuid str The UUID of the NcsPathwayItem to remove. required Returns: Type Description bool True if the item was successfully removed, else False. Source code in src/cplus_plugin/gui/component_item_model.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def remove_ncs_pathway_item ( self , item_uuid : str ) -> bool : \"\"\"Removes the NcsPathwayItem matching the given UUID. :param item_uuid: The UUID of the NcsPathwayItem to remove. :type item_uuid: str :returns: True if the item was successfully removed, else False. :rtype: bool \"\"\" if not self . contains_ncs_item ( item_uuid ): return False idxs = [ i for i , n in enumerate ( self . _ncs_items ) if n . uuid == item_uuid ] if len ( idxs ) == 0 : return False item = self . _ncs_items . pop ( idxs [ 0 ]) item . _parent = None del item self . _activity . remove_ncs_pathway ( item_uuid ) old_uuids = [ k for k , v in self . _uuid_remap . items () if v == item_uuid ] if len ( old_uuids ) > 0 : del self . _uuid_remap [ old_uuids [ 0 ]] return True","title":"remove_ncs_pathway_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.setEnabled","text":"setEnabled ( enabled ) Override for default implementation that also enables or disables NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 637 638 639 640 641 642 643 644 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables NCS pathway items. \"\"\" self . enable_default_pathways ( enabled ) self . _enable_layer_item ( enabled ) self . setSelectable ( enabled ) super () . setEnabled ( enabled )","title":"setEnabled"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.set_bold_font","text":"set_bold_font ( bold ) Set the text to bold or normal. Parameters: Name Type Description Default bold bool True to set the text font to be bold, else False to normal. required Source code in src/cplus_plugin/gui/component_item_model.py 335 336 337 338 339 340 341 342 343 344 def set_bold_font ( self , bold : bool ): \"\"\"Set the text to bold or normal. :param bold: True to set the text font to be bold, else False to normal. :type bold: bool \"\"\" font = self . font () font . setBold ( bold ) self . setFont ( font )","title":"set_bold_font"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 566 567 568 569 570 571 572 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return ACTIVITY_TYPE","title":"type"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel","text":"ActivityItemModel ( * args , ** kwargs ) Bases: ComponentItemModel View model for activity. Source code in src/cplus_plugin/gui/component_item_model.py 1006 1007 1008 def __init__ ( self , * args , ** kwargs ): self . _load_pathways = kwargs . pop ( \"load_pathways\" , True ) super () . __init__ ( * args , ** kwargs )","title":"ActivityItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.activities","text":"activities () Returns activity objects in the view model. Returns: Type Description list Activity objects in the view model. Source code in src/cplus_plugin/gui/component_item_model.py 1236 1237 1238 1239 1240 1241 1242 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns activity objects in the view model. :returns: Activity objects in the view model. :rtype: list \"\"\" return [ model_item . activity for model_item in self . activity_items ()]","title":"activities"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.activity_items","text":"activity_items () Returns all activity item objects in the model. Returns: Type Description list Activity items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 def activity_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns all activity item objects in the model. :returns: Activity items in the model. :rtype: list \"\"\" component_items = self . model_component_items () return [ ci for ci in component_items if ci . type () == ACTIVITY_TYPE ]","title":"activity_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.add_activity","text":"add_activity ( activity , layer = None ) Add an activity object to the model. Parameters: Name Type Description Default activity Activity Activity object to be added to the view. required layer QgsMapLayer Map layer for the activity. None Returns: Type Description bool True if an activity object was added successfully, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 def add_activity ( self , activity : Activity , layer : QgsMapLayer = None ) -> bool : \"\"\"Add an activity object to the model. :param activity: Activity object to be added to the view. :type activity: Activity :param layer: Map layer for the activity. :type layer: QgsMapLayer :returns: True if an activity object was added successfully, else False. :rtype: bool \"\"\" # Check if we can retrieve the layer from the path if layer is None : if activity . path : layer = activity . to_map_layer () activity_item = ActivityItem . create ( activity ) if self . checkable_item : activity_item . setCheckable ( True ) if not self . _load_pathways : activity_item . set_bold_font ( False ) result = self . add_component_item ( activity_item ) # No need to load any additional information if not showing pathways if not self . _load_pathways : return result if layer : status = self . set_model_layer ( activity_item , layer ) if not status : result = False else : # Add NCS pathways. If there are underlying NCS pathway objects then # clone them, remove then re-insert so that the underlying NCS pathways can # have the unique UUID in the activity item. if result : cloned_activity = clone_activity ( activity ) cloned_ncs_pathways = cloned_activity . pathways # Remove pathways in the IM activity . pathways = [] # Now add the NCSs afresh for ncs in cloned_ncs_pathways : ncs_item = NcsPathwayItem . create ( ncs ) self . add_ncs_pathway ( ncs_item , activity_item ) return result","title":"add_activity"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs_item , target_activity_item ) Adds an NCS pathway item to the activity. Parameters: Name Type Description Default ncs_item NcsPathwayItem NCS pathway item to the collection. required target_activity_item ActivityItem Target activity for the NCS item. required Returns: Type Description bool True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the activity. Source code in src/cplus_plugin/gui/component_item_model.py 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 def add_ncs_pathway ( self , ncs_item : NcsPathwayItem , target_activity_item : ActivityItem ) -> bool : \"\"\"Adds an NCS pathway item to the activity. :param ncs_item: NCS pathway item to the collection. :type ncs_item: NcsPathwayItem :param target_activity_item: Target activity for the NCS item. :type target_activity_item: ActivityItem :returns: True if the NCS pathway item was successfully added, else False if there underlying NCS pathway object was invalid, there is an existing item with the same UUID or if there is already a map layer defined for the activity. \"\"\" idx = target_activity_item . index () if not idx . isValid (): return False if not isinstance ( target_activity_item , LayerComponentItem ): return False # Do not add if the activity item has been disabled # (e.g. disabled default activities) if not target_activity_item . isEnabled (): return False # If there is an existing layer then return if target_activity_item . layer : return False clone_ncs_item = ncs_item . clone () status = target_activity_item . add_ncs_pathway_item ( clone_ncs_item ) if not status : return False bottom_idx = target_activity_item . bottom_ncs_item_index () reference_row = max ( bottom_idx . row (), idx . row ()) self . add_component_item ( clone_ncs_item , reference_row + 1 ) self . activity_pathways_updated . emit ( target_activity_item ) return True","title":"add_ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.dropMimeData","text":"dropMimeData ( data , action , row , column , parent ) Implements behaviour for handling data supplied by drag and drop operation. Parameters: Name Type Description Default data QMimeData Object containing data from the drag operation. required action DropAction Type of the drag and drop operation. required row int Row location of dropped data. required column int Column location of dropped data. required parent QModelIndex Index location for target item where the operation ended. required Returns: Type Description bool True if the data and action can be handled by the model, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 def dropMimeData ( self , data : QtCore . QMimeData , action : QtCore . Qt . DropAction , row : int , column : int , parent : QtCore . QModelIndex , ) -> bool : \"\"\"Implements behaviour for handling data supplied by drag and drop operation. :param data: Object containing data from the drag operation. :type data: QtCore.QMimeData :param action: Type of the drag and drop operation. :type action: QtCore.Qt.DropAction :param row: Row location of dropped data. :type row: int :param column: Column location of dropped data. :type column: int :param parent: Index location for target item where the operation ended. :type parent: QtCore.QModelIndex :returns: True if the data and action can be handled by the model, else False. :rtype: bool \"\"\" if action == QtCore . Qt . IgnoreAction : return True if not data . hasFormat ( NCS_MIME_TYPE ): return False encoded_data = data . data ( NCS_MIME_TYPE ) data_stream = QtCore . QDataStream ( encoded_data , QtCore . QIODevice . OpenModeFlag . ReadOnly ) ncs_items = [] while not data_stream . atEnd (): byte_data = QtCore . QByteArray () data_stream >> byte_data item_data = json . loads ( byte_data . data ()) ncs_pathway = create_ncs_pathway ( item_data ) ncs_item = NcsPathwayItem ( ncs_pathway ) ncs_items . append ( ncs_item ) # Get reference to activity item if parent . isValid (): activity_item = self . itemFromIndex ( parent ) else : row_count = self . rowCount () activity_item = self . item ( row_count - 1 ) if activity_item is None or isinstance ( activity_item , LayerItem ): return False if activity_item . type () == NCS_PATHWAY_TYPE : target_activity_item = activity_item . parent else : target_activity_item = activity_item # Add NCS items to the activity. status = True for item in ncs_items : status = self . add_ncs_pathway ( item , target_activity_item ) return status","title":"dropMimeData"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.remove_activity","text":"remove_activity ( uuid_str ) Remove an activity item from the view model. param uuid: UUID of the activity item to be removed. Returns: Type Description bool True if the activity item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 def remove_activity ( self , uuid_str : str ) -> bool : \"\"\"Remove an activity item from the view model. param uuid: UUID of the activity item to be removed. :type uuid_str: str :returns: True if the activity item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" activity_item = self . component_item_by_uuid ( uuid_str ) if activity_item is None : return False if len ( activity_item . ncs_items ) > 0 : ncs_items = activity_item . ncs_items for item in ncs_items : self . remove_component_item ( item . uuid ) else : # Layer item self . remove_layer ( activity_item ) return self . remove_component_item ( uuid_str )","title":"remove_activity"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.remove_layer","text":"remove_layer ( activity_item ) Removes the layer reference from the underlying activity. Parameters: Name Type Description Default activity_item ActivityItem activity item whose layer is to be removed. required Source code in src/cplus_plugin/gui/component_item_model.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 def remove_layer ( self , activity_item : ActivityItem ): \"\"\"Removes the layer reference from the underlying activity. :param activity_item: activity item whose layer is to be removed. :type activity_item: ActivityItem \"\"\" if activity_item . layer is None : return if not self . contains_item ( activity_item . uuid ): return # Remove item in model item_idx = self . index_by_uuid ( activity_item . uuid ) layer_row = item_idx . row () + 1 self . removeRows ( layer_row , 1 ) self . _re_index_rows () # Remove underlying layer reference activity_item . clear_layer ()","title":"remove_layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.remove_ncs_pathway_item","text":"remove_ncs_pathway_item ( ncs_uuid , parent ) Remove an NCS pathway item from the activity. param uuid: UUID of the NCS pathway item to be removed. Parameters: Name Type Description Default parent ActivityItem Reference activity item that is the parent to the NCS pathway item. required Returns: Type Description bool True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 def remove_ncs_pathway_item ( self , ncs_uuid : str , parent : ActivityItem ) -> bool : \"\"\"Remove an NCS pathway item from the activity. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :param parent: Reference activity item that is the parent to the NCS pathway item. :type parent: ActivityItem :returns: True if the NCS pathway item has been successfully removed, else False if there was no matching UUID. :rtype: bool \"\"\" status = parent . remove_ncs_pathway_item ( ncs_uuid ) if not status : return False self . activity_pathways_updated . emit ( parent ) return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.remove_ncs_pathway_items","text":"remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be deleted. Parameters: Name Type Description Default ncs_pathway_uuid str Unique identifier of the NCS pathway object whose corresponding models are to be removed in the activities. required Source code in src/cplus_plugin/gui/component_item_model.py 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be deleted. :param ncs_pathway_uuid: Unique identifier of the NCS pathway object whose corresponding models are to be removed in the activities. :type ncs_pathway_uuid: str \"\"\" for im_item in self . activity_items (): ncs_item_for_original = im_item . ncs_item_from_original_pathway ( ncs_pathway_uuid ) if ncs_item_for_original is None : continue status = self . remove_ncs_pathway_item ( ncs_item_for_original . uuid , im_item )","title":"remove_ncs_pathway_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.set_model_layer","text":"set_model_layer ( activity_item , layer , display_name = '' ) Set the layer for the given activity item. Parameters: Name Type Description Default activity_item ActivityItem activity item whose layer is to be specified. required layer QgsMapLayer Map layer to be set for the activity. required display_name str Display name for the layer node. If not specified then the name from the map layer is used. '' Returns: Type Description bool True if the layer was successfully set for the activity, else False if the layer is invalid, if there are already existing NCS pathways in the activity or if the item is not in the model. Source code in src/cplus_plugin/gui/component_item_model.py 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 def set_model_layer ( self , activity_item : ActivityItem , layer : QgsMapLayer , display_name : str = \"\" , ) -> bool : \"\"\"Set the layer for the given activity item. :param activity_item: activity item whose layer is to be specified. :type activity_item: ActivityItem :param layer: Map layer to be set for the activity. :type layer: QgsMapLayer :param display_name: Display name for the layer node. If not specified then the name from the map layer is used. :type display_name: str :returns: True if the layer was successfully set for the activity, else False if the layer is invalid, if there are already existing NCS pathways in the activity or if the item is not in the model. :rtype: bool \"\"\" if len ( activity_item . ncs_items ) > 0 : return False if not self . contains_item ( activity_item . uuid ): return False if not activity_item . set_layer ( layer ): return False if not display_name : display_name = layer . name () icon = FileUtils . get_icon ( \"mIconRaster.svg\" ) item = LayerItem ( icon , display_name ) item . setToolTip ( layer . source ()) item . setData ( activity_item ) item_idx = self . index_by_uuid ( activity_item . uuid ) layer_row = item_idx . row () + 1 self . insertRow ( layer_row , item ) self . _re_index_rows () return True","title":"set_model_layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.update_activity","text":"update_activity ( activity , layer = None ) Updates the activity item using the given activity. Parameters: Name Type Description Default activity Activity Activity object whose corresponding item is to be updated. required layer QgsMapLayer Map layer to be updated for the activity if specified. None Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the activity. Source code in src/cplus_plugin/gui/component_item_model.py 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 def update_activity ( self , activity : Activity , layer : QgsMapLayer = None ) -> bool : \"\"\"Updates the activity item using the given activity. :param activity: Activity object whose corresponding item is to be updated. :type activity: Activity :param layer: Map layer to be updated for the activity if specified. :type layer: QgsMapLayer :returns: Returns True if the operation was successful else False if the matching item was not found in the activity. \"\"\" item = self . component_item_by_uuid ( str ( activity . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False # Update layer information self . remove_layer ( item ) if layer : layer_status = self . set_model_layer ( item , layer ) if not layer_status : return False return True","title":"update_activity"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ActivityItemModel.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be updated. Parameters: Name Type Description Default ncs_pathway NcsPathway Original NCS pathway object whose corresponding models are to be updated. required Returns: Type Description bool True if matching NCS pathway items have been updated, else False. Source code in src/cplus_plugin/gui/component_item_model.py 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items matching the given NCS pathway model. If the NCS pathway model is not valid then the NCS pathway items in the activity item will not be updated. :param ncs_pathway: Original NCS pathway object whose corresponding models are to be updated. :type ncs_pathway: NcsPathway :returns: True if matching NCS pathway items have been updated, else False. :rtype: bool \"\"\" if not ncs_pathway . is_valid (): return False for activity_item in self . activity_items (): ncs_item_for_original = activity_item . ncs_item_from_original_pathway ( ncs_pathway ) if ncs_item_for_original is None : continue item_pathway = ncs_item_for_original . ncs_pathway # Copy attribute values excluding the UUID copy_layer_component_attributes ( item_pathway , ncs_pathway ) ncs_item_for_original . update ( item_pathway ) return True","title":"update_ncs_pathway_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel","text":"ComponentItemModel ( parent = None , is_checkable = False ) Bases: QStandardItemModel View model for ModelComponent objects. Source code in src/cplus_plugin/gui/component_item_model.py 664 665 666 667 668 669 670 671 def __init__ ( self , parent = None , is_checkable = False ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Added in v1.1.18 self . checkable_item = is_checkable self . _uuid_row_idx = {}","title":"ComponentItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.add_component_item","text":"add_component_item ( component_item , position =- 1 ) Adds a model component item to the view model. Parameters: Name Type Description Default component_item ModelComponentItem Model component item to be added to the view model. required position int Reference row to insert the item. -1 Returns: Type Description bool True if the component item was successfully added, else False if there is an existing component item with the same UUID. Source code in src/cplus_plugin/gui/component_item_model.py 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 def add_component_item ( self , component_item : ModelComponentItem , position =- 1 ) -> bool : \"\"\"Adds a model component item to the view model. :param component_item: Model component item to be added to the view model. :type component_item: ModelComponentItem :param position: Reference row to insert the item. :type position: int :returns: True if the component item was successfully added, else False if there is an existing component item with the same UUID. :rtype: bool \"\"\" idx = position if position == - 1 : idx = self . rowCount () if self . contains_item ( str ( component_item . uuid )): return False self . insertRow ( idx , component_item ) self . _re_index_rows () return True","title":"add_component_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.component_item_by_uuid","text":"component_item_by_uuid ( uuid_str ) Retrieves a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description ModelComponentItem Component item matching the given UUID or None if not found. Source code in src/cplus_plugin/gui/component_item_model.py 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 def component_item_by_uuid ( self , uuid_str : str ) -> typing . Union [ ModelComponentItemType , None ]: \"\"\"Retrieves a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: Component item matching the given UUID or None if not found. :rtype: ModelComponentItem \"\"\" if uuid_str not in self . _uuid_row_idx : return None row = self . _uuid_row_idx [ uuid_str ] return self . item ( row )","title":"component_item_by_uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.contains_item","text":"contains_item ( item_uuid ) Checks if the model contains an item with the given UUID. Parameters: Name Type Description Default item_uuid str UUID of the model item. required Returns: Type Description bool True if there is an existing item else False. Source code in src/cplus_plugin/gui/component_item_model.py 702 703 704 705 706 707 708 709 710 711 def contains_item ( self , item_uuid : str ) -> bool : \"\"\"Checks if the model contains an item with the given UUID. :param item_uuid: UUID of the model item. :type item_uuid: str :returns: True if there is an existing item else False. :rtype: bool \"\"\" return True if self . component_item_by_uuid ( item_uuid ) is not None else False","title":"contains_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.disabled_items","text":"disabled_items () Gets the list of disabled items in the model. Returns: Type Description list Disabled items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 839 840 841 842 843 844 845 def disabled_items ( self ) -> typing . List [ LayerComponentItem ]: \"\"\"Gets the list of disabled items in the model. :returns: Disabled items in the model. :rtype: list \"\"\" return [ item for item in self . model_component_items () if not item . isEnabled ()]","title":"disabled_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.enable_default_items","text":"enable_default_items ( state ) Enable or disable items for default model components. Parameters: Name Type Description Default state bool True to enable or False to disable. required Source code in src/cplus_plugin/gui/component_item_model.py 826 827 828 829 830 831 832 833 834 835 836 837 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable items for default model components. :param state: True to enable or False to disable. :type state: bool \"\"\" for item in self . model_component_items (): if not isinstance ( item , LayerComponentItem ): continue if not item . user_defined : item . setEnabled ( state )","title":"enable_default_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.index_by_uuid","text":"index_by_uuid ( uuid_str ) Get the QModelIndex object for the component item matching the given UUID identifier. Parameters: Name Type Description Default uuid_str str UUID of the model item. required Returns: Type Description QtCore.QModelIndex QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. Source code in src/cplus_plugin/gui/component_item_model.py 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 def index_by_uuid ( self , uuid_str ) -> QtCore . QModelIndex : \"\"\"Get the QModelIndex object for the component item matching the given UUID identifier. :param uuid_str: UUID of the model item. :type uuid_str: str :returns: QModelIndex for the component item matching the given UUID or an invalid QModelIndex if not found. :rtype: QtCore.QModelIndex \"\"\" if uuid_str not in self . _uuid_row_idx : return QtCore . QModelIndex () row = self . _uuid_row_idx [ uuid_str ] return self . index ( row , 0 )","title":"index_by_uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_component_items","text":"model_component_items () Returns model component items in the model. Returns: Type Description list Model component items in the model. Source code in src/cplus_plugin/gui/component_item_model.py 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def model_component_items ( self ) -> typing . List [ ModelComponentItem ]: \"\"\"Returns model component items in the model. :returns: Model component items in the model. :rtype: list \"\"\" rows = self . rowCount () items = [] for r in range ( rows ): item = self . item ( r ) items . append ( item ) return items","title":"model_component_items"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.model_components","text":"model_components () Returns a collection of model component objects in the model. Returns: Type Description list A collection of all model component objects. Source code in src/cplus_plugin/gui/component_item_model.py 766 767 768 769 770 771 772 def model_components ( self ) -> typing . List [ BaseModelComponentType ]: \"\"\"Returns a collection of model component objects in the model. :returns: A collection of all model component objects. :rtype: list \"\"\" return [ item . model_component for item in self . model_component_items ()]","title":"model_components"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.remove_component_item","text":"remove_component_item ( uuid_str ) Removes a ModelComponentItem based on a matching UUID. Parameters: Name Type Description Default uuid_str str UUID of the model item to be removed. required Returns: Type Description bool True if the component item was successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 def remove_component_item ( self , uuid_str : str ) -> bool : \"\"\"Removes a ModelComponentItem based on a matching UUID. :param uuid_str: UUID of the model item to be removed. :type uuid_str: str :returns: True if the component item was successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" if not self . contains_item ( uuid_str ): return False if uuid_str not in self . _uuid_row_idx : return False self . removeRows ( self . _uuid_row_idx [ uuid_str ], 1 ) del self . _uuid_row_idx [ uuid_str ] self . _re_index_rows () return True","title":"remove_component_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ComponentItemModel.update_item","text":"update_item ( item ) Update an existing ModelComponentItem if it exists in the model. Parameters: Name Type Description Default item ModelComponentItemType An updated instance of the ModelComponentItem. required Returns: Type Description bool True if the item was successfully updated, else False if there was no matching item found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 def update_item ( self , item : ModelComponentItemType ) -> bool : \"\"\"Update an existing ModelComponentItem if it exists in the model. :param item: An updated instance of the ModelComponentItem. :type item: ModelComponentItem :returns: True if the item was successfully updated, else False if there was no matching item found in the model. :rtype: bool \"\"\" if not self . contains_item ( item . uuid ): return False item . update ( item . model_component ) return True","title":"update_item"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem","text":"LayerComponentItem ( model_component ) Bases: ModelComponentItem Base class view item for layer-based component items. Source code in src/cplus_plugin/gui/component_item_model.py 140 141 142 143 def __init__ ( self , model_component : LayerModelComponent ): if not isinstance ( model_component , LayerModelComponent ): raise TypeError ( \"'model_component' not of type LayerModelComponent\" ) super () . __init__ ( model_component )","title":"LayerComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.layer","text":"layer Returns the map layer from the underlying model component object. Returns: Type Description QgsMapLayer Map layer corresponding from the underlying model component.","title":"layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.user_defined","text":"user_defined Returns whether the model component is user-defined or default that is shipped together with the plugin. Returns: Type Description bool True if the model component is user-defined else False if its a default component.","title":"user_defined"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 214 215 216 217 218 219 220 221 222 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.is_valid","text":"is_valid () Checks whether the map layer of the underlying model component object is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/gui/component_item_model.py 145 146 147 148 149 150 151 152 153 154 155 156 def is_valid ( self ) -> bool : \"\"\"Checks whether the map layer of the underlying model component object is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . _model_component is None : return False return self . _model_component . is_valid ()","title":"is_valid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerComponentItem.set_layer","text":"set_layer ( layer ) Set the map layer for the component item. It sets the :py:attr: ~path attribute of the underlying data model. Parameters: Name Type Description Default layer QgsMapLayer Map layer for the component item. required Returns: Type Description bool Returns True if the layer was successfully set, else False if the layer is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def set_layer ( self , layer : QgsMapLayer ) -> bool : \"\"\"Set the map layer for the component item. It sets the :py:attr:`~path` attribute of the underlying data model. :param layer: Map layer for the component item. :type layer: QgsMapLayer :returns: Returns True if the layer was successfully set, else False if the layer is invalid. :rtype: bool \"\"\" if not layer : return False if not layer . isValid (): return False path = layer . source () self . _model_component . path = path if isinstance ( layer , QgsRasterLayer ): self . _model_component . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . _model_component . layer_type = LayerType . VECTOR return True","title":"set_layer"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem","text":"Bases: QStandardItem Contains a custom identifier for an item used to define a layer for an activity.","title":"LayerItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.LayerItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 652 653 654 655 656 657 658 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return LAYER_ITEM_TYPE","title":"type"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem","text":"ModelComponentItem ( model_component ) Bases: QStandardItem Base standard item for a BaseModelComponent object. Source code in src/cplus_plugin/gui/component_item_model.py 44 45 46 47 48 49 50 51 def __init__ ( self , model_component : BaseModelComponent ): super () . __init__ ( model_component . name ) self . setToolTip ( model_component . name ) self . _model_component = model_component if self . _model_component is not None : self . update ( self . _model_component )","title":"ModelComponentItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.component_name","text":"component_name Returns the name of the model component. Returns: Type Description str name of the model component.","title":"component_name"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.description","text":"description Returns the description of the item. Returns: Type Description str Description of the item.","title":"description"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.model_component","text":"model_component Returns an instance of the underlying model component object. Returns: Type Description BaseModelComponent Instance of underlying model component object.","title":"model_component"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.uuid","text":"uuid Returns the UUID of the item. Returns: Type Description str UUID string of the item.","title":"uuid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.clone","text":"clone () Creates a deep copied version of the model item. Returns: Type Description ModelComponentItem Cloned version of the model item containing all the properties as the source. Source code in src/cplus_plugin/gui/component_item_model.py 121 122 123 124 125 126 127 128 129 @abstractmethod def clone ( self ) -> \"ModelComponentItemType\" : \"\"\"Creates a deep copied version of the model item. :returns: Cloned version of the model item containing all the properties as the source. :rtype: ModelComponentItem \"\"\" pass","title":"clone"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.create","text":"create ( model_component ) Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. Parameters: Name Type Description Default model_component BaseModelComponent Source model component for creating the corresponding item. required Returns: Type Description ModelComponentItem Model component item for use in a standard item model. Source code in src/cplus_plugin/gui/component_item_model.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 @staticmethod @abstractmethod def create ( model_component : BaseModelComponent ) -> \"ModelComponentItem\" : \"\"\"Factory method for creating an instance of a model item. This is an abstract method that needs to be implemented by subclasses. :param model_component: Source model component for creating the corresponding item. :type model_component: BaseModelComponent :returns: Model component item for use in a standard item model. :rtype: ModelComponentItem \"\"\" pass","title":"create"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.ModelComponentItem.update","text":"update ( model_component ) Update the component-related properties of the item. Source code in src/cplus_plugin/gui/component_item_model.py 53 54 55 56 57 58 59 60 def update ( self , model_component : BaseModelComponent ): \"\"\"Update the component-related properties of the item.\"\"\" if model_component is None : return self . _model_component = model_component self . setText ( model_component . name ) self . setToolTip ( model_component . name )","title":"update"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem","text":"NcsPathwayItem ( ncs ) Bases: LayerComponentItem Standard item for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 239 240 241 242 def __init__ ( self , ncs : NcsPathway ): super () . __init__ ( ncs ) self . _ncs_pathway = ncs self . _parent = None","title":"NcsPathwayItem"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.ncs_pathway","text":"ncs_pathway Returns an instance of the underlying NcsPathway object. Returns: Type Description NcsPathway The underlying NcsPathway model object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.parent","text":"parent Returns the parent activity item if specified. Returns: Type Description ActivityItem Returns the parent item if set when this item is mapped to an ActivityItem.","title":"parent"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.clone","text":"clone () Creates a cloned version of this item. Source code in src/cplus_plugin/gui/component_item_model.py 284 285 286 287 288 def clone ( self ) -> \"NcsPathwayItem\" : \"\"\"Creates a cloned version of this item.\"\"\" ncs = clone_ncs_pathway ( self . ncs_pathway ) return NcsPathwayItem ( ncs )","title":"clone"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.create","text":"create ( ncs ) Creates an instance of the NcsPathwayItem from the model object. Parameters: Name Type Description Default ncs NcsPathway NcsPathway model object required Returns: Type Description NcsPathwayItem An instance of the NcsPathway item to be used in a standard model. Source code in src/cplus_plugin/gui/component_item_model.py 271 272 273 274 275 276 277 278 279 280 281 282 @staticmethod def create ( ncs : NcsPathway ) -> \"NcsPathwayItem\" : \"\"\"Creates an instance of the NcsPathwayItem from the model object. :param ncs: NcsPathway model object :type ncs: NcsPathway :returns: An instance of the NcsPathway item to be used in a standard model. :rtype: NcsPathwayItem \"\"\" return NcsPathwayItem ( ncs )","title":"create"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.is_carbon_valid","text":"is_carbon_valid () Returns the validity of the carbon layers in the underlying NCSPathway model object. Returns: Type Description bool True if the carbon layers are valid, else False. Source code in src/cplus_plugin/gui/component_item_model.py 302 303 304 305 306 307 308 309 310 def is_carbon_valid ( self ) -> bool : \"\"\"Returns the validity of the carbon layers in the underlying NCSPathway model object. :returns: True if the carbon layers are valid, else False. :rtype: bool \"\"\" return self . ncs_pathway . is_carbon_valid ()","title":"is_carbon_valid"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.json_data","text":"json_data () Creates a mapping of NCS pathway property names and their corresponding values. Returns: Type Description str JSON representation of property name-value pairs for an NCS pathway object. Source code in src/cplus_plugin/gui/component_item_model.py 290 291 292 293 294 295 296 297 298 299 300 def json_data ( self ) -> str : \"\"\"Creates a mapping of NCS pathway property names and their corresponding values. :returns: JSON representation of property name-value pairs for an NCS pathway object. :rtype: str \"\"\" ncs_attrs = ncs_pathway_to_dict ( self . _ncs_pathway ) return json . dumps ( ncs_attrs )","title":"json_data"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.setEnabled","text":"setEnabled ( enabled ) Override for default implementation that also enables or disables selection of the item. Source code in src/cplus_plugin/gui/component_item_model.py 312 313 314 315 316 317 def setEnabled ( self , enabled : bool ): \"\"\"Override for default implementation that also enables or disables selection of the item. \"\"\" self . setSelectable ( enabled ) super () . setEnabled ( enabled )","title":"setEnabled"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the standard item. Source code in src/cplus_plugin/gui/component_item_model.py 263 264 265 266 267 268 269 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the standard item. :rtype: int \"\"\" return NCS_PATHWAY_TYPE","title":"type"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel","text":"NcsPathwayItemModel ( parent = None , is_checkable = False ) Bases: ComponentItemModel View model for NCS pathways. Source code in src/cplus_plugin/gui/component_item_model.py 664 665 666 667 668 669 670 671 def __init__ ( self , parent = None , is_checkable = False ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Added in v1.1.18 self . checkable_item = is_checkable self . _uuid_row_idx = {}","title":"NcsPathwayItemModel"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Add an NCS pathway object to the model. Parameters: Name Type Description Default ncs NcsPathway NCS pathway object to the added to the view. required Returns: Type Description bool True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. Source code in src/cplus_plugin/gui/component_item_model.py 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Add an NCS pathway object to the model. :param ncs: NCS pathway object to the added to the view. :type ncs: NcsPathway :returns: True if the NCS pathway object was added successfully, else False if the NcsPathway object is invalid. :rtype: bool \"\"\" ncs_item = NcsPathwayItem . create ( ncs ) if self . checkable_item : ncs_item . setCheckable ( True ) self . _update_display ( ncs_item ) status = self . add_component_item ( ncs_item ) self . sort ( 0 ) self . _re_index_rows () return status","title":"add_ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeData","text":"mimeData ( indexes ) Serializes the NCS items corresponding to the specified indexes. Parameters: Name Type Description Default indexes List [ QModelIndex ] NCS items stored in the specified indexes. required Returns: Type Description QtCore.QMimeData Mime object containing serialized NCS items. Source code in src/cplus_plugin/gui/component_item_model.py 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 def mimeData ( self , indexes : typing . List [ QtCore . QModelIndex ]) -> QtCore . QMimeData : \"\"\"Serializes the NCS items corresponding to the specified indexes. :param indexes: NCS items stored in the specified indexes. :type indexes: list :returns: Mime object containing serialized NCS items. :rtype: QtCore.QMimeData \"\"\" mime_data = QtCore . QMimeData () item_data = QtCore . QByteArray () data_stream = QtCore . QDataStream ( item_data , QtCore . QIODevice . OpenModeFlag . WriteOnly ) for idx in indexes : if not idx . isValid (): continue ncs_item = self . itemFromIndex ( idx ) if ncs_item is None : continue # Do not add disabled items (e.g. disabled default NCS pathway items) if not ncs_item . isEnabled (): continue ncs_data = QtCore . QByteArray () ncs_data . append ( ncs_item . json_data ()) data_stream << ncs_data mime_data . setData ( NCS_MIME_TYPE , item_data ) return mime_data","title":"mimeData"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.mimeTypes","text":"mimeTypes () Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. Returns: Type Description list MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. Source code in src/cplus_plugin/gui/component_item_model.py 953 954 955 956 957 958 959 960 961 962 def mimeTypes ( self ) -> typing . List [ str ]: \"\"\"Returns supported MIME types that can be used to describe a list of model indexes for NCS pathway items. :returns: MIME type for NCS pathway items which is JSON string but MIME type is the default datalist type for Qt since it does not allow custom types. :rtype: list \"\"\" return [ NCS_MIME_TYPE ]","title":"mimeTypes"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.pathways","text":"pathways ( valid_only = False ) Returns NCS pathway objects in the model. Parameters: Name Type Description Default valid_only bool Whether to only return NCS pathway objects that are valid. False Returns: Type Description list All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. Source code in src/cplus_plugin/gui/component_item_model.py 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 def pathways ( self , valid_only : bool = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns NCS pathway objects in the model. :param valid_only: Whether to only return NCS pathway objects that are valid. :type valid_only: bool :returns: All NCS pathway objects in the model (default), else only those NCS pathway objects that are valid if valid_only is True. :rtype: list \"\"\" ncs_pathways = self . model_components () if valid_only : return [ p for p in ncs_pathways if p . is_valid ()] return ncs_pathways","title":"pathways"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.remove_ncs_pathway","text":"remove_ncs_pathway ( ncs_uuid ) Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. Returns: Type Description bool True if the NCS pathway item as successfully removed, else False if there was not matching UUID. Source code in src/cplus_plugin/gui/component_item_model.py 931 932 933 934 935 936 937 938 939 940 941 def remove_ncs_pathway ( self , ncs_uuid : str ) -> bool : \"\"\"Remove an NCS pathway item from the model. param uuid: UUID of the NCS pathway item to be removed. :type ncs_uuid: str :returns: True if the NCS pathway item as successfully removed, else False if there was not matching UUID. :rtype: bool \"\"\" return self . remove_component_item ( ncs_uuid )","title":"remove_ncs_pathway"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.supportedDropActions","text":"supportedDropActions () Configure the model to only support copying items in a drag-and-drop operation. Returns: Type Description QtCore.Qt.DropActions Supported drag-and-drop action for NCS pathway items. Source code in src/cplus_plugin/gui/component_item_model.py 943 944 945 946 947 948 949 950 951 def supportedDropActions ( self ) -> QtCore . Qt . DropActions : \"\"\"Configure the model to only support copying items in a drag-and-drop operation. :returns: Supported drag-and-drop action for NCS pathway items. :rtype: QtCore.Qt.DropActions \"\"\" return QtCore . Qt . CopyAction","title":"supportedDropActions"},{"location":"developer/api/gui/api_component_items/#src.cplus_plugin.gui.component_item_model.NcsPathwayItemModel.update_ncs_pathway","text":"update_ncs_pathway ( ncs ) Updates the NCS pathway item in the model. Parameters: Name Type Description Default ncs NcsPathway NcsPathway whose corresponding item is to be updated. required Returns: Type Description bool Returns True if the operation was successful else False if the matching item was not found in the model. Source code in src/cplus_plugin/gui/component_item_model.py 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 def update_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Updates the NCS pathway item in the model. :param ncs: NcsPathway whose corresponding item is to be updated. :type ncs: NcsPathway :returns: Returns True if the operation was successful else False if the matching item was not found in the model. \"\"\" item = self . component_item_by_uuid ( str ( ncs . uuid )) if item is None : return False status = self . update_item ( item ) if not status : return False self . _update_display ( item ) self . sort ( 0 ) self . _re_index_rows () return True","title":"update_ncs_pathway"},{"location":"developer/api/gui/api_gui_main/","text":"GUI main \u00b6 The plugin main window class. QgisCplusMain \u00b6 QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI class Source code in src/cplus_plugin/gui/qgis_cplus_main.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False self . current_analysis_task = None self . fetch_default_layer_task = None self . _aoi_layer = None # Set icons for buttons help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . help_btn . setIcon ( help_icon ) settings_icon = FileUtils . get_icon ( \"settings.svg\" ) self . options_btn . setIcon ( settings_icon ) self . prepare_input () # Set tooltips for all tabs self . tab_widget . setTabToolTip ( 0 , self . tr ( \"Scenario Setup\" )) # Insert widget for step 2 self . activity_widget = ActivityContainerWidget ( self , self . message_bar ) self . tab_widget . insertTab ( 1 , self . activity_widget , self . tr ( \"Step 2\" )) self . tab_widget . setTabToolTip ( 1 , self . tr ( \"Defining NCS Pathways and Activities\" ) ) self . tab_widget . setTabToolTip ( 2 , self . tr ( \"Variable Selection and Weighting\" )) self . tab_widget . setTabToolTip ( 3 , self . tr ( \"Run Analysis\" )) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . pwl_item_flags = None # Step 4 self . ncs_pwl_weighted . toggled . connect ( self . outputs_options_changed ) self . landuse_project . toggled . connect ( self . outputs_options_changed ) self . highest_position . toggled . connect ( self . outputs_options_changed ) self . processing_type . toggled . connect ( self . processing_options_changed ) self . chb_metric_builder . toggled . connect ( self . on_use_custom_metrics ) self . btn_metric_builder . clicked . connect ( self . on_show_metrics_wizard ) edit_table_icon = FileUtils . get_icon ( \"mActionEditTable.svg\" ) self . btn_metric_builder . setIcon ( edit_table_icon ) self . load_layer_options () self . load_report_options () self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis ) # Log updates QgsApplication . messageLog () . messageReceived . connect ( self . on_log_message_received ) # Fetch scenario history list self . fetch_scenario_history_list () # Fetch default layers self . fetch_default_layer_list () # Update metric button with metric profiles self . update_metric_button_profiles () add_priority_group \u00b6 add_priority_group () Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1261 1262 1263 1264 1265 1266 1267 def add_priority_group ( self ): \"\"\"Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. \"\"\" group_dialog = PriorityGroupDialog () group_dialog . exec () self . update_priority_groups () add_priority_layer \u00b6 add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1352 1353 1354 1355 1356 1357 1358 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec () self . update_priority_layers ( update_groups = False ) add_priority_layer_group \u00b6 add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . ItemDataRole . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . ItemDataRole . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , priority_layer . get ( USER_DEFINED_ATTRIBUTE ), ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) add_scenario \u00b6 add_scenario () Adds a new scenario into the scenario list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 def add_scenario ( self ): \"\"\"Adds a new scenario into the scenario list.\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_crs = self . extent_box . outputCrs () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] if self . can_clip_to_studyarea (): study_area_path = self . get_studyarea_path () layer = QgsVectorLayer ( study_area_path , \"studyarea\" ) if layer . isValid (): extent = layer . extent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] extent_crs = layer . crs () extent = SpatialExtent ( bbox = extent_box , crs = extent_crs . authid ()) scenario_id = uuid . uuid4 () activities = [] priority_layer_groups = [] if self . scenario_result : activities = self . scenario_result . scenario . activities priority_layer_groups = self . scenario_result . scenario . priority_layer_groups scenario = Scenario ( uuid = scenario_id , name = scenario_name , description = scenario_description , extent = extent , activities = activities , priority_layer_groups = priority_layer_groups , server_uuid = ( self . scenario_result . scenario . server_uuid if self . scenario_result else None ), clip_to_studyarea = self . can_clip_to_studyarea (), studyarea_path = self . get_studyarea_path (), crs = self . crs_selector . crs () . authid (), ) settings_manager . save_scenario ( scenario ) if self . scenario_result : settings_manager . save_scenario_result ( self . scenario_result , str ( scenario_id ) ) self . update_scenario_list () analysis_complete \u00b6 analysis_complete ( task , report_manager , progress_dialog ) Calls the responsible function for handling analysis results outputs Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 def analysis_complete ( self , task , report_manager , progress_dialog ): \"\"\"Calls the responsible function for handling analysis results outputs :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" self . scenario_result = task . scenario_result self . scenario_results ( task , report_manager , progress_dialog ) can_clip_to_studyarea \u00b6 can_clip_to_studyarea () Return true if clipping layers by study area is selected Source code in src/cplus_plugin/gui/qgis_cplus_main.py 612 613 614 615 616 617 618 619 620 621 def can_clip_to_studyarea ( self ) -> bool : \"\"\"Return true if clipping layers by study area is selected\"\"\" clip_to_studyarea = False studyarea_path = self . get_studyarea_path () if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and os . path . exists ( studyarea_path ) ): clip_to_studyarea = True return clip_to_studyarea cancel_processing_task \u00b6 cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2362 2363 2364 2365 2366 2367 2368 2369 2370 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" try : if self . current_analysis_task : self . current_analysis_task . cancel_task () except Exception as e : self . on_progress_dialog_cancelled () log ( f \"Problem cancelling task, { e } \" ) self . processing_cancelled = True edit_priority_group \u00b6 edit_priority_group () Edits the current selected priority group and updates the group box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def edit_priority_group ( self ): \"\"\"Edits the current selected priority group and updates the group box list.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list.\" ), Qgis . MessageLevel . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . ItemDataRole . UserRole ) if ( group_identifier == \"\" or group_identifier is None or not isinstance ( group_identifier , str ) ): self . show_message ( tr ( \"Could not fetch the selected\" \" priority groups for editing.\" ), Qgis . MessageLevel . Critical , ) return self . _show_priority_group_editor ( group_identifier ) edit_priority_layer \u00b6 edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . MessageLevel . Critical , ) return layer_identifier = self . priority_layers_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) if layer_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . MessageLevel . Critical , ) return self . _show_priority_layer_editor ( layer_identifier ) self . update_priority_layers ( update_groups = False ) enable_analysis_controls \u00b6 enable_analysis_controls ( enable ) Enable or disable controls related to running the scenario analysis. Parameters: Name Type Description Default enable bool True to enable else False to disable. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1987 1988 1989 1990 1991 1992 1993 1994 def enable_analysis_controls ( self , enable : bool ): \"\"\"Enable or disable controls related to running the scenario analysis. :param enable: True to enable else False to disable. :type enable: bool \"\"\" self . run_scenario_btn . setEnabled ( enable ) self . gp_report_options . setEnabled ( enable ) fetch_default_layer_list \u00b6 fetch_default_layer_list () Fetch default layer list from API. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1472 1473 1474 1475 1476 1477 def fetch_default_layer_list ( self ): \"\"\"Fetch default layer list from API.\"\"\" if not self . has_trends_auth (): return self . fetch_default_layer_task = FetchDefaultLayerTask () QgsApplication . taskManager () . addTask ( self . fetch_default_layer_task ) fetch_scenario_history_list \u00b6 fetch_scenario_history_list () Fetch scenario history list from API. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1845 1846 1847 1848 1849 1850 1851 1852 def fetch_scenario_history_list ( self ): \"\"\"Fetch scenario history list from API.\"\"\" if not self . has_trends_auth (): self . update_scenario_list () return task = FetchScenarioHistoryTask () task . task_finished . connect ( self . on_fetch_scenario_history_list_finished ) QgsApplication . taskManager () . addTask ( task ) get_studyarea_path \u00b6 get_studyarea_path () Return the path of the study area Returns: str: Study area path Source code in src/cplus_plugin/gui/qgis_cplus_main.py 635 636 637 638 639 640 641 642 643 def get_studyarea_path ( self ) -> str : \"\"\"Return the path of the study area Returns: str: Study area path \"\"\" if self . _aoi_layer : return self . _aoi_layer . source () return \"\" group_value_changed \u00b6 group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer ) has_trends_auth \u00b6 has_trends_auth () Check if plugin has user Trends.Earth authentication. Returns: Type Description bool True if user has provided the username and password. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 def has_trends_auth ( self ): \"\"\"Check if plugin has user Trends.Earth authentication. :return: True if user has provided the username and password. :rtype: bool \"\"\" auth_config = auth . get_auth_config ( auth . TE_API_AUTH_SETUP , warn = None ) return ( auth_config and auth_config . config ( \"username\" ) and auth_config . config ( \"password\" ) ) initialize_priority_layers \u00b6 initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . ItemDataRole . UserRole , layer . get ( \"uuid\" )) if not os . path . exists ( layer . get ( \"path\" )) and not layer . get ( \"path\" ) . startswith ( \"cplus://\" ): item . setIcon ( FileUtils . get_icon ( \"mIndicatorLayerError.svg\" )) item . setToolTip ( tr ( \"Contains invalid priority layer path, \" \"the provided layer path does not exist!\" ) ) if self . pwl_item_flags is None : self . pwl_item_flags = item . flags () self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = SortableTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , group . get ( \"uuid\" )) item . setData ( 0 , SORT_ROLE , group . get ( \"name\" )) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) layer_item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , layer . get ( USER_DEFINED_ATTRIBUTE ), ) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) self . priority_groups_list . sortItems ( 0 , QtCore . Qt . SortOrder . AscendingOrder ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ]) is_metric_configuration_valid \u00b6 is_metric_configuration_valid () Checks if the setup of the metric configuration for the scenario analysis report is correct. Returns: Type Description bool True if the configuration is correct else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 def is_metric_configuration_valid ( self ) -> bool : \"\"\"Checks if the setup of the metric configuration for the scenario analysis report is correct. :returns: True if the configuration is correct else False. :rtype: bool \"\"\" if not self . chb_metric_builder . isChecked (): # Not applicable so just return True return True else : profile_collection = settings_manager . get_metric_profile_collection () if profile_collection is None : self . show_message ( tr ( f \"No metric profiles found. Use the metric \" f \"builder to specify one or more metric \" f \"profiles.\" ) ) return False metric_profile = profile_collection . get_current_profile () if ( metric_profile is None or metric_profile . config is None or not metric_profile . config . is_valid () ): self . show_message ( tr ( f \"Metric configuration is invalid or not yet defined. \" f \"Use the metric builder to check and re-run the wizard.\" ) ) return False # Compare activities selected_activities_ids = set ( [ str ( activity . uuid ) for activity in self . selected_activities ()] ) metric_activity_ids = set ( [ str ( activity . uuid ) for activity in metric_profile . config . activities ] ) if selected_activities_ids == metric_activity_ids : return True elif selected_activities_ids . issubset ( metric_activity_ids ): return True elif len ( selected_activities_ids . difference ( metric_activity_ids )) > 0 : self . show_message ( tr ( f \"There are activities whose metrics has not not been \" f \"defined. Use the metric builder to update.\" ) ) return False return True load_layer_options \u00b6 load_layer_options () Retrieve outputs scenarion layers selection from settings and update the releated ui components Source code in src/cplus_plugin/gui/qgis_cplus_main.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def load_layer_options ( self ): \"\"\" Retrieve outputs scenarion layers selection from settings and update the releated ui components \"\"\" self . ncs_pwl_weighted . setChecked ( settings_manager . get_value ( Settings . NCS_WEIGHTED , default = False , setting_type = bool ) ) self . landuse_project . setChecked ( settings_manager . get_value ( Settings . LANDUSE_PROJECT , default = False , setting_type = bool ) ) self . highest_position . setChecked ( settings_manager . get_value ( Settings . HIGHEST_POSITION , default = False , setting_type = bool ) ) self . processing_type . setChecked ( settings_manager . get_value ( Settings . PROCESSING_TYPE , default = False , setting_type = bool ) ) self . view_status_btn . clicked . connect ( self . on_view_status_button_clicked ) running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if not online_task : self . view_status_btn . setEnabled ( False ) else : self . view_status_btn . setEnabled ( True ) load_report_options \u00b6 load_report_options () Load previously saved report options. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 331 332 333 334 335 336 337 def load_report_options ( self ): \"\"\"Load previously saved report options.\"\"\" self . chb_metric_builder . setChecked ( settings_manager . get_value ( Settings . USE_CUSTOM_METRICS , default = False , setting_type = bool ) ) load_scenario \u00b6 load_scenario ( scenario_identifier = None ) Edits the current selected scenario and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 def load_scenario ( self , scenario_identifier = None ): \"\"\"Edits the current selected scenario and updates the layer box list.\"\"\" if not scenario_identifier : if self . scenario_list . currentItem () is None : self . show_message ( tr ( \"Select first the scenario from the scenario list.\" ), Qgis . MessageLevel . Critical , ) return scenario_identifier = self . scenario_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) if scenario_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . MessageLevel . Critical , ) return scenario = settings_manager . get_scenario ( scenario_identifier ) if scenario is not None : self . scenario_name . setText ( scenario . name ) self . scenario_description . setText ( scenario . description ) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) # Set extent CRS and values extent_crs_text = ( scenario . extent . crs if scenario . extent and scenario . extent . crs else f \"EPSG: { DEFAULT_CRS_ID } \" ) extent_crs = QgsCoordinateReferenceSystem ( extent_crs_text ) extent_list = scenario . extent . bbox if scenario . extent else None if extent_list : default_extent = QgsRectangle ( float ( extent_list [ 0 ]), float ( extent_list [ 2 ]), float ( extent_list [ 1 ]), float ( extent_list [ 3 ]), ) self . extent_box . setOutputExtentFromUser ( default_extent , extent_crs ) self . extent_box . setOutputCrs ( extent_crs ) # Set analysis CRS analysis_crs_text = scenario . crs or extent_crs_text analysis_crs = QgsCoordinateReferenceSystem ( analysis_crs_text ) self . crs_selector . setCrs ( analysis_crs ) # Transform extent to analysis CRS transformed_analysis_extent = self . transform_extent ( self . extent_box . outputExtent (), extent_crs , analysis_crs ) transformed_analysis_extent_list = [ transformed_analysis_extent . xMinimum (), transformed_analysis_extent . xMaximum (), transformed_analysis_extent . yMinimum (), transformed_analysis_extent . yMaximum (), ] self . rb_studyarea . setChecked ( False ) self . rb_extent . setChecked ( False ) if scenario . clip_to_studyarea and os . path . exists ( scenario . studyarea_path ): # Area of Interest from the study area layer self . on_aoi_source_changed ( 0 , True ) self . rb_studyarea . setChecked ( True ) self . _aoi_layer = QgsVectorLayer ( scenario . studyarea_path , Path ( scenario . studyarea_path ) . stem ) # Use the study area layer extent transformed to analysis CRS extent = self . _aoi_layer . extent () transformed_analysis_extent = self . transform_extent ( extent , self . _aoi_layer . crs (), analysis_crs ) transformed_analysis_extent_list = [ transformed_analysis_extent . xMinimum (), transformed_analysis_extent . xMaximum (), transformed_analysis_extent . yMinimum (), transformed_analysis_extent . yMaximum (), ] else : # Area of Interest from the extent self . on_aoi_source_changed ( 1 , True ) self . rb_extent . setChecked ( True ) all_activities = sorted ( scenario . activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 scenario . activities = all_activities if scenario and scenario . server_uuid : self . analysis_scenario_name = scenario . name self . analysis_scenario_description = scenario . description self . analysis_extent = SpatialExtent ( bbox = transformed_analysis_extent_list , crs = analysis_crs_text ) self . analysis_activities = scenario . activities self . analysis_priority_layers_groups = scenario . priority_layer_groups scenario_obj = Scenario ( uuid = scenario . uuid , name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = SpatialExtent ( bbox = extent_list , crs = extent_crs_text ), activities = self . analysis_activities , priority_layer_groups = self . analysis_priority_layers_groups , crs = analysis_crs_text , ) scenario_obj . server_uuid = scenario . server_uuid self . processing_cancelled = False progress_dialog = OnlineProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () analysis_task = FetchScenarioOutputTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , None , ) analysis_task . scenario_api_uuid = scenario . server_uuid analysis_task . task_finished . connect ( self . update_scenario_list ) self . run_cplus_main_task ( progress_dialog , scenario , analysis_task ) main_task \u00b6 main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2355 2356 2357 2358 2359 2360 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" ) move_layer_to_group \u00b6 move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () ( group . insertChildNode ( 0 , layer_clone ) if group is not None else None ) # Add to top of group parent . removeChildNode ( layer ) on_aoi_source_changed \u00b6 on_aoi_source_changed ( button_id , toggled ) Slot raised when the area of interest source button group has been toggled. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def on_aoi_source_changed ( self , button_id : int , toggled : bool ): \"\"\"Slot raised when the area of interest source button group has been toggled. \"\"\" if not toggled : return if button_id == AreaOfInterestSource . LAYER . value : self . studyarea_stacked_widget . setCurrentIndex ( 0 ) elif button_id == AreaOfInterestSource . EXTENT . value : self . studyarea_stacked_widget . setCurrentIndex ( 1 ) self . save_scenario () # Check and fetch carbon impact for the current extent self . update_naturebase_carbon_impact () on_fetch_scenario_history_list_finished \u00b6 on_fetch_scenario_history_list_finished ( success ) Callback when plugin has finished pulling scenario history list. Parameters: Name Type Description Default success bool True if API call is successful required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1854 1855 1856 1857 1858 1859 1860 1861 1862 def on_fetch_scenario_history_list_finished ( self , success ): \"\"\"Callback when plugin has finished pulling scenario history list. :param success: True if API call is successful :type success: bool \"\"\" if not success : return self . update_scenario_list () on_generate_comparison_report \u00b6 on_generate_comparison_report () Slot raised to generate a comparison for two or more selected scenario results. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 def on_generate_comparison_report ( self ): \"\"\"Slot raised to generate a comparison for two or more selected scenario results. \"\"\" selected_items = self . scenario_list . selectedItems () if len ( selected_items ) < 2 : msg = tr ( \"You must select at least two scenarios to generate the comparison report.\" ) self . show_message ( msg ) return scenario_results = [] for item in selected_items : scenario_identifier = item . data ( QtCore . Qt . ItemDataRole . UserRole ) scenario = settings_manager . get_scenario ( scenario_identifier ) scenario_result = settings_manager . get_scenario_result ( scenario_identifier ) if not scenario_result and not scenario : continue all_activities = sorted ( scenario . activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 scenario . activities = all_activities scenario_result . scenario = scenario scenario_results . append ( scenario_result ) if len ( scenario_results ) < 2 : msg = tr ( \"Unable to retrieve the results for all the selected scenarios.\" ) self . show_message ( msg ) return if len ( scenario_results ) > MAXIMUM_COMPARISON_REPORTS : msg = tr ( \"Exceeded maximum number of scenarios for generating the comparison report. Limit is\" ) self . show_message ( f \" { msg } { MAXIMUM_COMPARISON_REPORTS } .\" ) return for result in scenario_results : msg_tr = tr ( \"Loading map layers for scenario\" ) log ( message = f \" { msg_tr } : { result . scenario . name } \" ) self . post_analysis ( result , None , None , None ) submit_result = report_manager . generate_comparison_report ( scenario_results ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for creating the comparison report.\" ) self . show_message ( f \" { msg } \" ) return QgsApplication . processEvents () self . report_progress_dialog = ReportProgressDialog ( tr ( \"Generating comparison report\" ), submit_result ) self . report_progress_dialog . run_dialog () on_log_message_received \u00b6 on_log_message_received ( message , tag , level ) Slot to handle log tab updates and processing logs Parameters: Name Type Description Default message str The received message from QGIS message log required tag str Message log tag required level MessageLevel Message level enum value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def on_log_message_received ( self , message , tag , level ): \"\"\"Slot to handle log tab updates and processing logs :param message: The received message from QGIS message log :type message: str :param tag: Message log tag :type tag: str :param level: Message level enum value :type level: Qgis.MessageLevel \"\"\" if tag == PLUGIN_MESSAGE_LOG_TAB : # If there is no current running analysis # task don't save the log message. if not self . current_analysis_task : return try : to_zone = tz . tzlocal () message_dict = json . loads ( message ) if sorted ( list ( message_dict . keys ())) == [ \"date_time\" , \"log\" ]: message = message_dict [ \"log\" ] message_time = message_dict [ \"date_time\" ] . replace ( \"Z\" , \"+00:00\" ) message_time = datetime . datetime . fromisoformat ( message_time ) message_time = message_time . astimezone ( to_zone ) . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) else : message_time = datetime . datetime . now () . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) except Exception : message_time = datetime . datetime . now () . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) message = ( f \" { self . log_text_box . toPlainText () } \" f \" { message_time } { QGIS_MESSAGE_LEVEL_DICT [ level ] } \" f \" { message } \" ) self . log_text_box . setPlainText ( f \" { message } \\n \" ) log_text_cursor = self . log_text_box . textCursor () log_text_cursor . movePosition ( QtGui . QTextCursor . MoveOperation . End ) self . log_text_box . setTextCursor ( log_text_cursor ) try : os . makedirs ( self . current_analysis_task . scenario_directory , exist_ok = True ) processing_log_file = os . path . join ( self . current_analysis_task . scenario_directory , SCENARIO_LOG_FILE_NAME , ) write_to_file ( message , processing_log_file ) except TypeError : pass on_manage_constant_raster_pwls \u00b6 on_manage_constant_raster_pwls () Slot raised to show the Constant Raster manager dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 def on_manage_constant_raster_pwls ( self ): \"\"\"Slot raised to show the Constant Raster manager dialog.\"\"\" # Show Constant Raster manager dialog constant_raster_dialog = ConstantRastersManagerDialog ( parent = self ) # Connect signal to handle raster creation constant_raster_dialog . create_rasters_requested . connect ( lambda context , collection , input_range , metadata_id , current_view : self . _on_constant_rasters_create_requested ( context , collection , input_range , metadata_id , current_view , constant_raster_dialog , ) ) constant_raster_dialog . exec () on_manage_pwls_relative_impact_matrix \u00b6 on_manage_pwls_relative_impact_matrix () Slot raised to show the dialog for managing relative impact matrix of PWLs. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1451 1452 1453 1454 1455 1456 1457 1458 def on_manage_pwls_relative_impact_matrix ( self ): \"\"\"Slot raised to show the dialog for managing relative impact matrix of PWLs.\"\"\" ncs_pwl_relative_impact_dialog = NcsPwlImpactManagerDialog ( self ) if ( ncs_pwl_relative_impact_dialog . exec () == QtWidgets . QDialog . DialogCode . Accepted ): pass on_npv_pwl_created \u00b6 on_npv_pwl_created ( pathway_npv , npv_pwl_path , algorithm , context , feedback ) Callback that creates an PWL item when the corresponding raster layer has been created. Parameters: Name Type Description Default pathway_npv ActivityNpv NPV mapping for an NCS pathway. required npv_pwl_path str Absolute file path of the created NPV PWL. required algorithm QgsProcessingAlgorithm Processing algorithm that created the NPV PWL. required context QgsProcessingContext Contextual information that was used to create the NPV PWL in processing. required feedback QgsProcessingFeedback Feedback to update on the processing progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 def on_npv_pwl_created ( self , pathway_npv : ActivityNpv , npv_pwl_path : str , algorithm : QgsProcessingAlgorithm , context : QgsProcessingContext , feedback : QgsProcessingFeedback , ): \"\"\"Callback that creates an PWL item when the corresponding raster layer has been created. :param pathway_npv: NPV mapping for an NCS pathway. :type pathway_npv: ActivityNpv :param npv_pwl_path: Absolute file path of the created NPV PWL. :type npv_pwl_path: str :param algorithm: Processing algorithm that created the NPV PWL. :type algorithm: QgsProcessingAlgorithm :param context: Contextual information that was used to create the NPV PWL in processing. :type context: QgsProcessingContext :param feedback: Feedback to update on the processing progress. :type feedback: QgsProcessingFeedback \"\"\" # Check if the PWL entry already exists in the settings. If it # exists then no further updates required as the filename of the # PWL layer is still the same. updated_pwl = settings_manager . find_layer_by_name ( pathway_npv . base_name ) if updated_pwl is None : # Create NPV PWL desc_tr = tr ( \"Normalized NPV for\" ) pwl_desc = f \" { desc_tr } { pathway_npv . pathway . name } .\" npv_layer_info = { \"uuid\" : str ( uuid . uuid4 ()), \"name\" : pathway_npv . base_name , \"description\" : pwl_desc , \"groups\" : [], \"path\" : npv_pwl_path , \"type\" : PriorityLayerType . NPV . value , USER_DEFINED_ATTRIBUTE : True , } settings_manager . save_priority_layer ( npv_layer_info ) # Updated the PWL for the NCS pathway pathway = settings_manager . get_ncs_pathway ( pathway_npv . pathway_id ) if pathway is not None : pathway . priority_layers . append ( npv_layer_info ) settings_manager . update_ncs_pathway ( pathway ) else : msg_tr = tr ( \"ncs pathway not found to attach the NPV PWL.\" ) log ( f \" { pathway_npv . pathway . name } { msg_tr } \" , info = False ) else : # Just update the path updated_pwl [ \"path\" ] = npv_pwl_path settings_manager . save_priority_layer ( updated_pwl ) self . update_priority_layers ( update_groups = False ) on_npv_pwl_removed \u00b6 on_npv_pwl_removed ( pwl_identifier ) Callback that is executed when an NPV PWL has been removed because it was disabled by the user. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1194 1195 1196 1197 1198 def on_npv_pwl_removed ( self , pwl_identifier : str ): \"\"\"Callback that is executed when an NPV PWL has been removed because it was disabled by the user.\"\"\" # We use this to refresh the view to reflect the removed NPV PWL. self . update_priority_layers ( update_groups = False ) on_online_task_check_finished \u00b6 on_online_task_check_finished ( status ) Handler for view online task and generate report button. The button itself will be shown when Cplus plugin becomes visible. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def on_online_task_check_finished ( self , status ): \"\"\" Handler for view online task and generate report button. The button itself will be shown when Cplus plugin becomes visible. \"\"\" running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if online_task : if status == JOB_COMPLETED_STATUS : message = f \"Task { online_task . name } has completed successfully. You can download the result from Log tab.\" button_text = \"OK\" elif status == JOB_RUNNING_STATUS : message = f \"Task { online_task . name } is still running.\" button_text = \"View status\" else : message = f \"Task { online_task . name } is { status } .\" button_text = \"OK\" widget = self . message_bar . createMessage ( tr ( message )) if status == JOB_RUNNING_STATUS : button = QPushButton ( widget ) button . setText ( button_text ) load_scenario = partial ( self . load_scenario , running_online_scenario_uuid ) button . pressed . connect ( load_scenario ) widget . layout () . addWidget ( button ) self . update_message_bar ( widget ) on_profile_action_group_triggered \u00b6 on_profile_action_group_triggered ( action ) Slot raised when the action group for profiles has been triggered. Parameters: Name Type Description Default action QAction Action in the group that has been triggered. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 def on_profile_action_group_triggered ( self , action : QtWidgets . QAction ): \"\"\"Slot raised when the action group for profiles has been triggered. :param action: Action in the group that has been triggered. :type action: QtWidgets.QAction \"\"\" metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is None : return # Set current profile current_profile = \"\" for profile in metric_profile_collection . profiles : if profile . name == action . text (): current_profile = profile . id break if current_profile : metric_profile_collection . current_profile = current_profile settings_manager . save_metric_profile_collection ( metric_profile_collection ) on_progress_dialog_cancelled \u00b6 on_progress_dialog_cancelled () Slot raised when analysis has been cancelled in progress dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3179 3180 3181 3182 def on_progress_dialog_cancelled ( self ): \"\"\"Slot raised when analysis has been cancelled in progress dialog.\"\"\" if not self . run_scenario_btn . isEnabled (): self . enable_analysis_controls ( True ) on_report_error \u00b6 on_report_error ( progress_dialog , message ) Slot raised when report task error has occured. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 def on_report_error ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task error has occured. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog \"\"\" progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) log ( message ) self . enable_analysis_controls ( True ) on_report_finished \u00b6 on_report_finished ( progress_dialog , scenario_id ) Slot raised when report task has finished. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 def on_report_finished ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has finished. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . set_report_complete () progress_dialog . change_status_message ( tr ( \"Report generation complete\" )) self . enable_analysis_controls ( True ) on_report_running \u00b6 on_report_running ( progress_dialog , scenario_id ) Slot raised when report task has started. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 def on_report_running ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has started. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . update_progress_bar ( 0 ) progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Generating report for the analysis output\" ) ) on_report_status_changed \u00b6 on_report_status_changed ( progress_dialog , message ) Slot raised when report task status has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message str Status message. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 def on_report_status_changed ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task status has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Status message. :type message: str \"\"\" status_message = f \" { tr ( 'Report generation' ) } - { message } ...\" progress_dialog . change_status_message ( status_message ) on_reporting_progress_changed \u00b6 on_reporting_progress_changed ( progress_dialog , progress ) Slot raised when the reporting progress has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required progress float Analysis progress value between 0 and 100 required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 def on_reporting_progress_changed ( self , progress_dialog , progress : float ): \"\"\"Slot raised when the reporting progress has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param progress: Analysis progress value between 0 and 100 :type progress: float \"\"\" progress_dialog . update_progress_bar ( progress ) on_scenario_list_selection_changed \u00b6 on_scenario_list_selection_changed () Slot raised when the selection of scenarios changes. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1837 1838 1839 1840 1841 1842 1843 def on_scenario_list_selection_changed ( self ): \"\"\"Slot raised when the selection of scenarios changes.\"\"\" selected_items = self . scenario_list . selectedItems () if len ( selected_items ) < 2 : self . comparison_report_btn . setEnabled ( False ) else : self . comparison_report_btn . setEnabled ( True ) on_show_metrics_wizard \u00b6 on_show_metrics_wizard () Slot raised to show the metric customization wizard for creating the scenario analysis report. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 def on_show_metrics_wizard ( self ): \"\"\"Slot raised to show the metric customization wizard for creating the scenario analysis report. \"\"\" metrics_builder = ActivityMetricsBuilder ( self ) metrics_builder . activities = self . selected_activities () # Load previously saved profile collection metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is not None : metrics_builder . profile_collection = metric_profile_collection else : metrics_builder . initialize_collection () if metrics_builder . exec () == QtWidgets . QDialog . DialogCode . Accepted : metric_profile_collection = metrics_builder . profile_collection settings_manager . save_metric_profile_collection ( metric_profile_collection ) self . update_metric_button_profiles () on_tab_step_changed \u00b6 on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" activity_tab_index = 1 priority_group_tab_index = 2 if index == activity_tab_index : self . activity_widget . can_show_error_messages = True self . activity_widget . load () # Check if CRS is valid crs = self . crs_selector . crs () if crs is None or not crs . isValid () or crs . isGeographic (): self . show_message ( self . tr ( \"Please select a valid coordinate system.\" )) self . tab_widget . setCurrentIndex ( 0 ) elif index == priority_group_tab_index : tab_valid = True msg = \"\" # Check if NCS pathways are valid ncs_valid = self . activity_widget . is_ncs_valid () if not ncs_valid : msg = self . tr ( \"NCS pathways are not valid or there is an ongoing validation process. \" \"Use the validation inspector to see more details.\" ) tab_valid = False # Validate activity selection selected_activities = self . activity_widget . selected_activity_items () if len ( selected_activities ) == 0 : msg = self . tr ( \"Please select at least one activity.\" ) tab_valid = False # Verify that the selected activities have at least one NCS pathway zero_pathway_activities = [] for activity_item in selected_activities : if len ( activity_item . activity . pathways ) == 0 : zero_pathway_activities . append ( activity_item . activity . name ) if len ( zero_pathway_activities ) > 0 : activity_tr = ( self . tr ( \"activity has\" ) if len ( zero_pathway_activities ) == 1 else self . tr ( \"activities have\" ) ) tr_msg = self . tr ( \"no NCS pathways defined.\" ) msg = f \" { ', ' . join ( zero_pathway_activities ) } { activity_tr } { tr_msg } \" tab_valid = False if not tab_valid : self . show_message ( msg ) self . tab_widget . setCurrentIndex ( activity_tab_index ) else : self . message_bar . clearWidgets () if index == priority_group_tab_index : analysis_activities = self . selected_activities () is_online_processing = False for activity in analysis_activities : for pathway in activity . pathways : if pathway . path . startswith ( \"cplus://\" ): is_online_processing = True break priority_layers = settings_manager . get_priority_layers () for priority_layer in priority_layers : if priority_layer [ \"path\" ] . startswith ( \"cplus://\" ): for group in priority_layer [ \"groups\" ]: if int ( group [ \"value\" ]) > 0 : is_online_processing = True break if analysis_activities : if is_online_processing : self . processing_type . setChecked ( True ) self . processing_type . setEnabled ( False ) else : self . processing_type . setChecked ( False ) self . processing_type . setEnabled ( True ) on_use_custom_metrics \u00b6 on_use_custom_metrics ( checked ) Slot raised when use custom metrics has been enabled or disabled. Parameters: Name Type Description Default checked bool True to use custom metrics else False. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2924 2925 2926 2927 2928 2929 2930 2931 def on_use_custom_metrics ( self , checked : bool ): \"\"\"Slot raised when use custom metrics has been enabled or disabled. :param checked: True to use custom metrics else False. :type checked: bool \"\"\" settings_manager . set_value ( Settings . USE_CUSTOM_METRICS , checked ) self . btn_metric_builder . setEnabled ( checked ) on_view_status_button_clicked \u00b6 on_view_status_button_clicked () Handler when view status report button in tab 4 is clicked. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 226 227 228 229 230 231 232 233 def on_view_status_button_clicked ( self ): \"\"\"Handler when view status report button in tab 4 is clicked.\"\"\" log ( \"View status button\" ) running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if online_task : self . load_scenario ( running_online_scenario_uuid ) open_help \u00b6 open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1060 1061 1062 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_settings \u00b6 open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2920 2921 2922 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE ) outputs_options_changed \u00b6 outputs_options_changed () Handles selected outputs changes Source code in src/cplus_plugin/gui/qgis_cplus_main.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def outputs_options_changed ( self ): \"\"\" Handles selected outputs changes \"\"\" settings_manager . set_value ( Settings . NCS_WEIGHTED , self . ncs_pwl_weighted . isChecked () ) settings_manager . set_value ( Settings . LANDUSE_PROJECT , self . landuse_project . isChecked () ) settings_manager . set_value ( Settings . HIGHEST_POSITION , self . highest_position . isChecked () ) post_analysis \u00b6 post_analysis ( scenario_result , task , report_manager , progress_dialog ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the activities to the canvas with styling. Adds each activities' pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 def post_analysis ( self , scenario_result , task , report_manager , progress_dialog ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the activities to the canvas with styling. Adds each activities' pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled and scenario_result is not None : list_activities = scenario_result . scenario . activities if task is not None : activities = task . analysis_activities elif scenario_result . scenario is not None : activities = scenario_result . scenario . activities else : activities = [] raster = scenario_result . analysis_output [ \"OUTPUT\" ] activities_dir = os . path . join ( os . path . dirname ( raster ), \"activities\" ) # Layer options load_weighted_ncs = settings_manager . get_value ( Settings . NCS_WEIGHTED , default = True , setting_type = bool ) load_landuse = settings_manager . get_value ( Settings . LANDUSE_PROJECT , default = True , setting_type = bool ) load_highest_position = settings_manager . get_value ( Settings . HIGHEST_POSITION , default = False , setting_type = bool ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups activity_group = None pathways_group = None scenario_group = instance_root . insertGroup ( 0 , group_name ) if load_landuse : activity_group = scenario_group . addGroup ( tr ( ACTIVITY_GROUP_LAYER_NAME )) if load_weighted_ncs : pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_WEIGHTED_GROUP_LAYER_NAME ) ) pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Group settings activity_group . setExpanded ( False ) if activity_group else None # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_dt = ( scenario_result . created_date if scenario_result . created_date else datetime . datetime . now () ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { layer_dt . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) if ( scenario_result . output_layer_name is not None and scenario_result . output_layer_name != \"\" ): layer_name = scenario_result . output_layer_name if ( scenario_result . output_layer_name is None or scenario_result . output_layer_name is \"\" ): scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) scenario_layer = qgis_instance . addMapLayer ( layer ) # Scenario result layer styling renderer = self . style_activities_layer ( layer , activities ) layer . setRenderer ( renderer ) layer . triggerRepaint () \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) # Add activities and pathways activity_index = 0 if load_landuse : for activity in list_activities : activity_name = activity . name activity_layer = QgsRasterLayer ( activity . path , activity . name ) activity_layer . setCustomProperty ( ACTIVITY_IDENTIFIER_PROPERTY , str ( activity . uuid ) ) list_pathways = activity . pathways # Add activity layer with styling, if available if activity_layer : renderer = self . style_activity_layer ( activity_layer , activity ) added_activity_layer = qgis_instance . addMapLayer ( activity_layer ) self . move_layer_to_group ( added_activity_layer , activity_group ) activity_layer . setRenderer ( renderer ) activity_layer . triggerRepaint () # Add activity pathways if load_weighted_ncs : if len ( list_pathways ) > 0 : activity_pathway_group = pathways_group . insertGroup ( activity_index , activity_name ) activity_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , activity_pathway_group ) pathway_layer . triggerRepaint () pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . MessageLevel . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) activity_index = activity_index + 1 # Initiate report generation if load_landuse and load_highest_position : ( self . run_report ( progress_dialog , report_manager ) if ( progress_dialog is not None and report_manager is not None ) else None ) else : ( progress_dialog . processing_finished () if progress_dialog is not None else None ) else : # Re-initializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () prepare_aoi_box \u00b6 prepare_aoi_box () Initialize the Area of interest box Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 def prepare_aoi_box ( self ): \"\"\"Initialize the Area of interest box\"\"\" # Area of Interest self . _aoi_source_group = QtWidgets . QButtonGroup ( self ) self . _aoi_source_group . setExclusive ( True ) self . _aoi_source_group . addButton ( self . rb_studyarea , AreaOfInterestSource . LAYER . value ) self . _aoi_source_group . addButton ( self . rb_extent , AreaOfInterestSource . EXTENT . value ) self . _aoi_source_group . idToggled . connect ( self . on_aoi_source_changed ) self . studyarea_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . cbo_studyarea . layerChanged . connect ( self . _on_studyarea_layer_changed ) self . cbo_studyarea . setAllowEmptyLayer ( True , tr ( \"<Select layer>\" )) self . cbo_studyarea . setFilters ( QgsMapLayerProxyModel . Filter . PolygonLayer ) self . studyarea_layer_file_widget . setToolTip ( tr ( \"Select the study area layer from the local filesystem\" ) ) self . studyarea_layer_file_widget . fileChanged . connect ( self . _on_studyarea_file_changed ) prepare_extent_box \u00b6 prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" crs = self . crs_selector . crs () if crs is None or not crs . isValid (): crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) self . crs_selector . setCrs ( crs ) self . extent_box . setOutputCrs ( crs ) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , crs , ) prepare_input \u00b6 prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_aoi_box () self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( lambda s : self . update_naturebase_carbon_impact () ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority groups buttons self . add_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_group_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_group_btn . clicked . connect ( self . add_priority_group ) self . edit_group_btn . clicked . connect ( self . edit_priority_group ) self . remove_group_btn . clicked . connect ( self . remove_priority_group ) # Priority layers buttons self . new_constant_raster_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionNewMap.svg\" ) ) self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . relative_pwl_matrix_btn . setIcon ( FileUtils . get_icon ( \"mActionAddVectorTileLayer.svg\" ) ) self . new_constant_raster_pwl_btn . clicked . connect ( self . on_manage_constant_raster_pwls ) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) self . relative_pwl_matrix_btn . clicked . connect ( self . on_manage_pwls_relative_impact_matrix ) self . priority_layers_list . itemDoubleClicked . connect ( self . _on_double_click_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setSelectionMode ( QtWidgets . QAbstractItemView . SelectionMode . ExtendedSelection ) self . priority_groups_list . setSortingEnabled ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) self . priority_groups_list . itemDoubleClicked . connect ( self . _on_double_click_priority_group ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_activities = None self . analysis_weighted_ims = [] self . analysis_priority_layers_groups = [] # Saved scenarios actions self . add_scenario_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . info_scenario_btn . setIcon ( FileUtils . get_icon ( \"mActionIdentify.svg\" )) self . load_scenario_btn . setIcon ( FileUtils . get_icon ( \"mActionReload.svg\" )) self . comparison_report_btn . setIcon ( FileUtils . get_icon ( \"mIconReport.svg\" )) self . remove_scenario_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_scenario_btn . clicked . connect ( self . add_scenario ) self . load_scenario_btn . clicked . connect ( self . load_scenario ) self . info_scenario_btn . clicked . connect ( self . show_scenario_info ) self . comparison_report_btn . clicked . connect ( self . on_generate_comparison_report ) self . remove_scenario_btn . clicked . connect ( self . remove_scenario ) self . scenario_list . itemSelectionChanged . connect ( self . on_scenario_list_selection_changed ) # Coordinate System self . lblCrsdescription . setText ( tr ( \"Scenario CRS for analysis (Must be projected CRS)\" ) ) project_crs = QgsProject . instance () . crs () crs = settings_manager . get_value ( Settings . SCENARIO_CRS , default = None ) if crs is not None : project_crs = QgsCoordinateReferenceSystem ( crs ) if not project_crs . isGeographic (): self . crs_selector . setCrs ( project_crs ) self . crs_selector . crsChanged . connect ( self . on_crs_changed ) prepare_message_bar \u00b6 prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1919 1920 1921 1922 1923 1924 1925 1926 1927 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Policy . Minimum , QtWidgets . QSizePolicy . Policy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignmentFlag . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout ) priority_groups_update \u00b6 priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item ) processing_options_changed \u00b6 processing_options_changed () Handles selected processing changes Source code in src/cplus_plugin/gui/qgis_cplus_main.py 286 287 288 289 290 291 def processing_options_changed ( self ): \"\"\"Handles selected processing changes\"\"\" settings_manager . set_value ( Settings . PROCESSING_TYPE , self . processing_type . isChecked () ) remove_priority_group \u00b6 remove_priority_group () Removes the current active priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def remove_priority_group ( self ): \"\"\"Removes the current active priority group.\"\"\" selected_groups = self . priority_groups_list . selectedItems () if not selected_groups : self . show_message ( tr ( \"Select the priority groups to be deleted from the groups list.\" ), Qgis . MessageLevel . Critical , ) return num_items = len ( selected_groups ) item_tr = self . tr ( \"groups\" ) if num_items > 1 else self . tr ( \"group\" ) msg = self . tr ( f \"Remove { num_items !s} selected priority { item_tr } ? \\n Click Yes to proceed or No to cancel.\" ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"Remove Priority Groups\" ), msg , QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : group_ids = [ group_item . data ( 0 , QtCore . Qt . ItemDataRole . UserRole ) for group_item in selected_groups ] for group_id in group_ids : if not group_id : log ( f \"Priority group identifier could not be determined.\" ) continue group = settings_manager . get_priority_group ( group_id ) if not group : log ( f \"Priority group for { group_id } not found in settings.\" ) continue settings_manager . delete_priority_group ( group_id ) self . update_priority_groups () remove_priority_layer \u00b6 remove_priority_layer () Removes one or more of the selected priority layers. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 def remove_priority_layer ( self ): \"\"\"Removes one or more of the selected priority layers.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . MessageLevel . Critical , ) return selected_pwl_items = self . priority_layers_list . selectedItems () if not selected_pwl_items : self . show_message ( tr ( \"Select one or more priority weighting layers to be removed \" \"from the layers list.\" ), Qgis . MessageLevel . Critical , ) return pwls = [ item . data ( QtCore . Qt . ItemDataRole . DisplayRole ) for item in selected_pwl_items ] if len ( pwls ) == 1 : tr_layer = tr ( \"layer\" ) else : tr_layer = tr ( \"layers\" ) tr_msg = tr ( \"Remove the priority weighting\" ) msg = f \" { tr_msg } { tr_layer } : { ', ' . join ( pwls ) } ?\" reply = QtWidgets . QMessageBox . warning ( self , tr ( \"Remove PWLs\" ), msg , QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : for pwl in pwls : layer = settings_manager . find_layer_by_name ( pwl ) if not layer : continue settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False ) # Remove PWL in priority groups for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children ) remove_priority_layer_group \u00b6 remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group ) remove_scenario \u00b6 remove_scenario () Removes the current active scenario. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def remove_scenario ( self ): \"\"\"Removes the current active scenario.\"\"\" if self . scenario_list . currentItem () is None : self . show_message ( tr ( \"Select first a scenario from the scenario list.\" ), Qgis . MessageLevel . Critical , ) return texts = [] for item in self . scenario_list . selectedItems (): current_text = item . data ( QtCore . Qt . ItemDataRole . UserRole + 1 ) texts . append ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the selected scenario(s) \" {} \"?' ) . format ( texts ), QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : for item in self . scenario_list . selectedItems (): scenario_id = item . data ( QtCore . Qt . ItemDataRole . UserRole ) if scenario_id == \"\" : continue settings_manager . delete_scenario ( scenario_id ) scenario_server_uuid = item . data ( QtCore . Qt . ItemDataRole . UserRole + 2 ) if scenario_server_uuid == \"\" : continue if not self . has_trends_auth (): continue task = DeleteScenarioTask ( scenario_server_uuid ) QgsApplication . taskManager () . addTask ( task ) self . update_scenario_list () report_job_is_for_current_scenario \u00b6 report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False reset_reporting_feedback \u00b6 reset_reporting_feedback ( progress_dialog ) Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Returns: Type Description QgsFeedback Feedback instance to be used in storing processing status details. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 def reset_reporting_feedback ( self , progress_dialog ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :returns reporting_feedback: Feedback instance to be used in storing processing status details. :rtype reporting_feedback: QgsFeedback \"\"\" progress_changed = partial ( self . on_reporting_progress_changed , progress_dialog ) reporting_feedback = QgsFeedback ( self ) reporting_feedback . progressChanged . connect ( progress_changed ) return reporting_feedback restore_scenario \u00b6 restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) studyarea_path = settings_manager . get_value ( Settings . STUDYAREA_PATH ) clip_to_studyarea = settings_manager . get_value ( Settings . CLIP_TO_STUDYAREA , default = False , setting_type = bool ) crs = QgsCoordinateReferenceSystem ( settings_manager . get_value ( Settings . SCENARIO_CRS , f \"EPSG: { DEFAULT_CRS_ID } \" ) ) if crs . isValid (): self . crs_selector . setCrs ( crs ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None ( self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None ) if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) extent_crs = QgsCoordinateReferenceSystem ( settings_manager . get_value ( Settings . SCENARIO_EXTENT_CRS , f \"EPSG: { DEFAULT_CRS_ID } \" ) ) extent_crs = ( extent_crs if extent_crs . isValid () else self . extent_box . outputCrs () ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , extent_crs , ) if studyarea_path : self . _aoi_layer = QgsVectorLayer ( studyarea_path , Path ( studyarea_path ) . stem ) if self . _aoi_layer . isValid (): self . studyarea_layer_file_widget . blockSignals ( True ) self . studyarea_layer_file_widget . setFilePath ( studyarea_path ) self . studyarea_layer_file_widget . blockSignals ( False ) if clip_to_studyarea : self . on_aoi_source_changed ( 0 , True ) self . rb_studyarea . setChecked ( True ) else : self . rb_extent . setChecked ( True ) self . on_aoi_source_changed ( 1 , True ) run_analysis \u00b6 run_analysis () Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 def run_analysis ( self ): \"\"\"Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. \"\"\" self . log_text_box . clear () if not self . is_metric_configuration_valid (): log ( \"Scenario cannot run due to an invalid metric configuration \" \"for the selected profile. Refer to the preceding \" \"errors above.\" ) return passed_extent = self . extent_box . outputExtent () passed_extent_crs = self . extent_box . outputCrs () # Check if CRS is valid analysis_crs = self . crs_selector . crs () if ( analysis_crs is None or not analysis_crs . isValid () or analysis_crs . isGeographic () ): self . show_message ( tr ( \"Please select a valid Coordinate System from step one.\" ), level = Qgis . MessageLevel . Critical , ) return clip_to_studyarea = False studyarea_path = settings_manager . get_value ( Settings . STUDYAREA_PATH , default = \"\" , setting_type = str ) aoi_layer = QgsVectorLayer ( studyarea_path , \"studyarea_path\" ) if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and aoi_layer . isValid () ): passed_extent = aoi_layer . extent () passed_extent_crs = aoi_layer . crs () clip_to_studyarea = True if passed_extent_crs != analysis_crs : # Transform extent to analysis CRS passed_extent = self . transform_extent ( passed_extent , passed_extent_crs , analysis_crs ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): pwl_items = self . priority_layers_list . findItems ( layer . get ( \"name\" ), QtCore . Qt . MatchFlag . MatchExactly ) if len ( pwl_items ) > 0 : # Exclude adding the PWL since its for a disabled default # item outside the pilot AOI. if pwl_items [ 0 ] . flags () == QtCore . Qt . NoItemFlags : continue group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_activities = self . selected_activities () self . analysis_weighted_ims = [] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . MessageLevel . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . MessageLevel . Critical , ) return if self . analysis_activities == [] or self . analysis_activities is None : self . show_message ( tr ( \"Select at least one activity from step two.\" ), level = Qgis . MessageLevel . Critical , ) return if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . MessageLevel . Critical , ) return if self . processing_type . isChecked (): if not self . has_trends_auth (): self . show_message ( tr ( f \"Trends.Earth account is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . MessageLevel . Critical , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ], crs = analysis_crs . authid (), ) try : self . enable_analysis_controls ( False ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , activities = self . analysis_activities , priority_layer_groups = self . analysis_priority_layers_groups , clip_to_studyarea = self . can_clip_to_studyarea (), studyarea_path = self . get_studyarea_path (), crs = self . analysis_extent . crs , ) self . processing_cancelled = False # Creates and opens the progress dialog for the analysis if self . processing_type . isChecked (): progress_dialog = OnlineProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) else : # Creates and opens the progress dialog for the analysis progress_dialog = ProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () progress_dialog . change_status_message ( tr ( \"Raster calculation for activities pathways\" ) ) pathway_found = False use_default_layer = False for activity in self . analysis_activities : if pathway_found : break for pathway in activity . pathways : if pathway is None : continue if pathway . layer_uuid : use_default_layer = True elif pathway . path : pathway_found = True break if not pathway_found and not use_default_layer : self . show_message ( tr ( \"NCS pathways were not found in the selected activities, \" \"Make sure to define pathways for the selected activities \" \"before running the scenario\" ) ) self . processing_cancelled = True self . enable_analysis_controls ( True ) return dt_alg = ApplyNcsDecisionTreeAlgorithm () pixel_size = 30.0 nodata_val = - 9999 dt_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) scenario_dir = settings_manager . get_value ( Settings . BASE_DIR ) os . makedirs ( scenario_dir , exist_ok = True ) for activity in self . analysis_activities : out_name = f \" { self . analysis_scenario_name } __ { activity . name } __decision_protect.tif\" out_path = os . path . join ( scenario_dir , out_name ) # Pass pathway UUIDs directly as JSON array pathway_uuids = [ str ( p . uuid ) for p in ( activity . pathways or [])] dt_params = { \"PATHWAY_UUIDS\" : json . dumps ( pathway_uuids ), dt_alg . P_TARGET_CRS : self . analysis_extent . crs , dt_alg . P_EXTENT : dt_extent , dt_alg . P_PIXEL : pixel_size , dt_alg . P_NODATA : nodata_val , dt_alg . P_SELECTED_ACTION : 0 , # 0=Protect; see CHOICES_ACTION dt_alg . O_SELECTED : out_path , } try : dt_result = dt_alg . processAlgorithm ( dt_params , self . processing_context , self . position_feedback , ) mask_path = dt_result [ dt_alg . O_SELECTED ] # Ensure mask_paths exists if ( not hasattr ( activity , \"mask_paths\" ) or activity . mask_paths is None ): activity . mask_paths = [] activity . mask_paths . append ( mask_path ) except Exception as e : log ( tr ( f \"Decision Tree failed for { activity . name } : { e } \" ), info = False ) if self . processing_type . isChecked (): analysis_task = ScenarioAnalysisTaskApiClient ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ], crs = passed_extent_crs . authid () if passed_extent_crs else None , ), clip_to_studyarea , self . get_studyarea_path (), ) else : analysis_task = ScenarioAnalysisTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , clip_to_studyarea , self . get_studyarea_path (), ) self . run_cplus_main_task ( progress_dialog , scenario , analysis_task ) except Exception as err : self . show_message ( tr ( \"An error occurred when preparing analysis task\" ), level = Qgis . MessageLevel . Info , ) log ( tr ( \"An error occurred when preparing analysis task\" ', error message \" {} \"' . format ( err ) ) ) run_report \u00b6 run_report ( progress_dialog , report_manager ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 def run_report ( self , progress_dialog , report_manager ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is not defined\" , info = False , ) return reporting_feedback = self . reset_reporting_feedback ( progress_dialog ) self . reporting_feedback = reporting_feedback submit_result = report_manager . generate ( self . scenario_result , reporting_feedback , self . chb_metric_builder . isChecked (), ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" ) save_scenario \u00b6 save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () if self . can_clip_to_studyarea (): settings_manager . set_value ( Settings . STUDYAREA_PATH , self . get_studyarea_path () ) else : extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box ) settings_manager . set_value ( Settings . SCENARIO_EXTENT_CRS , self . extent_box . outputCrs () . authid () ) settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_CRS , self . crs_selector . crs () . authid () ) settings_manager . set_value ( Settings . CLIP_TO_STUDYAREA , self . can_clip_to_studyarea () ) scenario_results \u00b6 scenario_results ( task , report_manager , progress_dialog ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 def scenario_results ( self , task , report_manager , progress_dialog ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED if task . output is not None : self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED self . post_analysis ( self . scenario_result , task , report_manager , progress_dialog ) else : status_message = \"No valid output from the processing results.\" task . set_status_message ( status_message ) log ( f \"No valid output from the processing results.\" ) selected_activities \u00b6 selected_activities () Gets the collection of selected activities. Returns: Type Description typing.List[Activity] A list of selected activities. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 def selected_activities ( self ) -> typing . List [ Activity ]: \"\"\"Gets the collection of selected activities. :returns: A list of selected activities. :rtype: typing.List[Activity] \"\"\" return [ item . activity for item in self . activity_widget . selected_activity_items () if item . isEnabled () ] show_message \u00b6 show_message ( message , level = Qgis . MessageLevel . Warning , duration = 0 ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level MessageLevel Message level type Warning duration int Duration of the shown message 0 Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 def show_message ( self , message , level = Qgis . MessageLevel . Warning , duration : int = 0 ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel :param duration: Duration of the shown message :type level: int \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level , duration = duration ) show_scenario_info \u00b6 show_scenario_info () Loads dialog for showing scenario information. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 def show_scenario_info ( self ): \"\"\"Loads dialog for showing scenario information.\"\"\" scenario_uuid = self . scenario_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) scenario = settings_manager . get_scenario ( scenario_uuid ) scenario_result = settings_manager . get_scenario_result ( scenario_uuid ) scenario_dialog = ScenarioDialog ( scenario , scenario_result ) scenario_dialog . exec () style_activities_layer \u00b6 style_activities_layer ( layer , activities ) Applies the styling to the passed layer that contains the passed list of activities. Parameters: Name Type Description Default layer QgsRasterLayer Layer to be styled required activities list List which contains the activities that were passed to the highest position analysis tool. required Returns: Type Description QgsPalettedRasterRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 def style_activities_layer ( self , layer , activities ): \"\"\"Applies the styling to the passed layer that contains the passed list of activities. :param layer: Layer to be styled :type layer: QgsRasterLayer :param activities: List which contains the activities that were passed to the highest position analysis tool. :type activities: list :returns: Renderer for the symbology. :rtype: QgsPalettedRasterRenderer \"\"\" area_classes = [] for activity in activities : activity_name = activity . name raster_val = activity . style_pixel_value color = activity . scenario_fill_symbol () . color () color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( raster_val ), QtGui . QColor ( color ), activity_name ) area_classes . append ( color_ramp_shader ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( area_classes ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) return renderer style_activity_layer \u00b6 style_activity_layer ( layer , activity ) Applies the styling to the layer that contains the passed activity name. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to which to apply the symbology required activity Activity activity required Returns: Type Description QgsSingleBandPseudoColorRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 def style_activity_layer ( self , layer , activity ): \"\"\"Applies the styling to the layer that contains the passed activity name. :param layer: Raster layer to which to apply the symbology :type layer: QgsRasterLayer :param activity: activity :type activity: Activity :returns: Renderer for the symbology. :rtype: QgsSingleBandPseudoColorRenderer \"\"\" # Retrieves a build-in QGIS color ramp color_ramp = activity . color_ramp () stats = layer . dataProvider () . bandStatistics ( 1 ) min_value = stats . minimumValue max_value = stats . maximumValue if stats . minimumValue == stats . maximumValue : # Create one class for the min/max value color = color_ramp . color ( min_value ) color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( min_value ), color , str ( min_value ) ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( [ color_ramp_shader ] ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) else : renderer = QgsSingleBandPseudoColorRenderer ( layer . dataProvider (), 1 ) renderer . setClassificationMin ( min_value ) renderer . setClassificationMax ( max_value ) renderer . createShader ( color_ramp , QgsColorRampShader . Type . Interpolated , QgsColorRampShader . ClassificationMode . Continuous , ) return renderer task_terminated \u00b6 task_terminated ( task ) Handles logging of the scenario analysis task status after it has been terminated. Parameters: Name Type Description Default task Union [ ScenarioAnalysisTask , ScenarioAnalysisTaskApiClient ] Task that was terminated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 def task_terminated ( self , task : typing . Union [ ScenarioAnalysisTask , ScenarioAnalysisTaskApiClient ] ): \"\"\"Handles logging of the scenario analysis task status after it has been terminated. :param task: Task that was terminated :type task: typing.Union[ScenarioAnalysisTask, ScenarioAnalysisTaskApiClient] \"\"\" task . on_terminated () log ( \"Main task terminated\" ) transform_extent \u00b6 transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent update_message_bar \u00b6 update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" log ( \"update_message_bar\" ) if isinstance ( message , str ): message_bar_item = self . message_bar . createMessage ( message ) else : message_bar_item = message self . message_bar . pushWidget ( message_bar_item , Qgis . MessageLevel . Info ) update_metric_button_profiles \u00b6 update_metric_button_profiles () Updates the profiles in the metric button menu based on the existing metric configuration profiles. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 def update_metric_button_profiles ( self ): \"\"\"Updates the profiles in the metric button menu based on the existing metric configuration profiles. \"\"\" metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is None : log ( \"Metric profile collection does not contain any profiles.\" ) return # Update tooltip current_profile = metric_profile_collection . get_current_profile () if current_profile : self . btn_metric_builder . setToolTip ( f \" { tr ( 'Active profile' ) } : <b> { current_profile . name } </b>\" ) else : self . btn_metric_builder . setToolTip ( f \" { tr ( 'No active profile specified' ) } \" ) # Update menu if not metric_profile_collection . profiles : return profiles_menu = QtWidgets . QMenu () self . profiles_action_group = QtWidgets . QActionGroup ( self ) self . profiles_action_group . setExclusive ( True ) self . profiles_action_group . triggered . connect ( self . on_profile_action_group_triggered ) for profile in metric_profile_collection . profiles : action = profiles_menu . addAction ( profile . name ) action . setCheckable ( True ) if profile . id == metric_profile_collection . current_profile : action . setChecked ( True ) # Disable invalid profiles if not profile . is_valid (): action . setEnabled ( False ) self . profiles_action_group . addAction ( action ) self . btn_metric_builder . setMenu ( profiles_menu ) self . btn_metric_builder . setPopupMode ( QtWidgets . QToolButton . ToolButtonPopupMode . MenuButtonPopup ) update_naturebase_carbon_impact \u00b6 update_naturebase_carbon_impact () Fetch the naturebase zonal stats based on the current extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 623 624 625 626 627 628 629 630 631 632 633 def update_naturebase_carbon_impact ( self ): \"\"\"Fetch the naturebase zonal stats based on the current extent.\"\"\" auto_refresh = settings_manager . get_value ( Settings . AUTO_REFRESH_NATURE_BASE_ZONAL_STATS , default = False , setting_type = bool , ) if not auto_refresh : return _ = calculate_zonal_stats_task () update_priority_layers \u00b6 update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . ItemDataRole . UserRole , layer . get ( \"uuid\" )) if os . path . exists ( layer . get ( \"path\" )) or layer . get ( \"path\" ) . startswith ( \"cplus://\" ): item . setIcon ( QtGui . QIcon ()) else : item . setIcon ( FileUtils . get_icon ( \"mIndicatorLayerError.svg\" )) item . setToolTip ( tr ( \"Contains invalid priority layer path, \" \"the provided layer path does not exist!\" ) ) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children ) update_progress_bar \u00b6 update_progress_bar ( progress_dialog , value ) Sets the value of the progress bar Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 def update_progress_bar ( self , progress_dialog , value ): \"\"\"Sets the value of the progress bar :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param value: Value to be set on the progress bar :type value: float \"\"\" if progress_dialog and not self . processing_cancelled : try : progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) update_progress_dialog \u00b6 update_progress_dialog ( progress_dialog , message = None ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message ReportManager Report manager used to generate analysis report_templates None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 def update_progress_dialog ( self , progress_dialog , message = None , ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Report manager used to generate analysis report_templates :type message: ReportManager \"\"\" progress_dialog . change_status_message ( message ) if message is not None else None update_pwl_layers \u00b6 update_pwl_layers ( notify = False ) Updates the priority layers path available in the store activities. Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store activities. :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_activities () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the activities\" \" with their respective priority layers\" ), Qgis . MessageLevel . Info , ) log ( tr ( \"Updated all the activities\" \" with their respective priority layers\" )) update_scenario_list \u00b6 update_scenario_list () Fetches scenarios from plugin settings and updates the scenario history list Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 def update_scenario_list ( self ): \"\"\"Fetches scenarios from plugin settings and updates the scenario history list \"\"\" scenarios = settings_manager . get_scenarios () if len ( scenarios ) >= 0 : self . scenario_list . clear () for scenario in scenarios : scenario_type = \"Available offline\" if scenario . server_uuid : scenario_result = settings_manager . get_scenario_result ( scenario . uuid ) if scenario_result is None : scenario_type = \"Online\" item_widget = ScenarioItemWidget ( scenario . name , scenario_type ) item = QtWidgets . QListWidgetItem ( self . scenario_list ) item . setSizeHint ( item_widget . sizeHint ()) item . setData ( QtCore . Qt . ItemDataRole . UserRole , str ( scenario . uuid )) item . setData ( QtCore . Qt . ItemDataRole . UserRole + 1 , scenario . name ) if scenario . server_uuid : item . setData ( QtCore . Qt . ItemDataRole . UserRole + 2 , str ( scenario . server_uuid ) ) else : item . setData ( QtCore . Qt . ItemDataRole . UserRole + 2 , \"\" ) self . scenario_list . setItemWidget ( item , item_widget ) zoom_pilot_area \u00b6 zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () zoom_extent = self . extent_box . outputExtent () original_crs = self . extent_box . outputCrs () if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and self . _aoi_layer ): zoom_extent = self . _aoi_layer . extent () original_crs = self . _aoi_layer . crs () canvas_crs = map_canvas . mapSettings () . destinationCrs () if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . GeometryType . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 2 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( zoom_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#gui-main","text":"The plugin main window class.","title":"GUI main"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain","text":"QgisCplusMain ( iface , parent = None ) Bases: QDockWidget , WidgetUi Main plugin UI class Source code in src/cplus_plugin/gui/qgis_cplus_main.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def __init__ ( self , iface , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . iface = iface self . progress_dialog = None self . task = None self . processing_cancelled = False self . current_analysis_task = None self . fetch_default_layer_task = None self . _aoi_layer = None # Set icons for buttons help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . help_btn . setIcon ( help_icon ) settings_icon = FileUtils . get_icon ( \"settings.svg\" ) self . options_btn . setIcon ( settings_icon ) self . prepare_input () # Set tooltips for all tabs self . tab_widget . setTabToolTip ( 0 , self . tr ( \"Scenario Setup\" )) # Insert widget for step 2 self . activity_widget = ActivityContainerWidget ( self , self . message_bar ) self . tab_widget . insertTab ( 1 , self . activity_widget , self . tr ( \"Step 2\" )) self . tab_widget . setTabToolTip ( 1 , self . tr ( \"Defining NCS Pathways and Activities\" ) ) self . tab_widget . setTabToolTip ( 2 , self . tr ( \"Variable Selection and Weighting\" )) self . tab_widget . setTabToolTip ( 3 , self . tr ( \"Run Analysis\" )) self . tab_widget . currentChanged . connect ( self . on_tab_step_changed ) # Step 3, priority weighting layers initialization self . priority_groups_widgets = {} self . pwl_item_flags = None # Step 4 self . ncs_pwl_weighted . toggled . connect ( self . outputs_options_changed ) self . landuse_project . toggled . connect ( self . outputs_options_changed ) self . highest_position . toggled . connect ( self . outputs_options_changed ) self . processing_type . toggled . connect ( self . processing_options_changed ) self . chb_metric_builder . toggled . connect ( self . on_use_custom_metrics ) self . btn_metric_builder . clicked . connect ( self . on_show_metrics_wizard ) edit_table_icon = FileUtils . get_icon ( \"mActionEditTable.svg\" ) self . btn_metric_builder . setIcon ( edit_table_icon ) self . load_layer_options () self . load_report_options () self . initialize_priority_layers () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () self . scenario_result = None self . analysis_finished . connect ( self . post_analysis ) # Log updates QgsApplication . messageLog () . messageReceived . connect ( self . on_log_message_received ) # Fetch scenario history list self . fetch_scenario_history_list () # Fetch default layers self . fetch_default_layer_list () # Update metric button with metric profiles self . update_metric_button_profiles ()","title":"QgisCplusMain"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_group","text":"add_priority_group () Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1261 1262 1263 1264 1265 1266 1267 def add_priority_group ( self ): \"\"\"Adds a new priority group into the plugin, then updates the priority list to show the new added priority group. \"\"\" group_dialog = PriorityGroupDialog () group_dialog . exec () self . update_priority_groups ()","title":"add_priority_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer","text":"add_priority_layer () Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1352 1353 1354 1355 1356 1357 1358 def add_priority_layer ( self ): \"\"\"Adds a new priority layer into the plugin, then updates the priority list to show the new added priority layer. \"\"\" layer_dialog = PriorityLayerDialog () layer_dialog . exec () self . update_priority_layers ( update_groups = False )","title":"add_priority_layer"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_priority_layer_group","text":"add_priority_layer_group ( target_group = None , priority_layer = None ) Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. Parameters: Name Type Description Default target_group dict Priority group where layer will be added to None priority_layer dict Priority weighting layer to be added None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 def add_priority_layer_group ( self , target_group = None , priority_layer = None ): \"\"\"Adds priority layer from the weighting layers into a priority group If no target_group or priority_layer is passed then the current selected group or priority layer from their respective list will be used. Checks if priority layer is already in the target group and if so no addition is done. Once the addition is done, the respective priority layer plugin settings are updated to store the new information. :param target_group: Priority group where layer will be added to :type target_group: dict :param priority_layer: Priority weighting layer to be added :type priority_layer: dict \"\"\" selected_priority_layers = ( priority_layer or self . priority_layers_list . selectedItems () ) selected_priority_layers = ( [ selected_priority_layers ] if not isinstance ( selected_priority_layers , list ) else selected_priority_layers ) selected_group = target_group or self . priority_groups_list . currentItem () for selected_priority_layer in selected_priority_layers : if ( selected_group is not None and selected_group . parent () is None ) and selected_priority_layer is not None : children = selected_group . takeChildren () item_found = False text = selected_priority_layer . data ( QtCore . Qt . ItemDataRole . DisplayRole ) for child in children : if child . text ( 0 ) == text : item_found = True break selected_group . addChildren ( children ) if not item_found : selected_group . setExpanded ( True ) item = QtWidgets . QTreeWidgetItem ( selected_group ) item . setText ( 0 , text ) group_widget = self . priority_groups_list . itemWidget ( selected_group , 0 ) layer_id = selected_priority_layer . data ( QtCore . Qt . ItemDataRole . UserRole ) priority_layer = settings_manager . get_priority_layer ( layer_id ) item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , priority_layer . get ( USER_DEFINED_ATTRIBUTE ), ) target_group_name = ( group_widget . group . get ( \"name\" ) if group_widget . group else None ) groups = priority_layer . get ( \"groups\" ) new_groups = [] group_found = False for group in groups : if target_group_name == group [ \"name\" ]: group_found = True new_group = settings_manager . find_group_by_name ( target_group_name ) else : new_group = group new_groups . append ( new_group ) if not group_found : searched_group = settings_manager . find_group_by_name ( target_group_name ) new_groups . append ( searched_group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer )","title":"add_priority_layer_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.add_scenario","text":"add_scenario () Adds a new scenario into the scenario list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 def add_scenario ( self ): \"\"\"Adds a new scenario into the scenario list.\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () extent = self . extent_box . outputExtent () extent_crs = self . extent_box . outputCrs () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] if self . can_clip_to_studyarea (): study_area_path = self . get_studyarea_path () layer = QgsVectorLayer ( study_area_path , \"studyarea\" ) if layer . isValid (): extent = layer . extent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] extent_crs = layer . crs () extent = SpatialExtent ( bbox = extent_box , crs = extent_crs . authid ()) scenario_id = uuid . uuid4 () activities = [] priority_layer_groups = [] if self . scenario_result : activities = self . scenario_result . scenario . activities priority_layer_groups = self . scenario_result . scenario . priority_layer_groups scenario = Scenario ( uuid = scenario_id , name = scenario_name , description = scenario_description , extent = extent , activities = activities , priority_layer_groups = priority_layer_groups , server_uuid = ( self . scenario_result . scenario . server_uuid if self . scenario_result else None ), clip_to_studyarea = self . can_clip_to_studyarea (), studyarea_path = self . get_studyarea_path (), crs = self . crs_selector . crs () . authid (), ) settings_manager . save_scenario ( scenario ) if self . scenario_result : settings_manager . save_scenario_result ( self . scenario_result , str ( scenario_id ) ) self . update_scenario_list ()","title":"add_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.analysis_complete","text":"analysis_complete ( task , report_manager , progress_dialog ) Calls the responsible function for handling analysis results outputs Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 def analysis_complete ( self , task , report_manager , progress_dialog ): \"\"\"Calls the responsible function for handling analysis results outputs :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" self . scenario_result = task . scenario_result self . scenario_results ( task , report_manager , progress_dialog )","title":"analysis_complete"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.can_clip_to_studyarea","text":"can_clip_to_studyarea () Return true if clipping layers by study area is selected Source code in src/cplus_plugin/gui/qgis_cplus_main.py 612 613 614 615 616 617 618 619 620 621 def can_clip_to_studyarea ( self ) -> bool : \"\"\"Return true if clipping layers by study area is selected\"\"\" clip_to_studyarea = False studyarea_path = self . get_studyarea_path () if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and os . path . exists ( studyarea_path ) ): clip_to_studyarea = True return clip_to_studyarea","title":"can_clip_to_studyarea"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.cancel_processing_task","text":"cancel_processing_task () Cancels the current processing task. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2362 2363 2364 2365 2366 2367 2368 2369 2370 def cancel_processing_task ( self ): \"\"\"Cancels the current processing task.\"\"\" try : if self . current_analysis_task : self . current_analysis_task . cancel_task () except Exception as e : self . on_progress_dialog_cancelled () log ( f \"Problem cancelling task, { e } \" ) self . processing_cancelled = True","title":"cancel_processing_task"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.edit_priority_group","text":"edit_priority_group () Edits the current selected priority group and updates the group box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 def edit_priority_group ( self ): \"\"\"Edits the current selected priority group and updates the group box list.\"\"\" if self . priority_groups_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority group from the groups list.\" ), Qgis . MessageLevel . Critical , ) return group_identifier = self . priority_groups_list . currentItem () . data ( 0 , QtCore . Qt . ItemDataRole . UserRole ) if ( group_identifier == \"\" or group_identifier is None or not isinstance ( group_identifier , str ) ): self . show_message ( tr ( \"Could not fetch the selected\" \" priority groups for editing.\" ), Qgis . MessageLevel . Critical , ) return self . _show_priority_group_editor ( group_identifier )","title":"edit_priority_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.edit_priority_layer","text":"edit_priority_layer () Edits the current selected priority layer and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 def edit_priority_layer ( self ): \"\"\"Edits the current selected priority layer and updates the layer box list.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . MessageLevel . Critical , ) return layer_identifier = self . priority_layers_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) if layer_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . MessageLevel . Critical , ) return self . _show_priority_layer_editor ( layer_identifier ) self . update_priority_layers ( update_groups = False )","title":"edit_priority_layer"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.enable_analysis_controls","text":"enable_analysis_controls ( enable ) Enable or disable controls related to running the scenario analysis. Parameters: Name Type Description Default enable bool True to enable else False to disable. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1987 1988 1989 1990 1991 1992 1993 1994 def enable_analysis_controls ( self , enable : bool ): \"\"\"Enable or disable controls related to running the scenario analysis. :param enable: True to enable else False to disable. :type enable: bool \"\"\" self . run_scenario_btn . setEnabled ( enable ) self . gp_report_options . setEnabled ( enable )","title":"enable_analysis_controls"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.fetch_default_layer_list","text":"fetch_default_layer_list () Fetch default layer list from API. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1472 1473 1474 1475 1476 1477 def fetch_default_layer_list ( self ): \"\"\"Fetch default layer list from API.\"\"\" if not self . has_trends_auth (): return self . fetch_default_layer_task = FetchDefaultLayerTask () QgsApplication . taskManager () . addTask ( self . fetch_default_layer_task )","title":"fetch_default_layer_list"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.fetch_scenario_history_list","text":"fetch_scenario_history_list () Fetch scenario history list from API. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1845 1846 1847 1848 1849 1850 1851 1852 def fetch_scenario_history_list ( self ): \"\"\"Fetch scenario history list from API.\"\"\" if not self . has_trends_auth (): self . update_scenario_list () return task = FetchScenarioHistoryTask () task . task_finished . connect ( self . on_fetch_scenario_history_list_finished ) QgsApplication . taskManager () . addTask ( task )","title":"fetch_scenario_history_list"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.get_studyarea_path","text":"get_studyarea_path () Return the path of the study area Returns: str: Study area path Source code in src/cplus_plugin/gui/qgis_cplus_main.py 635 636 637 638 639 640 641 642 643 def get_studyarea_path ( self ) -> str : \"\"\"Return the path of the study area Returns: str: Study area path \"\"\" if self . _aoi_layer : return self . _aoi_layer . source () return \"\"","title":"get_studyarea_path"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.group_value_changed","text":"group_value_changed ( group_name , group_value ) Slot to handle priority group widget changes. Parameters: Name Type Description Default group_name str Group name required group_value int Group value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 def group_value_changed ( self , group_name , group_value ): \"\"\"Slot to handle priority group widget changes. :param group_name: Group name :type group_name: str :param group_value: Group value :type group_value: int \"\"\" group = settings_manager . find_group_by_name ( group_name ) group [ \"value\" ] = group_value settings_manager . save_priority_group ( group ) for index in range ( self . priority_groups_list . topLevelItemCount ()): item = self . priority_groups_list . topLevelItem ( index ) for child_index in range ( item . childCount ()): child = item . child ( child_index ) layer = settings_manager . find_layer_by_name ( child . text ( 0 )) new_groups = [] for group in layer . get ( \"groups\" ): if group . get ( \"name\" ) == group_name : group [ \"value\" ] = group_value new_groups . append ( group ) layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( layer )","title":"group_value_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.has_trends_auth","text":"has_trends_auth () Check if plugin has user Trends.Earth authentication. Returns: Type Description bool True if user has provided the username and password. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 def has_trends_auth ( self ): \"\"\"Check if plugin has user Trends.Earth authentication. :return: True if user has provided the username and password. :rtype: bool \"\"\" auth_config = auth . get_auth_config ( auth . TE_API_AUTH_SETUP , warn = None ) return ( auth_config and auth_config . config ( \"username\" ) and auth_config . config ( \"password\" ) )","title":"has_trends_auth"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.initialize_priority_layers","text":"initialize_priority_layers () Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 def initialize_priority_layers ( self ): \"\"\"Prepares the priority weighted layers UI with the defaults. Gets the store priority layers from plugin settings and populates them into the QListWidget as QListWidgetItems then fetches the priority groups and adds them to the QTreeWidget as QTreeWidgetItems with their corresponding priority layers as their child items. \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . ItemDataRole . UserRole , layer . get ( \"uuid\" )) if not os . path . exists ( layer . get ( \"path\" )) and not layer . get ( \"path\" ) . startswith ( \"cplus://\" ): item . setIcon ( FileUtils . get_icon ( \"mIndicatorLayerError.svg\" )) item . setToolTip ( tr ( \"Contains invalid priority layer path, \" \"the provided layer path does not exist!\" ) ) if self . pwl_item_flags is None : self . pwl_item_flags = item . flags () self . priority_layers_list . addItem ( item ) list_items = [] items_only = [] stored_priority_groups = settings_manager . get_priority_groups () self . priority_groups_list . clear () for group in stored_priority_groups : group_widget = PriorityGroupWidget ( group , ) group_widget . input_value_changed . connect ( self . group_value_changed ) group_widget . slider_value_changed . connect ( self . group_value_changed ) self . priority_groups_widgets [ group [ \"name\" ]] = group_widget pw_layers = settings_manager . find_layers_by_group ( group [ \"name\" ]) item = SortableTreeWidgetItem () item . setSizeHint ( 0 , group_widget . sizeHint ()) item . setExpanded ( True ) item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , group . get ( \"uuid\" )) item . setData ( 0 , SORT_ROLE , group . get ( \"name\" )) # Add priority layers into the group as a child items. item . setExpanded ( True ) if len ( pw_layers ) > 0 else None for layer in pw_layers : if item . parent () is None : layer_item = QtWidgets . QTreeWidgetItem ( item ) layer_item . setText ( 0 , layer . get ( \"name\" )) layer_item . setData ( 0 , QtCore . Qt . ItemDataRole . UserRole , layer . get ( USER_DEFINED_ATTRIBUTE ), ) list_items . append (( item , group_widget )) items_only . append ( item ) self . priority_groups_list . addTopLevelItems ( items_only ) self . priority_groups_list . sortItems ( 0 , QtCore . Qt . SortOrder . AscendingOrder ) for item in list_items : self . priority_groups_list . setItemWidget ( item [ 0 ], 0 , item [ 1 ])","title":"initialize_priority_layers"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.is_metric_configuration_valid","text":"is_metric_configuration_valid () Checks if the setup of the metric configuration for the scenario analysis report is correct. Returns: Type Description bool True if the configuration is correct else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 def is_metric_configuration_valid ( self ) -> bool : \"\"\"Checks if the setup of the metric configuration for the scenario analysis report is correct. :returns: True if the configuration is correct else False. :rtype: bool \"\"\" if not self . chb_metric_builder . isChecked (): # Not applicable so just return True return True else : profile_collection = settings_manager . get_metric_profile_collection () if profile_collection is None : self . show_message ( tr ( f \"No metric profiles found. Use the metric \" f \"builder to specify one or more metric \" f \"profiles.\" ) ) return False metric_profile = profile_collection . get_current_profile () if ( metric_profile is None or metric_profile . config is None or not metric_profile . config . is_valid () ): self . show_message ( tr ( f \"Metric configuration is invalid or not yet defined. \" f \"Use the metric builder to check and re-run the wizard.\" ) ) return False # Compare activities selected_activities_ids = set ( [ str ( activity . uuid ) for activity in self . selected_activities ()] ) metric_activity_ids = set ( [ str ( activity . uuid ) for activity in metric_profile . config . activities ] ) if selected_activities_ids == metric_activity_ids : return True elif selected_activities_ids . issubset ( metric_activity_ids ): return True elif len ( selected_activities_ids . difference ( metric_activity_ids )) > 0 : self . show_message ( tr ( f \"There are activities whose metrics has not not been \" f \"defined. Use the metric builder to update.\" ) ) return False return True","title":"is_metric_configuration_valid"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.load_layer_options","text":"load_layer_options () Retrieve outputs scenarion layers selection from settings and update the releated ui components Source code in src/cplus_plugin/gui/qgis_cplus_main.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def load_layer_options ( self ): \"\"\" Retrieve outputs scenarion layers selection from settings and update the releated ui components \"\"\" self . ncs_pwl_weighted . setChecked ( settings_manager . get_value ( Settings . NCS_WEIGHTED , default = False , setting_type = bool ) ) self . landuse_project . setChecked ( settings_manager . get_value ( Settings . LANDUSE_PROJECT , default = False , setting_type = bool ) ) self . highest_position . setChecked ( settings_manager . get_value ( Settings . HIGHEST_POSITION , default = False , setting_type = bool ) ) self . processing_type . setChecked ( settings_manager . get_value ( Settings . PROCESSING_TYPE , default = False , setting_type = bool ) ) self . view_status_btn . clicked . connect ( self . on_view_status_button_clicked ) running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if not online_task : self . view_status_btn . setEnabled ( False ) else : self . view_status_btn . setEnabled ( True )","title":"load_layer_options"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.load_report_options","text":"load_report_options () Load previously saved report options. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 331 332 333 334 335 336 337 def load_report_options ( self ): \"\"\"Load previously saved report options.\"\"\" self . chb_metric_builder . setChecked ( settings_manager . get_value ( Settings . USE_CUSTOM_METRICS , default = False , setting_type = bool ) )","title":"load_report_options"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.load_scenario","text":"load_scenario ( scenario_identifier = None ) Edits the current selected scenario and updates the layer box list. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 def load_scenario ( self , scenario_identifier = None ): \"\"\"Edits the current selected scenario and updates the layer box list.\"\"\" if not scenario_identifier : if self . scenario_list . currentItem () is None : self . show_message ( tr ( \"Select first the scenario from the scenario list.\" ), Qgis . MessageLevel . Critical , ) return scenario_identifier = self . scenario_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) if scenario_identifier == \"\" : self . show_message ( tr ( \"Could not fetch the selected priority layer for editing.\" ), Qgis . MessageLevel . Critical , ) return scenario = settings_manager . get_scenario ( scenario_identifier ) if scenario is not None : self . scenario_name . setText ( scenario . name ) self . scenario_description . setText ( scenario . description ) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) # Set extent CRS and values extent_crs_text = ( scenario . extent . crs if scenario . extent and scenario . extent . crs else f \"EPSG: { DEFAULT_CRS_ID } \" ) extent_crs = QgsCoordinateReferenceSystem ( extent_crs_text ) extent_list = scenario . extent . bbox if scenario . extent else None if extent_list : default_extent = QgsRectangle ( float ( extent_list [ 0 ]), float ( extent_list [ 2 ]), float ( extent_list [ 1 ]), float ( extent_list [ 3 ]), ) self . extent_box . setOutputExtentFromUser ( default_extent , extent_crs ) self . extent_box . setOutputCrs ( extent_crs ) # Set analysis CRS analysis_crs_text = scenario . crs or extent_crs_text analysis_crs = QgsCoordinateReferenceSystem ( analysis_crs_text ) self . crs_selector . setCrs ( analysis_crs ) # Transform extent to analysis CRS transformed_analysis_extent = self . transform_extent ( self . extent_box . outputExtent (), extent_crs , analysis_crs ) transformed_analysis_extent_list = [ transformed_analysis_extent . xMinimum (), transformed_analysis_extent . xMaximum (), transformed_analysis_extent . yMinimum (), transformed_analysis_extent . yMaximum (), ] self . rb_studyarea . setChecked ( False ) self . rb_extent . setChecked ( False ) if scenario . clip_to_studyarea and os . path . exists ( scenario . studyarea_path ): # Area of Interest from the study area layer self . on_aoi_source_changed ( 0 , True ) self . rb_studyarea . setChecked ( True ) self . _aoi_layer = QgsVectorLayer ( scenario . studyarea_path , Path ( scenario . studyarea_path ) . stem ) # Use the study area layer extent transformed to analysis CRS extent = self . _aoi_layer . extent () transformed_analysis_extent = self . transform_extent ( extent , self . _aoi_layer . crs (), analysis_crs ) transformed_analysis_extent_list = [ transformed_analysis_extent . xMinimum (), transformed_analysis_extent . xMaximum (), transformed_analysis_extent . yMinimum (), transformed_analysis_extent . yMaximum (), ] else : # Area of Interest from the extent self . on_aoi_source_changed ( 1 , True ) self . rb_extent . setChecked ( True ) all_activities = sorted ( scenario . activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 scenario . activities = all_activities if scenario and scenario . server_uuid : self . analysis_scenario_name = scenario . name self . analysis_scenario_description = scenario . description self . analysis_extent = SpatialExtent ( bbox = transformed_analysis_extent_list , crs = analysis_crs_text ) self . analysis_activities = scenario . activities self . analysis_priority_layers_groups = scenario . priority_layer_groups scenario_obj = Scenario ( uuid = scenario . uuid , name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = SpatialExtent ( bbox = extent_list , crs = extent_crs_text ), activities = self . analysis_activities , priority_layer_groups = self . analysis_priority_layers_groups , crs = analysis_crs_text , ) scenario_obj . server_uuid = scenario . server_uuid self . processing_cancelled = False progress_dialog = OnlineProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () analysis_task = FetchScenarioOutputTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , None , ) analysis_task . scenario_api_uuid = scenario . server_uuid analysis_task . task_finished . connect ( self . update_scenario_list ) self . run_cplus_main_task ( progress_dialog , scenario , analysis_task )","title":"load_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.main_task","text":"main_task () Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2355 2356 2357 2358 2359 2360 def main_task ( self ): \"\"\"Serves as a QgsTask function for the main task that contains smaller sub-tasks running the actual processing calculations. \"\"\" log ( \"Running from main task.\" )","title":"main_task"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.move_layer_to_group","text":"move_layer_to_group ( layer , group ) Moves a layer open in QGIS to another group. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to move required group QgsLayerTreeGroup Group to which the raster should be moved required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 def move_layer_to_group ( self , layer , group ) -> None : \"\"\"Moves a layer open in QGIS to another group. :param layer: Raster layer to move :type layer: QgsRasterLayer :param group: Group to which the raster should be moved :type group: QgsLayerTreeGroup \"\"\" if layer : instance_root = QgsProject . instance () . layerTreeRoot () layer = instance_root . findLayer ( layer . id ()) layer_clone = layer . clone () parent = layer . parent () ( group . insertChildNode ( 0 , layer_clone ) if group is not None else None ) # Add to top of group parent . removeChildNode ( layer )","title":"move_layer_to_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_aoi_source_changed","text":"on_aoi_source_changed ( button_id , toggled ) Slot raised when the area of interest source button group has been toggled. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 def on_aoi_source_changed ( self , button_id : int , toggled : bool ): \"\"\"Slot raised when the area of interest source button group has been toggled. \"\"\" if not toggled : return if button_id == AreaOfInterestSource . LAYER . value : self . studyarea_stacked_widget . setCurrentIndex ( 0 ) elif button_id == AreaOfInterestSource . EXTENT . value : self . studyarea_stacked_widget . setCurrentIndex ( 1 ) self . save_scenario () # Check and fetch carbon impact for the current extent self . update_naturebase_carbon_impact ()","title":"on_aoi_source_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_fetch_scenario_history_list_finished","text":"on_fetch_scenario_history_list_finished ( success ) Callback when plugin has finished pulling scenario history list. Parameters: Name Type Description Default success bool True if API call is successful required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1854 1855 1856 1857 1858 1859 1860 1861 1862 def on_fetch_scenario_history_list_finished ( self , success ): \"\"\"Callback when plugin has finished pulling scenario history list. :param success: True if API call is successful :type success: bool \"\"\" if not success : return self . update_scenario_list ()","title":"on_fetch_scenario_history_list_finished"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_generate_comparison_report","text":"on_generate_comparison_report () Slot raised to generate a comparison for two or more selected scenario results. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 def on_generate_comparison_report ( self ): \"\"\"Slot raised to generate a comparison for two or more selected scenario results. \"\"\" selected_items = self . scenario_list . selectedItems () if len ( selected_items ) < 2 : msg = tr ( \"You must select at least two scenarios to generate the comparison report.\" ) self . show_message ( msg ) return scenario_results = [] for item in selected_items : scenario_identifier = item . data ( QtCore . Qt . ItemDataRole . UserRole ) scenario = settings_manager . get_scenario ( scenario_identifier ) scenario_result = settings_manager . get_scenario_result ( scenario_identifier ) if not scenario_result and not scenario : continue all_activities = sorted ( scenario . activities , key = lambda activity_instance : activity_instance . style_pixel_value , ) for index , activity in enumerate ( all_activities ): activity . style_pixel_value = index + 1 scenario . activities = all_activities scenario_result . scenario = scenario scenario_results . append ( scenario_result ) if len ( scenario_results ) < 2 : msg = tr ( \"Unable to retrieve the results for all the selected scenarios.\" ) self . show_message ( msg ) return if len ( scenario_results ) > MAXIMUM_COMPARISON_REPORTS : msg = tr ( \"Exceeded maximum number of scenarios for generating the comparison report. Limit is\" ) self . show_message ( f \" { msg } { MAXIMUM_COMPARISON_REPORTS } .\" ) return for result in scenario_results : msg_tr = tr ( \"Loading map layers for scenario\" ) log ( message = f \" { msg_tr } : { result . scenario . name } \" ) self . post_analysis ( result , None , None , None ) submit_result = report_manager . generate_comparison_report ( scenario_results ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for creating the comparison report.\" ) self . show_message ( f \" { msg } \" ) return QgsApplication . processEvents () self . report_progress_dialog = ReportProgressDialog ( tr ( \"Generating comparison report\" ), submit_result ) self . report_progress_dialog . run_dialog ()","title":"on_generate_comparison_report"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_log_message_received","text":"on_log_message_received ( message , tag , level ) Slot to handle log tab updates and processing logs Parameters: Name Type Description Default message str The received message from QGIS message log required tag str Message log tag required level MessageLevel Message level enum value required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def on_log_message_received ( self , message , tag , level ): \"\"\"Slot to handle log tab updates and processing logs :param message: The received message from QGIS message log :type message: str :param tag: Message log tag :type tag: str :param level: Message level enum value :type level: Qgis.MessageLevel \"\"\" if tag == PLUGIN_MESSAGE_LOG_TAB : # If there is no current running analysis # task don't save the log message. if not self . current_analysis_task : return try : to_zone = tz . tzlocal () message_dict = json . loads ( message ) if sorted ( list ( message_dict . keys ())) == [ \"date_time\" , \"log\" ]: message = message_dict [ \"log\" ] message_time = message_dict [ \"date_time\" ] . replace ( \"Z\" , \"+00:00\" ) message_time = datetime . datetime . fromisoformat ( message_time ) message_time = message_time . astimezone ( to_zone ) . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) else : message_time = datetime . datetime . now () . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) except Exception : message_time = datetime . datetime . now () . strftime ( \"%Y-%m- %d T%H:%M:%S\" ) message = ( f \" { self . log_text_box . toPlainText () } \" f \" { message_time } { QGIS_MESSAGE_LEVEL_DICT [ level ] } \" f \" { message } \" ) self . log_text_box . setPlainText ( f \" { message } \\n \" ) log_text_cursor = self . log_text_box . textCursor () log_text_cursor . movePosition ( QtGui . QTextCursor . MoveOperation . End ) self . log_text_box . setTextCursor ( log_text_cursor ) try : os . makedirs ( self . current_analysis_task . scenario_directory , exist_ok = True ) processing_log_file = os . path . join ( self . current_analysis_task . scenario_directory , SCENARIO_LOG_FILE_NAME , ) write_to_file ( message , processing_log_file ) except TypeError : pass","title":"on_log_message_received"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_manage_constant_raster_pwls","text":"on_manage_constant_raster_pwls () Slot raised to show the Constant Raster manager dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 def on_manage_constant_raster_pwls ( self ): \"\"\"Slot raised to show the Constant Raster manager dialog.\"\"\" # Show Constant Raster manager dialog constant_raster_dialog = ConstantRastersManagerDialog ( parent = self ) # Connect signal to handle raster creation constant_raster_dialog . create_rasters_requested . connect ( lambda context , collection , input_range , metadata_id , current_view : self . _on_constant_rasters_create_requested ( context , collection , input_range , metadata_id , current_view , constant_raster_dialog , ) ) constant_raster_dialog . exec ()","title":"on_manage_constant_raster_pwls"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_manage_pwls_relative_impact_matrix","text":"on_manage_pwls_relative_impact_matrix () Slot raised to show the dialog for managing relative impact matrix of PWLs. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1451 1452 1453 1454 1455 1456 1457 1458 def on_manage_pwls_relative_impact_matrix ( self ): \"\"\"Slot raised to show the dialog for managing relative impact matrix of PWLs.\"\"\" ncs_pwl_relative_impact_dialog = NcsPwlImpactManagerDialog ( self ) if ( ncs_pwl_relative_impact_dialog . exec () == QtWidgets . QDialog . DialogCode . Accepted ): pass","title":"on_manage_pwls_relative_impact_matrix"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_npv_pwl_created","text":"on_npv_pwl_created ( pathway_npv , npv_pwl_path , algorithm , context , feedback ) Callback that creates an PWL item when the corresponding raster layer has been created. Parameters: Name Type Description Default pathway_npv ActivityNpv NPV mapping for an NCS pathway. required npv_pwl_path str Absolute file path of the created NPV PWL. required algorithm QgsProcessingAlgorithm Processing algorithm that created the NPV PWL. required context QgsProcessingContext Contextual information that was used to create the NPV PWL in processing. required feedback QgsProcessingFeedback Feedback to update on the processing progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 def on_npv_pwl_created ( self , pathway_npv : ActivityNpv , npv_pwl_path : str , algorithm : QgsProcessingAlgorithm , context : QgsProcessingContext , feedback : QgsProcessingFeedback , ): \"\"\"Callback that creates an PWL item when the corresponding raster layer has been created. :param pathway_npv: NPV mapping for an NCS pathway. :type pathway_npv: ActivityNpv :param npv_pwl_path: Absolute file path of the created NPV PWL. :type npv_pwl_path: str :param algorithm: Processing algorithm that created the NPV PWL. :type algorithm: QgsProcessingAlgorithm :param context: Contextual information that was used to create the NPV PWL in processing. :type context: QgsProcessingContext :param feedback: Feedback to update on the processing progress. :type feedback: QgsProcessingFeedback \"\"\" # Check if the PWL entry already exists in the settings. If it # exists then no further updates required as the filename of the # PWL layer is still the same. updated_pwl = settings_manager . find_layer_by_name ( pathway_npv . base_name ) if updated_pwl is None : # Create NPV PWL desc_tr = tr ( \"Normalized NPV for\" ) pwl_desc = f \" { desc_tr } { pathway_npv . pathway . name } .\" npv_layer_info = { \"uuid\" : str ( uuid . uuid4 ()), \"name\" : pathway_npv . base_name , \"description\" : pwl_desc , \"groups\" : [], \"path\" : npv_pwl_path , \"type\" : PriorityLayerType . NPV . value , USER_DEFINED_ATTRIBUTE : True , } settings_manager . save_priority_layer ( npv_layer_info ) # Updated the PWL for the NCS pathway pathway = settings_manager . get_ncs_pathway ( pathway_npv . pathway_id ) if pathway is not None : pathway . priority_layers . append ( npv_layer_info ) settings_manager . update_ncs_pathway ( pathway ) else : msg_tr = tr ( \"ncs pathway not found to attach the NPV PWL.\" ) log ( f \" { pathway_npv . pathway . name } { msg_tr } \" , info = False ) else : # Just update the path updated_pwl [ \"path\" ] = npv_pwl_path settings_manager . save_priority_layer ( updated_pwl ) self . update_priority_layers ( update_groups = False )","title":"on_npv_pwl_created"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_npv_pwl_removed","text":"on_npv_pwl_removed ( pwl_identifier ) Callback that is executed when an NPV PWL has been removed because it was disabled by the user. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1194 1195 1196 1197 1198 def on_npv_pwl_removed ( self , pwl_identifier : str ): \"\"\"Callback that is executed when an NPV PWL has been removed because it was disabled by the user.\"\"\" # We use this to refresh the view to reflect the removed NPV PWL. self . update_priority_layers ( update_groups = False )","title":"on_npv_pwl_removed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_online_task_check_finished","text":"on_online_task_check_finished ( status ) Handler for view online task and generate report button. The button itself will be shown when Cplus plugin becomes visible. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def on_online_task_check_finished ( self , status ): \"\"\" Handler for view online task and generate report button. The button itself will be shown when Cplus plugin becomes visible. \"\"\" running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if online_task : if status == JOB_COMPLETED_STATUS : message = f \"Task { online_task . name } has completed successfully. You can download the result from Log tab.\" button_text = \"OK\" elif status == JOB_RUNNING_STATUS : message = f \"Task { online_task . name } is still running.\" button_text = \"View status\" else : message = f \"Task { online_task . name } is { status } .\" button_text = \"OK\" widget = self . message_bar . createMessage ( tr ( message )) if status == JOB_RUNNING_STATUS : button = QPushButton ( widget ) button . setText ( button_text ) load_scenario = partial ( self . load_scenario , running_online_scenario_uuid ) button . pressed . connect ( load_scenario ) widget . layout () . addWidget ( button ) self . update_message_bar ( widget )","title":"on_online_task_check_finished"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_profile_action_group_triggered","text":"on_profile_action_group_triggered ( action ) Slot raised when the action group for profiles has been triggered. Parameters: Name Type Description Default action QAction Action in the group that has been triggered. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 def on_profile_action_group_triggered ( self , action : QtWidgets . QAction ): \"\"\"Slot raised when the action group for profiles has been triggered. :param action: Action in the group that has been triggered. :type action: QtWidgets.QAction \"\"\" metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is None : return # Set current profile current_profile = \"\" for profile in metric_profile_collection . profiles : if profile . name == action . text (): current_profile = profile . id break if current_profile : metric_profile_collection . current_profile = current_profile settings_manager . save_metric_profile_collection ( metric_profile_collection )","title":"on_profile_action_group_triggered"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_progress_dialog_cancelled","text":"on_progress_dialog_cancelled () Slot raised when analysis has been cancelled in progress dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3179 3180 3181 3182 def on_progress_dialog_cancelled ( self ): \"\"\"Slot raised when analysis has been cancelled in progress dialog.\"\"\" if not self . run_scenario_btn . isEnabled (): self . enable_analysis_controls ( True )","title":"on_progress_dialog_cancelled"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_error","text":"on_report_error ( progress_dialog , message ) Slot raised when report task error has occured. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 def on_report_error ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task error has occured. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog \"\"\" progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) log ( message ) self . enable_analysis_controls ( True )","title":"on_report_error"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_finished","text":"on_report_finished ( progress_dialog , scenario_id ) Slot raised when report task has finished. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 def on_report_finished ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has finished. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . set_report_complete () progress_dialog . change_status_message ( tr ( \"Report generation complete\" )) self . enable_analysis_controls ( True )","title":"on_report_finished"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_running","text":"on_report_running ( progress_dialog , scenario_id ) Slot raised when report task has started. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required scenario_id str Scenario analysis id required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 def on_report_running ( self , progress_dialog , scenario_id : str ): \"\"\"Slot raised when report task has started. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param scenario_id: Scenario analysis id :type scenario_id: str \"\"\" if not self . report_job_is_for_current_scenario ( scenario_id ): return progress_dialog . update_progress_bar ( 0 ) progress_dialog . report_running = True progress_dialog . change_status_message ( tr ( \"Generating report for the analysis output\" ) )","title":"on_report_running"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_report_status_changed","text":"on_report_status_changed ( progress_dialog , message ) Slot raised when report task status has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message str Status message. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 def on_report_status_changed ( self , progress_dialog , message : str ): \"\"\"Slot raised when report task status has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Status message. :type message: str \"\"\" status_message = f \" { tr ( 'Report generation' ) } - { message } ...\" progress_dialog . change_status_message ( status_message )","title":"on_report_status_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_reporting_progress_changed","text":"on_reporting_progress_changed ( progress_dialog , progress ) Slot raised when the reporting progress has changed. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required progress float Analysis progress value between 0 and 100 required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 def on_reporting_progress_changed ( self , progress_dialog , progress : float ): \"\"\"Slot raised when the reporting progress has changed. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param progress: Analysis progress value between 0 and 100 :type progress: float \"\"\" progress_dialog . update_progress_bar ( progress )","title":"on_reporting_progress_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_scenario_list_selection_changed","text":"on_scenario_list_selection_changed () Slot raised when the selection of scenarios changes. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1837 1838 1839 1840 1841 1842 1843 def on_scenario_list_selection_changed ( self ): \"\"\"Slot raised when the selection of scenarios changes.\"\"\" selected_items = self . scenario_list . selectedItems () if len ( selected_items ) < 2 : self . comparison_report_btn . setEnabled ( False ) else : self . comparison_report_btn . setEnabled ( True )","title":"on_scenario_list_selection_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_show_metrics_wizard","text":"on_show_metrics_wizard () Slot raised to show the metric customization wizard for creating the scenario analysis report. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 def on_show_metrics_wizard ( self ): \"\"\"Slot raised to show the metric customization wizard for creating the scenario analysis report. \"\"\" metrics_builder = ActivityMetricsBuilder ( self ) metrics_builder . activities = self . selected_activities () # Load previously saved profile collection metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is not None : metrics_builder . profile_collection = metric_profile_collection else : metrics_builder . initialize_collection () if metrics_builder . exec () == QtWidgets . QDialog . DialogCode . Accepted : metric_profile_collection = metrics_builder . profile_collection settings_manager . save_metric_profile_collection ( metric_profile_collection ) self . update_metric_button_profiles ()","title":"on_show_metrics_wizard"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_tab_step_changed","text":"on_tab_step_changed ( index ) Slot raised when the current tab changes. Parameters: Name Type Description Default index int Zero-based index position of new current tab required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 def on_tab_step_changed ( self , index : int ): \"\"\"Slot raised when the current tab changes. :param index: Zero-based index position of new current tab :type index: int \"\"\" activity_tab_index = 1 priority_group_tab_index = 2 if index == activity_tab_index : self . activity_widget . can_show_error_messages = True self . activity_widget . load () # Check if CRS is valid crs = self . crs_selector . crs () if crs is None or not crs . isValid () or crs . isGeographic (): self . show_message ( self . tr ( \"Please select a valid coordinate system.\" )) self . tab_widget . setCurrentIndex ( 0 ) elif index == priority_group_tab_index : tab_valid = True msg = \"\" # Check if NCS pathways are valid ncs_valid = self . activity_widget . is_ncs_valid () if not ncs_valid : msg = self . tr ( \"NCS pathways are not valid or there is an ongoing validation process. \" \"Use the validation inspector to see more details.\" ) tab_valid = False # Validate activity selection selected_activities = self . activity_widget . selected_activity_items () if len ( selected_activities ) == 0 : msg = self . tr ( \"Please select at least one activity.\" ) tab_valid = False # Verify that the selected activities have at least one NCS pathway zero_pathway_activities = [] for activity_item in selected_activities : if len ( activity_item . activity . pathways ) == 0 : zero_pathway_activities . append ( activity_item . activity . name ) if len ( zero_pathway_activities ) > 0 : activity_tr = ( self . tr ( \"activity has\" ) if len ( zero_pathway_activities ) == 1 else self . tr ( \"activities have\" ) ) tr_msg = self . tr ( \"no NCS pathways defined.\" ) msg = f \" { ', ' . join ( zero_pathway_activities ) } { activity_tr } { tr_msg } \" tab_valid = False if not tab_valid : self . show_message ( msg ) self . tab_widget . setCurrentIndex ( activity_tab_index ) else : self . message_bar . clearWidgets () if index == priority_group_tab_index : analysis_activities = self . selected_activities () is_online_processing = False for activity in analysis_activities : for pathway in activity . pathways : if pathway . path . startswith ( \"cplus://\" ): is_online_processing = True break priority_layers = settings_manager . get_priority_layers () for priority_layer in priority_layers : if priority_layer [ \"path\" ] . startswith ( \"cplus://\" ): for group in priority_layer [ \"groups\" ]: if int ( group [ \"value\" ]) > 0 : is_online_processing = True break if analysis_activities : if is_online_processing : self . processing_type . setChecked ( True ) self . processing_type . setEnabled ( False ) else : self . processing_type . setChecked ( False ) self . processing_type . setEnabled ( True )","title":"on_tab_step_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_use_custom_metrics","text":"on_use_custom_metrics ( checked ) Slot raised when use custom metrics has been enabled or disabled. Parameters: Name Type Description Default checked bool True to use custom metrics else False. required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2924 2925 2926 2927 2928 2929 2930 2931 def on_use_custom_metrics ( self , checked : bool ): \"\"\"Slot raised when use custom metrics has been enabled or disabled. :param checked: True to use custom metrics else False. :type checked: bool \"\"\" settings_manager . set_value ( Settings . USE_CUSTOM_METRICS , checked ) self . btn_metric_builder . setEnabled ( checked )","title":"on_use_custom_metrics"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.on_view_status_button_clicked","text":"on_view_status_button_clicked () Handler when view status report button in tab 4 is clicked. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 226 227 228 229 230 231 232 233 def on_view_status_button_clicked ( self ): \"\"\"Handler when view status report button in tab 4 is clicked.\"\"\" log ( \"View status button\" ) running_online_scenario_uuid = settings_manager . get_running_online_scenario () online_task = settings_manager . get_scenario ( running_online_scenario_uuid ) if online_task : self . load_scenario ( running_online_scenario_uuid )","title":"on_view_status_button_clicked"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1060 1061 1062 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.open_settings","text":"open_settings () Options the CPLUS settings in the QGIS options dialog. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2920 2921 2922 def open_settings ( self ): \"\"\"Options the CPLUS settings in the QGIS options dialog.\"\"\" self . iface . showOptionsDialog ( currentPage = OPTIONS_TITLE )","title":"open_settings"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.outputs_options_changed","text":"outputs_options_changed () Handles selected outputs changes Source code in src/cplus_plugin/gui/qgis_cplus_main.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 def outputs_options_changed ( self ): \"\"\" Handles selected outputs changes \"\"\" settings_manager . set_value ( Settings . NCS_WEIGHTED , self . ncs_pwl_weighted . isChecked () ) settings_manager . set_value ( Settings . LANDUSE_PROJECT , self . landuse_project . isChecked () ) settings_manager . set_value ( Settings . HIGHEST_POSITION , self . highest_position . isChecked () )","title":"outputs_options_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.post_analysis","text":"post_analysis ( scenario_result , task , report_manager , progress_dialog ) Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the activities to the canvas with styling. Adds each activities' pathways to the canvas. Parameters: Name Type Description Default scenario_result ScenarioResult ScenarioResult of output results required task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 def post_analysis ( self , scenario_result , task , report_manager , progress_dialog ): \"\"\"Handles analysis outputs from the final analysis results. Adds the resulting scenario raster to the canvas with styling. Adds each of the activities to the canvas with styling. Adds each activities' pathways to the canvas. :param scenario_result: ScenarioResult of output results :type scenario_result: ScenarioResult :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" # If the processing were stopped, no file will be added if not self . processing_cancelled and scenario_result is not None : list_activities = scenario_result . scenario . activities if task is not None : activities = task . analysis_activities elif scenario_result . scenario is not None : activities = scenario_result . scenario . activities else : activities = [] raster = scenario_result . analysis_output [ \"OUTPUT\" ] activities_dir = os . path . join ( os . path . dirname ( raster ), \"activities\" ) # Layer options load_weighted_ncs = settings_manager . get_value ( Settings . NCS_WEIGHTED , default = True , setting_type = bool ) load_landuse = settings_manager . get_value ( Settings . LANDUSE_PROJECT , default = True , setting_type = bool ) load_highest_position = settings_manager . get_value ( Settings . HIGHEST_POSITION , default = False , setting_type = bool ) scenario_name = scenario_result . scenario . name qgis_instance = QgsProject . instance () instance_root = qgis_instance . layerTreeRoot () # Check if there are other groups for the scenario # and assign a suffix. counter = 1 group_name = scenario_name # Control to prevent infinite loop max_limit = 100 while True and counter <= max_limit : scenario_grp = instance_root . findGroup ( group_name ) if scenario_grp is None : break group_name = f \" { scenario_name } { counter !s} \" counter += 1 # Groups activity_group = None pathways_group = None scenario_group = instance_root . insertGroup ( 0 , group_name ) if load_landuse : activity_group = scenario_group . addGroup ( tr ( ACTIVITY_GROUP_LAYER_NAME )) if load_weighted_ncs : pathways_group = scenario_group . addGroup ( tr ( NCS_PATHWAYS_WEIGHTED_GROUP_LAYER_NAME ) ) pathways_group . setExpanded ( False ) pathways_group . setItemVisibilityCheckedRecursive ( False ) # Group settings activity_group . setExpanded ( False ) if activity_group else None # Add scenario result layer to the canvas with styling layer_file = scenario_result . analysis_output . get ( \"OUTPUT\" ) layer_dt = ( scenario_result . created_date if scenario_result . created_date else datetime . datetime . now () ) layer_name = ( f \" { SCENARIO_OUTPUT_LAYER_NAME } _\" f ' { layer_dt . strftime ( \"%Y_%m_ %d _%H_%M_%S\" ) } ' ) if ( scenario_result . output_layer_name is not None and scenario_result . output_layer_name != \"\" ): layer_name = scenario_result . output_layer_name if ( scenario_result . output_layer_name is None or scenario_result . output_layer_name is \"\" ): scenario_result . output_layer_name = layer_name layer = QgsRasterLayer ( layer_file , layer_name , QGIS_GDAL_PROVIDER ) scenario_layer = qgis_instance . addMapLayer ( layer ) # Scenario result layer styling renderer = self . style_activities_layer ( layer , activities ) layer . setRenderer ( renderer ) layer . triggerRepaint () \"\"\"A workaround to add a layer to a group. Adding it using group.insertChildNode or group.addLayer causes issues, but adding to the root is fine. This approach adds it to the root, and then moves it to the group. \"\"\" self . move_layer_to_group ( scenario_layer , scenario_group ) # Add activities and pathways activity_index = 0 if load_landuse : for activity in list_activities : activity_name = activity . name activity_layer = QgsRasterLayer ( activity . path , activity . name ) activity_layer . setCustomProperty ( ACTIVITY_IDENTIFIER_PROPERTY , str ( activity . uuid ) ) list_pathways = activity . pathways # Add activity layer with styling, if available if activity_layer : renderer = self . style_activity_layer ( activity_layer , activity ) added_activity_layer = qgis_instance . addMapLayer ( activity_layer ) self . move_layer_to_group ( added_activity_layer , activity_group ) activity_layer . setRenderer ( renderer ) activity_layer . triggerRepaint () # Add activity pathways if load_weighted_ncs : if len ( list_pathways ) > 0 : activity_pathway_group = pathways_group . insertGroup ( activity_index , activity_name ) activity_pathway_group . setExpanded ( False ) pw_index = 0 for pathway in list_pathways : try : # pathway_name = pathway.name pathway_layer = pathway . to_map_layer () added_pw_layer = qgis_instance . addMapLayer ( pathway_layer ) self . move_layer_to_group ( added_pw_layer , activity_pathway_group ) pathway_layer . triggerRepaint () pw_index = pw_index + 1 except Exception as err : self . show_message ( tr ( \"An error occurred loading a pathway, \" \"check logs for more information\" ), level = Qgis . MessageLevel . Info , ) log ( tr ( \"An error occurred loading a pathway, \" 'scenario analysis, error message \" {} \"' . format ( err ) ) ) activity_index = activity_index + 1 # Initiate report generation if load_landuse and load_highest_position : ( self . run_report ( progress_dialog , report_manager ) if ( progress_dialog is not None and report_manager is not None ) else None ) else : ( progress_dialog . processing_finished () if progress_dialog is not None else None ) else : # Re-initializes variables if processing were cancelled by the user # Not doing this breaks the processing if a user tries to run # the processing after cancelling or if the processing fails self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext ()","title":"post_analysis"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_aoi_box","text":"prepare_aoi_box () Initialize the Area of interest box Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 def prepare_aoi_box ( self ): \"\"\"Initialize the Area of interest box\"\"\" # Area of Interest self . _aoi_source_group = QtWidgets . QButtonGroup ( self ) self . _aoi_source_group . setExclusive ( True ) self . _aoi_source_group . addButton ( self . rb_studyarea , AreaOfInterestSource . LAYER . value ) self . _aoi_source_group . addButton ( self . rb_extent , AreaOfInterestSource . EXTENT . value ) self . _aoi_source_group . idToggled . connect ( self . on_aoi_source_changed ) self . studyarea_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . cbo_studyarea . layerChanged . connect ( self . _on_studyarea_layer_changed ) self . cbo_studyarea . setAllowEmptyLayer ( True , tr ( \"<Select layer>\" )) self . cbo_studyarea . setFilters ( QgsMapLayerProxyModel . Filter . PolygonLayer ) self . studyarea_layer_file_widget . setToolTip ( tr ( \"Select the study area layer from the local filesystem\" ) ) self . studyarea_layer_file_widget . fileChanged . connect ( self . _on_studyarea_file_changed )","title":"prepare_aoi_box"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_extent_box","text":"prepare_extent_box () Configure the spatial extent box with the initial settings. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 def prepare_extent_box ( self ): \"\"\"Configure the spatial extent box with the initial settings.\"\"\" crs = self . crs_selector . crs () if crs is None or not crs . isValid (): crs = QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) self . crs_selector . setCrs ( crs ) self . extent_box . setOutputCrs ( crs ) map_canvas = iface . mapCanvas () self . extent_box . setCurrentExtent ( map_canvas . mapSettings () . destinationCrs () . bounds (), map_canvas . mapSettings () . destinationCrs (), ) self . extent_box . setOutputExtentFromCurrent () self . extent_box . setMapCanvas ( map_canvas ) extent_list = PILOT_AREA_EXTENT [ \"coordinates\" ] default_extent = QgsRectangle ( extent_list [ 0 ], extent_list [ 2 ], extent_list [ 1 ], extent_list [ 3 ] ) self . extent_box . setOutputExtentFromUser ( default_extent , crs , )","title":"prepare_extent_box"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_input","text":"prepare_input () Initializes plugin input widgets Source code in src/cplus_plugin/gui/qgis_cplus_main.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 def prepare_input ( self ): \"\"\"Initializes plugin input widgets\"\"\" self . prepare_aoi_box () self . prepare_extent_box () self . grid_layout = QtWidgets . QGridLayout () self . message_bar = QgsMessageBar () self . prepare_message_bar () self . progress_dialog = None self . scenario_directory = None self . help_btn . clicked . connect ( self . open_help ) self . pilot_area_btn . clicked . connect ( self . zoom_pilot_area ) self . run_scenario_btn . clicked . connect ( self . run_analysis ) self . options_btn . clicked . connect ( self . open_settings ) self . restore_scenario () self . scenario_name . textChanged . connect ( self . save_scenario ) self . scenario_description . textChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( self . save_scenario ) self . extent_box . extentChanged . connect ( lambda s : self . update_naturebase_carbon_impact () ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) add_layer_icon = QtGui . QIcon ( ADD_LAYER_ICON_PATH ) self . layer_add_btn . setIcon ( add_layer_icon ) remove_layer_icon = QtGui . QIcon ( REMOVE_LAYER_ICON_PATH ) self . layer_remove_btn . setIcon ( remove_layer_icon ) self . layer_add_btn . clicked . connect ( self . add_priority_layer_group ) self . layer_remove_btn . clicked . connect ( self . remove_priority_layer_group ) # Priority groups buttons self . add_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_group_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_group_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_group_btn . clicked . connect ( self . add_priority_group ) self . edit_group_btn . clicked . connect ( self . edit_priority_group ) self . remove_group_btn . clicked . connect ( self . remove_priority_group ) # Priority layers buttons self . new_constant_raster_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionNewMap.svg\" ) ) self . add_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . edit_pwl_btn . setIcon ( FileUtils . get_icon ( \"mActionToggleEditing.svg\" )) self . remove_pwl_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . relative_pwl_matrix_btn . setIcon ( FileUtils . get_icon ( \"mActionAddVectorTileLayer.svg\" ) ) self . new_constant_raster_pwl_btn . clicked . connect ( self . on_manage_constant_raster_pwls ) self . add_pwl_btn . clicked . connect ( self . add_priority_layer ) self . edit_pwl_btn . clicked . connect ( self . edit_priority_layer ) self . remove_pwl_btn . clicked . connect ( self . remove_priority_layer ) self . relative_pwl_matrix_btn . clicked . connect ( self . on_manage_pwls_relative_impact_matrix ) self . priority_layers_list . itemDoubleClicked . connect ( self . _on_double_click_priority_layer ) # Add priority groups list into the groups frame self . priority_groups_list = CustomTreeWidget () self . priority_groups_list . setHeaderHidden ( True ) self . priority_groups_list . setSelectionMode ( QtWidgets . QAbstractItemView . SelectionMode . ExtendedSelection ) self . priority_groups_list . setSortingEnabled ( True ) self . priority_groups_list . setDragEnabled ( True ) self . priority_groups_list . setDragDropOverwriteMode ( True ) self . priority_groups_list . viewport () . setAcceptDrops ( True ) self . priority_groups_list . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DropOnly ) self . priority_groups_list . child_dragged_dropped . connect ( self . priority_groups_update ) self . priority_groups_list . itemDoubleClicked . connect ( self . _on_double_click_priority_group ) layout = QtWidgets . QVBoxLayout () layout . setSpacing ( 0 ) layout . setContentsMargins ( 0 , 0 , 0 , 0 ) layout . addWidget ( self . priority_groups_list ) self . priority_groups_frame . setLayout ( layout ) # Scenario analysis variables self . analysis_scenario_name = None self . analysis_scenario_description = None self . analysis_extent = None self . analysis_activities = None self . analysis_weighted_ims = [] self . analysis_priority_layers_groups = [] # Saved scenarios actions self . add_scenario_btn . setIcon ( FileUtils . get_icon ( \"symbologyAdd.svg\" )) self . info_scenario_btn . setIcon ( FileUtils . get_icon ( \"mActionIdentify.svg\" )) self . load_scenario_btn . setIcon ( FileUtils . get_icon ( \"mActionReload.svg\" )) self . comparison_report_btn . setIcon ( FileUtils . get_icon ( \"mIconReport.svg\" )) self . remove_scenario_btn . setIcon ( FileUtils . get_icon ( \"symbologyRemove.svg\" )) self . add_scenario_btn . clicked . connect ( self . add_scenario ) self . load_scenario_btn . clicked . connect ( self . load_scenario ) self . info_scenario_btn . clicked . connect ( self . show_scenario_info ) self . comparison_report_btn . clicked . connect ( self . on_generate_comparison_report ) self . remove_scenario_btn . clicked . connect ( self . remove_scenario ) self . scenario_list . itemSelectionChanged . connect ( self . on_scenario_list_selection_changed ) # Coordinate System self . lblCrsdescription . setText ( tr ( \"Scenario CRS for analysis (Must be projected CRS)\" ) ) project_crs = QgsProject . instance () . crs () crs = settings_manager . get_value ( Settings . SCENARIO_CRS , default = None ) if crs is not None : project_crs = QgsCoordinateReferenceSystem ( crs ) if not project_crs . isGeographic (): self . crs_selector . setCrs ( project_crs ) self . crs_selector . crsChanged . connect ( self . on_crs_changed )","title":"prepare_input"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.prepare_message_bar","text":"prepare_message_bar () Initializes the widget message bar settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1919 1920 1921 1922 1923 1924 1925 1926 1927 def prepare_message_bar ( self ): \"\"\"Initializes the widget message bar settings\"\"\" self . message_bar . setSizePolicy ( QtWidgets . QSizePolicy . Policy . Minimum , QtWidgets . QSizePolicy . Policy . Fixed ) self . grid_layout . addWidget ( self . message_bar , 0 , 0 , 1 , 1 , alignment = QtCore . Qt . AlignmentFlag . AlignTop ) self . dock_widget_contents . layout () . insertLayout ( 0 , self . grid_layout )","title":"prepare_message_bar"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.priority_groups_update","text":"priority_groups_update ( target_item , selected_items ) Updates the priority groups list item with the passed selected layer items. Parameters: Name Type Description Default target_item QTreeWidgetItem The priority group tree widget item that is to be updated required selected_items list Priority layers items from the list widget required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 def priority_groups_update ( self , target_item , selected_items ): \"\"\"Updates the priority groups list item with the passed selected layer items. :param target_item: The priority group tree widget item that is to be updated :type target_item: QTreeWidgetItem :param selected_items: Priority layers items from the list widget :type selected_items: list \"\"\" self . priority_groups_list . setCurrentItem ( target_item ) for item in selected_items : self . add_priority_layer_group ( target_item , item )","title":"priority_groups_update"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.processing_options_changed","text":"processing_options_changed () Handles selected processing changes Source code in src/cplus_plugin/gui/qgis_cplus_main.py 286 287 288 289 290 291 def processing_options_changed ( self ): \"\"\"Handles selected processing changes\"\"\" settings_manager . set_value ( Settings . PROCESSING_TYPE , self . processing_type . isChecked () )","title":"processing_options_changed"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_group","text":"remove_priority_group () Removes the current active priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 def remove_priority_group ( self ): \"\"\"Removes the current active priority group.\"\"\" selected_groups = self . priority_groups_list . selectedItems () if not selected_groups : self . show_message ( tr ( \"Select the priority groups to be deleted from the groups list.\" ), Qgis . MessageLevel . Critical , ) return num_items = len ( selected_groups ) item_tr = self . tr ( \"groups\" ) if num_items > 1 else self . tr ( \"group\" ) msg = self . tr ( f \"Remove { num_items !s} selected priority { item_tr } ? \\n Click Yes to proceed or No to cancel.\" ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"Remove Priority Groups\" ), msg , QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : group_ids = [ group_item . data ( 0 , QtCore . Qt . ItemDataRole . UserRole ) for group_item in selected_groups ] for group_id in group_ids : if not group_id : log ( f \"Priority group identifier could not be determined.\" ) continue group = settings_manager . get_priority_group ( group_id ) if not group : log ( f \"Priority group for { group_id } not found in settings.\" ) continue settings_manager . delete_priority_group ( group_id ) self . update_priority_groups ()","title":"remove_priority_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer","text":"remove_priority_layer () Removes one or more of the selected priority layers. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 def remove_priority_layer ( self ): \"\"\"Removes one or more of the selected priority layers.\"\"\" if self . priority_layers_list . currentItem () is None : self . show_message ( tr ( \"Select first the priority weighting layer from the layers list.\" ), Qgis . MessageLevel . Critical , ) return selected_pwl_items = self . priority_layers_list . selectedItems () if not selected_pwl_items : self . show_message ( tr ( \"Select one or more priority weighting layers to be removed \" \"from the layers list.\" ), Qgis . MessageLevel . Critical , ) return pwls = [ item . data ( QtCore . Qt . ItemDataRole . DisplayRole ) for item in selected_pwl_items ] if len ( pwls ) == 1 : tr_layer = tr ( \"layer\" ) else : tr_layer = tr ( \"layers\" ) tr_msg = tr ( \"Remove the priority weighting\" ) msg = f \" { tr_msg } { tr_layer } : { ', ' . join ( pwls ) } ?\" reply = QtWidgets . QMessageBox . warning ( self , tr ( \"Remove PWLs\" ), msg , QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : for pwl in pwls : layer = settings_manager . find_layer_by_name ( pwl ) if not layer : continue settings_manager . delete_priority_layer ( layer . get ( \"uuid\" )) self . update_priority_layers ( update_groups = False ) # Remove PWL in priority groups for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children )","title":"remove_priority_layer"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_priority_layer_group","text":"remove_priority_layer_group () Remove the current select priority layer from the current priority group. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 def remove_priority_layer_group ( self ): \"\"\"Remove the current select priority layer from the current priority group.\"\"\" selected_group = self . priority_groups_list . currentItem () parent_item = selected_group . parent () if selected_group is not None else None if parent_item : priority_layer = settings_manager . find_layer_by_name ( selected_group . text ( 0 )) group_widget = self . priority_groups_list . itemWidget ( parent_item , 0 ) groups = priority_layer . get ( \"groups\" ) new_groups = [] for group in groups : if group . get ( \"name\" ) == group_widget . group . get ( \"name\" ): continue new_groups . append ( group ) priority_layer [ \"groups\" ] = new_groups settings_manager . save_priority_layer ( priority_layer ) parent_item . removeChild ( selected_group )","title":"remove_priority_layer_group"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.remove_scenario","text":"remove_scenario () Removes the current active scenario. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 def remove_scenario ( self ): \"\"\"Removes the current active scenario.\"\"\" if self . scenario_list . currentItem () is None : self . show_message ( tr ( \"Select first a scenario from the scenario list.\" ), Qgis . MessageLevel . Critical , ) return texts = [] for item in self . scenario_list . selectedItems (): current_text = item . data ( QtCore . Qt . ItemDataRole . UserRole + 1 ) texts . append ( current_text ) reply = QtWidgets . QMessageBox . warning ( self , tr ( \"QGIS CPLUS PLUGIN\" ), tr ( 'Remove the selected scenario(s) \" {} \"?' ) . format ( texts ), QtWidgets . QMessageBox . StandardButton . Yes , QtWidgets . QMessageBox . StandardButton . No , ) if reply == QtWidgets . QMessageBox . StandardButton . Yes : for item in self . scenario_list . selectedItems (): scenario_id = item . data ( QtCore . Qt . ItemDataRole . UserRole ) if scenario_id == \"\" : continue settings_manager . delete_scenario ( scenario_id ) scenario_server_uuid = item . data ( QtCore . Qt . ItemDataRole . UserRole + 2 ) if scenario_server_uuid == \"\" : continue if not self . has_trends_auth (): continue task = DeleteScenarioTask ( scenario_server_uuid ) QgsApplication . taskManager () . addTask ( task ) self . update_scenario_list ()","title":"remove_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.report_job_is_for_current_scenario","text":"report_job_is_for_current_scenario ( scenario_id ) Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. Parameters: Name Type Description Default scenario_id str Scenario identifier usually from a signal raised by the report manager. required Returns: Type Description bool True if the scenario identifier matches the current scenario object in the results, else False. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 def report_job_is_for_current_scenario ( self , scenario_id : str ) -> bool : \"\"\"Checks if the given scenario identifier is for the current scenario result. This is to ensure that signals raised by the report manager refer to the current scenario result object and not for old jobs. :param scenario_id: Scenario identifier usually from a signal raised by the report manager. :type scenario_id: str :returns: True if the scenario identifier matches the current scenario object in the results, else False. :rtype: bool \"\"\" if self . scenario_result is None : return False current_scenario = self . scenario_result . scenario if current_scenario is None : return False if str ( current_scenario . uuid ) == scenario_id : return True return False","title":"report_job_is_for_current_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.reset_reporting_feedback","text":"reset_reporting_feedback ( progress_dialog ) Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required Returns: Type Description QgsFeedback Feedback instance to be used in storing processing status details. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 def reset_reporting_feedback ( self , progress_dialog ): \"\"\"Creates a new reporting feedback object and reconnects the signals. We are doing this to address cases where the feedback is canceled and the same object has to be reused for subsequent report generation tasks. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :returns reporting_feedback: Feedback instance to be used in storing processing status details. :rtype reporting_feedback: QgsFeedback \"\"\" progress_changed = partial ( self . on_reporting_progress_changed , progress_dialog ) reporting_feedback = QgsFeedback ( self ) reporting_feedback . progressChanged . connect ( progress_changed ) return reporting_feedback","title":"reset_reporting_feedback"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.restore_scenario","text":"restore_scenario () Update the first tab input with the last scenario details Source code in src/cplus_plugin/gui/qgis_cplus_main.py 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def restore_scenario ( self ): \"\"\"Update the first tab input with the last scenario details\"\"\" scenario_name = settings_manager . get_value ( Settings . SCENARIO_NAME ) scenario_description = settings_manager . get_value ( Settings . SCENARIO_DESCRIPTION ) extent = settings_manager . get_value ( Settings . SCENARIO_EXTENT ) studyarea_path = settings_manager . get_value ( Settings . STUDYAREA_PATH ) clip_to_studyarea = settings_manager . get_value ( Settings . CLIP_TO_STUDYAREA , default = False , setting_type = bool ) crs = QgsCoordinateReferenceSystem ( settings_manager . get_value ( Settings . SCENARIO_CRS , f \"EPSG: { DEFAULT_CRS_ID } \" ) ) if crs . isValid (): self . crs_selector . setCrs ( crs ) self . scenario_name . setText ( scenario_name ) if scenario_name is not None else None ( self . scenario_description . setText ( scenario_description ) if scenario_description is not None else None ) if extent is not None : extent_rectangle = QgsRectangle ( float ( extent [ 0 ]), float ( extent [ 2 ]), float ( extent [ 1 ]), float ( extent [ 3 ]) ) extent_crs = QgsCoordinateReferenceSystem ( settings_manager . get_value ( Settings . SCENARIO_EXTENT_CRS , f \"EPSG: { DEFAULT_CRS_ID } \" ) ) extent_crs = ( extent_crs if extent_crs . isValid () else self . extent_box . outputCrs () ) self . extent_box . setOutputExtentFromUser ( extent_rectangle , extent_crs , ) if studyarea_path : self . _aoi_layer = QgsVectorLayer ( studyarea_path , Path ( studyarea_path ) . stem ) if self . _aoi_layer . isValid (): self . studyarea_layer_file_widget . blockSignals ( True ) self . studyarea_layer_file_widget . setFilePath ( studyarea_path ) self . studyarea_layer_file_widget . blockSignals ( False ) if clip_to_studyarea : self . on_aoi_source_changed ( 0 , True ) self . rb_studyarea . setChecked ( True ) else : self . rb_extent . setChecked ( True ) self . on_aoi_source_changed ( 1 , True )","title":"restore_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_analysis","text":"run_analysis () Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 def run_analysis ( self ): \"\"\"Runs the plugin analysis Creates new QgsTask, progress dialog and report manager for each new scenario analysis. \"\"\" self . log_text_box . clear () if not self . is_metric_configuration_valid (): log ( \"Scenario cannot run due to an invalid metric configuration \" \"for the selected profile. Refer to the preceding \" \"errors above.\" ) return passed_extent = self . extent_box . outputExtent () passed_extent_crs = self . extent_box . outputCrs () # Check if CRS is valid analysis_crs = self . crs_selector . crs () if ( analysis_crs is None or not analysis_crs . isValid () or analysis_crs . isGeographic () ): self . show_message ( tr ( \"Please select a valid Coordinate System from step one.\" ), level = Qgis . MessageLevel . Critical , ) return clip_to_studyarea = False studyarea_path = settings_manager . get_value ( Settings . STUDYAREA_PATH , default = \"\" , setting_type = str ) aoi_layer = QgsVectorLayer ( studyarea_path , \"studyarea_path\" ) if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and aoi_layer . isValid () ): passed_extent = aoi_layer . extent () passed_extent_crs = aoi_layer . crs () clip_to_studyarea = True if passed_extent_crs != analysis_crs : # Transform extent to analysis CRS passed_extent = self . transform_extent ( passed_extent , passed_extent_crs , analysis_crs ) self . analysis_scenario_name = self . scenario_name . text () self . analysis_scenario_description = self . scenario_description . text () self . position_feedback = QgsProcessingFeedback () self . processing_context = QgsProcessingContext () for group in settings_manager . get_priority_groups (): group_layer_dict = { \"name\" : group . get ( \"name\" ), \"value\" : group . get ( \"value\" ), \"layers\" : [], } for layer in settings_manager . get_priority_layers (): pwl_items = self . priority_layers_list . findItems ( layer . get ( \"name\" ), QtCore . Qt . MatchFlag . MatchExactly ) if len ( pwl_items ) > 0 : # Exclude adding the PWL since its for a disabled default # item outside the pilot AOI. if pwl_items [ 0 ] . flags () == QtCore . Qt . NoItemFlags : continue group_names = [ group . get ( \"name\" ) for group in layer . get ( \"groups\" , [])] if group . get ( \"name\" ) in group_names : group_layer_dict [ \"layers\" ] . append ( layer . get ( \"name\" )) self . analysis_priority_layers_groups . append ( group_layer_dict ) self . analysis_activities = self . selected_activities () self . analysis_weighted_ims = [] base_dir = settings_manager . get_value ( Settings . BASE_DIR ) if self . analysis_scenario_name == \"\" or self . analysis_scenario_name is None : self . show_message ( tr ( f \"Scenario name cannot be blank.\" ), level = Qgis . MessageLevel . Critical , ) return if ( self . analysis_scenario_description == \"\" or self . analysis_scenario_description is None ): self . show_message ( tr ( f \"Scenario description cannot be blank.\" ), level = Qgis . MessageLevel . Critical , ) return if self . analysis_activities == [] or self . analysis_activities is None : self . show_message ( tr ( \"Select at least one activity from step two.\" ), level = Qgis . MessageLevel . Critical , ) return if base_dir is None : self . show_message ( tr ( f \"Plugin base data directory is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . MessageLevel . Critical , ) return if self . processing_type . isChecked (): if not self . has_trends_auth (): self . show_message ( tr ( f \"Trends.Earth account is not set! \" f \"Go to plugin settings in order to set it.\" ), level = Qgis . MessageLevel . Critical , ) return self . analysis_extent = SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ], crs = analysis_crs . authid (), ) try : self . enable_analysis_controls ( False ) scenario = Scenario ( uuid = uuid . uuid4 (), name = self . analysis_scenario_name , description = self . analysis_scenario_description , extent = self . analysis_extent , activities = self . analysis_activities , priority_layer_groups = self . analysis_priority_layers_groups , clip_to_studyarea = self . can_clip_to_studyarea (), studyarea_path = self . get_studyarea_path (), crs = self . analysis_extent . crs , ) self . processing_cancelled = False # Creates and opens the progress dialog for the analysis if self . processing_type . isChecked (): progress_dialog = OnlineProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) else : # Creates and opens the progress dialog for the analysis progress_dialog = ProgressDialog ( minimum = 0 , maximum = 100 , main_widget = self , scenario_id = str ( scenario . uuid ), scenario_name = self . analysis_scenario_name , ) progress_dialog . analysis_cancelled . connect ( self . on_progress_dialog_cancelled ) progress_dialog . run_dialog () progress_dialog . change_status_message ( tr ( \"Raster calculation for activities pathways\" ) ) pathway_found = False use_default_layer = False for activity in self . analysis_activities : if pathway_found : break for pathway in activity . pathways : if pathway is None : continue if pathway . layer_uuid : use_default_layer = True elif pathway . path : pathway_found = True break if not pathway_found and not use_default_layer : self . show_message ( tr ( \"NCS pathways were not found in the selected activities, \" \"Make sure to define pathways for the selected activities \" \"before running the scenario\" ) ) self . processing_cancelled = True self . enable_analysis_controls ( True ) return dt_alg = ApplyNcsDecisionTreeAlgorithm () pixel_size = 30.0 nodata_val = - 9999 dt_extent = QgsRectangle ( float ( self . analysis_extent . bbox [ 0 ]), float ( self . analysis_extent . bbox [ 2 ]), float ( self . analysis_extent . bbox [ 1 ]), float ( self . analysis_extent . bbox [ 3 ]), ) scenario_dir = settings_manager . get_value ( Settings . BASE_DIR ) os . makedirs ( scenario_dir , exist_ok = True ) for activity in self . analysis_activities : out_name = f \" { self . analysis_scenario_name } __ { activity . name } __decision_protect.tif\" out_path = os . path . join ( scenario_dir , out_name ) # Pass pathway UUIDs directly as JSON array pathway_uuids = [ str ( p . uuid ) for p in ( activity . pathways or [])] dt_params = { \"PATHWAY_UUIDS\" : json . dumps ( pathway_uuids ), dt_alg . P_TARGET_CRS : self . analysis_extent . crs , dt_alg . P_EXTENT : dt_extent , dt_alg . P_PIXEL : pixel_size , dt_alg . P_NODATA : nodata_val , dt_alg . P_SELECTED_ACTION : 0 , # 0=Protect; see CHOICES_ACTION dt_alg . O_SELECTED : out_path , } try : dt_result = dt_alg . processAlgorithm ( dt_params , self . processing_context , self . position_feedback , ) mask_path = dt_result [ dt_alg . O_SELECTED ] # Ensure mask_paths exists if ( not hasattr ( activity , \"mask_paths\" ) or activity . mask_paths is None ): activity . mask_paths = [] activity . mask_paths . append ( mask_path ) except Exception as e : log ( tr ( f \"Decision Tree failed for { activity . name } : { e } \" ), info = False ) if self . processing_type . isChecked (): analysis_task = ScenarioAnalysisTaskApiClient ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , SpatialExtent ( bbox = [ passed_extent . xMinimum (), passed_extent . xMaximum (), passed_extent . yMinimum (), passed_extent . yMaximum (), ], crs = passed_extent_crs . authid () if passed_extent_crs else None , ), clip_to_studyarea , self . get_studyarea_path (), ) else : analysis_task = ScenarioAnalysisTask ( self . analysis_scenario_name , self . analysis_scenario_description , self . analysis_activities , self . analysis_priority_layers_groups , self . analysis_extent , scenario , clip_to_studyarea , self . get_studyarea_path (), ) self . run_cplus_main_task ( progress_dialog , scenario , analysis_task ) except Exception as err : self . show_message ( tr ( \"An error occurred when preparing analysis task\" ), level = Qgis . MessageLevel . Info , ) log ( tr ( \"An error occurred when preparing analysis task\" ', error message \" {} \"' . format ( err ) ) )","title":"run_analysis"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.run_report","text":"run_report ( progress_dialog , report_manager ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 def run_report ( self , progress_dialog , report_manager ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" if self . processing_cancelled : # Will not proceed if processing has been cancelled by the user return if self . scenario_result is None : log ( \"Cannot run report generation, scenario result is not defined\" , info = False , ) return reporting_feedback = self . reset_reporting_feedback ( progress_dialog ) self . reporting_feedback = reporting_feedback submit_result = report_manager . generate ( self . scenario_result , reporting_feedback , self . chb_metric_builder . isChecked (), ) if not submit_result . status : msg = self . tr ( \"Unable to submit report request for scenario\" ) self . show_message ( f \" { msg } { self . scenario_result . scenario . name } .\" )","title":"run_report"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.save_scenario","text":"save_scenario () Save current scenario details into settings Source code in src/cplus_plugin/gui/qgis_cplus_main.py 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 def save_scenario ( self ): \"\"\"Save current scenario details into settings\"\"\" scenario_name = self . scenario_name . text () scenario_description = self . scenario_description . text () if self . can_clip_to_studyarea (): settings_manager . set_value ( Settings . STUDYAREA_PATH , self . get_studyarea_path () ) else : extent = self . extent_box . outputExtent () extent_box = [ extent . xMinimum (), extent . xMaximum (), extent . yMinimum (), extent . yMaximum (), ] settings_manager . set_value ( Settings . SCENARIO_EXTENT , extent_box ) settings_manager . set_value ( Settings . SCENARIO_EXTENT_CRS , self . extent_box . outputCrs () . authid () ) settings_manager . set_value ( Settings . SCENARIO_NAME , scenario_name ) settings_manager . set_value ( Settings . SCENARIO_DESCRIPTION , scenario_description ) settings_manager . set_value ( Settings . SCENARIO_CRS , self . crs_selector . crs () . authid () ) settings_manager . set_value ( Settings . CLIP_TO_STUDYAREA , self . can_clip_to_studyarea () )","title":"save_scenario"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.scenario_results","text":"scenario_results ( task , report_manager , progress_dialog ) Called when the task ends. Sets the progress bar to 100 if it finished. Parameters: Name Type Description Default task ScenarioAnalysisTask Analysis task required report_manager ReportManager Report manager used to generate analysis report_templates required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 def scenario_results ( self , task , report_manager , progress_dialog ): \"\"\"Called when the task ends. Sets the progress bar to 100 if it finished. :param task: Analysis task :type task: ScenarioAnalysisTask :param report_manager: Report manager used to generate analysis report_templates :type report_manager: ReportManager \"\"\" self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED if task . output is not None : self . update_progress_bar ( progress_dialog , 100 ) self . scenario_result . analysis_output = task . output self . scenario_result . state = ScenarioState . FINISHED self . post_analysis ( self . scenario_result , task , report_manager , progress_dialog ) else : status_message = \"No valid output from the processing results.\" task . set_status_message ( status_message ) log ( f \"No valid output from the processing results.\" )","title":"scenario_results"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.selected_activities","text":"selected_activities () Gets the collection of selected activities. Returns: Type Description typing.List[Activity] A list of selected activities. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 def selected_activities ( self ) -> typing . List [ Activity ]: \"\"\"Gets the collection of selected activities. :returns: A list of selected activities. :rtype: typing.List[Activity] \"\"\" return [ item . activity for item in self . activity_widget . selected_activity_items () if item . isEnabled () ]","title":"selected_activities"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.show_message","text":"show_message ( message , level = Qgis . MessageLevel . Warning , duration = 0 ) Shows message on the main widget message bar. Parameters: Name Type Description Default message str Text message required level MessageLevel Message level type Warning duration int Duration of the shown message 0 Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 def show_message ( self , message , level = Qgis . MessageLevel . Warning , duration : int = 0 ): \"\"\"Shows message on the main widget message bar. :param message: Text message :type message: str :param level: Message level type :type level: Qgis.MessageLevel :param duration: Duration of the shown message :type level: int \"\"\" self . message_bar . clearWidgets () self . message_bar . pushMessage ( message , level = level , duration = duration )","title":"show_message"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.show_scenario_info","text":"show_scenario_info () Loads dialog for showing scenario information. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 def show_scenario_info ( self ): \"\"\"Loads dialog for showing scenario information.\"\"\" scenario_uuid = self . scenario_list . currentItem () . data ( QtCore . Qt . ItemDataRole . UserRole ) scenario = settings_manager . get_scenario ( scenario_uuid ) scenario_result = settings_manager . get_scenario_result ( scenario_uuid ) scenario_dialog = ScenarioDialog ( scenario , scenario_result ) scenario_dialog . exec ()","title":"show_scenario_info"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.style_activities_layer","text":"style_activities_layer ( layer , activities ) Applies the styling to the passed layer that contains the passed list of activities. Parameters: Name Type Description Default layer QgsRasterLayer Layer to be styled required activities list List which contains the activities that were passed to the highest position analysis tool. required Returns: Type Description QgsPalettedRasterRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 def style_activities_layer ( self , layer , activities ): \"\"\"Applies the styling to the passed layer that contains the passed list of activities. :param layer: Layer to be styled :type layer: QgsRasterLayer :param activities: List which contains the activities that were passed to the highest position analysis tool. :type activities: list :returns: Renderer for the symbology. :rtype: QgsPalettedRasterRenderer \"\"\" area_classes = [] for activity in activities : activity_name = activity . name raster_val = activity . style_pixel_value color = activity . scenario_fill_symbol () . color () color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( raster_val ), QtGui . QColor ( color ), activity_name ) area_classes . append ( color_ramp_shader ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( area_classes ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) return renderer","title":"style_activities_layer"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.style_activity_layer","text":"style_activity_layer ( layer , activity ) Applies the styling to the layer that contains the passed activity name. Parameters: Name Type Description Default layer QgsRasterLayer Raster layer to which to apply the symbology required activity Activity activity required Returns: Type Description QgsSingleBandPseudoColorRenderer Renderer for the symbology. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 def style_activity_layer ( self , layer , activity ): \"\"\"Applies the styling to the layer that contains the passed activity name. :param layer: Raster layer to which to apply the symbology :type layer: QgsRasterLayer :param activity: activity :type activity: Activity :returns: Renderer for the symbology. :rtype: QgsSingleBandPseudoColorRenderer \"\"\" # Retrieves a build-in QGIS color ramp color_ramp = activity . color_ramp () stats = layer . dataProvider () . bandStatistics ( 1 ) min_value = stats . minimumValue max_value = stats . maximumValue if stats . minimumValue == stats . maximumValue : # Create one class for the min/max value color = color_ramp . color ( min_value ) color_ramp_shader = QgsColorRampShader . ColorRampItem ( float ( min_value ), color , str ( min_value ) ) class_data = QgsPalettedRasterRenderer . colorTableToClassData ( [ color_ramp_shader ] ) renderer = QgsPalettedRasterRenderer ( layer . dataProvider (), 1 , class_data ) else : renderer = QgsSingleBandPseudoColorRenderer ( layer . dataProvider (), 1 ) renderer . setClassificationMin ( min_value ) renderer . setClassificationMax ( max_value ) renderer . createShader ( color_ramp , QgsColorRampShader . Type . Interpolated , QgsColorRampShader . ClassificationMode . Continuous , ) return renderer","title":"style_activity_layer"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.task_terminated","text":"task_terminated ( task ) Handles logging of the scenario analysis task status after it has been terminated. Parameters: Name Type Description Default task Union [ ScenarioAnalysisTask , ScenarioAnalysisTaskApiClient ] Task that was terminated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 def task_terminated ( self , task : typing . Union [ ScenarioAnalysisTask , ScenarioAnalysisTaskApiClient ] ): \"\"\"Handles logging of the scenario analysis task status after it has been terminated. :param task: Task that was terminated :type task: typing.Union[ScenarioAnalysisTask, ScenarioAnalysisTaskApiClient] \"\"\" task . on_terminated () log ( \"Main task terminated\" )","title":"task_terminated"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.transform_extent","text":"transform_extent ( extent , source_crs , dest_crs ) Transforms the passed extent into the destination crs :param extent: Target extent Parameters: Name Type Description Default source_crs QgsCoordinateReferenceSystem Source CRS of the passed extent required dest_crs QgsCoordinateReferenceSystem Destination CRS required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 def transform_extent ( self , extent , source_crs , dest_crs ): \"\"\"Transforms the passed extent into the destination crs :param extent: Target extent :type extent: QgsRectangle :param source_crs: Source CRS of the passed extent :type source_crs: QgsCoordinateReferenceSystem :param dest_crs: Destination CRS :type dest_crs: QgsCoordinateReferenceSystem \"\"\" transform = QgsCoordinateTransform ( source_crs , dest_crs , QgsProject . instance ()) transformed_extent = transform . transformBoundingBox ( extent ) return transformed_extent","title":"transform_extent"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_message_bar","text":"update_message_bar ( message ) Changes the message in the message bar item. Parameters: Name Type Description Default message str Message to be updated required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 def update_message_bar ( self , message ): \"\"\"Changes the message in the message bar item. :param message: Message to be updated :type message: str \"\"\" log ( \"update_message_bar\" ) if isinstance ( message , str ): message_bar_item = self . message_bar . createMessage ( message ) else : message_bar_item = message self . message_bar . pushWidget ( message_bar_item , Qgis . MessageLevel . Info )","title":"update_message_bar"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_metric_button_profiles","text":"update_metric_button_profiles () Updates the profiles in the metric button menu based on the existing metric configuration profiles. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 def update_metric_button_profiles ( self ): \"\"\"Updates the profiles in the metric button menu based on the existing metric configuration profiles. \"\"\" metric_profile_collection = settings_manager . get_metric_profile_collection () if metric_profile_collection is None : log ( \"Metric profile collection does not contain any profiles.\" ) return # Update tooltip current_profile = metric_profile_collection . get_current_profile () if current_profile : self . btn_metric_builder . setToolTip ( f \" { tr ( 'Active profile' ) } : <b> { current_profile . name } </b>\" ) else : self . btn_metric_builder . setToolTip ( f \" { tr ( 'No active profile specified' ) } \" ) # Update menu if not metric_profile_collection . profiles : return profiles_menu = QtWidgets . QMenu () self . profiles_action_group = QtWidgets . QActionGroup ( self ) self . profiles_action_group . setExclusive ( True ) self . profiles_action_group . triggered . connect ( self . on_profile_action_group_triggered ) for profile in metric_profile_collection . profiles : action = profiles_menu . addAction ( profile . name ) action . setCheckable ( True ) if profile . id == metric_profile_collection . current_profile : action . setChecked ( True ) # Disable invalid profiles if not profile . is_valid (): action . setEnabled ( False ) self . profiles_action_group . addAction ( action ) self . btn_metric_builder . setMenu ( profiles_menu ) self . btn_metric_builder . setPopupMode ( QtWidgets . QToolButton . ToolButtonPopupMode . MenuButtonPopup )","title":"update_metric_button_profiles"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_naturebase_carbon_impact","text":"update_naturebase_carbon_impact () Fetch the naturebase zonal stats based on the current extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 623 624 625 626 627 628 629 630 631 632 633 def update_naturebase_carbon_impact ( self ): \"\"\"Fetch the naturebase zonal stats based on the current extent.\"\"\" auto_refresh = settings_manager . get_value ( Settings . AUTO_REFRESH_NATURE_BASE_ZONAL_STATS , default = False , setting_type = bool , ) if not auto_refresh : return _ = calculate_zonal_stats_task ()","title":"update_naturebase_carbon_impact"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_priority_layers","text":"update_priority_layers ( update_groups = True ) Updates the priority weighting layers list in the UI. Parameters: Name Type Description Default update_groups bool Whether to update the priority groups list or not True Source code in src/cplus_plugin/gui/qgis_cplus_main.py 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 def update_priority_layers ( self , update_groups = True ): \"\"\"Updates the priority weighting layers list in the UI. :param update_groups: Whether to update the priority groups list or not :type update_groups: bool \"\"\" self . priority_layers_list . clear () for layer in settings_manager . get_priority_layers (): item = QtWidgets . QListWidgetItem () item . setData ( QtCore . Qt . ItemDataRole . DisplayRole , layer . get ( \"name\" )) item . setData ( QtCore . Qt . ItemDataRole . UserRole , layer . get ( \"uuid\" )) if os . path . exists ( layer . get ( \"path\" )) or layer . get ( \"path\" ) . startswith ( \"cplus://\" ): item . setIcon ( QtGui . QIcon ()) else : item . setIcon ( FileUtils . get_icon ( \"mIndicatorLayerError.svg\" )) item . setToolTip ( tr ( \"Contains invalid priority layer path, \" \"the provided layer path does not exist!\" ) ) self . priority_layers_list . addItem ( item ) if update_groups : for index in range ( self . priority_groups_list . topLevelItemCount ()): group = self . priority_groups_list . topLevelItem ( index ) if group . text ( 0 ) in layer . get ( \"groups\" ): self . add_priority_layer_group ( group , item ) else : group_children = group . takeChildren () children = [] for child in group_children : if child . text ( 0 ) == layer . get ( \"name\" ): continue children . append ( child ) group . addChildren ( children )","title":"update_priority_layers"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_progress_bar","text":"update_progress_bar ( progress_dialog , value ) Sets the value of the progress bar Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 def update_progress_bar ( self , progress_dialog , value ): \"\"\"Sets the value of the progress bar :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param value: Value to be set on the progress bar :type value: float \"\"\" if progress_dialog and not self . processing_cancelled : try : progress_dialog . update_progress_bar ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_progress_dialog","text":"update_progress_dialog ( progress_dialog , message = None ) Run report generation. This should be called after the analysis is complete. Parameters: Name Type Description Default progress_dialog ProgressDialog Dialog responsible for showing all the analysis operations progress. required message ReportManager Report manager used to generate analysis report_templates None Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 def update_progress_dialog ( self , progress_dialog , message = None , ): \"\"\"Run report generation. This should be called after the analysis is complete. :param progress_dialog: Dialog responsible for showing all the analysis operations progress. :type progress_dialog: ProgressDialog :param message: Report manager used to generate analysis report_templates :type message: ReportManager \"\"\" progress_dialog . change_status_message ( message ) if message is not None else None","title":"update_progress_dialog"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_pwl_layers","text":"update_pwl_layers ( notify = False ) Updates the priority layers path available in the store activities. Parameters: Name Type Description Default notify bool Whether to show message to user about the update False Source code in src/cplus_plugin/gui/qgis_cplus_main.py 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 def update_pwl_layers ( self , notify = False ): \"\"\"Updates the priority layers path available in the store activities. :param notify: Whether to show message to user about the update :type notify: bool \"\"\" settings_manager . update_activities () self . update_priority_layers () if notify : self . show_message ( tr ( \"Updated all the activities\" \" with their respective priority layers\" ), Qgis . MessageLevel . Info , ) log ( tr ( \"Updated all the activities\" \" with their respective priority layers\" ))","title":"update_pwl_layers"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.update_scenario_list","text":"update_scenario_list () Fetches scenarios from plugin settings and updates the scenario history list Source code in src/cplus_plugin/gui/qgis_cplus_main.py 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 def update_scenario_list ( self ): \"\"\"Fetches scenarios from plugin settings and updates the scenario history list \"\"\" scenarios = settings_manager . get_scenarios () if len ( scenarios ) >= 0 : self . scenario_list . clear () for scenario in scenarios : scenario_type = \"Available offline\" if scenario . server_uuid : scenario_result = settings_manager . get_scenario_result ( scenario . uuid ) if scenario_result is None : scenario_type = \"Online\" item_widget = ScenarioItemWidget ( scenario . name , scenario_type ) item = QtWidgets . QListWidgetItem ( self . scenario_list ) item . setSizeHint ( item_widget . sizeHint ()) item . setData ( QtCore . Qt . ItemDataRole . UserRole , str ( scenario . uuid )) item . setData ( QtCore . Qt . ItemDataRole . UserRole + 1 , scenario . name ) if scenario . server_uuid : item . setData ( QtCore . Qt . ItemDataRole . UserRole + 2 , str ( scenario . server_uuid ) ) else : item . setData ( QtCore . Qt . ItemDataRole . UserRole + 2 , \"\" ) self . scenario_list . setItemWidget ( item , item_widget )","title":"update_scenario_list"},{"location":"developer/api/gui/api_gui_main/#src.cplus_plugin.gui.qgis_cplus_main.QgisCplusMain.zoom_pilot_area","text":"zoom_pilot_area () Zoom the current main map canvas to the pilot area extent. Source code in src/cplus_plugin/gui/qgis_cplus_main.py 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 def zoom_pilot_area ( self ): \"\"\"Zoom the current main map canvas to the pilot area extent.\"\"\" map_canvas = iface . mapCanvas () zoom_extent = self . extent_box . outputExtent () original_crs = self . extent_box . outputCrs () if ( self . _aoi_source_group . checkedId () == AreaOfInterestSource . LAYER . value and self . _aoi_layer ): zoom_extent = self . _aoi_layer . extent () original_crs = self . _aoi_layer . crs () canvas_crs = map_canvas . mapSettings () . destinationCrs () if canvas_crs . authid () != original_crs . authid (): zoom_extent = self . transform_extent ( zoom_extent , original_crs , canvas_crs ) aoi = QgsRubberBand ( iface . mapCanvas (), QgsWkbTypes . GeometryType . PolygonGeometry ) aoi . setFillColor ( QtGui . QColor ( 0 , 0 , 0 , 0 )) aoi . setStrokeColor ( QtGui . QColor ( 88 , 128 , 8 )) aoi . setWidth ( 2 ) aoi . setLineStyle ( QtCore . Qt . DashLine ) geom = QgsGeometry . fromRect ( zoom_extent ) aoi . setToGeometry ( geom , canvas_crs ) map_canvas . setExtent ( zoom_extent ) map_canvas . refresh ()","title":"zoom_pilot_area"},{"location":"developer/api/gui/api_items_selection_dialog/","text":"Items selection dialog \u00b6 Item selection dialog file ItemsSelectionDialog \u00b6 ItemsSelectionDialog ( parent , parent_item = None , items = None , item_type = NcsPathway ) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , parent , parent_item = None , items = None , item_type = NcsPathway ): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . parent_item = parent_item self . item_type = item_type self . items = items or [] select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) item_uuid = item . data ( QtCore . Qt . ItemDataRole . UserRole ) if self . item_type is NcsPathway : pathway = settings_manager . get_ncs_pathway ( str ( item_uuid )) layer_model_uuids = [ item . uuid for item in self . items ] pathway_layer_uuids = [ layer . get ( \"uuid\" ) for layer in pathway . priority_layers if layer is not None ] if ( self . parent_item is not None and str ( self . parent_item . get ( \"uuid\" )) in pathway_layer_uuids ) or ( pathway . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . CheckState . Checked ) else : layer = settings_manager . get_priority_layer ( str ( item_uuid )) group_uuids = [] for group in layer . get ( \"groups\" ): group = settings_manager . find_group_by_name ( group . get ( \"name\" )) if group is not None : group_uuids . append ( str ( group . get ( \"uuid\" ))) if ( self . parent_item is not None and self . parent_item . get ( \"uuid\" ) in group_uuids ): item . setCheckState ( QtCore . Qt . CheckState . Checked ) accept \u00b6 accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 177 178 179 180 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_items ( self . selected_items (), self . unselected_items ()) super () . accept () clear_all_clicked \u00b6 clear_all_clicked () Slot for handling clear selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 188 189 190 191 192 def clear_all_clicked ( self ): \"\"\"Slot for handling clear selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . CheckState . Unchecked ) select_all_clicked \u00b6 select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 182 183 184 185 186 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . CheckState . Checked ) selected_items \u00b6 selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . CheckState . Checked : items_text . append ( item . text ()) final_items = [] for item in items : for item_name in items_text : if item . name == item_name : final_items . append ( item ) break return final_items set_items \u00b6 set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) for item in items : list_widget_item = QtWidgets . QListWidgetItem ( item . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemFlag . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item . uuid ) list_widget_item . setCheckState ( QtCore . Qt . CheckState . Unchecked ) self . list_widget . addItem ( list_widget_item ) toggle_selection_clicked \u00b6 toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 194 195 196 197 198 199 200 201 202 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . CheckState . Checked : item_item . setCheckState ( QtCore . Qt . CheckState . Unchecked ) elif state == QtCore . Qt . CheckState . Unchecked : item_item . setCheckState ( QtCore . Qt . CheckState . Checked ) unselected_items \u00b6 unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . CheckState . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#items-selection-dialog","text":"Item selection dialog file","title":"Items selection dialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog","text":"ItemsSelectionDialog ( parent , parent_item = None , items = None , item_type = NcsPathway ) Bases: QDialog , DialogUi Dialog for handling items selection Constructor Source code in src/cplus_plugin/gui/items_selection_dialog.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def __init__ ( self , parent , parent_item = None , items = None , item_type = NcsPathway ): \"\"\"Constructor\"\"\" super () . __init__ () self . setupUi ( self ) self . parent = parent self . parent_item = parent_item self . item_type = item_type self . items = items or [] select_all_btn = QtWidgets . QPushButton ( tr ( \"Select All\" )) select_all_btn . setToolTip ( tr ( \"Select the all listed items\" )) select_all_btn . clicked . connect ( self . select_all_clicked ) self . mButtonBox . addButton ( select_all_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) clear_all_btn = QtWidgets . QPushButton ( tr ( \"Clear Selection\" )) clear_all_btn . setToolTip ( tr ( \"Clear the current selection\" )) clear_all_btn . clicked . connect ( self . clear_all_clicked ) self . mButtonBox . addButton ( clear_all_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) toggle_selection_btn = QtWidgets . QPushButton ( tr ( \"Toggle Selection\" )) toggle_selection_btn . clicked . connect ( self . toggle_selection_clicked ) self . mButtonBox . addButton ( toggle_selection_btn , QtWidgets . QDialogButtonBox . ButtonRole . ActionRole ) self . mButtonBox . accepted . connect ( self . accept ) self . set_items () for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) item_uuid = item . data ( QtCore . Qt . ItemDataRole . UserRole ) if self . item_type is NcsPathway : pathway = settings_manager . get_ncs_pathway ( str ( item_uuid )) layer_model_uuids = [ item . uuid for item in self . items ] pathway_layer_uuids = [ layer . get ( \"uuid\" ) for layer in pathway . priority_layers if layer is not None ] if ( self . parent_item is not None and str ( self . parent_item . get ( \"uuid\" )) in pathway_layer_uuids ) or ( pathway . uuid in layer_model_uuids ): item . setCheckState ( QtCore . Qt . CheckState . Checked ) else : layer = settings_manager . get_priority_layer ( str ( item_uuid )) group_uuids = [] for group in layer . get ( \"groups\" ): group = settings_manager . find_group_by_name ( group . get ( \"name\" )) if group is not None : group_uuids . append ( str ( group . get ( \"uuid\" ))) if ( self . parent_item is not None and self . parent_item . get ( \"uuid\" ) in group_uuids ): item . setCheckState ( QtCore . Qt . CheckState . Checked )","title":"ItemsSelectionDialog"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.accept","text":"accept () Saves the item selection Source code in src/cplus_plugin/gui/items_selection_dialog.py 177 178 179 180 def accept ( self ): \"\"\"Saves the item selection\"\"\" self . parent . set_selected_items ( self . selected_items (), self . unselected_items ()) super () . accept ()","title":"accept"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.clear_all_clicked","text":"clear_all_clicked () Slot for handling clear selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 188 189 190 191 192 def clear_all_clicked ( self ): \"\"\"Slot for handling clear selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . CheckState . Unchecked )","title":"clear_all_clicked"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.select_all_clicked","text":"select_all_clicked () Slot for handling selection for all items. Source code in src/cplus_plugin/gui/items_selection_dialog.py 182 183 184 185 186 def select_all_clicked ( self ): \"\"\"Slot for handling selection for all items.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) item_item . setCheckState ( QtCore . Qt . CheckState . Checked )","title":"select_all_clicked"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.selected_items","text":"selected_items () Returns the selected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def selected_items ( self ): \"\"\"Returns the selected items from the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . CheckState . Checked : items_text . append ( item . text ()) final_items = [] for item in items : for item_name in items_text : if item . name == item_name : final_items . append ( item ) break return final_items","title":"selected_items"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.set_items","text":"set_items () Sets the item list in the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def set_items ( self ): \"\"\"Sets the item list in the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) for item in items : list_widget_item = QtWidgets . QListWidgetItem ( item . name ) list_widget_item . setFlags ( list_widget_item . flags () | QtCore . Qt . ItemFlag . ItemIsUserCheckable ) list_widget_item . setData ( QtCore . Qt . ItemDataRole . UserRole , item . uuid ) list_widget_item . setCheckState ( QtCore . Qt . CheckState . Unchecked ) self . list_widget . addItem ( list_widget_item )","title":"set_items"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.toggle_selection_clicked","text":"toggle_selection_clicked () Toggles all the current items selection. Source code in src/cplus_plugin/gui/items_selection_dialog.py 194 195 196 197 198 199 200 201 202 def toggle_selection_clicked ( self ): \"\"\"Toggles all the current items selection.\"\"\" for item_index in range ( self . list_widget . count ()): item_item = self . list_widget . item ( item_index ) state = item_item . checkState () if state == QtCore . Qt . CheckState . Checked : item_item . setCheckState ( QtCore . Qt . CheckState . Unchecked ) elif state == QtCore . Qt . CheckState . Unchecked : item_item . setCheckState ( QtCore . Qt . CheckState . Checked )","title":"toggle_selection_clicked"},{"location":"developer/api/gui/api_items_selection_dialog/#src.cplus_plugin.gui.items_selection_dialog.ItemsSelectionDialog.unselected_items","text":"unselected_items () Returns unselected items from the dialog Source code in src/cplus_plugin/gui/items_selection_dialog.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def unselected_items ( self ): \"\"\"Returns unselected items from the dialog\"\"\" if self . item_type is NcsPathway : items = settings_manager . get_all_ncs_pathways () else : all_layers = settings_manager . get_priority_layers () items = [] for layer in all_layers : model_layer = PriorityLayer ( uuid = uuid . UUID ( layer . get ( \"uuid\" )), name = layer . get ( \"name\" ), description = layer . get ( \"description\" ), groups = layer . get ( \"groups\" ), ) items . append ( model_layer ) items_text = [] for index in range ( self . list_widget . count ()): item = self . list_widget . item ( index ) if item . checkState () == QtCore . Qt . CheckState . Unchecked : items_text . append ( item . text ()) item_names = \",\" . join ( items_text ) items = [ item for item in items if item . name in item_names ] return items","title":"unselected_items"},{"location":"developer/api/gui/api_map_repeat_item_widget/","text":"Map repeat item widget \u00b6 Widget for the custom CPLUS layout map item. CplusMapLayoutItemGuiMetadata \u00b6 CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME ) createItem \u00b6 createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout ) createItemWidget \u00b6 createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item ) creationIcon \u00b6 creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" ) newItemAddedToLayout \u00b6 newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" ) visibleName \u00b6 visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME CplusMapRepeatItemWidget \u00b6 CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeat item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Activity\" ), ModelComponentType . ACTIVITY . value , )","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#map-repeat-item-widget","text":"Widget for the custom CPLUS layout map item.","title":"Map repeat item widget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata","text":"CplusMapLayoutItemGuiMetadata () Bases: QgsLayoutItemAbstractGuiMetadata GUI metadata for a CPLUS map layout item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 55 56 def __init__ ( self ): super () . __init__ ( CPLUS_MAP_REPEAT_ITEM_TYPE , CPLUS_ITEM_NAME )","title":"CplusMapLayoutItemGuiMetadata"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItem","text":"createItem ( layout ) Factory override that returns the map item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 62 63 64 def createItem ( self , layout ) -> QgsLayoutItem : \"\"\"Factory override that returns the map item.\"\"\" return CplusMapRepeatItem ( layout )","title":"createItem"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.createItemWidget","text":"createItemWidget ( item ) Factory override for the item widget. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 58 59 60 def createItemWidget ( self , item ) -> QtWidgets . QWidget : \"\"\"Factory override for the item widget.\"\"\" return CplusMapRepeatItemWidget ( None , item )","title":"createItemWidget"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.creationIcon","text":"creationIcon () Factory override for item icon. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 70 71 72 def creationIcon ( self ) -> QtGui . QIcon : \"\"\"Factory override for item icon.\"\"\" return FileUtils . get_icon ( \"mLayoutItemMap_cplus_add.svg\" )","title":"creationIcon"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.newItemAddedToLayout","text":"newItemAddedToLayout ( map_repeat_item ) Define action that is called when the CplusMapItem is added to a layout through the GUI. Parameters: Name Type Description Default map_repeat_item CplusMapRepeatItem Map repeat item to be added to the layout. required Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 def newItemAddedToLayout ( self , map_repeat_item : CplusMapRepeatItem ): \"\"\"Define action that is called when the CplusMapItem is added to a layout through the GUI. :param map_repeat_item: Map repeat item to be added to the layout. :type map_repeat_item: CplusMapRepeatItem \"\"\" items = map_repeat_item . layout () . items () counter = 1 for item in items : if isinstance ( item , CplusMapRepeatItem ): counter += 1 # Set frame properties map_repeat_item . setFrameEnabled ( True ) map_repeat_item . setFrameJoinStyle ( QtCore . Qt . MiterJoin ) map_repeat_item . setFrameStrokeColor ( QtGui . QColor ( 132 , 192 , 68 )) map_repeat_item . setFrameStrokeWidth ( QgsLayoutMeasurement ( 0.4 )) map_repeat_item . setId ( f \" { CPLUS_ITEM_NAME } { counter !s} \" )","title":"newItemAddedToLayout"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapLayoutItemGuiMetadata.visibleName","text":"visibleName () Override for user-visible name identifying the item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 66 67 68 def visibleName ( self ) -> str : \"\"\"Override for user-visible name identifying the item.\"\"\" return CPLUS_ITEM_NAME","title":"visibleName"},{"location":"developer/api/gui/api_map_repeat_item_widget/#src.cplus_plugin.gui.map_repeat_item_widget.CplusMapRepeatItemWidget","text":"CplusMapRepeatItemWidget ( parent , layout_object ) Bases: QgsLayoutItemBaseWidget , WidgetUi Widget for configuring the CPLUS layout map repeat item. Source code in src/cplus_plugin/gui/map_repeat_item_widget.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , parent , layout_object : CplusMapRepeatItem ): super () . __init__ ( parent , layout_object ) self . setupUi ( self ) self . _map_item = layout_object # Common item properties widget self . _prop_widget = QgsLayoutItemPropertiesWidget ( self , layout_object ) self . layout . addWidget ( self . _prop_widget , 2 , 0 , 1 , 2 ) self . cbo_map_type . addItem ( self . tr ( \"Activity\" ), ModelComponentType . ACTIVITY . value , )","title":"CplusMapRepeatItemWidget"},{"location":"developer/api/gui/api_metrics_builder_dialog/","text":"Metrics Builder Dialog \u00b6 Wizard for customizing custom activity metrics table. ActivityMetricsBuilder \u00b6 ActivityMetricsBuilder ( parent = None , activities = None ) Bases: QWizard , WidgetUi Wizard for customizing custom activity metrics table. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def __init__ ( self , parent = None , activities = None , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _activities = [] if activities is not None : self . _activities = [ clone_activity ( activity ) for activity in activities ] self . _profile_collection = None # Setup notification bars self . _column_message_bar = QgsMessageBar () self . vl_column_notification . addWidget ( self . _column_message_bar ) self . _activity_metric_message_bar = QgsMessageBar () self . vl_metric_notification . addWidget ( self . _activity_metric_message_bar ) self . _column_list_model = MetricColumnListModel () self . _activity_metric_table_model = ActivityMetricTableModel () self . _summary_model = ActivityColumnSummaryTreeModel () # Initialize wizard ci_icon = FileUtils . get_icon ( \"cplus_logo.svg\" ) ci_pixmap = ci_icon . pixmap ( 64 , 64 ) self . setPixmap ( QtWidgets . QWizard . WizardPixmap . LogoPixmap , ci_pixmap ) help_button = self . button ( QtWidgets . QWizard . WizardButton . HelpButton ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) help_button . setIcon ( help_icon ) self . currentIdChanged . connect ( self . on_page_id_changed ) self . helpRequested . connect ( self . on_help_requested ) self . accepted . connect ( self . on_accepted ) # Intro page banner = FileUtils . get_pixmap ( \"metrics_illustration.svg\" ) self . lbl_banner . setPixmap ( banner ) self . lbl_banner . setScaledContents ( True ) # Columns page add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_column . setIcon ( add_icon ) self . btn_add_column . clicked . connect ( self . on_add_column ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_column . setIcon ( remove_icon ) self . btn_delete_column . setEnabled ( False ) self . btn_delete_column . clicked . connect ( self . on_remove_column ) move_up_icon = FileUtils . get_icon ( \"mActionArrowUp.svg\" ) self . btn_column_up . setIcon ( move_up_icon ) self . btn_column_up . setEnabled ( False ) self . btn_column_up . clicked . connect ( self . on_move_up_column ) move_down_icon = FileUtils . get_icon ( \"mActionArrowDown.svg\" ) self . btn_column_down . setIcon ( move_down_icon ) self . btn_column_down . setEnabled ( False ) self . btn_column_down . clicked . connect ( self . on_move_down_column ) # Profile management self . cbo_profile . currentIndexChanged . connect ( self . on_profile_changed ) self . btn_add_profile . setIcon ( add_icon ) self . btn_add_profile . clicked . connect ( self . on_add_profile ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_rename_profile . setIcon ( edit_icon ) self . btn_rename_profile . clicked . connect ( self . on_rename_profile ) copy_icon = FileUtils . get_icon ( \"mActionEditCopy.svg\" ) self . btn_copy_profile . setIcon ( copy_icon ) self . btn_copy_profile . clicked . connect ( self . on_copy_profile ) self . btn_delete_profile . setIcon ( remove_icon ) self . btn_delete_profile . clicked . connect ( self . on_delete_profile ) self . splitter . setStretchFactor ( 0 , 20 ) self . splitter . setStretchFactor ( 1 , 80 ) self . cbo_column_expression . setAllowEmptyFieldName ( True ) self . cbo_column_expression . setAllowEvalErrors ( False ) self . cbo_column_expression . setExpressionDialogTitle ( tr ( \"Column Expression Builder\" ) ) self . _metrics_context_generator = MetricsExpressionContextGenerator () self . cbo_column_expression . registerExpressionContextGenerator ( self . _metrics_context_generator ) self . lst_columns . setModel ( self . _column_list_model ) self . lst_columns . selectionModel () . selectionChanged . connect ( self . on_column_selection_changed ) self . txt_column_name . textChanged . connect ( self . _on_column_header_changed ) self . cbo_column_alignment . currentIndexChanged . connect ( self . _on_column_alignment_changed ) self . cbo_column_expression . fieldChanged . connect ( self . _on_column_expression_changed ) self . column_properties_widget . setDockMode ( True ) self . column_properties_stack . setMainPanel ( self . column_properties_widget ) self . chk_format_number . toggled . connect ( self . on_format_number_checked ) self . btn_customize_number . clicked . connect ( self . on_customize_number ) self . chk_format_number . setChecked ( False ) # Activity metrics page self . tb_activity_metrics . setModel ( self . _activity_metric_table_model ) # Update activities if specified self . _update_activities () self . tb_activity_metrics . installEventFilter ( self ) # Final summary page self . tv_summary . setModel ( self . _summary_model ) activities property writable \u00b6 activities Gets the activities in the model. Returns: Type Description All the activities in the model. activity_table_model property \u00b6 activity_table_model Gets the activity table model used to show the metric for each activity and column. Returns: Type Description ActivityMetricTableModel The activity table model. column_list_model property \u00b6 column_list_model Gets the columns list model used in the wizard. Returns: Type Description MetricColumnListModel The columns list model used in the model. metric_configuration property \u00b6 metric_configuration Gets the user configuration for metric column and corresponding cell metric configuration. Returns: Type Description MetricConfiguration User metric configuration. profile_collection property writable \u00b6 profile_collection Gets the profile collection used in the wizard. Returns: Type Description MetricProfileCollection The profile collection used in the wizard. add_column_item \u00b6 add_column_item ( item ) Adds a metric column item. If there is a column with a similar name, the item will not be added. Parameters: Name Type Description Default item MetricColumnListItem Metrics column item to be added. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 def add_column_item ( self , item : MetricColumnListItem ): \"\"\"Adds a metric column item. If there is a column with a similar name, the item will not be added. :param item: Metrics column item to be added. :type item: MetricColumnListItem \"\"\" # Check if the maximum limit has been reached if not self . can_add_new_column (): log ( \"Maximum number of columns reached.\" , info = False ) return # Check if there are items with a similar name if self . _column_list_model . column_exists ( item . name ): return self . _column_list_model . add_column ( item ) # Select item self . select_column ( item . row ()) # Add column to activity metrics table self . _activity_metric_table_model . append_column ( item . model ) self . resize_activity_table_columns () if not item . model . auto_calculated : self . tb_activity_metrics . setItemDelegateForColumn ( item . row () + 1 , ColumnMetricItemDelegate ( self . tb_activity_metrics ) ) can_add_new_column \u00b6 can_add_new_column () Checks if the maximum limit has been reached. Returns: Type Description bool True if the limit has not been reached else False if MAX_COLUMNS has been reached. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 852 853 854 855 856 857 858 859 def can_add_new_column ( self ) -> bool : \"\"\"Checks if the maximum limit has been reached. :returns: True if the limit has not been reached else False if MAX_COLUMNS has been reached. :rtype: bool \"\"\" return len ( self . _column_list_model . column_items ) < self . MAX_COLUMNS check_duplicate_profile_name \u00b6 check_duplicate_profile_name ( clean_profile_name ) Check if a profile name already exists. Parameters: Name Type Description Default clean_profile_name str The cleaned profile name to check required Returns: Type Description bool True if duplicate exists, False otherwise Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 def check_duplicate_profile_name ( self , clean_profile_name : str ) -> bool : \"\"\"Check if a profile name already exists. :param clean_profile_name: The cleaned profile name to check :type clean_profile_name: str :returns: True if duplicate exists, False otherwise :rtype: bool \"\"\" tr_msg = tr ( \"There is an already existing profile with the name\" ) if clean_profile_name in self . profile_collection . identifiers . values (): QtWidgets . QMessageBox . warning ( self , tr ( \"Duplicate Profile Name\" ), f \" { tr_msg } ' { clean_profile_name } '\" , ) return True return False clean_profile_name staticmethod \u00b6 clean_profile_name ( profile_name ) Remove special characters from profile name. Parameters: Name Type Description Default profile_name str The raw profile name required Returns: Type Description str Cleaned profile name with special characters removed Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 @staticmethod def clean_profile_name ( profile_name : str ) -> str : \"\"\"Remove special characters from profile name. :param profile_name: The raw profile name :type profile_name: str :returns: Cleaned profile name with special characters removed :rtype: str \"\"\" return re . sub ( r \"\\W+\" , \" \" , profile_name ) clear_activities \u00b6 clear_activities () Removes all activities in the activity metrics table. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 749 750 751 752 753 def clear_activities ( self ): \"\"\"Removes all activities in the activity metrics table.\"\"\" self . _activity_metric_table_model . removeRows ( 0 , self . _activity_metric_table_model . rowCount () ) clear_column_properties \u00b6 clear_column_properties () Clear widget values for column properties. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1344 1345 1346 1347 1348 def clear_column_properties ( self ): \"\"\"Clear widget values for column properties.\"\"\" self . txt_column_name . clear () self . cbo_column_alignment . clear () self . cbo_column_expression . setExpression ( \"\" ) clear_columns \u00b6 clear_columns () Remove columns from the UI list model. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 402 403 404 405 406 407 def clear_columns ( self ): \"\"\"Remove columns from the UI list model.\"\"\" # Remove columns while self . _column_list_model . rowCount () > 0 : column_name = self . _column_list_model . column_items [ 0 ] . name self . remove_column ( column_name ) clear_views \u00b6 clear_views () Removes items in item views i.e. combobox, list and table items. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 396 397 398 399 400 def clear_views ( self ): \"\"\"Removes items in item views i.e. combobox, list and table items.\"\"\" self . cbo_profile . clear () self . clear_columns () eventFilter \u00b6 eventFilter ( observed_object , event ) Captures events sent to specific widgets in the wizard. Parameters: Name Type Description Default observed_object QObject Object receiving the event. required event QEvent The specific event being received by the observed object. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def eventFilter ( self , observed_object : QtCore . QObject , event : QtCore . QEvent ): \"\"\"Captures events sent to specific widgets in the wizard. :param observed_object: Object receiving the event. :type observed_object: QtCore.QObject :param event: The specific event being received by the observed object. :type event: QtCore.QEvent \"\"\" # Resize activity metric table columns based on the size of the table view. if observed_object == self . tb_activity_metrics : if event . type () == QtCore . QEvent . Type . Resize : self . resize_activity_table_columns () return super () . eventFilter ( observed_object , event ) initialize_collection \u00b6 initialize_collection () Creates an initial profile collection. Use this if None is specified. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def initialize_collection ( self ): \"\"\"Creates an initial profile collection. Use this if None is specified. \"\"\" # Default columns to be used in the 'Default' profile. defaults_columns = [] # Area area_metric_column = MetricColumn . create_default_column ( self . AREA_COLUMN , tr ( \"Area (Ha)\" ), f \"@ { VAR_ACTIVITY_AREA } \" ) area_metric_column . auto_calculated = True area_metric_column . format_as_number = True defaults_columns . append ( area_metric_column ) # Carbon protect self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Protect\" ), tr ( \"C.I. Protect\" ), FUNC_CARBON_IMPACT_PROTECT , ) # Carbon manage self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Manage\" ), tr ( \"C.I. Manage\" ), FUNC_CARBON_IMPACT_MANAGE , ) # Carbon restore self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Restore\" ), tr ( \"C.I. Restore\" ), FUNC_CARBON_IMPACT_RESTORE , ) # NPV self . _add_metric_column ( defaults_columns , tr ( \"Net Present Value\" ), tr ( \"NPV\" ), FUNC_ACTIVITY_NPV ) column_metrics = [] for activity in self . _activities : row_metrics = [] for metric_column in defaults_columns : activity_column_metric = ActivityColumnMetric ( activity , metric_column , MetricType . COLUMN , metric_column . expression , ) row_metrics . append ( activity_column_metric ) column_metrics . append ( row_metrics ) default_configuration = MetricConfiguration ( defaults_columns , column_metrics ) # Create a default profile default_metric_profile = MetricConfigurationProfile ( tr ( \"Default\" ), default_configuration ) self . _profile_collection = MetricProfileCollection () self . _profile_collection . add_profile ( default_metric_profile ) self . cbo_profile . blockSignals ( True ) self . cbo_profile . addItem ( default_metric_profile . name , default_metric_profile . id ) self . cbo_profile . blockSignals ( False ) self . set_current_profile ( default_metric_profile . id ) is_activity_metrics_page_valid \u00b6 is_activity_metrics_page_valid () Validates the activity metrics page. Returns: Type Description bool True if the activity metrics page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 def is_activity_metrics_page_valid ( self ) -> bool : \"\"\"Validates the activity metrics page. :returns: True if the activity metrics page is valid, else False. :rtype: bool \"\"\" self . _activity_metric_message_bar . clearWidgets () is_valid = self . _activity_metric_table_model . validate ( True ) if not is_valid : msg = tr ( \"The metrics for the highlighted items are undefined.\" ) self . push_activity_metric_message ( msg ) return is_valid is_columns_page_valid \u00b6 is_columns_page_valid () Validates the columns page. Returns: Type Description bool True if the columns page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 def is_columns_page_valid ( self ) -> bool : \"\"\"Validates the columns page. :returns: True if the columns page is valid, else False. :rtype: bool \"\"\" self . _column_message_bar . clearWidgets () if self . _column_list_model . rowCount () == 0 : self . push_column_message ( tr ( \"At least one column is required to use in the activity \" \"metrics table.\" ) ) return False else : # Check other profiles zero_column_profiles = [] for profile in self . _profile_collection . profiles : if not profile . config . metric_columns : zero_column_profiles . append ( profile . name ) if zero_column_profiles : msg_tr = tr ( \"At least one column is required in the following profiles\" ) self . push_column_message ( f \" { msg_tr } : { ', ' . join ( zero_column_profiles ) } \" ) return False # Check column headers start with current profile then other profiles is_valid = True for item in self . _column_list_model . column_items : if not item . is_valid : if is_valid : is_valid = False tr_msg = tr ( \"header label is empty\" ) msg = f \"' { item . name } ' { tr_msg } .\" self . push_column_message ( msg ) if not is_valid : return False # Try other profiles if current profile is valid null_header_profiles = [] for profile in self . _profile_collection . profiles : for metric_column in profile . config . metric_columns : if not metric_column . header or not metric_column . name : if profile . name not in null_header_profiles : null_header_profiles . append ( profile . name ) if null_header_profiles : msg_tr = tr ( \"The following profiles have one or more empty column headers\" ) self . push_column_message ( f \" { msg_tr } : { ', ' . join ( null_header_profiles ) } \" ) return False return True load_column_properties \u00b6 load_column_properties ( column_item ) Load the properties of the column item in the corresponding UI controls. Parameters: Name Type Description Default column_item MetricColumnListItem Column item whose properties are to be loaded. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 def load_column_properties ( self , column_item : MetricColumnListItem ): \"\"\"Load the properties of the column item in the corresponding UI controls. :param column_item: Column item whose properties are to be loaded. :type column_item: MetricColumnListItem \"\"\" # Set column properties self . txt_column_name . blockSignals ( True ) self . txt_column_name . setText ( column_item . header ) self . txt_column_name . blockSignals ( False ) # Load alignment options self . cbo_column_alignment . blockSignals ( True ) self . cbo_column_alignment . clear () left_icon = FileUtils . get_icon ( \"mIconAlignLeft.svg\" ) self . cbo_column_alignment . addItem ( left_icon , tr ( \"Left\" ), QtCore . Qt . AlignmentFlag . AlignLeft ) right_icon = FileUtils . get_icon ( \"mIconAlignRight.svg\" ) self . cbo_column_alignment . addItem ( right_icon , tr ( \"Right\" ), QtCore . Qt . AlignmentFlag . AlignRight ) center_icon = FileUtils . get_icon ( \"mIconAlignCenter.svg\" ) self . cbo_column_alignment . addItem ( center_icon , tr ( \"Center\" ), QtCore . Qt . AlignmentFlag . AlignHCenter ) justify_icon = FileUtils . get_icon ( \"mIconAlignJustify.svg\" ) self . cbo_column_alignment . addItem ( justify_icon , tr ( \"Justify\" ), QtCore . Qt . AlignmentFlag . AlignJustify ) alignment_index = self . cbo_column_alignment . findData ( column_item . alignment ) if alignment_index != - 1 : self . cbo_column_alignment . setCurrentIndex ( alignment_index ) self . cbo_column_alignment . blockSignals ( False ) self . cbo_column_expression . blockSignals ( True ) if column_item . auto_calculated : self . cbo_column_expression . setEnabled ( False ) else : self . cbo_column_expression . setEnabled ( True ) self . cbo_column_expression . setExpression ( column_item . expression ) self . cbo_column_expression . blockSignals ( False ) self . chk_format_number . blockSignals ( True ) self . chk_format_number . setChecked ( column_item . format_as_number ) self . chk_format_number . blockSignals ( False ) load_configuration \u00b6 load_configuration ( configuration ) Load a metric configuration. All the columns in the configuration will be loaded, with an attempt to restore the metric configuration of similar activities that existed in the configuration with those currently being configured. Parameters: Name Type Description Default configuration MetricConfiguration Configuration containing mapping of metric columns and cell metrics. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def load_configuration ( self , configuration : MetricConfiguration ): \"\"\"Load a metric configuration. All the columns in the configuration will be loaded, with an attempt to restore the metric configuration of similar activities that existed in the configuration with those currently being configured. :param configuration: Configuration containing mapping of metric columns and cell metrics. :type configuration: MetricConfiguration \"\"\" if configuration is None : return if not configuration . is_valid (): log ( \"Metric configuration is invalid and cannot be loaded.\" ) return # Add metric columns for mc in configuration . metric_columns : # Do not add a column with a similar name if self . _column_list_model . column_exists ( mc . name ): continue item = MetricColumnListItem ( mc ) self . add_column_item ( item ) # Configure activity cell metrics matching the same activity # and column name in the configuration for r in range ( self . _activity_metric_table_model . rowCount ()): for c in range ( 1 , self . _activity_metric_table_model . columnCount ()): item = self . _activity_metric_table_model . item ( r , c ) # Fetch the closest match in configuration (based on activity # ID and name or header label) model_match = configuration . find ( str ( item . model . activity . uuid ), item . model . metric_column . name ) if model_match is None : continue item . update_metric_type ( model_match . metric_type , model_match . expression ) load_summary_details \u00b6 load_summary_details () Load items summarizing the metric configuration. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1548 1549 1550 1551 1552 def load_summary_details ( self ): \"\"\"Load items summarizing the metric configuration.\"\"\" activity_column_metric_models = self . _activity_metric_table_model . models self . _summary_model . set_summary_models ( activity_column_metric_models ) self . tv_summary . expandAll () on_accepted \u00b6 on_accepted () Slot raised when the wizard has been accepted by the user. Used to save any changes for the current metric configuration profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1554 1555 1556 1557 1558 1559 1560 def on_accepted ( self ): \"\"\"Slot raised when the wizard has been accepted by the user. Used to save any changes for the current metric configuration profile. \"\"\" self . update_current_profile () on_add_column \u00b6 on_add_column () Slot raised to add a new column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 def on_add_column ( self ): \"\"\"Slot raised to add a new column.\"\"\" if not self . can_add_new_column (): QtWidgets . QMessageBox . warning ( self , tr ( \"Columns Limit\" ), tr ( \"Maximum number of columns reached.\" ), ) return label_text = ( f \" { tr ( 'Specify the name of the column.' ) } <br>\" f \"<i><sup>*</sup> { tr ( 'Any special characters will be removed.' ) } \" f \"</i>\" ) column_name , ok = QtWidgets . QInputDialog . getText ( self , tr ( \"Set Column Name\" ), label_text , ) if ok and column_name : # Remove special characters clean_column_name = re . sub ( \"\\W+\" , \" \" , column_name ) column_exists = self . _column_list_model . column_exists ( clean_column_name ) if column_exists : QtWidgets . QMessageBox . warning ( self , tr ( \"Duplicate Column Name\" ), tr ( \"There is an already existing column name.\" ), ) return column_item = MetricColumnListItem ( clean_column_name ) # Set default number formatter; can always be changed column_item . number_formatter = MetricColumn . default_formatter () self . add_column_item ( column_item ) on_add_profile \u00b6 on_add_profile () Slot to add a new profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 def on_add_profile ( self ): \"\"\"Slot to add a new profile.\"\"\" clean_profile_name = self . _get_validated_profile_name ( tr ( \"Add New Profile\" )) if clean_profile_name is None : return metric_profile = MetricConfigurationProfile ( clean_profile_name , MetricConfiguration . create () ) if not self . _profile_collection . add_profile ( metric_profile ): QtWidgets . QMessageBox . warning ( self , tr ( \"Add New Profile\" ), tr ( \"Profile could not be added. Check for a \" \"duplicate name or an invalid profile\" ), ) return # Save any changes to the profile the user was working self . update_current_profile () self . cbo_profile . addItem ( clean_profile_name , metric_profile . id ) self . set_current_profile ( metric_profile . id ) on_column_selection_changed \u00b6 on_column_selection_changed ( selected , deselected ) Slot raised when selection in the columns view has changed. Parameters: Name Type Description Default selected QItemSelection Current item selection. required deselected QItemSelection Previously selected items that have been deselected. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 def on_column_selection_changed ( self , selected : QtCore . QItemSelection , deselected : QtCore . QItemSelection ): \"\"\"Slot raised when selection in the columns view has changed. :param selected: Current item selection. :type selected: QtCore.QItemSelection :param deselected: Previously selected items that have been deselected. :type deselected: QtCore.QItemSelection \"\"\" self . btn_delete_column . setEnabled ( True ) self . btn_column_up . setEnabled ( True ) self . btn_column_down . setEnabled ( True ) # Close any open panels self . column_properties_stack . acceptAllPanels () selected_columns = self . selected_column_items () if len ( selected_columns ) != 1 : self . btn_delete_column . setEnabled ( False ) self . btn_column_up . setEnabled ( False ) self . btn_column_down . setEnabled ( False ) self . clear_column_properties () else : # List view is set to single selection hence this # condition will be for one item selected. self . load_column_properties ( selected_columns [ 0 ]) on_copy_profile \u00b6 on_copy_profile () Slot to copy the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 def on_copy_profile ( self ): \"\"\"Slot to copy the current profile.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Please select a profile to copy\" ), ) return # Check validity if not current_profile . is_valid (): QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"The current profile cannot be copied as it is invalid\" ), ) return clean_profile_name = self . _get_validated_profile_name ( tr ( \"Copy Profile\" ), f \" { current_profile . name } { tr ( 'Copy' ) } \" ) if clean_profile_name is None : return # Save any changes before cloning self . update_current_profile () cloned_profile = clone_metric_configuration_profile ( current_profile , self . _activities ) if cloned_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Unable to copy the current profile\" ), ) return # Update the name then add it to the collection cloned_profile . name = clean_profile_name if not self . _profile_collection . add_profile ( cloned_profile ): QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Copied profile could not be added. Check for a \" \"duplicate name or an invalid profile\" ), ) return self . cbo_profile . addItem ( clean_profile_name , cloned_profile . id ) self . set_current_profile ( cloned_profile . id ) on_customize_number \u00b6 on_customize_number () Slot raised to customize number formatting options. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 705 706 707 708 709 710 711 712 713 714 715 716 717 def on_customize_number ( self ): \"\"\"Slot raised to customize number formatting options.\"\"\" format_selector = QgsNumericFormatSelectorWidget ( self . column_properties_widget ) format_selector . setPanelTitle ( tr ( \"Number Formatter\" )) format_selector . changed . connect ( self . _on_number_format_changed ) # Get current column item current_columns_items = self . selected_column_items () if len ( current_columns_items ) > 0 : number_formatter = current_columns_items [ 0 ] . number_formatter format_selector . setFormat ( number_formatter ) self . column_properties_widget . openPanel ( format_selector ) on_delete_profile \u00b6 on_delete_profile () Slot to delete the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 def on_delete_profile ( self ): \"\"\"Slot to delete the current profile.\"\"\" # Check to ensure that at least one profile # exists in the collection if len ( self . _profile_collection . profiles ) == 1 : QtWidgets . QMessageBox . warning ( self , tr ( \"Delete Profile\" ), tr ( \"Cannot delete as at least one metric profile must exist.\" ), ) return current_index = self . cbo_profile . currentIndex () current_profile_id = self . cbo_profile . itemData ( current_index ) if not current_profile_id or not self . _profile_collection . remove_profile ( current_profile_id ): QtWidgets . QMessageBox . warning ( self , tr ( \"Delete Profile\" ), tr ( \"An error occurred in attempting to delete the current profile.\" ), ) return self . cbo_profile . removeItem ( current_index ) # Set last profile in the collection as the current profile last_profile_id = self . _profile_collection . profiles [ - 1 ] . id self . set_current_profile ( last_profile_id ) on_format_number_checked \u00b6 on_format_number_checked ( checked ) Slot raised when the format number checkbox has been checked or unchecked. Parameters: Name Type Description Default checked bool True if checked or False if unchecked. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 739 740 741 742 743 744 745 746 747 def on_format_number_checked ( self , checked : bool ): \"\"\"Slot raised when the format number checkbox has been checked or unchecked. :param checked: True if checked or False if unchecked. :type checked: bool \"\"\" self . btn_customize_number . setEnabled ( checked ) self . save_column_properties () on_help_requested \u00b6 on_help_requested () Slot raised when the help button has been clicked. Opens the online help documentation in the user's browser. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 698 699 700 701 702 703 def on_help_requested ( self ): \"\"\"Slot raised when the help button has been clicked. Opens the online help documentation in the user's browser. \"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) on_move_down_column \u00b6 on_move_down_column () Slot raised to move the selected column one level down. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def on_move_down_column ( self ): \"\"\"Slot raised to move the selected column one level down.\"\"\" selected_items = self . selected_column_items () if len ( selected_items ) == 0 : return item = selected_items [ 0 ] current_row = item . row () row = self . _column_list_model . move_column_down ( current_row ) if row == - 1 : return # Maintain selection self . select_column ( row ) # Move corresponding column in the activity metrics table. # We have normalized it to reflect the position in the # metrics table. reference_index = current_row + 1 self . _move_activity_metric_column ( reference_index , HorizontalMoveDirection . RIGHT ) on_move_up_column \u00b6 on_move_up_column () Slot raised to move the selected column one level up. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 def on_move_up_column ( self ): \"\"\"Slot raised to move the selected column one level up.\"\"\" selected_items = self . selected_column_items () if len ( selected_items ) == 0 : return item = selected_items [ 0 ] current_row = item . row () row = self . _column_list_model . move_column_up ( current_row ) if row == - 1 : return # Maintain selection self . select_column ( row ) # Move corresponding column in the activity metrics table. # We have normalized it to reflect the position in the # metrics table. reference_index = current_row + 1 self . _move_activity_metric_column ( reference_index , HorizontalMoveDirection . LEFT ) on_page_id_changed \u00b6 on_page_id_changed ( page_id ) Slot raised when the page ID changes. Parameters: Name Type Description Default page_id int ID of the new page. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 def on_page_id_changed ( self , page_id : int ): \"\"\"Slot raised when the page ID changes. :param page_id: ID of the new page. :type page_id: int \"\"\" # Update title window_title = ( f \" { tr ( 'Activity Metrics Wizard' ) } - \" f \" { tr ( 'Step' ) } { page_id + 1 } { tr ( 'of' ) } \" f \" { len ( self . pageIds ()) !s} \" ) self . setWindowTitle ( window_title ) # Activity metrics page if page_id == 2 : # If expression is not specified for at # least one column then enable the groupbox. group_box_checked = False self . gb_custom_activity_metric . setChecked ( group_box_checked ) for item in self . _column_list_model . column_items : if ( not item . expression and not self . gb_custom_activity_metric . isChecked () ): group_box_checked = True break self . gb_custom_activity_metric . setChecked ( group_box_checked ) # Final summary page elif page_id == 3 : self . load_summary_details () on_profile_changed \u00b6 on_profile_changed ( index ) Slot raised when the profile has changed. Parameters: Name Type Description Default index int Index of the current profile. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def on_profile_changed ( self , index : int ): \"\"\"Slot raised when the profile has changed. :param index: Index of the current profile. :type index: int \"\"\" if index == - 1 : return profile_id = self . cbo_profile . itemData ( index ) if not profile_id : return self . update_current_profile () self . set_current_profile ( profile_id ) on_remove_column \u00b6 on_remove_column () Slot raised to remove the selected column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 893 894 895 896 897 898 899 def on_remove_column ( self ): \"\"\"Slot raised to remove the selected column.\"\"\" selected_items = self . selected_column_items () for item in selected_items : self . remove_column ( item . name ) self . resize_activity_table_columns () on_rename_profile \u00b6 on_rename_profile () Slot to rename the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def on_rename_profile ( self ): \"\"\"Slot to rename the current profile.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Rename Profile\" ), tr ( \"Please select a profile to rename.\" ), ) return clean_profile_name = self . _get_validated_profile_name ( tr ( \"Rename Profile\" ), current_profile . name ) if clean_profile_name is None : return # Update UI current_index = self . cbo_profile . currentIndex () self . cbo_profile . setItemText ( current_index , clean_profile_name ) # Update profile name current_profile . name = clean_profile_name self . cbo_profile . setItemData ( current_index , current_profile . id ) # Update profile collection self . _profile_collection . current_profile = current_profile . id self . update_current_profile () push_activity_metric_message \u00b6 push_activity_metric_message ( message , level = Qgis . MessageLevel . Warning , clear_first = False ) Push a message to the notification bar in the activity metric wizard page. Parameters: Name Type Description Default message str Message to the show in the notification bar. required level MessageLevel Severity of the message. Warning is the default. Warning clear_first bool Clear any current messages in the notification bar, default is False. False Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def push_activity_metric_message ( self , message : str , level : Qgis . MessageLevel = Qgis . MessageLevel . Warning , clear_first : bool = False , ): \"\"\"Push a message to the notification bar in the activity metric wizard page. :param message: Message to the show in the notification bar. :type message: str :param level: Severity of the message. Warning is the default. :type level: Qgis.MessageLevel :param clear_first: Clear any current messages in the notification bar, default is False. :type clear_first: bool \"\"\" if clear_first : self . _activity_metric_message_bar . clearWidgets () self . _activity_metric_message_bar . pushMessage ( message , level , 5 ) push_column_message \u00b6 push_column_message ( message , level = Qgis . MessageLevel . Warning , clear_first = False ) Push a message to the notification bar in the columns wizard page. Parameters: Name Type Description Default message str Message to the show in the notification bar. required level MessageLevel Severity of the message. Warning is the default. Warning clear_first bool Clear any current messages in the notification bar, default is False. False Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def push_column_message ( self , message : str , level : Qgis . MessageLevel = Qgis . MessageLevel . Warning , clear_first : bool = False , ): \"\"\"Push a message to the notification bar in the columns wizard page. :param message: Message to the show in the notification bar. :type message: str :param level: Severity of the message. Warning is the default. :type level: Qgis.MessageLevel :param clear_first: Clear any current messages in the notification bar, default is False. :type clear_first: bool \"\"\" if clear_first : self . _column_message_bar . clearWidgets () self . _column_message_bar . pushMessage ( message , level , 5 ) remove_column \u00b6 remove_column ( name ) Remove a metric column with the given name. Parameters: Name Type Description Default name str Name of the metric column to be removed. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 def remove_column ( self , name : str ): \"\"\"Remove a metric column with the given name. :param name: Name of the metric column to be removed. :type name: str \"\"\" item = self . _column_list_model . item_from_name ( name ) if item is None : return index = item . row () self . _column_list_model . remove_column ( name ) # Remove corresponding column in activity metrics table self . _activity_metric_table_model . remove_column ( index ) resize_activity_table_columns \u00b6 resize_activity_table_columns () Resize column width of activity metrics table for the entire width to be occupied. Use a reasonable size if the table has only one column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 def resize_activity_table_columns ( self ): \"\"\"Resize column width of activity metrics table for the entire width to be occupied. Use a reasonable size if the table has only one column. \"\"\" if self . _activity_metric_table_model . columnCount () == 1 : self . tb_activity_metrics . setColumnWidth ( 0 , 120 ) return width = self . tb_activity_metrics . width () # Make all columns have the same width column_count = self . _activity_metric_table_model . columnCount () column_width = int ( width / float ( column_count )) for c in range ( column_count ): self . tb_activity_metrics . setColumnWidth ( c , column_width ) save_column_properties \u00b6 save_column_properties () Updates the properties of the metric column based on the values of the UI controls for the current selected column item. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 def save_column_properties ( self ): \"\"\"Updates the properties of the metric column based on the values of the UI controls for the current selected column item. \"\"\" selected_columns = self . selected_column_items () if len ( selected_columns ) == 0 : return current_column = selected_columns [ 0 ] current_column . header = self . txt_column_name . text () current_column . alignment = self . cbo_column_alignment . itemData ( self . cbo_column_alignment . currentIndex () ) current_column . expression = self . cbo_column_expression . expression () current_column . format_as_number = self . chk_format_number . isChecked () if not current_column . format_as_number : current_column . number_formatter = QgsFallbackNumericFormat () # Update column properties in activity metrics table self . _activity_metric_table_model . update_column_properties ( current_column . row (), current_column . model ) select_column \u00b6 select_column ( row ) Select the column item in the specified row. Parameters: Name Type Description Default row int Column item in the specified row number to be selected. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 def select_column ( self , row : int ): \"\"\"Select the column item in the specified row. :param row: Column item in the specified row number to be selected. :type row: int \"\"\" index = self . _column_list_model . index ( row , 0 ) if not index . isValid (): return selection_model = self . lst_columns . selectionModel () selection_model . select ( index , QtCore . QItemSelectionModel . SelectionFlag . ClearAndSelect ) selected_column_items \u00b6 selected_column_items () Returns the selected column items in the column list view. Returns: Type Description list A collection of the selected column items. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 def selected_column_items ( self ) -> typing . List [ MetricColumnListItem ]: \"\"\"Returns the selected column items in the column list view. :returns: A collection of the selected column items. :rtype: list \"\"\" selection_model = self . lst_columns . selectionModel () idxs = selection_model . selectedRows () return [ self . _column_list_model . item ( idx . row ()) for idx in idxs ] set_current_profile \u00b6 set_current_profile ( profile ) Updates the UI to set the current metric profile. Parameters: Name Type Description Default profile Union [ str , MetricConfigurationProfile ] Profile or profile ID to be set. It must exist in the profile collection. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 def set_current_profile ( self , profile : typing . Union [ str , MetricConfigurationProfile ] ): \"\"\"Updates the UI to set the current metric profile. :param profile: Profile or profile ID to be set. It must exist in the profile collection. :type profile: typing.Union[str, MetricConfigurationProfile] \"\"\" if self . _profile_collection is None : return # Convert profile to corresponding ID if isinstance ( profile , MetricConfigurationProfile ): profile = profile . id if not self . _profile_collection . profile_exists ( profile ): return metric_profile = self . _profile_collection . get_profile ( profile ) if metric_profile is None : return # Update combobox item_index = self . cbo_profile . findData ( profile ) if item_index == - 1 : return self . cbo_profile . blockSignals ( True ) self . cbo_profile . setCurrentIndex ( item_index ) self . cbo_profile . blockSignals ( False ) # Clear columns self . clear_columns () # Load configuration in the view self . load_configuration ( metric_profile . config ) # Set the current profile self . _profile_collection . current_profile = profile update_current_profile \u00b6 update_current_profile () Saves the current profile to the profile collection. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1028 1029 1030 1031 1032 1033 1034 1035 def update_current_profile ( self ): \"\"\"Saves the current profile to the profile collection.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : return # Update metric config as per setup in the UI current_profile . config = self . metric_configuration validateCurrentPage \u00b6 validateCurrentPage () Validates the current page. Returns: Type Description bool True if the current page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 def validateCurrentPage ( self ) -> bool : \"\"\"Validates the current page. :returns: True if the current page is valid, else False. :rtype: bool \"\"\" # Columns page if self . currentId () == 1 : # Save latest changes in current profile self . update_current_profile () return self . is_columns_page_valid () elif self . currentId () == 2 : return self . is_activity_metrics_page_valid () return True ColumnMetricItemDelegate \u00b6 Bases: QStyledItemDelegate Delegate that allows the user to choose the type of metric for a particular activity column. createEditor \u00b6 createEditor ( parent , option , idx ) Creates a combobox for choosing the metric type. Parameters: Name Type Description Default parent QWidget Parent widget. required option QStyleOptionViewItem Options for drawing the widget in the view. required idx QModelIndex Location of the request in the data model. required Returns: Type Description QtWidgets.QLineEdit The editor widget. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ) -> QtWidgets . QLineEdit : \"\"\"Creates a combobox for choosing the metric type. :param parent: Parent widget. :type parent: QtWidgets.QWidget :param option: Options for drawing the widget in the view. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the request in the data model. :type idx: QtCore.QModelIndex :returns: The editor widget. :rtype: QtWidgets.QLineEdit \"\"\" metric_combobox = QtWidgets . QComboBox ( parent ) metric_combobox . setFrame ( False ) metric_combobox . setProperty ( self . INDEX_PROPERTY_NAME , idx ) metric_combobox . addItem ( tr ( COLUMN_METRIC_STR ), MetricType . COLUMN ) metric_combobox . addItem ( tr ( CELL_METRIC_STR ), MetricType . CELL ) metric_combobox . activated . connect ( self . on_metric_type_changed ) return metric_combobox on_metric_type_changed \u00b6 on_metric_type_changed ( index ) Slot raised when the metric type has changed. We use this to load the expression builder if a cell metric is selected. Parameters: Name Type Description Default index int Index of the current selection. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def on_metric_type_changed ( self , index : int ): \"\"\"Slot raised when the metric type has changed. We use this to load the expression builder if a cell metric is selected. :param index: Index of the current selection. :type index: int \"\"\" if index == - 1 : return editor = self . sender () metric_type = editor . itemData ( index ) if metric_type != MetricType . CELL : return model_index = editor . property ( self . INDEX_PROPERTY_NAME ) if not model_index . isValid (): log ( tr ( \"Invalid index for activity column metric.\" )) return activity_column_metric_item = model_index . model () . itemFromIndex ( model_index ) if activity_column_metric_item is None : log ( tr ( \"Activity column metric could not be found.\" )) return expression_builder = QgsExpressionBuilderDialog ( None , activity_column_metric_item . expression , editor , \"CPLUS\" , create_metrics_expression_context (), ) expression_builder . setWindowTitle ( tr ( \"Activity Column Expression Builder\" )) if expression_builder . exec () == QtWidgets . QDialog . DialogCode . Accepted : # Save the expression for use when persisting in the model editor . setProperty ( self . EXPRESSION_PROPERTY_NAME , expression_builder . expressionText () ) self . commitData . emit ( editor ) self . closeEditor . emit ( editor , QtWidgets . QAbstractItemDelegate . NoHint ) setEditorData \u00b6 setEditorData ( widget , idx ) Sets the data to be displayed and edited by the editor. Parameters: Name Type Description Default widget QWidget Editor widget. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def setEditorData ( self , widget : QtWidgets . QWidget , idx : QtCore . QModelIndex ): \"\"\"Sets the data to be displayed and edited by the editor. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" select_index = - 1 item = idx . model () . itemFromIndex ( idx ) if item is None or not isinstance ( item , ActivityColumnMetricItem ): return current_metric_type = item . metric_type if current_metric_type == MetricType . COLUMN : select_index = widget . findData ( MetricType . COLUMN ) elif current_metric_type == MetricType . CELL : select_index = widget . findData ( MetricType . CELL ) if select_index != - 1 : # We are temporarily blocking the index changed slot # so that the expression dialog will not be shown if # the metric type is cell-based. widget . blockSignals ( True ) widget . setCurrentIndex ( select_index ) widget . blockSignals ( False ) setModelData \u00b6 setModelData ( widget , model , idx ) Gets data from the editor widget and stores it in the specified model at the item index. Parameters: Name Type Description Default widget QWidget Editor widget. required model QAbstractItemModel Model to store the editor data in. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def setModelData ( self , widget : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , idx : QtCore . QModelIndex , ): \"\"\"Gets data from the editor widget and stores it in the specified model at the item index. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param model: Model to store the editor data in. :type model: QtCore.QAbstractItemModel :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" metric_type = widget . itemData ( widget . currentIndex ()) item = idx . model () . itemFromIndex ( idx ) if item is None or not isinstance ( item , ActivityColumnMetricItem ): return expression = \"\" if metric_type == MetricType . COLUMN : # Inherit the column expression if defined metric_column = model . metric_column ( idx . column () - 1 ) if metric_column is not None : expression = metric_column . expression elif metric_type == MetricType . CELL : expression = widget . property ( self . EXPRESSION_PROPERTY_NAME ) item . update_metric_type ( metric_type , expression ) updateEditorGeometry \u00b6 updateEditorGeometry ( widget , option , idx ) Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. Parameters: Name Type Description Default widget QWidget Widget whose geometry will be updated. required option QStyleOptionViewItem Option containing the rectangle for updating the widget. required idx QModelIndex Location of the widget in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def updateEditorGeometry ( self , widget : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ): \"\"\"Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. :param widget: Widget whose geometry will be updated. :type widget: QtWidgets.QWidget :param option: Option containing the rectangle for updating the widget. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the widget in the data model. :type idx: QtCore.QModelIndex \"\"\" widget . setGeometry ( option . rect )","title":"Builder Dialog"},{"location":"developer/api/gui/api_metrics_builder_dialog/#metrics-builder-dialog","text":"Wizard for customizing custom activity metrics table.","title":"Metrics Builder Dialog"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder","text":"ActivityMetricsBuilder ( parent = None , activities = None ) Bases: QWizard , WidgetUi Wizard for customizing custom activity metrics table. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 def __init__ ( self , parent = None , activities = None , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _activities = [] if activities is not None : self . _activities = [ clone_activity ( activity ) for activity in activities ] self . _profile_collection = None # Setup notification bars self . _column_message_bar = QgsMessageBar () self . vl_column_notification . addWidget ( self . _column_message_bar ) self . _activity_metric_message_bar = QgsMessageBar () self . vl_metric_notification . addWidget ( self . _activity_metric_message_bar ) self . _column_list_model = MetricColumnListModel () self . _activity_metric_table_model = ActivityMetricTableModel () self . _summary_model = ActivityColumnSummaryTreeModel () # Initialize wizard ci_icon = FileUtils . get_icon ( \"cplus_logo.svg\" ) ci_pixmap = ci_icon . pixmap ( 64 , 64 ) self . setPixmap ( QtWidgets . QWizard . WizardPixmap . LogoPixmap , ci_pixmap ) help_button = self . button ( QtWidgets . QWizard . WizardButton . HelpButton ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) help_button . setIcon ( help_icon ) self . currentIdChanged . connect ( self . on_page_id_changed ) self . helpRequested . connect ( self . on_help_requested ) self . accepted . connect ( self . on_accepted ) # Intro page banner = FileUtils . get_pixmap ( \"metrics_illustration.svg\" ) self . lbl_banner . setPixmap ( banner ) self . lbl_banner . setScaledContents ( True ) # Columns page add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add_column . setIcon ( add_icon ) self . btn_add_column . clicked . connect ( self . on_add_column ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_delete_column . setIcon ( remove_icon ) self . btn_delete_column . setEnabled ( False ) self . btn_delete_column . clicked . connect ( self . on_remove_column ) move_up_icon = FileUtils . get_icon ( \"mActionArrowUp.svg\" ) self . btn_column_up . setIcon ( move_up_icon ) self . btn_column_up . setEnabled ( False ) self . btn_column_up . clicked . connect ( self . on_move_up_column ) move_down_icon = FileUtils . get_icon ( \"mActionArrowDown.svg\" ) self . btn_column_down . setIcon ( move_down_icon ) self . btn_column_down . setEnabled ( False ) self . btn_column_down . clicked . connect ( self . on_move_down_column ) # Profile management self . cbo_profile . currentIndexChanged . connect ( self . on_profile_changed ) self . btn_add_profile . setIcon ( add_icon ) self . btn_add_profile . clicked . connect ( self . on_add_profile ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_rename_profile . setIcon ( edit_icon ) self . btn_rename_profile . clicked . connect ( self . on_rename_profile ) copy_icon = FileUtils . get_icon ( \"mActionEditCopy.svg\" ) self . btn_copy_profile . setIcon ( copy_icon ) self . btn_copy_profile . clicked . connect ( self . on_copy_profile ) self . btn_delete_profile . setIcon ( remove_icon ) self . btn_delete_profile . clicked . connect ( self . on_delete_profile ) self . splitter . setStretchFactor ( 0 , 20 ) self . splitter . setStretchFactor ( 1 , 80 ) self . cbo_column_expression . setAllowEmptyFieldName ( True ) self . cbo_column_expression . setAllowEvalErrors ( False ) self . cbo_column_expression . setExpressionDialogTitle ( tr ( \"Column Expression Builder\" ) ) self . _metrics_context_generator = MetricsExpressionContextGenerator () self . cbo_column_expression . registerExpressionContextGenerator ( self . _metrics_context_generator ) self . lst_columns . setModel ( self . _column_list_model ) self . lst_columns . selectionModel () . selectionChanged . connect ( self . on_column_selection_changed ) self . txt_column_name . textChanged . connect ( self . _on_column_header_changed ) self . cbo_column_alignment . currentIndexChanged . connect ( self . _on_column_alignment_changed ) self . cbo_column_expression . fieldChanged . connect ( self . _on_column_expression_changed ) self . column_properties_widget . setDockMode ( True ) self . column_properties_stack . setMainPanel ( self . column_properties_widget ) self . chk_format_number . toggled . connect ( self . on_format_number_checked ) self . btn_customize_number . clicked . connect ( self . on_customize_number ) self . chk_format_number . setChecked ( False ) # Activity metrics page self . tb_activity_metrics . setModel ( self . _activity_metric_table_model ) # Update activities if specified self . _update_activities () self . tb_activity_metrics . installEventFilter ( self ) # Final summary page self . tv_summary . setModel ( self . _summary_model )","title":"ActivityMetricsBuilder"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.activities","text":"activities Gets the activities in the model. Returns: Type Description All the activities in the model.","title":"activities"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.activity_table_model","text":"activity_table_model Gets the activity table model used to show the metric for each activity and column. Returns: Type Description ActivityMetricTableModel The activity table model.","title":"activity_table_model"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.column_list_model","text":"column_list_model Gets the columns list model used in the wizard. Returns: Type Description MetricColumnListModel The columns list model used in the model.","title":"column_list_model"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.metric_configuration","text":"metric_configuration Gets the user configuration for metric column and corresponding cell metric configuration. Returns: Type Description MetricConfiguration User metric configuration.","title":"metric_configuration"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.profile_collection","text":"profile_collection Gets the profile collection used in the wizard. Returns: Type Description MetricProfileCollection The profile collection used in the wizard.","title":"profile_collection"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.add_column_item","text":"add_column_item ( item ) Adds a metric column item. If there is a column with a similar name, the item will not be added. Parameters: Name Type Description Default item MetricColumnListItem Metrics column item to be added. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 def add_column_item ( self , item : MetricColumnListItem ): \"\"\"Adds a metric column item. If there is a column with a similar name, the item will not be added. :param item: Metrics column item to be added. :type item: MetricColumnListItem \"\"\" # Check if the maximum limit has been reached if not self . can_add_new_column (): log ( \"Maximum number of columns reached.\" , info = False ) return # Check if there are items with a similar name if self . _column_list_model . column_exists ( item . name ): return self . _column_list_model . add_column ( item ) # Select item self . select_column ( item . row ()) # Add column to activity metrics table self . _activity_metric_table_model . append_column ( item . model ) self . resize_activity_table_columns () if not item . model . auto_calculated : self . tb_activity_metrics . setItemDelegateForColumn ( item . row () + 1 , ColumnMetricItemDelegate ( self . tb_activity_metrics ) )","title":"add_column_item"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.can_add_new_column","text":"can_add_new_column () Checks if the maximum limit has been reached. Returns: Type Description bool True if the limit has not been reached else False if MAX_COLUMNS has been reached. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 852 853 854 855 856 857 858 859 def can_add_new_column ( self ) -> bool : \"\"\"Checks if the maximum limit has been reached. :returns: True if the limit has not been reached else False if MAX_COLUMNS has been reached. :rtype: bool \"\"\" return len ( self . _column_list_model . column_items ) < self . MAX_COLUMNS","title":"can_add_new_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.check_duplicate_profile_name","text":"check_duplicate_profile_name ( clean_profile_name ) Check if a profile name already exists. Parameters: Name Type Description Default clean_profile_name str The cleaned profile name to check required Returns: Type Description bool True if duplicate exists, False otherwise Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 def check_duplicate_profile_name ( self , clean_profile_name : str ) -> bool : \"\"\"Check if a profile name already exists. :param clean_profile_name: The cleaned profile name to check :type clean_profile_name: str :returns: True if duplicate exists, False otherwise :rtype: bool \"\"\" tr_msg = tr ( \"There is an already existing profile with the name\" ) if clean_profile_name in self . profile_collection . identifiers . values (): QtWidgets . QMessageBox . warning ( self , tr ( \"Duplicate Profile Name\" ), f \" { tr_msg } ' { clean_profile_name } '\" , ) return True return False","title":"check_duplicate_profile_name"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.clean_profile_name","text":"clean_profile_name ( profile_name ) Remove special characters from profile name. Parameters: Name Type Description Default profile_name str The raw profile name required Returns: Type Description str Cleaned profile name with special characters removed Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 @staticmethod def clean_profile_name ( profile_name : str ) -> str : \"\"\"Remove special characters from profile name. :param profile_name: The raw profile name :type profile_name: str :returns: Cleaned profile name with special characters removed :rtype: str \"\"\" return re . sub ( r \"\\W+\" , \" \" , profile_name )","title":"clean_profile_name"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.clear_activities","text":"clear_activities () Removes all activities in the activity metrics table. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 749 750 751 752 753 def clear_activities ( self ): \"\"\"Removes all activities in the activity metrics table.\"\"\" self . _activity_metric_table_model . removeRows ( 0 , self . _activity_metric_table_model . rowCount () )","title":"clear_activities"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.clear_column_properties","text":"clear_column_properties () Clear widget values for column properties. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1344 1345 1346 1347 1348 def clear_column_properties ( self ): \"\"\"Clear widget values for column properties.\"\"\" self . txt_column_name . clear () self . cbo_column_alignment . clear () self . cbo_column_expression . setExpression ( \"\" )","title":"clear_column_properties"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.clear_columns","text":"clear_columns () Remove columns from the UI list model. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 402 403 404 405 406 407 def clear_columns ( self ): \"\"\"Remove columns from the UI list model.\"\"\" # Remove columns while self . _column_list_model . rowCount () > 0 : column_name = self . _column_list_model . column_items [ 0 ] . name self . remove_column ( column_name )","title":"clear_columns"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.clear_views","text":"clear_views () Removes items in item views i.e. combobox, list and table items. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 396 397 398 399 400 def clear_views ( self ): \"\"\"Removes items in item views i.e. combobox, list and table items.\"\"\" self . cbo_profile . clear () self . clear_columns ()","title":"clear_views"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.eventFilter","text":"eventFilter ( observed_object , event ) Captures events sent to specific widgets in the wizard. Parameters: Name Type Description Default observed_object QObject Object receiving the event. required event QEvent The specific event being received by the observed object. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 def eventFilter ( self , observed_object : QtCore . QObject , event : QtCore . QEvent ): \"\"\"Captures events sent to specific widgets in the wizard. :param observed_object: Object receiving the event. :type observed_object: QtCore.QObject :param event: The specific event being received by the observed object. :type event: QtCore.QEvent \"\"\" # Resize activity metric table columns based on the size of the table view. if observed_object == self . tb_activity_metrics : if event . type () == QtCore . QEvent . Type . Resize : self . resize_activity_table_columns () return super () . eventFilter ( observed_object , event )","title":"eventFilter"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.initialize_collection","text":"initialize_collection () Creates an initial profile collection. Use this if None is specified. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def initialize_collection ( self ): \"\"\"Creates an initial profile collection. Use this if None is specified. \"\"\" # Default columns to be used in the 'Default' profile. defaults_columns = [] # Area area_metric_column = MetricColumn . create_default_column ( self . AREA_COLUMN , tr ( \"Area (Ha)\" ), f \"@ { VAR_ACTIVITY_AREA } \" ) area_metric_column . auto_calculated = True area_metric_column . format_as_number = True defaults_columns . append ( area_metric_column ) # Carbon protect self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Protect\" ), tr ( \"C.I. Protect\" ), FUNC_CARBON_IMPACT_PROTECT , ) # Carbon manage self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Manage\" ), tr ( \"C.I. Manage\" ), FUNC_CARBON_IMPACT_MANAGE , ) # Carbon restore self . _add_metric_column ( defaults_columns , tr ( \"Carbon Impact Restore\" ), tr ( \"C.I. Restore\" ), FUNC_CARBON_IMPACT_RESTORE , ) # NPV self . _add_metric_column ( defaults_columns , tr ( \"Net Present Value\" ), tr ( \"NPV\" ), FUNC_ACTIVITY_NPV ) column_metrics = [] for activity in self . _activities : row_metrics = [] for metric_column in defaults_columns : activity_column_metric = ActivityColumnMetric ( activity , metric_column , MetricType . COLUMN , metric_column . expression , ) row_metrics . append ( activity_column_metric ) column_metrics . append ( row_metrics ) default_configuration = MetricConfiguration ( defaults_columns , column_metrics ) # Create a default profile default_metric_profile = MetricConfigurationProfile ( tr ( \"Default\" ), default_configuration ) self . _profile_collection = MetricProfileCollection () self . _profile_collection . add_profile ( default_metric_profile ) self . cbo_profile . blockSignals ( True ) self . cbo_profile . addItem ( default_metric_profile . name , default_metric_profile . id ) self . cbo_profile . blockSignals ( False ) self . set_current_profile ( default_metric_profile . id )","title":"initialize_collection"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.is_activity_metrics_page_valid","text":"is_activity_metrics_page_valid () Validates the activity metrics page. Returns: Type Description bool True if the activity metrics page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 def is_activity_metrics_page_valid ( self ) -> bool : \"\"\"Validates the activity metrics page. :returns: True if the activity metrics page is valid, else False. :rtype: bool \"\"\" self . _activity_metric_message_bar . clearWidgets () is_valid = self . _activity_metric_table_model . validate ( True ) if not is_valid : msg = tr ( \"The metrics for the highlighted items are undefined.\" ) self . push_activity_metric_message ( msg ) return is_valid","title":"is_activity_metrics_page_valid"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.is_columns_page_valid","text":"is_columns_page_valid () Validates the columns page. Returns: Type Description bool True if the columns page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 def is_columns_page_valid ( self ) -> bool : \"\"\"Validates the columns page. :returns: True if the columns page is valid, else False. :rtype: bool \"\"\" self . _column_message_bar . clearWidgets () if self . _column_list_model . rowCount () == 0 : self . push_column_message ( tr ( \"At least one column is required to use in the activity \" \"metrics table.\" ) ) return False else : # Check other profiles zero_column_profiles = [] for profile in self . _profile_collection . profiles : if not profile . config . metric_columns : zero_column_profiles . append ( profile . name ) if zero_column_profiles : msg_tr = tr ( \"At least one column is required in the following profiles\" ) self . push_column_message ( f \" { msg_tr } : { ', ' . join ( zero_column_profiles ) } \" ) return False # Check column headers start with current profile then other profiles is_valid = True for item in self . _column_list_model . column_items : if not item . is_valid : if is_valid : is_valid = False tr_msg = tr ( \"header label is empty\" ) msg = f \"' { item . name } ' { tr_msg } .\" self . push_column_message ( msg ) if not is_valid : return False # Try other profiles if current profile is valid null_header_profiles = [] for profile in self . _profile_collection . profiles : for metric_column in profile . config . metric_columns : if not metric_column . header or not metric_column . name : if profile . name not in null_header_profiles : null_header_profiles . append ( profile . name ) if null_header_profiles : msg_tr = tr ( \"The following profiles have one or more empty column headers\" ) self . push_column_message ( f \" { msg_tr } : { ', ' . join ( null_header_profiles ) } \" ) return False return True","title":"is_columns_page_valid"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.load_column_properties","text":"load_column_properties ( column_item ) Load the properties of the column item in the corresponding UI controls. Parameters: Name Type Description Default column_item MetricColumnListItem Column item whose properties are to be loaded. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 def load_column_properties ( self , column_item : MetricColumnListItem ): \"\"\"Load the properties of the column item in the corresponding UI controls. :param column_item: Column item whose properties are to be loaded. :type column_item: MetricColumnListItem \"\"\" # Set column properties self . txt_column_name . blockSignals ( True ) self . txt_column_name . setText ( column_item . header ) self . txt_column_name . blockSignals ( False ) # Load alignment options self . cbo_column_alignment . blockSignals ( True ) self . cbo_column_alignment . clear () left_icon = FileUtils . get_icon ( \"mIconAlignLeft.svg\" ) self . cbo_column_alignment . addItem ( left_icon , tr ( \"Left\" ), QtCore . Qt . AlignmentFlag . AlignLeft ) right_icon = FileUtils . get_icon ( \"mIconAlignRight.svg\" ) self . cbo_column_alignment . addItem ( right_icon , tr ( \"Right\" ), QtCore . Qt . AlignmentFlag . AlignRight ) center_icon = FileUtils . get_icon ( \"mIconAlignCenter.svg\" ) self . cbo_column_alignment . addItem ( center_icon , tr ( \"Center\" ), QtCore . Qt . AlignmentFlag . AlignHCenter ) justify_icon = FileUtils . get_icon ( \"mIconAlignJustify.svg\" ) self . cbo_column_alignment . addItem ( justify_icon , tr ( \"Justify\" ), QtCore . Qt . AlignmentFlag . AlignJustify ) alignment_index = self . cbo_column_alignment . findData ( column_item . alignment ) if alignment_index != - 1 : self . cbo_column_alignment . setCurrentIndex ( alignment_index ) self . cbo_column_alignment . blockSignals ( False ) self . cbo_column_expression . blockSignals ( True ) if column_item . auto_calculated : self . cbo_column_expression . setEnabled ( False ) else : self . cbo_column_expression . setEnabled ( True ) self . cbo_column_expression . setExpression ( column_item . expression ) self . cbo_column_expression . blockSignals ( False ) self . chk_format_number . blockSignals ( True ) self . chk_format_number . setChecked ( column_item . format_as_number ) self . chk_format_number . blockSignals ( False )","title":"load_column_properties"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.load_configuration","text":"load_configuration ( configuration ) Load a metric configuration. All the columns in the configuration will be loaded, with an attempt to restore the metric configuration of similar activities that existed in the configuration with those currently being configured. Parameters: Name Type Description Default configuration MetricConfiguration Configuration containing mapping of metric columns and cell metrics. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def load_configuration ( self , configuration : MetricConfiguration ): \"\"\"Load a metric configuration. All the columns in the configuration will be loaded, with an attempt to restore the metric configuration of similar activities that existed in the configuration with those currently being configured. :param configuration: Configuration containing mapping of metric columns and cell metrics. :type configuration: MetricConfiguration \"\"\" if configuration is None : return if not configuration . is_valid (): log ( \"Metric configuration is invalid and cannot be loaded.\" ) return # Add metric columns for mc in configuration . metric_columns : # Do not add a column with a similar name if self . _column_list_model . column_exists ( mc . name ): continue item = MetricColumnListItem ( mc ) self . add_column_item ( item ) # Configure activity cell metrics matching the same activity # and column name in the configuration for r in range ( self . _activity_metric_table_model . rowCount ()): for c in range ( 1 , self . _activity_metric_table_model . columnCount ()): item = self . _activity_metric_table_model . item ( r , c ) # Fetch the closest match in configuration (based on activity # ID and name or header label) model_match = configuration . find ( str ( item . model . activity . uuid ), item . model . metric_column . name ) if model_match is None : continue item . update_metric_type ( model_match . metric_type , model_match . expression )","title":"load_configuration"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.load_summary_details","text":"load_summary_details () Load items summarizing the metric configuration. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1548 1549 1550 1551 1552 def load_summary_details ( self ): \"\"\"Load items summarizing the metric configuration.\"\"\" activity_column_metric_models = self . _activity_metric_table_model . models self . _summary_model . set_summary_models ( activity_column_metric_models ) self . tv_summary . expandAll ()","title":"load_summary_details"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_accepted","text":"on_accepted () Slot raised when the wizard has been accepted by the user. Used to save any changes for the current metric configuration profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1554 1555 1556 1557 1558 1559 1560 def on_accepted ( self ): \"\"\"Slot raised when the wizard has been accepted by the user. Used to save any changes for the current metric configuration profile. \"\"\" self . update_current_profile ()","title":"on_accepted"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_add_column","text":"on_add_column () Slot raised to add a new column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 def on_add_column ( self ): \"\"\"Slot raised to add a new column.\"\"\" if not self . can_add_new_column (): QtWidgets . QMessageBox . warning ( self , tr ( \"Columns Limit\" ), tr ( \"Maximum number of columns reached.\" ), ) return label_text = ( f \" { tr ( 'Specify the name of the column.' ) } <br>\" f \"<i><sup>*</sup> { tr ( 'Any special characters will be removed.' ) } \" f \"</i>\" ) column_name , ok = QtWidgets . QInputDialog . getText ( self , tr ( \"Set Column Name\" ), label_text , ) if ok and column_name : # Remove special characters clean_column_name = re . sub ( \"\\W+\" , \" \" , column_name ) column_exists = self . _column_list_model . column_exists ( clean_column_name ) if column_exists : QtWidgets . QMessageBox . warning ( self , tr ( \"Duplicate Column Name\" ), tr ( \"There is an already existing column name.\" ), ) return column_item = MetricColumnListItem ( clean_column_name ) # Set default number formatter; can always be changed column_item . number_formatter = MetricColumn . default_formatter () self . add_column_item ( column_item )","title":"on_add_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_add_profile","text":"on_add_profile () Slot to add a new profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 def on_add_profile ( self ): \"\"\"Slot to add a new profile.\"\"\" clean_profile_name = self . _get_validated_profile_name ( tr ( \"Add New Profile\" )) if clean_profile_name is None : return metric_profile = MetricConfigurationProfile ( clean_profile_name , MetricConfiguration . create () ) if not self . _profile_collection . add_profile ( metric_profile ): QtWidgets . QMessageBox . warning ( self , tr ( \"Add New Profile\" ), tr ( \"Profile could not be added. Check for a \" \"duplicate name or an invalid profile\" ), ) return # Save any changes to the profile the user was working self . update_current_profile () self . cbo_profile . addItem ( clean_profile_name , metric_profile . id ) self . set_current_profile ( metric_profile . id )","title":"on_add_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_column_selection_changed","text":"on_column_selection_changed ( selected , deselected ) Slot raised when selection in the columns view has changed. Parameters: Name Type Description Default selected QItemSelection Current item selection. required deselected QItemSelection Previously selected items that have been deselected. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 def on_column_selection_changed ( self , selected : QtCore . QItemSelection , deselected : QtCore . QItemSelection ): \"\"\"Slot raised when selection in the columns view has changed. :param selected: Current item selection. :type selected: QtCore.QItemSelection :param deselected: Previously selected items that have been deselected. :type deselected: QtCore.QItemSelection \"\"\" self . btn_delete_column . setEnabled ( True ) self . btn_column_up . setEnabled ( True ) self . btn_column_down . setEnabled ( True ) # Close any open panels self . column_properties_stack . acceptAllPanels () selected_columns = self . selected_column_items () if len ( selected_columns ) != 1 : self . btn_delete_column . setEnabled ( False ) self . btn_column_up . setEnabled ( False ) self . btn_column_down . setEnabled ( False ) self . clear_column_properties () else : # List view is set to single selection hence this # condition will be for one item selected. self . load_column_properties ( selected_columns [ 0 ])","title":"on_column_selection_changed"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_copy_profile","text":"on_copy_profile () Slot to copy the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 def on_copy_profile ( self ): \"\"\"Slot to copy the current profile.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Please select a profile to copy\" ), ) return # Check validity if not current_profile . is_valid (): QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"The current profile cannot be copied as it is invalid\" ), ) return clean_profile_name = self . _get_validated_profile_name ( tr ( \"Copy Profile\" ), f \" { current_profile . name } { tr ( 'Copy' ) } \" ) if clean_profile_name is None : return # Save any changes before cloning self . update_current_profile () cloned_profile = clone_metric_configuration_profile ( current_profile , self . _activities ) if cloned_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Unable to copy the current profile\" ), ) return # Update the name then add it to the collection cloned_profile . name = clean_profile_name if not self . _profile_collection . add_profile ( cloned_profile ): QtWidgets . QMessageBox . warning ( self , tr ( \"Copy Profile\" ), tr ( \"Copied profile could not be added. Check for a \" \"duplicate name or an invalid profile\" ), ) return self . cbo_profile . addItem ( clean_profile_name , cloned_profile . id ) self . set_current_profile ( cloned_profile . id )","title":"on_copy_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_customize_number","text":"on_customize_number () Slot raised to customize number formatting options. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 705 706 707 708 709 710 711 712 713 714 715 716 717 def on_customize_number ( self ): \"\"\"Slot raised to customize number formatting options.\"\"\" format_selector = QgsNumericFormatSelectorWidget ( self . column_properties_widget ) format_selector . setPanelTitle ( tr ( \"Number Formatter\" )) format_selector . changed . connect ( self . _on_number_format_changed ) # Get current column item current_columns_items = self . selected_column_items () if len ( current_columns_items ) > 0 : number_formatter = current_columns_items [ 0 ] . number_formatter format_selector . setFormat ( number_formatter ) self . column_properties_widget . openPanel ( format_selector )","title":"on_customize_number"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_delete_profile","text":"on_delete_profile () Slot to delete the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 def on_delete_profile ( self ): \"\"\"Slot to delete the current profile.\"\"\" # Check to ensure that at least one profile # exists in the collection if len ( self . _profile_collection . profiles ) == 1 : QtWidgets . QMessageBox . warning ( self , tr ( \"Delete Profile\" ), tr ( \"Cannot delete as at least one metric profile must exist.\" ), ) return current_index = self . cbo_profile . currentIndex () current_profile_id = self . cbo_profile . itemData ( current_index ) if not current_profile_id or not self . _profile_collection . remove_profile ( current_profile_id ): QtWidgets . QMessageBox . warning ( self , tr ( \"Delete Profile\" ), tr ( \"An error occurred in attempting to delete the current profile.\" ), ) return self . cbo_profile . removeItem ( current_index ) # Set last profile in the collection as the current profile last_profile_id = self . _profile_collection . profiles [ - 1 ] . id self . set_current_profile ( last_profile_id )","title":"on_delete_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_format_number_checked","text":"on_format_number_checked ( checked ) Slot raised when the format number checkbox has been checked or unchecked. Parameters: Name Type Description Default checked bool True if checked or False if unchecked. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 739 740 741 742 743 744 745 746 747 def on_format_number_checked ( self , checked : bool ): \"\"\"Slot raised when the format number checkbox has been checked or unchecked. :param checked: True if checked or False if unchecked. :type checked: bool \"\"\" self . btn_customize_number . setEnabled ( checked ) self . save_column_properties ()","title":"on_format_number_checked"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_help_requested","text":"on_help_requested () Slot raised when the help button has been clicked. Opens the online help documentation in the user's browser. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 698 699 700 701 702 703 def on_help_requested ( self ): \"\"\"Slot raised when the help button has been clicked. Opens the online help documentation in the user's browser. \"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"on_help_requested"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_move_down_column","text":"on_move_down_column () Slot raised to move the selected column one level down. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 def on_move_down_column ( self ): \"\"\"Slot raised to move the selected column one level down.\"\"\" selected_items = self . selected_column_items () if len ( selected_items ) == 0 : return item = selected_items [ 0 ] current_row = item . row () row = self . _column_list_model . move_column_down ( current_row ) if row == - 1 : return # Maintain selection self . select_column ( row ) # Move corresponding column in the activity metrics table. # We have normalized it to reflect the position in the # metrics table. reference_index = current_row + 1 self . _move_activity_metric_column ( reference_index , HorizontalMoveDirection . RIGHT )","title":"on_move_down_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_move_up_column","text":"on_move_up_column () Slot raised to move the selected column one level up. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 def on_move_up_column ( self ): \"\"\"Slot raised to move the selected column one level up.\"\"\" selected_items = self . selected_column_items () if len ( selected_items ) == 0 : return item = selected_items [ 0 ] current_row = item . row () row = self . _column_list_model . move_column_up ( current_row ) if row == - 1 : return # Maintain selection self . select_column ( row ) # Move corresponding column in the activity metrics table. # We have normalized it to reflect the position in the # metrics table. reference_index = current_row + 1 self . _move_activity_metric_column ( reference_index , HorizontalMoveDirection . LEFT )","title":"on_move_up_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_page_id_changed","text":"on_page_id_changed ( page_id ) Slot raised when the page ID changes. Parameters: Name Type Description Default page_id int ID of the new page. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 def on_page_id_changed ( self , page_id : int ): \"\"\"Slot raised when the page ID changes. :param page_id: ID of the new page. :type page_id: int \"\"\" # Update title window_title = ( f \" { tr ( 'Activity Metrics Wizard' ) } - \" f \" { tr ( 'Step' ) } { page_id + 1 } { tr ( 'of' ) } \" f \" { len ( self . pageIds ()) !s} \" ) self . setWindowTitle ( window_title ) # Activity metrics page if page_id == 2 : # If expression is not specified for at # least one column then enable the groupbox. group_box_checked = False self . gb_custom_activity_metric . setChecked ( group_box_checked ) for item in self . _column_list_model . column_items : if ( not item . expression and not self . gb_custom_activity_metric . isChecked () ): group_box_checked = True break self . gb_custom_activity_metric . setChecked ( group_box_checked ) # Final summary page elif page_id == 3 : self . load_summary_details ()","title":"on_page_id_changed"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_profile_changed","text":"on_profile_changed ( index ) Slot raised when the profile has changed. Parameters: Name Type Description Default index int Index of the current profile. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 def on_profile_changed ( self , index : int ): \"\"\"Slot raised when the profile has changed. :param index: Index of the current profile. :type index: int \"\"\" if index == - 1 : return profile_id = self . cbo_profile . itemData ( index ) if not profile_id : return self . update_current_profile () self . set_current_profile ( profile_id )","title":"on_profile_changed"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_remove_column","text":"on_remove_column () Slot raised to remove the selected column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 893 894 895 896 897 898 899 def on_remove_column ( self ): \"\"\"Slot raised to remove the selected column.\"\"\" selected_items = self . selected_column_items () for item in selected_items : self . remove_column ( item . name ) self . resize_activity_table_columns ()","title":"on_remove_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.on_rename_profile","text":"on_rename_profile () Slot to rename the current profile. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def on_rename_profile ( self ): \"\"\"Slot to rename the current profile.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : QtWidgets . QMessageBox . warning ( self , tr ( \"Rename Profile\" ), tr ( \"Please select a profile to rename.\" ), ) return clean_profile_name = self . _get_validated_profile_name ( tr ( \"Rename Profile\" ), current_profile . name ) if clean_profile_name is None : return # Update UI current_index = self . cbo_profile . currentIndex () self . cbo_profile . setItemText ( current_index , clean_profile_name ) # Update profile name current_profile . name = clean_profile_name self . cbo_profile . setItemData ( current_index , current_profile . id ) # Update profile collection self . _profile_collection . current_profile = current_profile . id self . update_current_profile ()","title":"on_rename_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.push_activity_metric_message","text":"push_activity_metric_message ( message , level = Qgis . MessageLevel . Warning , clear_first = False ) Push a message to the notification bar in the activity metric wizard page. Parameters: Name Type Description Default message str Message to the show in the notification bar. required level MessageLevel Severity of the message. Warning is the default. Warning clear_first bool Clear any current messages in the notification bar, default is False. False Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 def push_activity_metric_message ( self , message : str , level : Qgis . MessageLevel = Qgis . MessageLevel . Warning , clear_first : bool = False , ): \"\"\"Push a message to the notification bar in the activity metric wizard page. :param message: Message to the show in the notification bar. :type message: str :param level: Severity of the message. Warning is the default. :type level: Qgis.MessageLevel :param clear_first: Clear any current messages in the notification bar, default is False. :type clear_first: bool \"\"\" if clear_first : self . _activity_metric_message_bar . clearWidgets () self . _activity_metric_message_bar . pushMessage ( message , level , 5 )","title":"push_activity_metric_message"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.push_column_message","text":"push_column_message ( message , level = Qgis . MessageLevel . Warning , clear_first = False ) Push a message to the notification bar in the columns wizard page. Parameters: Name Type Description Default message str Message to the show in the notification bar. required level MessageLevel Severity of the message. Warning is the default. Warning clear_first bool Clear any current messages in the notification bar, default is False. False Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 def push_column_message ( self , message : str , level : Qgis . MessageLevel = Qgis . MessageLevel . Warning , clear_first : bool = False , ): \"\"\"Push a message to the notification bar in the columns wizard page. :param message: Message to the show in the notification bar. :type message: str :param level: Severity of the message. Warning is the default. :type level: Qgis.MessageLevel :param clear_first: Clear any current messages in the notification bar, default is False. :type clear_first: bool \"\"\" if clear_first : self . _column_message_bar . clearWidgets () self . _column_message_bar . pushMessage ( message , level , 5 )","title":"push_column_message"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.remove_column","text":"remove_column ( name ) Remove a metric column with the given name. Parameters: Name Type Description Default name str Name of the metric column to be removed. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 def remove_column ( self , name : str ): \"\"\"Remove a metric column with the given name. :param name: Name of the metric column to be removed. :type name: str \"\"\" item = self . _column_list_model . item_from_name ( name ) if item is None : return index = item . row () self . _column_list_model . remove_column ( name ) # Remove corresponding column in activity metrics table self . _activity_metric_table_model . remove_column ( index )","title":"remove_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.resize_activity_table_columns","text":"resize_activity_table_columns () Resize column width of activity metrics table for the entire width to be occupied. Use a reasonable size if the table has only one column. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 def resize_activity_table_columns ( self ): \"\"\"Resize column width of activity metrics table for the entire width to be occupied. Use a reasonable size if the table has only one column. \"\"\" if self . _activity_metric_table_model . columnCount () == 1 : self . tb_activity_metrics . setColumnWidth ( 0 , 120 ) return width = self . tb_activity_metrics . width () # Make all columns have the same width column_count = self . _activity_metric_table_model . columnCount () column_width = int ( width / float ( column_count )) for c in range ( column_count ): self . tb_activity_metrics . setColumnWidth ( c , column_width )","title":"resize_activity_table_columns"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.save_column_properties","text":"save_column_properties () Updates the properties of the metric column based on the values of the UI controls for the current selected column item. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 def save_column_properties ( self ): \"\"\"Updates the properties of the metric column based on the values of the UI controls for the current selected column item. \"\"\" selected_columns = self . selected_column_items () if len ( selected_columns ) == 0 : return current_column = selected_columns [ 0 ] current_column . header = self . txt_column_name . text () current_column . alignment = self . cbo_column_alignment . itemData ( self . cbo_column_alignment . currentIndex () ) current_column . expression = self . cbo_column_expression . expression () current_column . format_as_number = self . chk_format_number . isChecked () if not current_column . format_as_number : current_column . number_formatter = QgsFallbackNumericFormat () # Update column properties in activity metrics table self . _activity_metric_table_model . update_column_properties ( current_column . row (), current_column . model )","title":"save_column_properties"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.select_column","text":"select_column ( row ) Select the column item in the specified row. Parameters: Name Type Description Default row int Column item in the specified row number to be selected. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 def select_column ( self , row : int ): \"\"\"Select the column item in the specified row. :param row: Column item in the specified row number to be selected. :type row: int \"\"\" index = self . _column_list_model . index ( row , 0 ) if not index . isValid (): return selection_model = self . lst_columns . selectionModel () selection_model . select ( index , QtCore . QItemSelectionModel . SelectionFlag . ClearAndSelect )","title":"select_column"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.selected_column_items","text":"selected_column_items () Returns the selected column items in the column list view. Returns: Type Description list A collection of the selected column items. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 def selected_column_items ( self ) -> typing . List [ MetricColumnListItem ]: \"\"\"Returns the selected column items in the column list view. :returns: A collection of the selected column items. :rtype: list \"\"\" selection_model = self . lst_columns . selectionModel () idxs = selection_model . selectedRows () return [ self . _column_list_model . item ( idx . row ()) for idx in idxs ]","title":"selected_column_items"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.set_current_profile","text":"set_current_profile ( profile ) Updates the UI to set the current metric profile. Parameters: Name Type Description Default profile Union [ str , MetricConfigurationProfile ] Profile or profile ID to be set. It must exist in the profile collection. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 def set_current_profile ( self , profile : typing . Union [ str , MetricConfigurationProfile ] ): \"\"\"Updates the UI to set the current metric profile. :param profile: Profile or profile ID to be set. It must exist in the profile collection. :type profile: typing.Union[str, MetricConfigurationProfile] \"\"\" if self . _profile_collection is None : return # Convert profile to corresponding ID if isinstance ( profile , MetricConfigurationProfile ): profile = profile . id if not self . _profile_collection . profile_exists ( profile ): return metric_profile = self . _profile_collection . get_profile ( profile ) if metric_profile is None : return # Update combobox item_index = self . cbo_profile . findData ( profile ) if item_index == - 1 : return self . cbo_profile . blockSignals ( True ) self . cbo_profile . setCurrentIndex ( item_index ) self . cbo_profile . blockSignals ( False ) # Clear columns self . clear_columns () # Load configuration in the view self . load_configuration ( metric_profile . config ) # Set the current profile self . _profile_collection . current_profile = profile","title":"set_current_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.update_current_profile","text":"update_current_profile () Saves the current profile to the profile collection. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 1028 1029 1030 1031 1032 1033 1034 1035 def update_current_profile ( self ): \"\"\"Saves the current profile to the profile collection.\"\"\" current_profile = self . _profile_collection . get_current_profile () if current_profile is None : return # Update metric config as per setup in the UI current_profile . config = self . metric_configuration","title":"update_current_profile"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ActivityMetricsBuilder.validateCurrentPage","text":"validateCurrentPage () Validates the current page. Returns: Type Description bool True if the current page is valid, else False. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 def validateCurrentPage ( self ) -> bool : \"\"\"Validates the current page. :returns: True if the current page is valid, else False. :rtype: bool \"\"\" # Columns page if self . currentId () == 1 : # Save latest changes in current profile self . update_current_profile () return self . is_columns_page_valid () elif self . currentId () == 2 : return self . is_activity_metrics_page_valid () return True","title":"validateCurrentPage"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate","text":"Bases: QStyledItemDelegate Delegate that allows the user to choose the type of metric for a particular activity column.","title":"ColumnMetricItemDelegate"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate.createEditor","text":"createEditor ( parent , option , idx ) Creates a combobox for choosing the metric type. Parameters: Name Type Description Default parent QWidget Parent widget. required option QStyleOptionViewItem Options for drawing the widget in the view. required idx QModelIndex Location of the request in the data model. required Returns: Type Description QtWidgets.QLineEdit The editor widget. Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ) -> QtWidgets . QLineEdit : \"\"\"Creates a combobox for choosing the metric type. :param parent: Parent widget. :type parent: QtWidgets.QWidget :param option: Options for drawing the widget in the view. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the request in the data model. :type idx: QtCore.QModelIndex :returns: The editor widget. :rtype: QtWidgets.QLineEdit \"\"\" metric_combobox = QtWidgets . QComboBox ( parent ) metric_combobox . setFrame ( False ) metric_combobox . setProperty ( self . INDEX_PROPERTY_NAME , idx ) metric_combobox . addItem ( tr ( COLUMN_METRIC_STR ), MetricType . COLUMN ) metric_combobox . addItem ( tr ( CELL_METRIC_STR ), MetricType . CELL ) metric_combobox . activated . connect ( self . on_metric_type_changed ) return metric_combobox","title":"createEditor"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate.on_metric_type_changed","text":"on_metric_type_changed ( index ) Slot raised when the metric type has changed. We use this to load the expression builder if a cell metric is selected. Parameters: Name Type Description Default index int Index of the current selection. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def on_metric_type_changed ( self , index : int ): \"\"\"Slot raised when the metric type has changed. We use this to load the expression builder if a cell metric is selected. :param index: Index of the current selection. :type index: int \"\"\" if index == - 1 : return editor = self . sender () metric_type = editor . itemData ( index ) if metric_type != MetricType . CELL : return model_index = editor . property ( self . INDEX_PROPERTY_NAME ) if not model_index . isValid (): log ( tr ( \"Invalid index for activity column metric.\" )) return activity_column_metric_item = model_index . model () . itemFromIndex ( model_index ) if activity_column_metric_item is None : log ( tr ( \"Activity column metric could not be found.\" )) return expression_builder = QgsExpressionBuilderDialog ( None , activity_column_metric_item . expression , editor , \"CPLUS\" , create_metrics_expression_context (), ) expression_builder . setWindowTitle ( tr ( \"Activity Column Expression Builder\" )) if expression_builder . exec () == QtWidgets . QDialog . DialogCode . Accepted : # Save the expression for use when persisting in the model editor . setProperty ( self . EXPRESSION_PROPERTY_NAME , expression_builder . expressionText () ) self . commitData . emit ( editor ) self . closeEditor . emit ( editor , QtWidgets . QAbstractItemDelegate . NoHint )","title":"on_metric_type_changed"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate.setEditorData","text":"setEditorData ( widget , idx ) Sets the data to be displayed and edited by the editor. Parameters: Name Type Description Default widget QWidget Editor widget. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def setEditorData ( self , widget : QtWidgets . QWidget , idx : QtCore . QModelIndex ): \"\"\"Sets the data to be displayed and edited by the editor. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" select_index = - 1 item = idx . model () . itemFromIndex ( idx ) if item is None or not isinstance ( item , ActivityColumnMetricItem ): return current_metric_type = item . metric_type if current_metric_type == MetricType . COLUMN : select_index = widget . findData ( MetricType . COLUMN ) elif current_metric_type == MetricType . CELL : select_index = widget . findData ( MetricType . CELL ) if select_index != - 1 : # We are temporarily blocking the index changed slot # so that the expression dialog will not be shown if # the metric type is cell-based. widget . blockSignals ( True ) widget . setCurrentIndex ( select_index ) widget . blockSignals ( False )","title":"setEditorData"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate.setModelData","text":"setModelData ( widget , model , idx ) Gets data from the editor widget and stores it in the specified model at the item index. Parameters: Name Type Description Default widget QWidget Editor widget. required model QAbstractItemModel Model to store the editor data in. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def setModelData ( self , widget : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , idx : QtCore . QModelIndex , ): \"\"\"Gets data from the editor widget and stores it in the specified model at the item index. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param model: Model to store the editor data in. :type model: QtCore.QAbstractItemModel :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" metric_type = widget . itemData ( widget . currentIndex ()) item = idx . model () . itemFromIndex ( idx ) if item is None or not isinstance ( item , ActivityColumnMetricItem ): return expression = \"\" if metric_type == MetricType . COLUMN : # Inherit the column expression if defined metric_column = model . metric_column ( idx . column () - 1 ) if metric_column is not None : expression = metric_column . expression elif metric_type == MetricType . CELL : expression = widget . property ( self . EXPRESSION_PROPERTY_NAME ) item . update_metric_type ( metric_type , expression )","title":"setModelData"},{"location":"developer/api/gui/api_metrics_builder_dialog/#src.cplus_plugin.gui.metrics_builder_dialog.ColumnMetricItemDelegate.updateEditorGeometry","text":"updateEditorGeometry ( widget , option , idx ) Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. Parameters: Name Type Description Default widget QWidget Widget whose geometry will be updated. required option QStyleOptionViewItem Option containing the rectangle for updating the widget. required idx QModelIndex Location of the widget in the data model. required Source code in src/cplus_plugin/gui/metrics_builder_dialog.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def updateEditorGeometry ( self , widget : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ): \"\"\"Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. :param widget: Widget whose geometry will be updated. :type widget: QtWidgets.QWidget :param option: Option containing the rectangle for updating the widget. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the widget in the data model. :type idx: QtCore.QModelIndex \"\"\" widget . setGeometry ( option . rect )","title":"updateEditorGeometry"},{"location":"developer/api/gui/api_metrics_builder_model/","text":"Metrics Builder View Model \u00b6 MVC models for the metrics builder. ActivityColumnMetricItem \u00b6 ActivityColumnMetricItem ( activity_column_metric ) Bases: QStandardItem Represents an activity's metric information for a specific column. Source code in src/cplus_plugin/gui/metrics_builder_model.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def __init__ ( self , activity_column_metric : ActivityColumnMetric ): super () . __init__ () self . _activity_column_metric = activity_column_metric if activity_column_metric . metric_column . auto_calculated : self . setEditable ( False ) else : self . setEditable ( True ) self . _update_display_text () self . setTextAlignment ( self . _activity_column_metric . metric_column . alignment | QtCore . Qt . AlignmentFlag . AlignVCenter ) self . _update_tool_tip () expression property \u00b6 expression Gets the item's expression. Returns: Type Description str Item's expression. metric_type property \u00b6 metric_type Gets the metric type of the underlying data model. Returns: Type Description MetricType The metric type of the underlying data model. model property \u00b6 model Gets the underlying activity column metric data model. Returns: Type Description ActivityColumnMetric The underlying activity column metric data model. highlight_invalid \u00b6 highlight_invalid ( show ) Highlights the item with a red background to indicate that the activity column metric is invalid. Parameters: Name Type Description Default show bool True to highlight the item else False to disable. A call to highlight will first verify that the data model is valid. If it is valid then the item will not be highlighted. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def highlight_invalid ( self , show : bool ): \"\"\"Highlights the item with a red background to indicate that the activity column metric is invalid. :param show: True to highlight the item else False to disable. A call to highlight will first verify that the data model is valid. If it is valid then the item will not be highlighted. :type show: bool \"\"\" if self . is_valid () and show : return background = self . background () if show : background . setColor ( QtGui . QColor ( \"#ffaeae\" )) background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) else : background . setColor ( QtCore . Qt . GlobalColor . white ) background . setStyle ( QtCore . Qt . BrushStyle . NoBrush ) self . setBackground ( background ) is_valid \u00b6 is_valid () Checks if the activity column metric is valid. Returns: Type Description bool True if the activity column metric is valid else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 591 592 593 594 595 596 597 598 def is_valid ( self ) -> bool : \"\"\"Checks if the activity column metric is valid. :returns: True if the activity column metric is valid else False. :rtype: bool \"\"\" return self . _activity_column_metric . is_valid () metric_type_to_str staticmethod \u00b6 metric_type_to_str ( metric_type ) Returns the corresponding string representation for the given metric type. Parameters: Name Type Description Default metric_type MetricType Type of metric or expression. required Returns: Type Description str The corresponding string representation of the given metric type. Source code in src/cplus_plugin/gui/metrics_builder_model.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 @staticmethod def metric_type_to_str ( metric_type : MetricType ) -> str : \"\"\"Returns the corresponding string representation for the given metric type. :param metric_type: Type of metric or expression. :type metric_type: MetricType :returns: The corresponding string representation of the given metric type. :rtype: str \"\"\" if metric_type == MetricType . COLUMN : return tr ( COLUMN_METRIC_STR ) elif metric_type == MetricType . CELL : return tr ( CELL_METRIC_STR ) else : return tr ( \"<Not set>\" ) type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 583 584 585 586 587 588 589 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return ACTIVITY_COLUMN_METRIC_TABLE_ITEM_TYPE update_metric_model \u00b6 update_metric_model ( model ) Updates the underlying metric model. Parameters: Name Type Description Default model MetricColumn Metric column containing updated properties. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def update_metric_model ( self , model : MetricColumn ): \"\"\"Updates the underlying metric model. :param model: Metric column containing updated properties. :type model: MetricColumn \"\"\" if ( self . _activity_column_metric . metric_type == MetricType . NOT_SET and model . expression ): self . _activity_column_metric . metric_type = MetricType . COLUMN self . _activity_column_metric . expression = model . expression elif ( self . _activity_column_metric . metric_type == MetricType . COLUMN and not model . expression ): self . _activity_column_metric . metric_type = MetricType . NOT_SET self . _activity_column_metric . expression = \"\" elif ( self . _activity_column_metric . metric_type == MetricType . COLUMN and model . expression ): # Just update the expression self . _activity_column_metric . expression = model . expression self . _activity_column_metric . metric_column = model self . _update_display_text () self . _update_tool_tip () update_metric_type \u00b6 update_metric_type ( metric_type , expression = '' ) Updates the metric type of the underlying metric model. Parameters: Name Type Description Default metric_type MetricType Metric type to be used by the model. required expression str Expression for the given metric type. Default is an empty string. '' Source code in src/cplus_plugin/gui/metrics_builder_model.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def update_metric_type ( self , metric_type : MetricType , expression : str = \"\" ): \"\"\"Updates the metric type of the underlying metric model. :param metric_type: Metric type to be used by the model. :type metric_type: MetricType :param expression: Expression for the given metric type. Default is an empty string. :type expression: str \"\"\" self . _activity_column_metric . metric_type = metric_type self . _activity_column_metric . expression = expression self . _update_display_text () self . _update_tool_tip () ActivityColumnSummaryItem \u00b6 ActivityColumnSummaryItem ( activity_column_metrics ) Bases: QStandardItem Provides an item for displaying the configuration of metrics for the activity by listing the specific metrics for each column. Source code in src/cplus_plugin/gui/metrics_builder_model.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 def __init__ ( self , activity_column_metrics : typing . List [ ActivityColumnMetric ]): super () . __init__ () self . _activity_column_metrics = activity_column_metrics self . _reference_activity = None for acm in self . _activity_column_metrics : if self . _reference_activity is None : self . _reference_activity = acm . activity self . setText ( acm . activity . name ) column_item = QtGui . QStandardItem () column_item . setIcon ( FileUtils . get_icon ( \"table_column.svg\" )) column_details = ( f \" { acm . metric_column . header } : \" f \" { ActivityColumnMetricItem . metric_type_to_str ( acm . metric_type ) } \" ) column_item . setText ( column_details ) column_item . setToolTip ( acm . expression ) self . appendRow ( column_item ) ActivityColumnSummaryTreeModel \u00b6 ActivityColumnSummaryTreeModel ( parent = None ) Bases: QStandardItemModel View model for managing activity column metric data models in a tree view. Source code in src/cplus_plugin/gui/metrics_builder_model.py 965 966 967 968 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) set_summary_models \u00b6 set_summary_models ( activity_metric_models ) Update the model to use the specified activity column metric data models. Any existing items will be removed prior to loading the specified data models. Parameters: Name Type Description Default activity_metric_models List [ List [ ActivityColumnMetric ]] Nested list of activity column metric data models. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 def set_summary_models ( self , activity_metric_models : typing . List [ typing . List [ ActivityColumnMetric ]] ): \"\"\"Update the model to use the specified activity column metric data models. Any existing items will be removed prior to loading the specified data models. :param activity_metric_models: Nested list of activity column metric data models. :type activity_metric_models: typing.List[typing.List[ActivityColumnMetric]] \"\"\" # Clear any prior existing items self . removeRows ( 0 , self . rowCount ()) for activity_metric_row in activity_metric_models : summary_item = ActivityColumnSummaryItem ( activity_metric_row ) self . appendRow ( summary_item ) ActivityMetricTableModel \u00b6 ActivityMetricTableModel ( parent = None , columns = None ) Bases: QStandardItemModel View model for activity metrics in a table. Source code in src/cplus_plugin/gui/metrics_builder_model.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def __init__ ( self , parent = None , columns : typing . List [ MetricColumn ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Add default activity name header self . setHorizontalHeaderLabels ([ tr ( ACTIVITY_NAME )]) self . _metric_columns = [] if columns is not None : self . _metric_columns = columns # Timer for intermittently showing invalid items self . _validation_highlight_timer = QtCore . QTimer () self . _validation_highlight_timer . setSingleShot ( True ) self . _validation_highlight_timer . setInterval ( 5000 ) self . _validation_highlight_timer . timeout . connect ( self . _on_validation_highlight_timeout ) activities property \u00b6 activities Gets all the activities in the model. Returns: Type Description typing.List[Activity] All activities in the model. metric_columns property \u00b6 metric_columns Gets the metric columns used in the model to define the headers. Returns: Type Description typing.List[MetricColumn] Metric columns used in the model. models property \u00b6 models Gets the mapping of activity column metric data models. Returns: Type Description typing.List[typing.List[ActivityColumnMetric]] A nested list of activity column metrics in the same order that they are stored in the model. append_activity \u00b6 append_activity ( activity ) Adds an activity row in the activity metrics table. Parameters: Name Type Description Default activity Activity Activity to be added. required Returns: Type Description bool True if the activity was successfully added else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 def append_activity ( self , activity : Activity ) -> bool : \"\"\"Adds an activity row in the activity metrics table. :param activity: Activity to be added. :type activity: Activity :returns: True if the activity was successfully added else False. :rtype: bool \"\"\" # Check if there is a similar activity matching_activities = [ act for act in self . activities if act . uuid == activity . uuid ] if len ( matching_activities ) > 0 : return False row_items = [] activity_item = ActivityNameTableItem ( activity ) row_items . append ( activity_item ) # Set corresponding activity column metric items for mc in self . _metric_columns : activity_column_metric = ActivityColumnMetric ( activity , mc , MetricType . COLUMN if mc . expression else MetricType . NOT_SET , mc . expression if mc . expression else \"\" , ) row_items . append ( ActivityColumnMetricItem ( activity_column_metric )) self . appendRow ( row_items ) return True append_column \u00b6 append_column ( column ) Adds a column to the model based on the information in the metric column. Parameters: Name Type Description Default column MetricColumn Metric column containing information for defining the new column. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 def append_column ( self , column : MetricColumn ): \"\"\"Adds a column to the model based on the information in the metric column. :param column: Metric column containing information for defining the new column. :type column: MetricColumn \"\"\" column_items = [] # Update rows based on the selected activities for activity in self . activities : activity_column_metric = ActivityColumnMetric ( activity , column , MetricType . COLUMN if column . expression else MetricType . NOT_SET , column . expression if column . expression else \"\" , ) item = ActivityColumnMetricItem ( activity_column_metric ) column_items . append ( item ) self . appendColumn ( column_items ) self . setHeaderData ( self . columnCount () - 1 , QtCore . Qt . Orientation . Horizontal , column . header , QtCore . Qt . ItemDataRole . DisplayRole , ) self . _metric_columns . append ( column ) metric_column \u00b6 metric_column ( index ) Gets the metric column at the given location. Parameters: Name Type Description Default index int Index of the metric column. required Returns: Type Description typing.Optional[MetricColumn] The metric column at the given index else None if the index is invalid. Source code in src/cplus_plugin/gui/metrics_builder_model.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def metric_column ( self , index : int ) -> typing . Optional [ MetricColumn ]: \"\"\"Gets the metric column at the given location. :param index: Index of the metric column. :type index: int :returns: The metric column at the given index else None if the index is invalid. :rtype: typing.Optional[MetricColumn] \"\"\" if index < 0 or index > len ( self . _metric_columns ) - 1 : return None return self . _metric_columns [ index ] move_column \u00b6 move_column ( current_index , direction ) Move the column in the specified index left or right depending on the move direction. Parameters: Name Type Description Default current_index int Index of the column to be moved. required direction HorizontalMoveDirection Direction to move the column, either left or right. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def move_column ( self , current_index : int , direction : HorizontalMoveDirection ) -> int : \"\"\"Move the column in the specified index left or right depending on the move direction. :param current_index: Index of the column to be moved. :type current_index: int :param direction: Direction to move the column, either left or right. :type direction: HorizontalMoveDirection :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" # The activity name column will always be on the extreme left if current_index <= 1 and direction == HorizontalMoveDirection . LEFT : return - 1 if ( current_index >= self . columnCount () - 1 and direction == HorizontalMoveDirection . RIGHT ): return - 1 if direction == HorizontalMoveDirection . LEFT : new_index = current_index - 1 else : new_index = current_index + 1 # Move header and items header_item = self . takeHorizontalHeaderItem ( current_index ) column_items = self . takeColumn ( current_index ) self . insertColumn ( new_index , column_items ) self . setHorizontalHeaderItem ( new_index , header_item ) # Also reposition metric columns metric_column = self . _metric_columns . pop ( current_index - 1 ) self . _metric_columns . insert ( new_index - 1 , metric_column ) return new_index move_column_left \u00b6 move_column_left ( current_index ) Convenience method for moving a column to the left. Parameters: Name Type Description Default current_index int Index of the column to be moved. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 851 852 853 854 855 856 857 858 859 860 861 def move_column_left ( self , current_index : int ) -> int : \"\"\"Convenience method for moving a column to the left. :param current_index: Index of the column to be moved. :type current_index: int :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" return self . move_column ( current_index , HorizontalMoveDirection . LEFT ) move_column_right \u00b6 move_column_right ( current_index ) Convenience method for moving a column to the right. Parameters: Name Type Description Default current_index int Index of the column to be moved. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 863 864 865 866 867 868 869 870 871 872 873 def move_column_right ( self , current_index : int ) -> int : \"\"\"Convenience method for moving a column to the right. :param current_index: Index of the column to be moved. :type current_index: int :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" return self . move_column ( current_index , HorizontalMoveDirection . RIGHT ) remove_column \u00b6 remove_column ( index ) Remove the column at the specified index. The index will be normalized to reflect the first metric column since index zero is reserved for the activity name column which is fixed. Parameters: Name Type Description Default index int Index of the column to be removed. required Returns: Type Description bool True if the column was successfully removed else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 def remove_column ( self , index : int ) -> bool : \"\"\"Remove the column at the specified index. The index will be normalized to reflect the first metric column since index zero is reserved for the activity name column which is fixed. :param index: Index of the column to be removed. :type index: int :returns: True if the column was successfully removed else False. :rtype: bool \"\"\" if index == - 1 : return False model_index = index + 1 status = self . removeColumns ( model_index , 1 ) del self . _metric_columns [ index ] return status update_column_properties \u00b6 update_column_properties ( index , column ) Updates the properties of an underlying metric column in the model. Parameters: Name Type Description Default index int Index of the column to the updated. required column MetricColumn Updated column metric object. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def update_column_properties ( self , index : int , column : MetricColumn ): \"\"\"Updates the properties of an underlying metric column in the model. :param index: Index of the column to the updated. :type index: int :param column: Updated column metric object. :type column: MetricColumn \"\"\" model_index = index + 1 if model_index == 0 or model_index >= self . columnCount (): return # Update header self . setHeaderData ( model_index , QtCore . Qt . Orientation . Horizontal , column . header , QtCore . Qt . ItemDataRole . DisplayRole , ) self . _metric_columns [ index ] = column # Update corresponding column metric items in the given column for r in range ( self . rowCount ()): column_metric_item = self . item ( r , model_index ) if column_metric_item is None : continue # We ignore cell metrics since we do not want to change # what the user has already specified. if column_metric_item . metric_type == MetricType . CELL : continue column_metric_item . update_metric_model ( column ) validate \u00b6 validate ( highlight_invalid ) Validate the items in the model. Parameters: Name Type Description Default highlight_invalid bool True to highlight invalid activity metric column items, else False to ignore highlighting invalid items. If True, the invalid items will be highlighted for a default period of 3000ms. required Returns: Type Description bool True if the items are valid else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 def validate ( self , highlight_invalid : bool ) -> bool : \"\"\"Validate the items in the model. :param highlight_invalid: True to highlight invalid activity metric column items, else False to ignore highlighting invalid items. If True, the invalid items will be highlighted for a default period of 3000ms. :type highlight_invalid: bool :returns: True if the items are valid else False. :rtype: bool \"\"\" is_valid = True if self . _validation_highlight_timer . isActive (): self . _validation_highlight_timer . stop () self . _validation_highlight_timer . start () for r in range ( self . rowCount ()): for c in range ( 1 , self . columnCount ()): item = self . item ( r , c ) if not item . is_valid (): if is_valid : is_valid = False if highlight_invalid : item . highlight_invalid ( True ) return is_valid ActivityNameTableItem \u00b6 ActivityNameTableItem ( activity ) Bases: QStandardItem Represents an activity name in the metrics table. Source code in src/cplus_plugin/gui/metrics_builder_model.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def __init__ ( self , activity : Activity ): super () . __init__ () self . _activity = activity self . setEditable ( False ) self . setText ( activity . name ) self . setToolTip ( activity . name ) self . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) background = self . background () background . setColor ( QtCore . Qt . GlobalColor . lightGray ) background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) self . setBackground ( background ) activity property \u00b6 activity Gets the activity model in the item. Returns: Type Description Activity The activity model in the item. type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 440 441 442 443 444 445 446 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return ACTIVITY_NAME_TABLE_ITEM_TYPE HorizontalMoveDirection \u00b6 Bases: IntEnum Move an item left or right. MetricColumnListItem \u00b6 MetricColumnListItem ( name_column ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/metrics_builder_model.py 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , name_column : typing . Union [ str , MetricColumn ]): super () . __init__ () self . _column = None if isinstance ( name_column , str ): self . _column = MetricColumn ( name_column , name_column , \"\" ) else : self . _column = name_column self . name = self . _column . name column_icon = FileUtils . get_icon ( \"table_column.svg\" ) self . setIcon ( column_icon ) alignment property writable \u00b6 alignment Gest the alignment of the column text. Returns: Type Description QtCore.Qt.AlignmentFlag The alignment of the column text. auto_calculated property writable \u00b6 auto_calculated Indicates whether the column value is auto-calculated. Returns: Type Description bool True if the column value is auto-calculated else False. expression property writable \u00b6 expression Gets the column-wide expression used by activity metrics. Returns: Type Description str The column-wide expression used by the activity metrics. format_as_number property writable \u00b6 format_as_number Gets whether the result of evaluating the column or cell metric should be formatted as a number. Returns: Type Description bool True if the value should be formatted as a number else False. header property writable \u00b6 header Gets the column header. Returns: Type Description str The column header. is_valid property \u00b6 is_valid Returns the validity status of the item. The name and header label should be defined. Returns: Type Description bool True if valid, else False. model property \u00b6 model Gets the underlying data model used in the item. Returns: Type Description MetricColumn The underlying data model used in the item. name property writable \u00b6 name Gets the name of the column. Returns: Type Description str The name of the column. number_formatter property writable \u00b6 number_formatter Gets the formatter used for the value of the expression result. This is applicable if :py:attr: ~format_as_number has been set to True. Returns: Type Description QgsNumericFormat The number formatter to use. type \u00b6 type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 210 211 212 213 214 215 216 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return METRIC_COLUMN_LIST_ITEM_TYPE MetricColumnListModel \u00b6 MetricColumnListModel ( parent = None ) Bases: QStandardItemModel View model for list-based metric column objects. Source code in src/cplus_plugin/gui/metrics_builder_model.py 240 241 242 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) column_items property \u00b6 column_items Gets all the column items in the model. Returns: Type Description typing.List[MetricColumnListItem] All the column items in the model. add_column \u00b6 add_column ( column_item ) Adds a column item to the model. Parameters: Name Type Description Default column_item MetricColumnListItem Column item to be added to the model. required Returns: Type Description MetricColumnListItem | None The item successfully added to the model else None if the item could not be successfully added due to an already existing name in the model. Source code in src/cplus_plugin/gui/metrics_builder_model.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def add_column ( self , column_item : MetricColumnListItem ) -> typing . Optional [ MetricColumnListItem ]: \"\"\"Adds a column item to the model. :param column_item: Column item to be added to the model. :type column_item: MetricColumnListItem :returns: The item successfully added to the model else None if the item could not be successfully added due to an already existing name in the model. :rtype: MetricColumnListItem or None \"\"\" existing_column = self . column_exists ( column_item . name ) if existing_column : return None self . appendRow ( column_item ) self . column_added . emit ( column_item ) return column_item add_new_column \u00b6 add_new_column ( name_column ) Adds a new column to the model. Parameters: Name Type Description Default name_column Union [ str , MetricColumn ] Name of the column or metric column data model. required Returns: Type Description bool True if the column was successfully added due to an already existing column with a similar name, else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def add_new_column ( self , name_column : typing . Union [ str , MetricColumn ]) -> bool : \"\"\"Adds a new column to the model. :param name_column: Name of the column or metric column data model. :type name_column: :returns: True if the column was successfully added due to an already existing column with a similar name, else False. :rtype: bool \"\"\" column_item = MetricColumnListItem ( name_column ) item = self . add_column ( column_item ) if item is None : return False return True column_exists \u00b6 column_exists ( name ) Checks if a column with the given name exists. Parameters: Name Type Description Default name str Name of the column. required Returns: Type Description bool True if the column name exists, else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def column_exists ( self , name : str ) -> bool : \"\"\"Checks if a column with the given name exists. :param name: Name of the column. :type name: str :returns: True if the column name exists, else False. :rtype: bool \"\"\" item = self . item_from_name ( name ) if item is None : return False return True item_from_name \u00b6 item_from_name ( name ) Gets the model item from the column name. It performs a case-insensitive search of the first matching model item. Parameters: Name Type Description Default name str Name of the column. required Returns: Type Description MetricColumnListItem The first matching model item if found else None. Source code in src/cplus_plugin/gui/metrics_builder_model.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def item_from_name ( self , name : str ) -> typing . Optional [ MetricColumnListItem ]: \"\"\"Gets the model item from the column name. It performs a case-insensitive search of the first matching model item. :param name: Name of the column. :type name:str :returns: The first matching model item if found else None. :rtype: MetricColumnListItem \"\"\" items = self . findItems ( name , QtCore . Qt . MatchFlag . MatchFixedString ) if len ( items ) > 0 : return items [ 0 ] return None move_column \u00b6 move_column ( row , direction ) Moves the column item in the given row one by a level up or down as defined in the direction. Parameters: Name Type Description Default row int Position of the column item to be moved. required direction VerticalMoveDirection Direction to move the column item. required Returns: Type Description int New position of the column item or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 def move_column ( self , row : int , direction : VerticalMoveDirection ) -> int : \"\"\"Moves the column item in the given row one by a level up or down as defined in the direction. :param row: Position of the column item to be moved. :type row: int :param direction: Direction to move the column item. :type direction: VerticalMoveDirection :returns: New position of the column item or -1 if the column item was not moved. :rtype: int \"\"\" if direction == VerticalMoveDirection . UP and row < 1 : return - 1 elif direction == VerticalMoveDirection . DOWN and row >= self . rowCount () - 1 : return - 1 items = self . takeRow ( row ) if items is None or len ( items ) == 0 : return - 1 if direction == VerticalMoveDirection . UP : new_position = row - 1 elif direction == VerticalMoveDirection . DOWN : new_position = row + 1 self . insertRow ( new_position , items [ 0 ]) self . column_moved . emit ( items [ 0 ], direction ) return new_position move_column_down \u00b6 move_column_down ( row ) Moves the column item in the given row one level down. Parameters: Name Type Description Default row int Column item in the given row to be moved down. required Returns: Type Description int New position of the column item or -1 if the column item was not moved down. Source code in src/cplus_plugin/gui/metrics_builder_model.py 366 367 368 369 370 371 372 373 374 375 376 def move_column_down ( self , row : int ) -> int : \"\"\"Moves the column item in the given row one level down. :param row: Column item in the given row to be moved down. :type row: int :returns: New position of the column item or -1 if the column item was not moved down. :rtype: int \"\"\" return self . move_column ( row , VerticalMoveDirection . DOWN ) move_column_up \u00b6 move_column_up ( row ) Moves the column item in the given row one level up. Parameters: Name Type Description Default row int Column item in the given row to be moved up. required Returns: Type Description int New position of the column item or -1 if the column item was not moved up. Source code in src/cplus_plugin/gui/metrics_builder_model.py 354 355 356 357 358 359 360 361 362 363 364 def move_column_up ( self , row : int ) -> int : \"\"\"Moves the column item in the given row one level up. :param row: Column item in the given row to be moved up. :type row: int :returns: New position of the column item or -1 if the column item was not moved up. :rtype: int \"\"\" return self . move_column ( row , VerticalMoveDirection . UP ) remove_column \u00b6 remove_column ( name ) Removes the column matching the given name. Parameters: Name Type Description Default name str Name of the column to be removed. required Returns: Type Description bool True if the column was successfully removed else False if there is no column matching the given name. Source code in src/cplus_plugin/gui/metrics_builder_model.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def remove_column ( self , name : str ) -> bool : \"\"\"Removes the column matching the given name. :param name: Name of the column to be removed. :type name: str :returns: True if the column was successfully removed else False if there is no column matching the given name. :rtype: bool \"\"\" item = self . item_from_name ( name ) if item is None : return False status = self . removeRows ( item . row (), 1 ) if status : self . column_removed . emit ( item ) return status VerticalMoveDirection \u00b6 Bases: IntEnum Move an item up or down.","title":"Builder Model"},{"location":"developer/api/gui/api_metrics_builder_model/#metrics-builder-view-model","text":"MVC models for the metrics builder.","title":"Metrics Builder View Model"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem","text":"ActivityColumnMetricItem ( activity_column_metric ) Bases: QStandardItem Represents an activity's metric information for a specific column. Source code in src/cplus_plugin/gui/metrics_builder_model.py 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 def __init__ ( self , activity_column_metric : ActivityColumnMetric ): super () . __init__ () self . _activity_column_metric = activity_column_metric if activity_column_metric . metric_column . auto_calculated : self . setEditable ( False ) else : self . setEditable ( True ) self . _update_display_text () self . setTextAlignment ( self . _activity_column_metric . metric_column . alignment | QtCore . Qt . AlignmentFlag . AlignVCenter ) self . _update_tool_tip ()","title":"ActivityColumnMetricItem"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.expression","text":"expression Gets the item's expression. Returns: Type Description str Item's expression.","title":"expression"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.metric_type","text":"metric_type Gets the metric type of the underlying data model. Returns: Type Description MetricType The metric type of the underlying data model.","title":"metric_type"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.model","text":"model Gets the underlying activity column metric data model. Returns: Type Description ActivityColumnMetric The underlying activity column metric data model.","title":"model"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.highlight_invalid","text":"highlight_invalid ( show ) Highlights the item with a red background to indicate that the activity column metric is invalid. Parameters: Name Type Description Default show bool True to highlight the item else False to disable. A call to highlight will first verify that the data model is valid. If it is valid then the item will not be highlighted. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 def highlight_invalid ( self , show : bool ): \"\"\"Highlights the item with a red background to indicate that the activity column metric is invalid. :param show: True to highlight the item else False to disable. A call to highlight will first verify that the data model is valid. If it is valid then the item will not be highlighted. :type show: bool \"\"\" if self . is_valid () and show : return background = self . background () if show : background . setColor ( QtGui . QColor ( \"#ffaeae\" )) background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) else : background . setColor ( QtCore . Qt . GlobalColor . white ) background . setStyle ( QtCore . Qt . BrushStyle . NoBrush ) self . setBackground ( background )","title":"highlight_invalid"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.is_valid","text":"is_valid () Checks if the activity column metric is valid. Returns: Type Description bool True if the activity column metric is valid else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 591 592 593 594 595 596 597 598 def is_valid ( self ) -> bool : \"\"\"Checks if the activity column metric is valid. :returns: True if the activity column metric is valid else False. :rtype: bool \"\"\" return self . _activity_column_metric . is_valid ()","title":"is_valid"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.metric_type_to_str","text":"metric_type_to_str ( metric_type ) Returns the corresponding string representation for the given metric type. Parameters: Name Type Description Default metric_type MetricType Type of metric or expression. required Returns: Type Description str The corresponding string representation of the given metric type. Source code in src/cplus_plugin/gui/metrics_builder_model.py 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 @staticmethod def metric_type_to_str ( metric_type : MetricType ) -> str : \"\"\"Returns the corresponding string representation for the given metric type. :param metric_type: Type of metric or expression. :type metric_type: MetricType :returns: The corresponding string representation of the given metric type. :rtype: str \"\"\" if metric_type == MetricType . COLUMN : return tr ( COLUMN_METRIC_STR ) elif metric_type == MetricType . CELL : return tr ( CELL_METRIC_STR ) else : return tr ( \"<Not set>\" )","title":"metric_type_to_str"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 583 584 585 586 587 588 589 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return ACTIVITY_COLUMN_METRIC_TABLE_ITEM_TYPE","title":"type"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.update_metric_model","text":"update_metric_model ( model ) Updates the underlying metric model. Parameters: Name Type Description Default model MetricColumn Metric column containing updated properties. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def update_metric_model ( self , model : MetricColumn ): \"\"\"Updates the underlying metric model. :param model: Metric column containing updated properties. :type model: MetricColumn \"\"\" if ( self . _activity_column_metric . metric_type == MetricType . NOT_SET and model . expression ): self . _activity_column_metric . metric_type = MetricType . COLUMN self . _activity_column_metric . expression = model . expression elif ( self . _activity_column_metric . metric_type == MetricType . COLUMN and not model . expression ): self . _activity_column_metric . metric_type = MetricType . NOT_SET self . _activity_column_metric . expression = \"\" elif ( self . _activity_column_metric . metric_type == MetricType . COLUMN and model . expression ): # Just update the expression self . _activity_column_metric . expression = model . expression self . _activity_column_metric . metric_column = model self . _update_display_text () self . _update_tool_tip ()","title":"update_metric_model"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnMetricItem.update_metric_type","text":"update_metric_type ( metric_type , expression = '' ) Updates the metric type of the underlying metric model. Parameters: Name Type Description Default metric_type MetricType Metric type to be used by the model. required expression str Expression for the given metric type. Default is an empty string. '' Source code in src/cplus_plugin/gui/metrics_builder_model.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def update_metric_type ( self , metric_type : MetricType , expression : str = \"\" ): \"\"\"Updates the metric type of the underlying metric model. :param metric_type: Metric type to be used by the model. :type metric_type: MetricType :param expression: Expression for the given metric type. Default is an empty string. :type expression: str \"\"\" self . _activity_column_metric . metric_type = metric_type self . _activity_column_metric . expression = expression self . _update_display_text () self . _update_tool_tip ()","title":"update_metric_type"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnSummaryItem","text":"ActivityColumnSummaryItem ( activity_column_metrics ) Bases: QStandardItem Provides an item for displaying the configuration of metrics for the activity by listing the specific metrics for each column. Source code in src/cplus_plugin/gui/metrics_builder_model.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 def __init__ ( self , activity_column_metrics : typing . List [ ActivityColumnMetric ]): super () . __init__ () self . _activity_column_metrics = activity_column_metrics self . _reference_activity = None for acm in self . _activity_column_metrics : if self . _reference_activity is None : self . _reference_activity = acm . activity self . setText ( acm . activity . name ) column_item = QtGui . QStandardItem () column_item . setIcon ( FileUtils . get_icon ( \"table_column.svg\" )) column_details = ( f \" { acm . metric_column . header } : \" f \" { ActivityColumnMetricItem . metric_type_to_str ( acm . metric_type ) } \" ) column_item . setText ( column_details ) column_item . setToolTip ( acm . expression ) self . appendRow ( column_item )","title":"ActivityColumnSummaryItem"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnSummaryTreeModel","text":"ActivityColumnSummaryTreeModel ( parent = None ) Bases: QStandardItemModel View model for managing activity column metric data models in a tree view. Source code in src/cplus_plugin/gui/metrics_builder_model.py 965 966 967 968 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 )","title":"ActivityColumnSummaryTreeModel"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityColumnSummaryTreeModel.set_summary_models","text":"set_summary_models ( activity_metric_models ) Update the model to use the specified activity column metric data models. Any existing items will be removed prior to loading the specified data models. Parameters: Name Type Description Default activity_metric_models List [ List [ ActivityColumnMetric ]] Nested list of activity column metric data models. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 def set_summary_models ( self , activity_metric_models : typing . List [ typing . List [ ActivityColumnMetric ]] ): \"\"\"Update the model to use the specified activity column metric data models. Any existing items will be removed prior to loading the specified data models. :param activity_metric_models: Nested list of activity column metric data models. :type activity_metric_models: typing.List[typing.List[ActivityColumnMetric]] \"\"\" # Clear any prior existing items self . removeRows ( 0 , self . rowCount ()) for activity_metric_row in activity_metric_models : summary_item = ActivityColumnSummaryItem ( activity_metric_row ) self . appendRow ( summary_item )","title":"set_summary_models"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel","text":"ActivityMetricTableModel ( parent = None , columns = None ) Bases: QStandardItemModel View model for activity metrics in a table. Source code in src/cplus_plugin/gui/metrics_builder_model.py 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 def __init__ ( self , parent = None , columns : typing . List [ MetricColumn ] = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 ) # Add default activity name header self . setHorizontalHeaderLabels ([ tr ( ACTIVITY_NAME )]) self . _metric_columns = [] if columns is not None : self . _metric_columns = columns # Timer for intermittently showing invalid items self . _validation_highlight_timer = QtCore . QTimer () self . _validation_highlight_timer . setSingleShot ( True ) self . _validation_highlight_timer . setInterval ( 5000 ) self . _validation_highlight_timer . timeout . connect ( self . _on_validation_highlight_timeout )","title":"ActivityMetricTableModel"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.activities","text":"activities Gets all the activities in the model. Returns: Type Description typing.List[Activity] All activities in the model.","title":"activities"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.metric_columns","text":"metric_columns Gets the metric columns used in the model to define the headers. Returns: Type Description typing.List[MetricColumn] Metric columns used in the model.","title":"metric_columns"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.models","text":"models Gets the mapping of activity column metric data models. Returns: Type Description typing.List[typing.List[ActivityColumnMetric]] A nested list of activity column metrics in the same order that they are stored in the model.","title":"models"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.append_activity","text":"append_activity ( activity ) Adds an activity row in the activity metrics table. Parameters: Name Type Description Default activity Activity Activity to be added. required Returns: Type Description bool True if the activity was successfully added else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 def append_activity ( self , activity : Activity ) -> bool : \"\"\"Adds an activity row in the activity metrics table. :param activity: Activity to be added. :type activity: Activity :returns: True if the activity was successfully added else False. :rtype: bool \"\"\" # Check if there is a similar activity matching_activities = [ act for act in self . activities if act . uuid == activity . uuid ] if len ( matching_activities ) > 0 : return False row_items = [] activity_item = ActivityNameTableItem ( activity ) row_items . append ( activity_item ) # Set corresponding activity column metric items for mc in self . _metric_columns : activity_column_metric = ActivityColumnMetric ( activity , mc , MetricType . COLUMN if mc . expression else MetricType . NOT_SET , mc . expression if mc . expression else \"\" , ) row_items . append ( ActivityColumnMetricItem ( activity_column_metric )) self . appendRow ( row_items ) return True","title":"append_activity"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.append_column","text":"append_column ( column ) Adds a column to the model based on the information in the metric column. Parameters: Name Type Description Default column MetricColumn Metric column containing information for defining the new column. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 def append_column ( self , column : MetricColumn ): \"\"\"Adds a column to the model based on the information in the metric column. :param column: Metric column containing information for defining the new column. :type column: MetricColumn \"\"\" column_items = [] # Update rows based on the selected activities for activity in self . activities : activity_column_metric = ActivityColumnMetric ( activity , column , MetricType . COLUMN if column . expression else MetricType . NOT_SET , column . expression if column . expression else \"\" , ) item = ActivityColumnMetricItem ( activity_column_metric ) column_items . append ( item ) self . appendColumn ( column_items ) self . setHeaderData ( self . columnCount () - 1 , QtCore . Qt . Orientation . Horizontal , column . header , QtCore . Qt . ItemDataRole . DisplayRole , ) self . _metric_columns . append ( column )","title":"append_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.metric_column","text":"metric_column ( index ) Gets the metric column at the given location. Parameters: Name Type Description Default index int Index of the metric column. required Returns: Type Description typing.Optional[MetricColumn] The metric column at the given index else None if the index is invalid. Source code in src/cplus_plugin/gui/metrics_builder_model.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 def metric_column ( self , index : int ) -> typing . Optional [ MetricColumn ]: \"\"\"Gets the metric column at the given location. :param index: Index of the metric column. :type index: int :returns: The metric column at the given index else None if the index is invalid. :rtype: typing.Optional[MetricColumn] \"\"\" if index < 0 or index > len ( self . _metric_columns ) - 1 : return None return self . _metric_columns [ index ]","title":"metric_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.move_column","text":"move_column ( current_index , direction ) Move the column in the specified index left or right depending on the move direction. Parameters: Name Type Description Default current_index int Index of the column to be moved. required direction HorizontalMoveDirection Direction to move the column, either left or right. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def move_column ( self , current_index : int , direction : HorizontalMoveDirection ) -> int : \"\"\"Move the column in the specified index left or right depending on the move direction. :param current_index: Index of the column to be moved. :type current_index: int :param direction: Direction to move the column, either left or right. :type direction: HorizontalMoveDirection :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" # The activity name column will always be on the extreme left if current_index <= 1 and direction == HorizontalMoveDirection . LEFT : return - 1 if ( current_index >= self . columnCount () - 1 and direction == HorizontalMoveDirection . RIGHT ): return - 1 if direction == HorizontalMoveDirection . LEFT : new_index = current_index - 1 else : new_index = current_index + 1 # Move header and items header_item = self . takeHorizontalHeaderItem ( current_index ) column_items = self . takeColumn ( current_index ) self . insertColumn ( new_index , column_items ) self . setHorizontalHeaderItem ( new_index , header_item ) # Also reposition metric columns metric_column = self . _metric_columns . pop ( current_index - 1 ) self . _metric_columns . insert ( new_index - 1 , metric_column ) return new_index","title":"move_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.move_column_left","text":"move_column_left ( current_index ) Convenience method for moving a column to the left. Parameters: Name Type Description Default current_index int Index of the column to be moved. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 851 852 853 854 855 856 857 858 859 860 861 def move_column_left ( self , current_index : int ) -> int : \"\"\"Convenience method for moving a column to the left. :param current_index: Index of the column to be moved. :type current_index: int :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" return self . move_column ( current_index , HorizontalMoveDirection . LEFT )","title":"move_column_left"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.move_column_right","text":"move_column_right ( current_index ) Convenience method for moving a column to the right. Parameters: Name Type Description Default current_index int Index of the column to be moved. required Returns: Type Description int New position of the column or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 863 864 865 866 867 868 869 870 871 872 873 def move_column_right ( self , current_index : int ) -> int : \"\"\"Convenience method for moving a column to the right. :param current_index: Index of the column to be moved. :type current_index: int :returns: New position of the column or -1 if the column item was not moved. :rtype: int \"\"\" return self . move_column ( current_index , HorizontalMoveDirection . RIGHT )","title":"move_column_right"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.remove_column","text":"remove_column ( index ) Remove the column at the specified index. The index will be normalized to reflect the first metric column since index zero is reserved for the activity name column which is fixed. Parameters: Name Type Description Default index int Index of the column to be removed. required Returns: Type Description bool True if the column was successfully removed else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 def remove_column ( self , index : int ) -> bool : \"\"\"Remove the column at the specified index. The index will be normalized to reflect the first metric column since index zero is reserved for the activity name column which is fixed. :param index: Index of the column to be removed. :type index: int :returns: True if the column was successfully removed else False. :rtype: bool \"\"\" if index == - 1 : return False model_index = index + 1 status = self . removeColumns ( model_index , 1 ) del self . _metric_columns [ index ] return status","title":"remove_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.update_column_properties","text":"update_column_properties ( index , column ) Updates the properties of an underlying metric column in the model. Parameters: Name Type Description Default index int Index of the column to the updated. required column MetricColumn Updated column metric object. required Source code in src/cplus_plugin/gui/metrics_builder_model.py 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 def update_column_properties ( self , index : int , column : MetricColumn ): \"\"\"Updates the properties of an underlying metric column in the model. :param index: Index of the column to the updated. :type index: int :param column: Updated column metric object. :type column: MetricColumn \"\"\" model_index = index + 1 if model_index == 0 or model_index >= self . columnCount (): return # Update header self . setHeaderData ( model_index , QtCore . Qt . Orientation . Horizontal , column . header , QtCore . Qt . ItemDataRole . DisplayRole , ) self . _metric_columns [ index ] = column # Update corresponding column metric items in the given column for r in range ( self . rowCount ()): column_metric_item = self . item ( r , model_index ) if column_metric_item is None : continue # We ignore cell metrics since we do not want to change # what the user has already specified. if column_metric_item . metric_type == MetricType . CELL : continue column_metric_item . update_metric_model ( column )","title":"update_column_properties"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityMetricTableModel.validate","text":"validate ( highlight_invalid ) Validate the items in the model. Parameters: Name Type Description Default highlight_invalid bool True to highlight invalid activity metric column items, else False to ignore highlighting invalid items. If True, the invalid items will be highlighted for a default period of 3000ms. required Returns: Type Description bool True if the items are valid else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 def validate ( self , highlight_invalid : bool ) -> bool : \"\"\"Validate the items in the model. :param highlight_invalid: True to highlight invalid activity metric column items, else False to ignore highlighting invalid items. If True, the invalid items will be highlighted for a default period of 3000ms. :type highlight_invalid: bool :returns: True if the items are valid else False. :rtype: bool \"\"\" is_valid = True if self . _validation_highlight_timer . isActive (): self . _validation_highlight_timer . stop () self . _validation_highlight_timer . start () for r in range ( self . rowCount ()): for c in range ( 1 , self . columnCount ()): item = self . item ( r , c ) if not item . is_valid (): if is_valid : is_valid = False if highlight_invalid : item . highlight_invalid ( True ) return is_valid","title":"validate"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityNameTableItem","text":"ActivityNameTableItem ( activity ) Bases: QStandardItem Represents an activity name in the metrics table. Source code in src/cplus_plugin/gui/metrics_builder_model.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 def __init__ ( self , activity : Activity ): super () . __init__ () self . _activity = activity self . setEditable ( False ) self . setText ( activity . name ) self . setToolTip ( activity . name ) self . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) background = self . background () background . setColor ( QtCore . Qt . GlobalColor . lightGray ) background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) self . setBackground ( background )","title":"ActivityNameTableItem"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityNameTableItem.activity","text":"activity Gets the activity model in the item. Returns: Type Description Activity The activity model in the item.","title":"activity"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.ActivityNameTableItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 440 441 442 443 444 445 446 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return ACTIVITY_NAME_TABLE_ITEM_TYPE","title":"type"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.HorizontalMoveDirection","text":"Bases: IntEnum Move an item left or right.","title":"HorizontalMoveDirection"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem","text":"MetricColumnListItem ( name_column ) Bases: QStandardItem Represents a single carbon layer path. Source code in src/cplus_plugin/gui/metrics_builder_model.py 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , name_column : typing . Union [ str , MetricColumn ]): super () . __init__ () self . _column = None if isinstance ( name_column , str ): self . _column = MetricColumn ( name_column , name_column , \"\" ) else : self . _column = name_column self . name = self . _column . name column_icon = FileUtils . get_icon ( \"table_column.svg\" ) self . setIcon ( column_icon )","title":"MetricColumnListItem"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.alignment","text":"alignment Gest the alignment of the column text. Returns: Type Description QtCore.Qt.AlignmentFlag The alignment of the column text.","title":"alignment"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.auto_calculated","text":"auto_calculated Indicates whether the column value is auto-calculated. Returns: Type Description bool True if the column value is auto-calculated else False.","title":"auto_calculated"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.expression","text":"expression Gets the column-wide expression used by activity metrics. Returns: Type Description str The column-wide expression used by the activity metrics.","title":"expression"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.format_as_number","text":"format_as_number Gets whether the result of evaluating the column or cell metric should be formatted as a number. Returns: Type Description bool True if the value should be formatted as a number else False.","title":"format_as_number"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.header","text":"header Gets the column header. Returns: Type Description str The column header.","title":"header"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.is_valid","text":"is_valid Returns the validity status of the item. The name and header label should be defined. Returns: Type Description bool True if valid, else False.","title":"is_valid"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.model","text":"model Gets the underlying data model used in the item. Returns: Type Description MetricColumn The underlying data model used in the item.","title":"model"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.name","text":"name Gets the name of the column. Returns: Type Description str The name of the column.","title":"name"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.number_formatter","text":"number_formatter Gets the formatter used for the value of the expression result. This is applicable if :py:attr: ~format_as_number has been set to True. Returns: Type Description QgsNumericFormat The number formatter to use.","title":"number_formatter"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListItem.type","text":"type () Returns the type of the standard item. Returns: Type Description int Type identifier of the item. Source code in src/cplus_plugin/gui/metrics_builder_model.py 210 211 212 213 214 215 216 def type ( self ) -> int : \"\"\"Returns the type of the standard item. :returns: Type identifier of the item. :rtype: int \"\"\" return METRIC_COLUMN_LIST_ITEM_TYPE","title":"type"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel","text":"MetricColumnListModel ( parent = None ) Bases: QStandardItemModel View model for list-based metric column objects. Source code in src/cplus_plugin/gui/metrics_builder_model.py 240 241 242 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 1 )","title":"MetricColumnListModel"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.column_items","text":"column_items Gets all the column items in the model. Returns: Type Description typing.List[MetricColumnListItem] All the column items in the model.","title":"column_items"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.add_column","text":"add_column ( column_item ) Adds a column item to the model. Parameters: Name Type Description Default column_item MetricColumnListItem Column item to be added to the model. required Returns: Type Description MetricColumnListItem | None The item successfully added to the model else None if the item could not be successfully added due to an already existing name in the model. Source code in src/cplus_plugin/gui/metrics_builder_model.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def add_column ( self , column_item : MetricColumnListItem ) -> typing . Optional [ MetricColumnListItem ]: \"\"\"Adds a column item to the model. :param column_item: Column item to be added to the model. :type column_item: MetricColumnListItem :returns: The item successfully added to the model else None if the item could not be successfully added due to an already existing name in the model. :rtype: MetricColumnListItem or None \"\"\" existing_column = self . column_exists ( column_item . name ) if existing_column : return None self . appendRow ( column_item ) self . column_added . emit ( column_item ) return column_item","title":"add_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.add_new_column","text":"add_new_column ( name_column ) Adds a new column to the model. Parameters: Name Type Description Default name_column Union [ str , MetricColumn ] Name of the column or metric column data model. required Returns: Type Description bool True if the column was successfully added due to an already existing column with a similar name, else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def add_new_column ( self , name_column : typing . Union [ str , MetricColumn ]) -> bool : \"\"\"Adds a new column to the model. :param name_column: Name of the column or metric column data model. :type name_column: :returns: True if the column was successfully added due to an already existing column with a similar name, else False. :rtype: bool \"\"\" column_item = MetricColumnListItem ( name_column ) item = self . add_column ( column_item ) if item is None : return False return True","title":"add_new_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.column_exists","text":"column_exists ( name ) Checks if a column with the given name exists. Parameters: Name Type Description Default name str Name of the column. required Returns: Type Description bool True if the column name exists, else False. Source code in src/cplus_plugin/gui/metrics_builder_model.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def column_exists ( self , name : str ) -> bool : \"\"\"Checks if a column with the given name exists. :param name: Name of the column. :type name: str :returns: True if the column name exists, else False. :rtype: bool \"\"\" item = self . item_from_name ( name ) if item is None : return False return True","title":"column_exists"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.item_from_name","text":"item_from_name ( name ) Gets the model item from the column name. It performs a case-insensitive search of the first matching model item. Parameters: Name Type Description Default name str Name of the column. required Returns: Type Description MetricColumnListItem The first matching model item if found else None. Source code in src/cplus_plugin/gui/metrics_builder_model.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def item_from_name ( self , name : str ) -> typing . Optional [ MetricColumnListItem ]: \"\"\"Gets the model item from the column name. It performs a case-insensitive search of the first matching model item. :param name: Name of the column. :type name:str :returns: The first matching model item if found else None. :rtype: MetricColumnListItem \"\"\" items = self . findItems ( name , QtCore . Qt . MatchFlag . MatchFixedString ) if len ( items ) > 0 : return items [ 0 ] return None","title":"item_from_name"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.move_column","text":"move_column ( row , direction ) Moves the column item in the given row one by a level up or down as defined in the direction. Parameters: Name Type Description Default row int Position of the column item to be moved. required direction VerticalMoveDirection Direction to move the column item. required Returns: Type Description int New position of the column item or -1 if the column item was not moved. Source code in src/cplus_plugin/gui/metrics_builder_model.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 def move_column ( self , row : int , direction : VerticalMoveDirection ) -> int : \"\"\"Moves the column item in the given row one by a level up or down as defined in the direction. :param row: Position of the column item to be moved. :type row: int :param direction: Direction to move the column item. :type direction: VerticalMoveDirection :returns: New position of the column item or -1 if the column item was not moved. :rtype: int \"\"\" if direction == VerticalMoveDirection . UP and row < 1 : return - 1 elif direction == VerticalMoveDirection . DOWN and row >= self . rowCount () - 1 : return - 1 items = self . takeRow ( row ) if items is None or len ( items ) == 0 : return - 1 if direction == VerticalMoveDirection . UP : new_position = row - 1 elif direction == VerticalMoveDirection . DOWN : new_position = row + 1 self . insertRow ( new_position , items [ 0 ]) self . column_moved . emit ( items [ 0 ], direction ) return new_position","title":"move_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.move_column_down","text":"move_column_down ( row ) Moves the column item in the given row one level down. Parameters: Name Type Description Default row int Column item in the given row to be moved down. required Returns: Type Description int New position of the column item or -1 if the column item was not moved down. Source code in src/cplus_plugin/gui/metrics_builder_model.py 366 367 368 369 370 371 372 373 374 375 376 def move_column_down ( self , row : int ) -> int : \"\"\"Moves the column item in the given row one level down. :param row: Column item in the given row to be moved down. :type row: int :returns: New position of the column item or -1 if the column item was not moved down. :rtype: int \"\"\" return self . move_column ( row , VerticalMoveDirection . DOWN )","title":"move_column_down"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.move_column_up","text":"move_column_up ( row ) Moves the column item in the given row one level up. Parameters: Name Type Description Default row int Column item in the given row to be moved up. required Returns: Type Description int New position of the column item or -1 if the column item was not moved up. Source code in src/cplus_plugin/gui/metrics_builder_model.py 354 355 356 357 358 359 360 361 362 363 364 def move_column_up ( self , row : int ) -> int : \"\"\"Moves the column item in the given row one level up. :param row: Column item in the given row to be moved up. :type row: int :returns: New position of the column item or -1 if the column item was not moved up. :rtype: int \"\"\" return self . move_column ( row , VerticalMoveDirection . UP )","title":"move_column_up"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.MetricColumnListModel.remove_column","text":"remove_column ( name ) Removes the column matching the given name. Parameters: Name Type Description Default name str Name of the column to be removed. required Returns: Type Description bool True if the column was successfully removed else False if there is no column matching the given name. Source code in src/cplus_plugin/gui/metrics_builder_model.py 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 def remove_column ( self , name : str ) -> bool : \"\"\"Removes the column matching the given name. :param name: Name of the column to be removed. :type name: str :returns: True if the column was successfully removed else False if there is no column matching the given name. :rtype: bool \"\"\" item = self . item_from_name ( name ) if item is None : return False status = self . removeRows ( item . row (), 1 ) if status : self . column_removed . emit ( item ) return status","title":"remove_column"},{"location":"developer/api/gui/api_metrics_builder_model/#src.cplus_plugin.gui.metrics_builder_model.VerticalMoveDirection","text":"Bases: IntEnum Move an item up or down.","title":"VerticalMoveDirection"},{"location":"developer/api/gui/api_model_component_widget/","text":"Model component widget \u00b6 Composite list view-based widgets for displaying activity and NCS pathway items. ActivityComponentWidget \u00b6 ActivityComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing activities. Source code in src/cplus_plugin/gui/model_component_widget.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = ActivityItemModel ( parent ) self . item_model . activity_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False ) self . btn_pixel_editor = None self . add_auxiliary_widgets () activities \u00b6 activities () Returns a collection of activity objects in the list view. Returns: Type Description list Collection of activity objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 737 738 739 740 741 742 743 744 745 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns a collection of activity objects in the list view. :returns: Collection of activity objects in the list view. :rtype: list \"\"\" return self . item_model . activities () add_activity \u00b6 add_activity ( activity , layer = None ) Adds an activity object to the view with the option of specifying the layer. Parameters: Name Type Description Default activity Activity activity object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the activity. None Returns: Type Description bool True if the activity was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 def add_activity ( self , activity : Activity , layer : QgsMapLayer = None ): \"\"\"Adds an activity object to the view with the option of specifying the layer. :param activity: activity object to be added to the view. :type activity: Activity :param layer: Optional map layer to be added to the activity. :type layer: QgsMapLayer :returns: True if the activity was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_activity ( activity , layer ) add_auxiliary_widgets \u00b6 add_auxiliary_widgets () Adds additional action widgets for managing activities. Source code in src/cplus_plugin/gui/model_component_widget.py 747 748 749 750 751 752 753 754 755 756 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing activities.\"\"\" self . btn_pixel_editor = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"rendererCategorizedSymbol.svg\" ) self . btn_pixel_editor . setIcon ( style_icon ) self . btn_pixel_editor . setToolTip ( self . tr ( \"Show dialog for ordering pixel values for styling.\" ) ) self . btn_pixel_editor . clicked . connect ( self . on_show_pixel_value_editor ) self . add_action_widget ( self . btn_pixel_editor ) add_ncs_pathway_items \u00b6 add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target activity item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the activity. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target activity item needs to have been selected. :param ncs_items: NCS pathway items to be added to the activity. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_activities = self . selected_items () if len ( selected_activities ) == 0 or len ( selected_activities ) > 1 : return False sel_activity = selected_activities [ 0 ] item_type = sel_activity . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_activity . parent is None : return False sel_activity = sel_activity . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_activity ) return status clear \u00b6 clear () Removes all activity items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 805 806 807 808 809 def clear ( self ): \"\"\"Removes all activity items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_activity ( item . uuid ) load \u00b6 load () Load activities from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 811 812 813 814 815 816 def load ( self ): \"\"\"Load activities from settings.\"\"\" self . clear () for activity in settings_manager . get_all_activities (): self . add_activity ( activity ) model_items \u00b6 model_items () Returns a collection of all ActivityItem objects in the list view. Returns: Type Description list Collection of ActivityItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 795 796 797 798 799 800 801 802 803 def model_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns a collection of all ActivityItem objects in the list view. :returns: Collection of ActivityItem objects in the list view. :rtype: list \"\"\" return self . item_model . activity_items () model_names \u00b6 model_names () Gets the names of the activities in the item model. Returns: Type Description list Returns the names of activities in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 775 776 777 778 779 780 781 782 783 784 785 786 787 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the activities in the item model. :returns: Returns the names of activities in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . activities () return [ mc . name . lower () for mc in model_components ] on_pathways_updated \u00b6 on_pathways_updated ( activity_item ) Slot raised when the pathways of an ActivityItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 789 790 791 792 793 def on_pathways_updated ( self , activity_item : ActivityItem ): \"\"\"Slot raised when the pathways of an ActivityItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( activity_item ) on_show_pixel_value_editor \u00b6 on_show_pixel_value_editor () Slot raised to show editor dialog for managing activity pixel values for styling. Source code in src/cplus_plugin/gui/model_component_widget.py 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 def on_show_pixel_value_editor ( self ): \"\"\"Slot raised to show editor dialog for managing activity pixel values for styling. \"\"\" pixel_dialog = PixelValueEditorDialog ( self ) if pixel_dialog . exec () == QtWidgets . QDialog . DialogCode . Accepted : # Update pixel values pixel_values = pixel_dialog . item_mapping for val , activity_id in pixel_values . items (): activity = settings_manager . get_activity ( activity_id ) if not activity : continue activity . style_pixel_value = val settings_manager . update_activity ( activity ) self . load () reassign_pixel_values \u00b6 reassign_pixel_values ( start_position ) Reassign the styling pixel values for activities from the given start position. It is important to call this function when the maximum pixel value does not match the number of activities such as when one or more activities have been deleted. Parameters: Name Type Description Default start_position int Position to start reassigning the pixel values. required Source code in src/cplus_plugin/gui/model_component_widget.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 def reassign_pixel_values ( self , start_position : int ): \"\"\"Reassign the styling pixel values for activities from the given start position. It is important to call this function when the maximum pixel value does not match the number of activities such as when one or more activities have been deleted. :param start_position: Position to start reassigning the pixel values. :type start_position: int \"\"\" sorted_activities = sorted ( settings_manager . get_all_activities (), key = lambda activity : activity . style_pixel_value , ) remap_activities = sorted_activities [ start_position - 1 :] for val , activity in enumerate ( remap_activities , start = start_position ): activity . style_pixel_value = val settings_manager . update_activity ( activity ) self . load () remove_ncs_pathway_items \u00b6 remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items used for activities that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway_uuid str NCS pathway whose corresponding items will be deleted in the activity items that contain it. required Source code in src/cplus_plugin/gui/model_component_widget.py 1033 1034 1035 1036 1037 1038 1039 1040 1041 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items used for activities that are linked to the given NCS pathway. :param ncs_pathway_uuid: NCS pathway whose corresponding items will be deleted in the activity items that contain it. :type ncs_pathway_uuid: str \"\"\" self . item_model . remove_ncs_pathway_items ( ncs_pathway_uuid ) update_ncs_pathway_items \u00b6 update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for activities that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the activities. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for activities that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the activities. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway ) ModelComponentWidget \u00b6 ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model self . lst_model_items . doubleClicked . connect ( self . _on_double_click_item ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description ) item_model property writable \u00b6 item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view. selection_model property \u00b6 selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model. title property writable \u00b6 title Returns the title of the view. Returns: Type Description str Title of the view. add_action_widget \u00b6 add_action_widget ( widget ) Adds an auxiliary widget below the list view from the left-hand side. Parameters: Name Type Description Default widget QWidget Widget to be added to the collection of controls below the list view. required Source code in src/cplus_plugin/gui/model_component_widget.py 330 331 332 333 334 335 336 337 def add_action_widget ( self , widget : QtWidgets . QWidget ): \"\"\"Adds an auxiliary widget below the list view from the left-hand side. :param widget: Widget to be added to the collection of controls below the list view. :type widget: QtWidgets.QWidget \"\"\" self . widget_container . addWidget ( widget ) clear \u00b6 clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 282 283 284 285 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass clear_description \u00b6 clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 198 199 200 201 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" ) enable_default_items \u00b6 enable_default_items ( state ) Enable or disable default model component items in the view. Parameters: Name Type Description Default state bool True to enable or False to disable default model component items. required Source code in src/cplus_plugin/gui/model_component_widget.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable default model component items in the view. :param state: True to enable or False to disable default model component items. :type state: bool \"\"\" self . _item_model . enable_default_items ( state ) # If false, deselect default items if not state : selection_model = self . lst_model_items . selectionModel () selected_idxs = selection_model . selectedRows () for sel_idx in selected_idxs : item = self . _item_model . item ( sel_idx . row (), 0 ) # If not enabled then deselect if not item . isEnabled (): selection_model . select ( sel_idx , QtCore . QItemSelectionModel . SelectionFlag . Deselect ) load \u00b6 load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 133 134 135 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass model_names \u00b6 model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 295 296 297 298 299 300 301 302 303 304 305 306 307 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ] selected_items \u00b6 selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ] set_description \u00b6 set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 189 190 191 192 193 194 195 196 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description ) NcsComponentWidget \u00b6 NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def __init__ ( self , parent = None ): super () . __init__ ( parent ) # Add option for deleting disabled items self . btn_remove . clicked . disconnect ( self . _on_remove_item ) self . _delete_menu = QtWidgets . QMenu () self . _remove_default_action = self . _delete_menu . addAction ( FileUtils . get_icon ( \"symbologyRemove.svg\" ), \"Remove Selected\" ) self . _remove_default_action . setEnabled ( False ) self . _remove_default_action . triggered . connect ( self . _on_remove_item ) self . _remove_disabled_action = self . _delete_menu . addAction ( FileUtils . get_icon ( \"repositoryDisabled.svg\" ), \"Remove Disabled\" ) self . _remove_disabled_action . setEnabled ( False ) self . _remove_disabled_action . triggered . connect ( self . _on_remove_disabled ) self . btn_remove . setMenu ( self . _delete_menu ) self . btn_remove . setDefaultAction ( self . _remove_default_action ) self . btn_remove . setPopupMode ( QtWidgets . QToolButton . ToolButtonPopupMode . MenuButtonPopup ) self . btn_remove . triggered . connect ( self . on_delete_triggered ) self . item_model = NcsPathwayItemModel ( parent ) self . item_model . itemChanged . connect ( self . on_item_changed ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DragOnly ) self . lst_model_items . setAcceptDrops ( False ) self . _validation_manager = validation_manager self . _validation_submit_result = None self . btn_validate_pathways = None self . add_auxiliary_widgets () add_auxiliary_widgets \u00b6 add_auxiliary_widgets () Adds additional action widgets for managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 498 499 500 501 502 503 504 505 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing NCS pathways.\"\"\" self . btn_validate_pathways = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"mIconRasterValidate.svg\" ) self . btn_validate_pathways . setIcon ( style_icon ) self . btn_validate_pathways . setToolTip ( self . tr ( \"Show validation inspector\" )) self . btn_validate_pathways . clicked . connect ( self . on_load_validation_inspector ) self . add_action_widget ( self . btn_validate_pathways ) add_ncs_pathway \u00b6 add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 486 487 488 489 490 491 492 493 494 495 496 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway ) clear \u00b6 clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 507 508 509 510 511 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid ) is_valid \u00b6 is_valid () Returns whether the NCS pathways are valid based on the validation against a given set of rules defined for an NCSValidator. The validation process is automatically triggered through the validation manager object. Returns: Type Description bool True if the NCS pathways are valid, else False. If the validation result has warnings and no errors, the overall results will be True. However, if there are errors, it will return False. Source code in src/cplus_plugin/gui/model_component_widget.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def is_valid ( self ) -> bool : \"\"\"Returns whether the NCS pathways are valid based on the validation against a given set of rules defined for an NCSValidator. The validation process is automatically triggered through the validation manager object. :returns: True if the NCS pathways are valid, else False. If the validation result has warnings and no errors, the overall results will be True. However, if there are errors, it will return False. :rtype: bool \"\"\" if self . _validation_submit_result is None : return False if not self . _validation_submit_result . success : return False if self . _validation_manager . is_validation_complete ( self . _validation_submit_result ): validation_result = self . _validation_manager . validation_result ( self . _validation_submit_result ) if validation_result . success : return True if validation_result . warnings and not validation_result . errors : return True return False load \u00b6 load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () if len ( ncs_pathways ) > 0 : progress_dialog = QtWidgets . QProgressDialog ( self ) progress_dialog . setWindowTitle ( self . tr ( \"Load NCS Pathways\" )) progress_dialog . setMinimum ( 0 ) progress_dialog . setMaximum ( len ( ncs_pathways )) progress_dialog . setLabelText ( self . tr ( \"Updating NCS pathways...\" )) for i , ncs in enumerate ( ncs_pathways , start = 1 ): progress_dialog . setValue ( i ) if progress_dialog . wasCanceled (): break self . add_ncs_pathway ( ncs ) self . validate_pathways () ncs_items \u00b6 ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 557 558 559 560 561 562 563 564 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items () on_delete_triggered \u00b6 on_delete_triggered ( action ) Slot raised to select the default delete action. Parameters: Name Type Description Default action QAction Action that has been triggered. required Source code in src/cplus_plugin/gui/model_component_widget.py 389 390 391 392 393 394 395 def on_delete_triggered ( self , action : QtWidgets . QAction ): \"\"\"Slot raised to select the default delete action. :param action: Action that has been triggered. :type action: QtWidgets.QAction \"\"\" self . btn_remove . setDefaultAction ( action ) on_item_changed \u00b6 on_item_changed ( item ) Slot raised when the data of an NCS pathway item changes. Parameters: Name Type Description Default item NcsPathwayItem NCS pathway item whose data has changed. required Source code in src/cplus_plugin/gui/model_component_widget.py 446 447 448 449 450 451 452 453 454 def on_item_changed ( self , item : NcsPathwayItem ): \"\"\"Slot raised when the data of an NCS pathway item changes. :param item: NCS pathway item whose data has changed. :type item: NcsPathwayItem \"\"\" # Check if there are items disabled and enable or disable # the option for deleting disabled items. self . _on_item_and_selection_changed () on_load_validation_inspector \u00b6 on_load_validation_inspector () Slot raised to show the validation inspector dialog. If the validation process is not yet completed, a progress dialog will be shown. Source code in src/cplus_plugin/gui/model_component_widget.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def on_load_validation_inspector ( self ): \"\"\"Slot raised to show the validation inspector dialog. If the validation process is not yet completed, a progress dialog will be shown. \"\"\" if self . _validation_submit_result is None : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Load Validation Inspector\" ), self . tr ( \"Unable to show the validation inspector window. \\n No request for validation has been submitted.\" ), ) log ( message = \"Unable to load validation inspector\" , info = False ) return if self . _validation_manager . is_validation_complete ( self . _validation_submit_result ): validation_result = self . _validation_manager . validation_result ( self . _validation_submit_result ) if validation_result is None : return self . inspector_dialog = ValidationInspectorDialog ( result = validation_result ) self . inspector_dialog . setModal ( False ) self . inspector_dialog . show () else : # Show progress dialog progress_dialog = ValidationProgressDialog ( self . _validation_submit_result , self ) progress_dialog . exec () pathways \u00b6 pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 513 514 515 516 517 518 519 520 521 522 523 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only ) validate_pathways \u00b6 validate_pathways () Validates NCS pathway model components against a given set of rules using the ValidationManager. Source code in src/cplus_plugin/gui/model_component_widget.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def validate_pathways ( self ): \"\"\"Validates NCS pathway model components against a given set of rules using the ValidationManager. \"\"\" self . _validation_submit_result = None ncs_pathways = self . pathways () # No need for validating if there are no NCS pathways. if len ( ncs_pathways ) == 0 : log ( message = \"At least one NCS pathway is required for the validation process to be initiated.\" , info = False , ) return self . _validation_submit_result = validation_manager . validate_ncs_pathways ( ncs_pathways ) if not self . _validation_submit_result . success : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Validate NCS Pathways\" ), self . tr ( \"Unable to submit NCS pathways for validation\" ), ) log ( message = \"Unable to submit NCS pathways for validation\" , info = False ) return","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#model-component-widget","text":"Composite list view-based widgets for displaying activity and NCS pathway items.","title":"Model component widget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget","text":"ActivityComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing activities. Source code in src/cplus_plugin/gui/model_component_widget.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . item_model = ActivityItemModel ( parent ) self . item_model . activity_pathways_updated . connect ( self . on_pathways_updated ) self . lst_model_items . setAcceptDrops ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DropOnly ) self . lst_model_items . setDropIndicatorShown ( True ) self . btn_reload . setVisible ( False ) self . btn_pixel_editor = None self . add_auxiliary_widgets ()","title":"ActivityComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.activities","text":"activities () Returns a collection of activity objects in the list view. Returns: Type Description list Collection of activity objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 737 738 739 740 741 742 743 744 745 def activities ( self ) -> typing . List [ Activity ]: \"\"\"Returns a collection of activity objects in the list view. :returns: Collection of activity objects in the list view. :rtype: list \"\"\" return self . item_model . activities ()","title":"activities"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.add_activity","text":"add_activity ( activity , layer = None ) Adds an activity object to the view with the option of specifying the layer. Parameters: Name Type Description Default activity Activity activity object to be added to the view. required layer QgsMapLayer Optional map layer to be added to the activity. None Returns: Type Description bool True if the activity was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 def add_activity ( self , activity : Activity , layer : QgsMapLayer = None ): \"\"\"Adds an activity object to the view with the option of specifying the layer. :param activity: activity object to be added to the view. :type activity: Activity :param layer: Optional map layer to be added to the activity. :type layer: QgsMapLayer :returns: True if the activity was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_activity ( activity , layer )","title":"add_activity"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.add_auxiliary_widgets","text":"add_auxiliary_widgets () Adds additional action widgets for managing activities. Source code in src/cplus_plugin/gui/model_component_widget.py 747 748 749 750 751 752 753 754 755 756 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing activities.\"\"\" self . btn_pixel_editor = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"rendererCategorizedSymbol.svg\" ) self . btn_pixel_editor . setIcon ( style_icon ) self . btn_pixel_editor . setToolTip ( self . tr ( \"Show dialog for ordering pixel values for styling.\" ) ) self . btn_pixel_editor . clicked . connect ( self . on_show_pixel_value_editor ) self . add_action_widget ( self . btn_pixel_editor )","title":"add_auxiliary_widgets"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.add_ncs_pathway_items","text":"add_ncs_pathway_items ( ncs_items ) Adds an NCS pathway item to the collection. One, and only one, target activity item needs to have been selected. Parameters: Name Type Description Default ncs_items List [ NcsPathwayItem ] NCS pathway items to be added to the activity. required Returns: Type Description bool True if the item was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 def add_ncs_pathway_items ( self , ncs_items : typing . List [ NcsPathwayItem ]) -> bool : \"\"\"Adds an NCS pathway item to the collection. One, and only one, target activity item needs to have been selected. :param ncs_items: NCS pathway items to be added to the activity. :type ncs_items: list :returns: True if the item was successfully added, else False. :rtype: bool \"\"\" selected_activities = self . selected_items () if len ( selected_activities ) == 0 or len ( selected_activities ) > 1 : return False sel_activity = selected_activities [ 0 ] item_type = sel_activity . type () # Use the parent to add the NCS item if item_type == NCS_PATHWAY_TYPE : if sel_activity . parent is None : return False sel_activity = sel_activity . parent elif item_type == LAYER_ITEM_TYPE : return False status = True for ncs_item in ncs_items : status = self . item_model . add_ncs_pathway ( ncs_item , sel_activity ) return status","title":"add_ncs_pathway_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.clear","text":"clear () Removes all activity items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 805 806 807 808 809 def clear ( self ): \"\"\"Removes all activity items in the view.\"\"\" items = self . model_items () for item in items : self . item_model . remove_activity ( item . uuid )","title":"clear"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.load","text":"load () Load activities from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 811 812 813 814 815 816 def load ( self ): \"\"\"Load activities from settings.\"\"\" self . clear () for activity in settings_manager . get_all_activities (): self . add_activity ( activity )","title":"load"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.model_items","text":"model_items () Returns a collection of all ActivityItem objects in the list view. Returns: Type Description list Collection of ActivityItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 795 796 797 798 799 800 801 802 803 def model_items ( self ) -> typing . List [ ActivityItem ]: \"\"\"Returns a collection of all ActivityItem objects in the list view. :returns: Collection of ActivityItem objects in the list view. :rtype: list \"\"\" return self . item_model . activity_items ()","title":"model_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.model_names","text":"model_names () Gets the names of the activities in the item model. Returns: Type Description list Returns the names of activities in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 775 776 777 778 779 780 781 782 783 784 785 786 787 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the activities in the item model. :returns: Returns the names of activities in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . activities () return [ mc . name . lower () for mc in model_components ]","title":"model_names"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.on_pathways_updated","text":"on_pathways_updated ( activity_item ) Slot raised when the pathways of an ActivityItem have been added or removed. Persist this information in settings. Source code in src/cplus_plugin/gui/model_component_widget.py 789 790 791 792 793 def on_pathways_updated ( self , activity_item : ActivityItem ): \"\"\"Slot raised when the pathways of an ActivityItem have been added or removed. Persist this information in settings. \"\"\" self . _save_item ( activity_item )","title":"on_pathways_updated"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.on_show_pixel_value_editor","text":"on_show_pixel_value_editor () Slot raised to show editor dialog for managing activity pixel values for styling. Source code in src/cplus_plugin/gui/model_component_widget.py 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 def on_show_pixel_value_editor ( self ): \"\"\"Slot raised to show editor dialog for managing activity pixel values for styling. \"\"\" pixel_dialog = PixelValueEditorDialog ( self ) if pixel_dialog . exec () == QtWidgets . QDialog . DialogCode . Accepted : # Update pixel values pixel_values = pixel_dialog . item_mapping for val , activity_id in pixel_values . items (): activity = settings_manager . get_activity ( activity_id ) if not activity : continue activity . style_pixel_value = val settings_manager . update_activity ( activity ) self . load ()","title":"on_show_pixel_value_editor"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.reassign_pixel_values","text":"reassign_pixel_values ( start_position ) Reassign the styling pixel values for activities from the given start position. It is important to call this function when the maximum pixel value does not match the number of activities such as when one or more activities have been deleted. Parameters: Name Type Description Default start_position int Position to start reassigning the pixel values. required Source code in src/cplus_plugin/gui/model_component_widget.py 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 def reassign_pixel_values ( self , start_position : int ): \"\"\"Reassign the styling pixel values for activities from the given start position. It is important to call this function when the maximum pixel value does not match the number of activities such as when one or more activities have been deleted. :param start_position: Position to start reassigning the pixel values. :type start_position: int \"\"\" sorted_activities = sorted ( settings_manager . get_all_activities (), key = lambda activity : activity . style_pixel_value , ) remap_activities = sorted_activities [ start_position - 1 :] for val , activity in enumerate ( remap_activities , start = start_position ): activity . style_pixel_value = val settings_manager . update_activity ( activity ) self . load ()","title":"reassign_pixel_values"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.remove_ncs_pathway_items","text":"remove_ncs_pathway_items ( ncs_pathway_uuid ) Delete NCS pathway items used for activities that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway_uuid str NCS pathway whose corresponding items will be deleted in the activity items that contain it. required Source code in src/cplus_plugin/gui/model_component_widget.py 1033 1034 1035 1036 1037 1038 1039 1040 1041 def remove_ncs_pathway_items ( self , ncs_pathway_uuid : str ): \"\"\"Delete NCS pathway items used for activities that are linked to the given NCS pathway. :param ncs_pathway_uuid: NCS pathway whose corresponding items will be deleted in the activity items that contain it. :type ncs_pathway_uuid: str \"\"\" self . item_model . remove_ncs_pathway_items ( ncs_pathway_uuid )","title":"remove_ncs_pathway_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ActivityComponentWidget.update_ncs_pathway_items","text":"update_ncs_pathway_items ( ncs_pathway ) Update NCS pathway items used for activities that are linked to the given NCS pathway. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway whose attribute values will be updated for the related pathways used in the activities. required Returns: Type Description bool True if NCS pathway items were updated, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 def update_ncs_pathway_items ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Update NCS pathway items used for activities that are linked to the given NCS pathway. :param ncs_pathway: NCS pathway whose attribute values will be updated for the related pathways used in the activities. :type ncs_pathway: NcsPathway :returns: True if NCS pathway items were updated, else False. :rtype: bool \"\"\" return self . item_model . update_ncs_pathway_items ( ncs_pathway )","title":"update_ncs_pathway_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget","text":"ModelComponentWidget ( parent = None , item_model = None ) Bases: QWidget , WidgetUi Widget for displaying and managing model items in a list view. Source code in src/cplus_plugin/gui/model_component_widget.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , parent = None , item_model = None ): super () . __init__ ( parent ) self . setupUi ( self ) self . _item_model = item_model if self . _item_model is not None : self . item_model = self . _item_model self . lst_model_items . doubleClicked . connect ( self . _on_double_click_item ) add_icon = FileUtils . get_icon ( \"symbologyAdd.svg\" ) self . btn_add . setIcon ( add_icon ) self . btn_add . clicked . connect ( self . _on_add_item ) remove_icon = FileUtils . get_icon ( \"symbologyRemove.svg\" ) self . btn_remove . setIcon ( remove_icon ) self . btn_remove . setEnabled ( False ) self . btn_remove . clicked . connect ( self . _on_remove_item ) edit_icon = FileUtils . get_icon ( \"mActionToggleEditing.svg\" ) self . btn_edit . setIcon ( edit_icon ) self . btn_edit . setEnabled ( False ) self . btn_edit . clicked . connect ( self . _on_edit_item ) reload_icon = FileUtils . get_icon ( \"mActionReload.svg\" ) self . btn_reload . setIcon ( reload_icon ) self . btn_reload . setToolTip ( self . tr ( \"Refresh view\" )) self . btn_reload . clicked . connect ( self . _on_reload ) self . btn_edit_description . setIcon ( edit_icon ) self . btn_edit_description . setToolTip ( self . tr ( \"Edit description\" )) self . btn_edit_description . setEnabled ( False ) self . btn_edit_description . clicked . connect ( self . _on_update_description )","title":"ModelComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.item_model","text":"item_model Returns the component item model for managing items the list view. Returns: Type Description ComponentItemModel Component item model for managing items the list view.","title":"item_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selection_model","text":"selection_model Gets the item's view selection model. Returns: Type Description QtCore.QItemSelectionModel The item's view selection model.","title":"selection_model"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.title","text":"title Returns the title of the view. Returns: Type Description str Title of the view.","title":"title"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.add_action_widget","text":"add_action_widget ( widget ) Adds an auxiliary widget below the list view from the left-hand side. Parameters: Name Type Description Default widget QWidget Widget to be added to the collection of controls below the list view. required Source code in src/cplus_plugin/gui/model_component_widget.py 330 331 332 333 334 335 336 337 def add_action_widget ( self , widget : QtWidgets . QWidget ): \"\"\"Adds an auxiliary widget below the list view from the left-hand side. :param widget: Widget to be added to the collection of controls below the list view. :type widget: QtWidgets.QWidget \"\"\" self . widget_container . addWidget ( widget )","title":"add_action_widget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear","text":"clear () Remove all items in the view. To be implemented by subclasses. Source code in src/cplus_plugin/gui/model_component_widget.py 282 283 284 285 def clear ( self ): \"\"\"Remove all items in the view. To be implemented by subclasses.\"\"\" pass","title":"clear"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.clear_description","text":"clear_description () Clears the content in the description text box. Source code in src/cplus_plugin/gui/model_component_widget.py 198 199 200 201 def clear_description ( self ): \"\"\"Clears the content in the description text box.\"\"\" self . txt_item_description . clear () self . txt_item_description . setToolTip ( \"\" )","title":"clear_description"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.enable_default_items","text":"enable_default_items ( state ) Enable or disable default model component items in the view. Parameters: Name Type Description Default state bool True to enable or False to disable default model component items. required Source code in src/cplus_plugin/gui/model_component_widget.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 def enable_default_items ( self , state : bool ): \"\"\"Enable or disable default model component items in the view. :param state: True to enable or False to disable default model component items. :type state: bool \"\"\" self . _item_model . enable_default_items ( state ) # If false, deselect default items if not state : selection_model = self . lst_model_items . selectionModel () selected_idxs = selection_model . selectedRows () for sel_idx in selected_idxs : item = self . _item_model . item ( sel_idx . row (), 0 ) # If not enabled then deselect if not item . isEnabled (): selection_model . select ( sel_idx , QtCore . QItemSelectionModel . SelectionFlag . Deselect )","title":"enable_default_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.load","text":"load () Subclass to determine how to initialize the items. Source code in src/cplus_plugin/gui/model_component_widget.py 133 134 135 def load ( self ): \"\"\"Subclass to determine how to initialize the items.\"\"\" pass","title":"load"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.model_names","text":"model_names () Gets the names of the components in the item model. Returns: Type Description list Returns the model names in lower case or an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 295 296 297 298 299 300 301 302 303 304 305 306 307 def model_names ( self ) -> typing . List [ str ]: \"\"\"Gets the names of the components in the item model. :returns: Returns the model names in lower case or an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] model_components = self . _item_model . model_components () return [ mc . name . lower () for mc in model_components ]","title":"model_names"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.selected_items","text":"selected_items () Returns the selected items in the list view. Returns: Type Description list A collection of the selected model component items. Returns an empty list if the item model has not been set. Source code in src/cplus_plugin/gui/model_component_widget.py 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def selected_items ( self ) -> typing . List [ ModelComponentItemType ]: \"\"\"Returns the selected items in the list view. :returns: A collection of the selected model component items. Returns an empty list if the item model has not been set. :rtype: list \"\"\" if self . _item_model is None : return [] selection_model = self . lst_model_items . selectionModel () idxs = selection_model . selectedRows () return [ self . _item_model . item ( idx . row ()) for idx in idxs ]","title":"selected_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.ModelComponentWidget.set_description","text":"set_description ( description ) Updates the text for the selected item. Parameters: Name Type Description Default description str Description for the selected item. required Source code in src/cplus_plugin/gui/model_component_widget.py 189 190 191 192 193 194 195 196 def set_description ( self , description : str ): \"\"\"Updates the text for the selected item. :param description: Description for the selected item. :type description: str \"\"\" self . txt_item_description . setText ( description ) self . txt_item_description . setToolTip ( description )","title":"set_description"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget","text":"NcsComponentWidget ( parent = None ) Bases: ModelComponentWidget Widget for displaying and managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def __init__ ( self , parent = None ): super () . __init__ ( parent ) # Add option for deleting disabled items self . btn_remove . clicked . disconnect ( self . _on_remove_item ) self . _delete_menu = QtWidgets . QMenu () self . _remove_default_action = self . _delete_menu . addAction ( FileUtils . get_icon ( \"symbologyRemove.svg\" ), \"Remove Selected\" ) self . _remove_default_action . setEnabled ( False ) self . _remove_default_action . triggered . connect ( self . _on_remove_item ) self . _remove_disabled_action = self . _delete_menu . addAction ( FileUtils . get_icon ( \"repositoryDisabled.svg\" ), \"Remove Disabled\" ) self . _remove_disabled_action . setEnabled ( False ) self . _remove_disabled_action . triggered . connect ( self . _on_remove_disabled ) self . btn_remove . setMenu ( self . _delete_menu ) self . btn_remove . setDefaultAction ( self . _remove_default_action ) self . btn_remove . setPopupMode ( QtWidgets . QToolButton . ToolButtonPopupMode . MenuButtonPopup ) self . btn_remove . triggered . connect ( self . on_delete_triggered ) self . item_model = NcsPathwayItemModel ( parent ) self . item_model . itemChanged . connect ( self . on_item_changed ) self . lst_model_items . setDragEnabled ( True ) self . lst_model_items . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . DragOnly ) self . lst_model_items . setAcceptDrops ( False ) self . _validation_manager = validation_manager self . _validation_submit_result = None self . btn_validate_pathways = None self . add_auxiliary_widgets ()","title":"NcsComponentWidget"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.add_auxiliary_widgets","text":"add_auxiliary_widgets () Adds additional action widgets for managing NCS pathways. Source code in src/cplus_plugin/gui/model_component_widget.py 498 499 500 501 502 503 504 505 def add_auxiliary_widgets ( self ): \"\"\"Adds additional action widgets for managing NCS pathways.\"\"\" self . btn_validate_pathways = QtWidgets . QToolButton ( self ) style_icon = FileUtils . get_icon ( \"mIconRasterValidate.svg\" ) self . btn_validate_pathways . setIcon ( style_icon ) self . btn_validate_pathways . setToolTip ( self . tr ( \"Show validation inspector\" )) self . btn_validate_pathways . clicked . connect ( self . on_load_validation_inspector ) self . add_action_widget ( self . btn_validate_pathways )","title":"add_auxiliary_widgets"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.add_ncs_pathway","text":"add_ncs_pathway ( ncs_pathway ) Adds an NCS pathway object to the view. Parameters: Name Type Description Default ncs_pathway NcsPathway NCS pathway object to be added to the view. required Returns: Type Description bool Returns True if the NcsPathway was successfully added, else False. Source code in src/cplus_plugin/gui/model_component_widget.py 486 487 488 489 490 491 492 493 494 495 496 def add_ncs_pathway ( self , ncs_pathway : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the view. :param ncs_pathway: NCS pathway object to be added to the view. :type ncs_pathway: NcsPathway :returns: Returns True if the NcsPathway was successfully added, else False. :rtype: bool \"\"\" return self . item_model . add_ncs_pathway ( ncs_pathway )","title":"add_ncs_pathway"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.clear","text":"clear () Removes all NCS pathway items in the view. Source code in src/cplus_plugin/gui/model_component_widget.py 507 508 509 510 511 def clear ( self ): \"\"\"Removes all NCS pathway items in the view.\"\"\" items = self . ncs_items () for item in items : self . item_model . remove_ncs_pathway ( item . uuid )","title":"clear"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.is_valid","text":"is_valid () Returns whether the NCS pathways are valid based on the validation against a given set of rules defined for an NCSValidator. The validation process is automatically triggered through the validation manager object. Returns: Type Description bool True if the NCS pathways are valid, else False. If the validation result has warnings and no errors, the overall results will be True. However, if there are errors, it will return False. Source code in src/cplus_plugin/gui/model_component_widget.py 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 def is_valid ( self ) -> bool : \"\"\"Returns whether the NCS pathways are valid based on the validation against a given set of rules defined for an NCSValidator. The validation process is automatically triggered through the validation manager object. :returns: True if the NCS pathways are valid, else False. If the validation result has warnings and no errors, the overall results will be True. However, if there are errors, it will return False. :rtype: bool \"\"\" if self . _validation_submit_result is None : return False if not self . _validation_submit_result . success : return False if self . _validation_manager . is_validation_complete ( self . _validation_submit_result ): validation_result = self . _validation_manager . validation_result ( self . _validation_submit_result ) if validation_result . success : return True if validation_result . warnings and not validation_result . errors : return True return False","title":"is_valid"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.load","text":"load () Load items from settings. Source code in src/cplus_plugin/gui/model_component_widget.py 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 def load ( self ): \"\"\"Load items from settings.\"\"\" self . clear () settings_manager . update_ncs_pathways () ncs_pathways = settings_manager . get_all_ncs_pathways () if len ( ncs_pathways ) > 0 : progress_dialog = QtWidgets . QProgressDialog ( self ) progress_dialog . setWindowTitle ( self . tr ( \"Load NCS Pathways\" )) progress_dialog . setMinimum ( 0 ) progress_dialog . setMaximum ( len ( ncs_pathways )) progress_dialog . setLabelText ( self . tr ( \"Updating NCS pathways...\" )) for i , ncs in enumerate ( ncs_pathways , start = 1 ): progress_dialog . setValue ( i ) if progress_dialog . wasCanceled (): break self . add_ncs_pathway ( ncs ) self . validate_pathways ()","title":"load"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.ncs_items","text":"ncs_items () Returns a collection of all NcsPathwayItem objects in the list view. Returns: Type Description list Collection of NcsPathwayItem objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 557 558 559 560 561 562 563 564 def ncs_items ( self ) -> typing . List [ NcsPathwayItem ]: \"\"\"Returns a collection of all NcsPathwayItem objects in the list view. :returns: Collection of NcsPathwayItem objects in the list view. :rtype: list \"\"\" return self . item_model . model_component_items ()","title":"ncs_items"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.on_delete_triggered","text":"on_delete_triggered ( action ) Slot raised to select the default delete action. Parameters: Name Type Description Default action QAction Action that has been triggered. required Source code in src/cplus_plugin/gui/model_component_widget.py 389 390 391 392 393 394 395 def on_delete_triggered ( self , action : QtWidgets . QAction ): \"\"\"Slot raised to select the default delete action. :param action: Action that has been triggered. :type action: QtWidgets.QAction \"\"\" self . btn_remove . setDefaultAction ( action )","title":"on_delete_triggered"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.on_item_changed","text":"on_item_changed ( item ) Slot raised when the data of an NCS pathway item changes. Parameters: Name Type Description Default item NcsPathwayItem NCS pathway item whose data has changed. required Source code in src/cplus_plugin/gui/model_component_widget.py 446 447 448 449 450 451 452 453 454 def on_item_changed ( self , item : NcsPathwayItem ): \"\"\"Slot raised when the data of an NCS pathway item changes. :param item: NCS pathway item whose data has changed. :type item: NcsPathwayItem \"\"\" # Check if there are items disabled and enable or disable # the option for deleting disabled items. self . _on_item_and_selection_changed ()","title":"on_item_changed"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.on_load_validation_inspector","text":"on_load_validation_inspector () Slot raised to show the validation inspector dialog. If the validation process is not yet completed, a progress dialog will be shown. Source code in src/cplus_plugin/gui/model_component_widget.py 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 def on_load_validation_inspector ( self ): \"\"\"Slot raised to show the validation inspector dialog. If the validation process is not yet completed, a progress dialog will be shown. \"\"\" if self . _validation_submit_result is None : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Load Validation Inspector\" ), self . tr ( \"Unable to show the validation inspector window. \\n No request for validation has been submitted.\" ), ) log ( message = \"Unable to load validation inspector\" , info = False ) return if self . _validation_manager . is_validation_complete ( self . _validation_submit_result ): validation_result = self . _validation_manager . validation_result ( self . _validation_submit_result ) if validation_result is None : return self . inspector_dialog = ValidationInspectorDialog ( result = validation_result ) self . inspector_dialog . setModal ( False ) self . inspector_dialog . show () else : # Show progress dialog progress_dialog = ValidationProgressDialog ( self . _validation_submit_result , self ) progress_dialog . exec ()","title":"on_load_validation_inspector"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.pathways","text":"pathways ( valid_only = False ) Returns a collection of NcsPathway objects in the list view. Parameters: Name Type Description Default valid_only bool True to only return those NcsPathway objects that are valid, default is False. False Returns: Type Description list Collection of NcsPathway objects in the list view. Source code in src/cplus_plugin/gui/model_component_widget.py 513 514 515 516 517 518 519 520 521 522 523 def pathways ( self , valid_only = False ) -> typing . List [ NcsPathway ]: \"\"\"Returns a collection of NcsPathway objects in the list view. :param valid_only: True to only return those NcsPathway objects that are valid, default is False. :type valid_only: bool :returns: Collection of NcsPathway objects in the list view. :rtype: list \"\"\" return self . item_model . pathways ( valid_only )","title":"pathways"},{"location":"developer/api/gui/api_model_component_widget/#src.cplus_plugin.gui.model_component_widget.NcsComponentWidget.validate_pathways","text":"validate_pathways () Validates NCS pathway model components against a given set of rules using the ValidationManager. Source code in src/cplus_plugin/gui/model_component_widget.py 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 def validate_pathways ( self ): \"\"\"Validates NCS pathway model components against a given set of rules using the ValidationManager. \"\"\" self . _validation_submit_result = None ncs_pathways = self . pathways () # No need for validating if there are no NCS pathways. if len ( ncs_pathways ) == 0 : log ( message = \"At least one NCS pathway is required for the validation process to be initiated.\" , info = False , ) return self . _validation_submit_result = validation_manager . validate_ncs_pathways ( ncs_pathways ) if not self . _validation_submit_result . success : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Validate NCS Pathways\" ), self . tr ( \"Unable to submit NCS pathways for validation\" ), ) log ( message = \"Unable to submit NCS pathways for validation\" , info = False ) return","title":"validate_pathways"},{"location":"developer/api/gui/api_ncs_pathway_editor/","text":"NCS pathway editor \u00b6 Dialog for creating or editing an NCS pathway entry. NcsPathwayEditorDialog \u00b6 NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . txt_description . textChanged . connect ( self . description_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . cbo_default_layer_source . addItems ( [ LayerSource . CPLUS . value , LayerSource . NATUREBASE . value ] ) self . cbo_default_layer_source . currentIndexChanged . connect ( self . _on_default_layer_source_selection_changed ) self . cplus_list = [] pathways = settings_manager . get_default_layers ( \"ncs_pathway\" ) self . cbo_default_layer . setModel ( QtGui . QStandardItemModel ()) self . cbo_naturebase_carbon_mng . setModel ( QtGui . QStandardItemModel ()) self . naturebase_pathway_type_groups = { \"Restore\" : [], \"Manage\" : [], \"Protect\" : [], \"General\" : [], } self . cbo_default_layer . addItem ( \"\" ) # Populate the default layer combobox with available pathways for pathway in pathways : source = pathway . get ( \"source\" , \"\" ) . lower () if source == LayerSource . CPLUS . value . lower (): self . cplus_list . append ( pathway ) elif source == LayerSource . NATUREBASE . value . lower (): pathway_type = NcsPathwayType . from_int ( pathway . get ( \"action\" )) group_key = ( pathway_type . name . capitalize () if pathway_type != NcsPathwayType . UNDEFINED else \"General\" ) self . naturebase_pathway_type_groups [ group_key ] . append ( pathway [ \"name\" ]) items = sorted ([ p [ \"name\" ] for p in self . cplus_list ]) self . cbo_default_layer . addItems ( items ) self . cbo_default_layer . setCurrentIndex ( 0 ) self . cbo_default_layer . currentIndexChanged . connect ( self . _on_default_layer_selection_changed ) # Pathway type self . _pathway_type_group = QtWidgets . QButtonGroup ( self ) self . _pathway_type_group . addButton ( self . rb_protection , NcsPathwayType . PROTECT . value ) self . _pathway_type_group . addButton ( self . rb_management , NcsPathwayType . MANAGE . value ) self . _pathway_type_group . addButton ( self . rb_restoration , NcsPathwayType . RESTORE . value ) self . _pathway_type_group . idToggled . connect ( self . _on_pathway_type_changed ) # Pathway type options self . sw_pathway_type . hide () self . sb_management_carbon_impact_mng . setMaximum ( MAX_CARBON_IMPACT_MANAGE ) self . sb_management_carbon_impact_rst . setMaximum ( MAX_CARBON_IMPACT_MANAGE ) # Naturebase carbon impact reference self . carbon_impact_info = settings_manager . get_nature_base_zonal_stats () if self . carbon_impact_info : self . cbo_naturebase_carbon_mng . addItem ( \"\" ) self . cbo_naturebase_carbon_rst . addItem ( \"\" ) self . add_online_group ( \"Manage\" , self . naturebase_pathway_type_groups . get ( \"Manage\" ), self . cbo_naturebase_carbon_mng . model (), ) self . add_online_group ( \"Restore\" , self . naturebase_pathway_type_groups . get ( \"Restore\" ), self . cbo_naturebase_carbon_rst . model (), ) self . cbo_naturebase_carbon_mng . currentIndexChanged . connect ( self . _on_naturebase_carbon_changed_manage ) self . cbo_naturebase_carbon_rst . currentIndexChanged . connect ( self . _on_naturebase_carbon_changed_restore ) # Data source type self . _data_source_type_group = QtWidgets . QButtonGroup ( self ) self . _data_source_type_group . setExclusive ( True ) self . _data_source_type_group . addButton ( self . rb_local , DataSourceType . LOCAL . value ) self . _data_source_type_group . addButton ( self . rb_online , DataSourceType . ONLINE . value ) self . _data_source_type_group . idToggled . connect ( self . _on_data_source_changed ) self . rb_local . setChecked ( True ) # Configure map combobox self . cbo_layer . setAllowEmptyLayer ( True , tr ( \"<Layer not set>\" )) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls () edit_mode property \u00b6 edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object. layer property \u00b6 layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set. ncs_pathway property \u00b6 ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object. description_changed \u00b6 description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 210 211 212 213 214 215 216 217 218 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ]) get_pathway_type_options \u00b6 get_pathway_type_options () Returns the user-defined option values for the currently selected pathway type. Returns: Type Description dict User-defined options values for the current pathway type. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_pathway_type_options ( self ) -> dict : \"\"\"Returns the user-defined option values for the currently selected pathway type. :returns: User-defined options values for the current pathway type. :rtype: dict \"\"\" # Manage pathways if self . _pathway_type_group . checkedId () == NcsPathwayType . MANAGE : return { CARBON_IMPACT_ATTRIBUTE : self . sb_management_carbon_impact_mng . value () } elif self . _pathway_type_group . checkedId () == NcsPathwayType . RESTORE : return { CARBON_IMPACT_ATTRIBUTE : self . sb_management_carbon_impact_rst . value () } return {} open_help \u00b6 open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 514 515 516 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) validate \u00b6 validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if self . _pathway_type_group . checkedId () == - 1 : msg = tr ( \"The NCS pathway type is not specified.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () default_layer = self . _get_selected_default_layer () data_source_type_id = self . _data_source_type_group . checkedId () if data_source_type_id == DataSourceType . LOCAL . value and layer is None : msg = tr ( \"Local map layer not specified.\" ) self . _show_warning_message ( msg ) status = False elif ( data_source_type_id == DataSourceType . ONLINE . value and len ( default_layer ) == 0 ): msg = tr ( \"Online default layer not specified.\" ) self . _show_warning_message ( msg ) status = False if ( data_source_type_id == DataSourceType . LOCAL . value and layer and not layer . isValid () ): msg = tr ( \"Local map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"NCS Pathway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#ncs-pathway-editor","text":"Dialog for creating or editing an NCS pathway entry.","title":"NCS pathway editor"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog","text":"NcsPathwayEditorDialog ( parent = None , ncs_pathway = None , excluded_names = None ) Bases: QDialog , WidgetUi Dialog for creating or editing an NCS pathway entry. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def __init__ ( self , parent = None , ncs_pathway = None , excluded_names = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . txt_description . textChanged . connect ( self . description_changed ) self . buttonBox . accepted . connect ( self . _on_accepted ) self . btn_add_layer . clicked . connect ( self . _on_select_file ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . cbo_default_layer_source . addItems ( [ LayerSource . CPLUS . value , LayerSource . NATUREBASE . value ] ) self . cbo_default_layer_source . currentIndexChanged . connect ( self . _on_default_layer_source_selection_changed ) self . cplus_list = [] pathways = settings_manager . get_default_layers ( \"ncs_pathway\" ) self . cbo_default_layer . setModel ( QtGui . QStandardItemModel ()) self . cbo_naturebase_carbon_mng . setModel ( QtGui . QStandardItemModel ()) self . naturebase_pathway_type_groups = { \"Restore\" : [], \"Manage\" : [], \"Protect\" : [], \"General\" : [], } self . cbo_default_layer . addItem ( \"\" ) # Populate the default layer combobox with available pathways for pathway in pathways : source = pathway . get ( \"source\" , \"\" ) . lower () if source == LayerSource . CPLUS . value . lower (): self . cplus_list . append ( pathway ) elif source == LayerSource . NATUREBASE . value . lower (): pathway_type = NcsPathwayType . from_int ( pathway . get ( \"action\" )) group_key = ( pathway_type . name . capitalize () if pathway_type != NcsPathwayType . UNDEFINED else \"General\" ) self . naturebase_pathway_type_groups [ group_key ] . append ( pathway [ \"name\" ]) items = sorted ([ p [ \"name\" ] for p in self . cplus_list ]) self . cbo_default_layer . addItems ( items ) self . cbo_default_layer . setCurrentIndex ( 0 ) self . cbo_default_layer . currentIndexChanged . connect ( self . _on_default_layer_selection_changed ) # Pathway type self . _pathway_type_group = QtWidgets . QButtonGroup ( self ) self . _pathway_type_group . addButton ( self . rb_protection , NcsPathwayType . PROTECT . value ) self . _pathway_type_group . addButton ( self . rb_management , NcsPathwayType . MANAGE . value ) self . _pathway_type_group . addButton ( self . rb_restoration , NcsPathwayType . RESTORE . value ) self . _pathway_type_group . idToggled . connect ( self . _on_pathway_type_changed ) # Pathway type options self . sw_pathway_type . hide () self . sb_management_carbon_impact_mng . setMaximum ( MAX_CARBON_IMPACT_MANAGE ) self . sb_management_carbon_impact_rst . setMaximum ( MAX_CARBON_IMPACT_MANAGE ) # Naturebase carbon impact reference self . carbon_impact_info = settings_manager . get_nature_base_zonal_stats () if self . carbon_impact_info : self . cbo_naturebase_carbon_mng . addItem ( \"\" ) self . cbo_naturebase_carbon_rst . addItem ( \"\" ) self . add_online_group ( \"Manage\" , self . naturebase_pathway_type_groups . get ( \"Manage\" ), self . cbo_naturebase_carbon_mng . model (), ) self . add_online_group ( \"Restore\" , self . naturebase_pathway_type_groups . get ( \"Restore\" ), self . cbo_naturebase_carbon_rst . model (), ) self . cbo_naturebase_carbon_mng . currentIndexChanged . connect ( self . _on_naturebase_carbon_changed_manage ) self . cbo_naturebase_carbon_rst . currentIndexChanged . connect ( self . _on_naturebase_carbon_changed_restore ) # Data source type self . _data_source_type_group = QtWidgets . QButtonGroup ( self ) self . _data_source_type_group . setExclusive ( True ) self . _data_source_type_group . addButton ( self . rb_local , DataSourceType . LOCAL . value ) self . _data_source_type_group . addButton ( self . rb_online , DataSourceType . ONLINE . value ) self . _data_source_type_group . idToggled . connect ( self . _on_data_source_changed ) self . rb_local . setChecked ( True ) # Configure map combobox self . cbo_layer . setAllowEmptyLayer ( True , tr ( \"<Layer not set>\" )) self . cbo_layer . setFilters ( QgsMapLayerProxyModel . Filter . RasterLayer ) self . _excluded_names = excluded_names if excluded_names is None : self . _excluded_names = [] self . _edit_mode = False self . _layer = None self . _ncs_pathway = ncs_pathway if self . _ncs_pathway is not None : self . _edit_mode = True self . _layer = self . _ncs_pathway . to_map_layer () self . _update_controls ()","title":"NcsPathwayEditorDialog"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.edit_mode","text":"edit_mode Returns the state of the editor. Returns: Type Description bool True if the editor is editing an existing NcsPathway object, else False if its creating a new object.","title":"edit_mode"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.layer","text":"layer Returns the raster layer specified by the user, either existing layers in the map canvas or from the selected file. Returns: Type Description QgsRasterLayer The raster layer specified by the user or None if not set.","title":"layer"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.ncs_pathway","text":"ncs_pathway Returns a reference to the NcsPathway object. Returns: Type Description NcsPathway Reference to the NcsPathway object.","title":"ncs_pathway"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.description_changed","text":"description_changed () Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 210 211 212 213 214 215 216 217 218 def description_changed ( self ): \"\"\"Slot to handle description text changes, it currently limits the number of characters to only be 300 characters per description \"\"\" description = self . txt_description . toPlainText () if len ( description ) > 300 : self . txt_description . setPlainText ( description [: 300 ])","title":"description_changed"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.get_pathway_type_options","text":"get_pathway_type_options () Returns the user-defined option values for the currently selected pathway type. Returns: Type Description dict User-defined options values for the current pathway type. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_pathway_type_options ( self ) -> dict : \"\"\"Returns the user-defined option values for the currently selected pathway type. :returns: User-defined options values for the current pathway type. :rtype: dict \"\"\" # Manage pathways if self . _pathway_type_group . checkedId () == NcsPathwayType . MANAGE : return { CARBON_IMPACT_ATTRIBUTE : self . sb_management_carbon_impact_mng . value () } elif self . _pathway_type_group . checkedId () == NcsPathwayType . RESTORE : return { CARBON_IMPACT_ATTRIBUTE : self . sb_management_carbon_impact_rst . value () } return {}","title":"get_pathway_type_options"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 514 515 516 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_ncs_pathway_editor/#src.cplus_plugin.gui.ncs_pathway_editor_dialog.NcsPathwayEditorDialog.validate","text":"validate () Validates if name and layer have been specified. Returns: Type Description True True if user input (i.e. name and layer) have been set. Source code in src/cplus_plugin/gui/ncs_pathway_editor_dialog.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def validate ( self ) -> bool : \"\"\"Validates if name and layer have been specified. :returns: True if user input (i.e. name and layer) have been set. :rtype: True \"\"\" status = True self . _message_bar . clearWidgets () name = self . txt_name . text () if not name : msg = tr ( \"NCS pathway name cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if name . lower () in self . _excluded_names : msg = tr ( \"name has already been used.\" ) self . _show_warning_message ( f \"' { name } ' { msg } \" ) status = False if not self . txt_description . toPlainText (): msg = tr ( \"Description cannot be empty.\" ) self . _show_warning_message ( msg ) status = False if self . _pathway_type_group . checkedId () == - 1 : msg = tr ( \"The NCS pathway type is not specified.\" ) self . _show_warning_message ( msg ) status = False layer = self . _get_selected_map_layer () default_layer = self . _get_selected_default_layer () data_source_type_id = self . _data_source_type_group . checkedId () if data_source_type_id == DataSourceType . LOCAL . value and layer is None : msg = tr ( \"Local map layer not specified.\" ) self . _show_warning_message ( msg ) status = False elif ( data_source_type_id == DataSourceType . ONLINE . value and len ( default_layer ) == 0 ): msg = tr ( \"Online default layer not specified.\" ) self . _show_warning_message ( msg ) status = False if ( data_source_type_id == DataSourceType . LOCAL . value and layer and not layer . isValid () ): msg = tr ( \"Local map layer is not valid.\" ) self . _show_warning_message ( msg ) status = False return status","title":"validate"},{"location":"developer/api/gui/api_npv_financial_model/","text":"NPV Parameters View Model \u00b6 View model for computation of financial NPV values. NpvFinancialModel \u00b6 NpvFinancialModel ( parent = None ) Bases: QStandardItemModel View model for costs and revenues used in NPV computation. Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 4 ) # Headers self . setHorizontalHeaderLabels ( [ tr ( YEAR_HEADER ), tr ( TOTAL_PROJECTED_REVENUES_HEADER ), tr ( TOTAL_PROJECTED_COSTS_HEADER ), tr ( DISCOUNTED_VALUE_HEADER ), ] ) add_year_row \u00b6 add_year_row () Adds a new row for the year. The year number is automatically set. Returns: Type Description int The newly added row number, or -1 if the row was not added. Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def add_year_row ( self ) -> int : \"\"\"Adds a new row for the year. The year number is automatically set. :returns: The newly added row number, or -1 if the row was not added. :rtype: int \"\"\" if self . rowCount () >= MAX_YEARS : return - 1 year_number = self . rowCount () + 1 year_item = QtGui . QStandardItem ( str ( year_number )) year_item . setEditable ( False ) year_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) year_background = year_item . background () year_background . setColor ( QtCore . Qt . GlobalColor . lightGray ) year_background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) year_item . setBackground ( year_background ) revenue_item = QtGui . QStandardItem () revenue_item . setEditable ( True ) revenue_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) cost_item = QtGui . QStandardItem () cost_item . setEditable ( True ) cost_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) discount_item = QtGui . QStandardItem () discount_item . setEditable ( False ) discount_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) discount_background = discount_item . background () discount_background . setColor ( QtCore . Qt . GlobalColor . lightGray ) discount_background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) discount_item . setBackground ( discount_background ) self . appendRow ([ year_item , revenue_item , cost_item , discount_item ]) return year_number append_years \u00b6 append_years ( number_years ) Appends new rows based on the number of years specified. Parameters: Name Type Description Default number_years int Number of rows to be added. required Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 79 80 81 82 83 84 85 86 87 88 def append_years ( self , number_years : int ): \"\"\"Appends new rows based on the number of years specified. :param number_years: Number of rows to be added. :type number_years: int \"\"\" for i in range ( number_years ): row_number = self . add_year_row () if row_number == - 1 : break set_number_of_years \u00b6 set_number_of_years ( number_years ) Sets the number of years by adding or removing rows to match the number of years. Parameters: Name Type Description Default number_years int Number of years to be used in the computation. required Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def set_number_of_years ( self , number_years : int ): \"\"\"Sets the number of years by adding or removing rows to match the number of years. :param number_years: Number of years to be used in the computation. :type number_years: int \"\"\" if self . rowCount () < number_years : # Append additional years additional_years = number_years - self . rowCount () self . append_years ( additional_years ) elif self . rowCount () > number_years : # Remove extra years remove_years = self . rowCount () - number_years self . removeRows ( self . rowCount () - remove_years , remove_years )","title":"NPV view model"},{"location":"developer/api/gui/api_npv_financial_model/#npv-parameters-view-model","text":"View model for computation of financial NPV values.","title":"NPV Parameters View Model"},{"location":"developer/api/gui/api_npv_financial_model/#src.cplus_plugin.gui.financials.npv_financial_model.NpvFinancialModel","text":"NpvFinancialModel ( parent = None ) Bases: QStandardItemModel View model for costs and revenues used in NPV computation. Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setColumnCount ( 4 ) # Headers self . setHorizontalHeaderLabels ( [ tr ( YEAR_HEADER ), tr ( TOTAL_PROJECTED_REVENUES_HEADER ), tr ( TOTAL_PROJECTED_COSTS_HEADER ), tr ( DISCOUNTED_VALUE_HEADER ), ] )","title":"NpvFinancialModel"},{"location":"developer/api/gui/api_npv_financial_model/#src.cplus_plugin.gui.financials.npv_financial_model.NpvFinancialModel.add_year_row","text":"add_year_row () Adds a new row for the year. The year number is automatically set. Returns: Type Description int The newly added row number, or -1 if the row was not added. Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def add_year_row ( self ) -> int : \"\"\"Adds a new row for the year. The year number is automatically set. :returns: The newly added row number, or -1 if the row was not added. :rtype: int \"\"\" if self . rowCount () >= MAX_YEARS : return - 1 year_number = self . rowCount () + 1 year_item = QtGui . QStandardItem ( str ( year_number )) year_item . setEditable ( False ) year_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) year_background = year_item . background () year_background . setColor ( QtCore . Qt . GlobalColor . lightGray ) year_background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) year_item . setBackground ( year_background ) revenue_item = QtGui . QStandardItem () revenue_item . setEditable ( True ) revenue_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) cost_item = QtGui . QStandardItem () cost_item . setEditable ( True ) cost_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) discount_item = QtGui . QStandardItem () discount_item . setEditable ( False ) discount_item . setTextAlignment ( QtCore . Qt . AlignmentFlag . AlignCenter ) discount_background = discount_item . background () discount_background . setColor ( QtCore . Qt . GlobalColor . lightGray ) discount_background . setStyle ( QtCore . Qt . BrushStyle . SolidPattern ) discount_item . setBackground ( discount_background ) self . appendRow ([ year_item , revenue_item , cost_item , discount_item ]) return year_number","title":"add_year_row"},{"location":"developer/api/gui/api_npv_financial_model/#src.cplus_plugin.gui.financials.npv_financial_model.NpvFinancialModel.append_years","text":"append_years ( number_years ) Appends new rows based on the number of years specified. Parameters: Name Type Description Default number_years int Number of rows to be added. required Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 79 80 81 82 83 84 85 86 87 88 def append_years ( self , number_years : int ): \"\"\"Appends new rows based on the number of years specified. :param number_years: Number of rows to be added. :type number_years: int \"\"\" for i in range ( number_years ): row_number = self . add_year_row () if row_number == - 1 : break","title":"append_years"},{"location":"developer/api/gui/api_npv_financial_model/#src.cplus_plugin.gui.financials.npv_financial_model.NpvFinancialModel.set_number_of_years","text":"set_number_of_years ( number_years ) Sets the number of years by adding or removing rows to match the number of years. Parameters: Name Type Description Default number_years int Number of years to be used in the computation. required Source code in src/cplus_plugin/gui/financials/npv_financial_model.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def set_number_of_years ( self , number_years : int ): \"\"\"Sets the number of years by adding or removing rows to match the number of years. :param number_years: Number of years to be used in the computation. :type number_years: int \"\"\" if self . rowCount () < number_years : # Append additional years additional_years = number_years - self . rowCount () self . append_years ( additional_years ) elif self . rowCount () > number_years : # Remove extra years remove_years = self . rowCount () - number_years self . removeRows ( self . rowCount () - remove_years , remove_years )","title":"set_number_of_years"},{"location":"developer/api/gui/api_npv_manager_dialog/","text":"NPV Priority Weighting Layer Manager Dialog \u00b6 Dialog for creating a new financial PWL. DisplayValueFormatterItemDelegate \u00b6 Bases: QStyledItemDelegate Delegate for formatting numeric values using thousand comma separator, number of decimal places etc. displayText \u00b6 displayText ( value , locale ) Format the value to incorporate thousand comma separator. Parameters: Name Type Description Default value float Value of the display role provided by the model. required locale QLocale Locale for the value in the display role. required Returns: Type Description str Formatted value of the display role data. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def displayText ( self , value : float , locale : QtCore . QLocale ) -> str : \"\"\"Format the value to incorporate thousand comma separator. :param value: Value of the display role provided by the model. :type value: float :param locale: Locale for the value in the display role. :type locale: QtCore.QLocale :returns: Formatted value of the display role data. :rtype: str \"\"\" if value is None : return \"\" formatter = QgsBasicNumericFormat () formatter . setShowThousandsSeparator ( True ) formatter . setNumberDecimalPlaces ( DEFAULT_DECIMAL_PLACES ) return formatter . formatDouble ( float ( value ), QgsNumericFormatContext ()) FinancialValueItemDelegate \u00b6 Bases: DisplayValueFormatterItemDelegate Delegate for ensuring only numbers are specified in financial value fields. createEditor \u00b6 createEditor ( parent , option , idx ) Creates a line edit control whose input value is limited to numbers only. Parameters: Name Type Description Default parent QWidget Parent widget. required option QStyleOptionViewItem Options for drawing the widget in the view. required idx QModelIndex Location of the request in the data model. required Returns: Type Description QtWidgets.QLineEdit The editor widget. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ) -> QtWidgets . QLineEdit : \"\"\"Creates a line edit control whose input value is limited to numbers only. :param parent: Parent widget. :type parent: QtWidgets.QWidget :param option: Options for drawing the widget in the view. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the request in the data model. :type idx: QtCore.QModelIndex :returns: The editor widget. :rtype: QtWidgets.QLineEdit \"\"\" line_edit = QtWidgets . QLineEdit ( parent ) line_edit . setFrame ( False ) line_edit . setMaxLength ( 50 ) validator = QtGui . QDoubleValidator () validator . setDecimals ( 2 ) line_edit . setValidator ( validator ) return line_edit setEditorData \u00b6 setEditorData ( widget , idx ) Sets the data to be displayed and edited by the editor. Parameters: Name Type Description Default widget QWidget Editor widget. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def setEditorData ( self , widget : QtWidgets . QWidget , idx : QtCore . QModelIndex ): \"\"\"Sets the data to be displayed and edited by the editor. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" value = idx . model () . data ( idx , QtCore . Qt . ItemDataRole . EditRole ) if value is None : widget . setText ( \"\" ) else : widget . setText ( str ( value )) setModelData \u00b6 setModelData ( widget , model , idx ) Gets data from the editor widget and stores it in the specified model at the item index. Parameters: Name Type Description Default widget QWidget Editor widget. required model QAbstractItemModel Model to store the editor data in. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def setModelData ( self , widget : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , idx : QtCore . QModelIndex , ): \"\"\"Gets data from the editor widget and stores it in the specified model at the item index. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param model: Model to store the editor data in. :type model: QtCore.QAbstractItemModel :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" if not widget . text (): value = None else : value = float ( widget . text ()) model . setData ( idx , value , QtCore . Qt . ItemDataRole . EditRole ) updateEditorGeometry \u00b6 updateEditorGeometry ( widget , option , idx ) Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. Parameters: Name Type Description Default widget QWidget Widget whose geometry will be updated. required option QStyleOptionViewItem Option containing the rectangle for updating the widget. required idx QModelIndex Location of the widget in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def updateEditorGeometry ( self , widget : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ): \"\"\"Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. :param widget: Widget whose geometry will be updated. :type widget: QtWidgets.QWidget :param option: Option containing the rectangle for updating the widget. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the widget in the data model. :type idx: QtCore.QModelIndex \"\"\" widget . setGeometry ( option . rect ) NpvPwlManagerDialog \u00b6 NpvPwlManagerDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for managing NPVs for activities. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . sb_npv . setMaximum ( self . MAXIMUM_NPV_VALUE ) self . sb_npv . setMinimum ( self . MINIMUM_NPV_VALUE ) self . sb_npv . setDecimals ( self . NUM_DECIMAL_PLACES ) self . sb_npv . setReadOnly ( True ) # Initialize UI help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) copy_icon = FileUtils . get_icon ( \"mActionEditCopy.svg\" ) self . tb_copy_npv . setIcon ( copy_icon ) self . tb_copy_npv . clicked . connect ( self . copy_npv ) ok_button = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) ok_button . setText ( tr ( \"Update\" )) # Prevent button from being triggered when Enter is pressed # and use dummy interceptor below ok_button . setAutoDefault ( False ) ok_button . setDefault ( False ) ok_button . clicked . connect ( self . _on_accepted ) # Workaround for intercepting Enter triggers thus preventing the # dialog from being accepted. Not ideal but Qt issue self . _enter_interceptor_btn . setAutoDefault ( True ) self . _enter_interceptor_btn . setDefault ( True ) self . _enter_interceptor_btn . setVisible ( False ) self . _npv = None # Current selected activity identifier self . _current_activity_identifier : str = None icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . btn_help . clicked . connect ( self . open_help ) # Load activities self . _activity_model = ActivityItemModel ( load_pathways = False ) self . lst_activities . setModel ( self . _activity_model ) for activity in settings_manager . get_all_activities (): self . _activity_model . add_activity ( activity ) self . lst_activities . selectionModel () . selectionChanged . connect ( self . on_activity_selection_changed ) # Set view model self . _npv_model = NpvFinancialModel () self . tv_revenue_costs . setModel ( self . _npv_model ) self . _revenue_delegate = FinancialValueItemDelegate () self . _costs_delegate = FinancialValueItemDelegate () self . _discounted_value_delegate = DisplayValueFormatterItemDelegate () self . tv_revenue_costs . setItemDelegateForColumn ( 1 , self . _revenue_delegate ) self . tv_revenue_costs . setItemDelegateForColumn ( 2 , self . _costs_delegate ) self . tv_revenue_costs . setItemDelegateForColumn ( 3 , self . _discounted_value_delegate ) self . _npv_model . itemChanged . connect ( self . on_npv_computation_item_changed ) self . _npv_model . rowsRemoved . connect ( self . on_years_removed ) self . tv_revenue_costs . installEventFilter ( self ) self . sb_num_years . valueChanged . connect ( self . on_number_years_changed ) self . sb_discount . valueChanged . connect ( self . on_discount_rate_changed ) self . sb_npv . valueChanged . connect ( self . on_total_npv_value_changed ) # Set default values self . reset_npv_values () self . cb_computed_npv . toggled . connect ( self . on_use_computed_npvs_toggled ) self . _npv_collection = None # settings_manager.get_npv_collection() if self . _npv_collection is None : self . _npv_collection = ActivityNpvCollection ( 0.0 , 0.0 ) self . sb_min_normalize . setValue ( self . _npv_collection . min_value ) self . sb_max_normalize . setValue ( self . _npv_collection . max_value ) self . cb_computed_npv . setChecked ( self . _npv_collection . use_computed ) self . cb_remove_disabled . setChecked ( self . _npv_collection . remove_existing ) # Select first activity if self . _activity_model . rowCount () > 0 : activity_idx = self . _activity_model . index ( 0 , 0 ) if activity_idx . isValid (): self . lst_activities . selectionModel () . select ( activity_idx , QtCore . QItemSelectionModel . SelectionFlag . ClearAndSelect , ) self . gp_npv_pwl . toggled . connect ( self . _on_activity_npv_groupbox_toggled ) self . cb_manual_npv . toggled . connect ( self . _on_manual_npv_toggled ) npv_collection property \u00b6 npv_collection Gets the activity NPV collection as defined by the user. Returns: Type Description ActivityNpvCollection The activity NPV collection containing the NPV parameters for activities. compute_npv \u00b6 compute_npv () Computes the NPV based on the total of the discounted value and sets it in the corresponding text control. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def compute_npv ( self ): \"\"\"Computes the NPV based on the total of the discounted value and sets it in the corresponding text control. \"\"\" npv = 0.0 self . _npv = None for row in range ( self . _npv_model . rowCount ()): discount_value = self . _npv_model . data ( self . _npv_model . index ( row , 3 ), QtCore . Qt . ItemDataRole . EditRole ) if discount_value is None : continue npv += discount_value self . _npv = npv self . sb_npv . setValue ( npv ) copy_npv \u00b6 copy_npv () Copy NPV to the clipboard. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 453 454 455 def copy_npv ( self ): \"\"\"Copy NPV to the clipboard.\"\"\" QgsApplication . instance () . clipboard () . setText ( str ( self . sb_npv . value ())) enable_npv_parameters_widgets \u00b6 enable_npv_parameters_widgets ( enable ) Enable or disable the UI widgets for specifying NPV parameters. Parameters: Name Type Description Default enable bool True to enable the widgets, else False to disable. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 789 790 791 792 793 794 795 796 797 def enable_npv_parameters_widgets ( self , enable : bool ): \"\"\"Enable or disable the UI widgets for specifying NPV parameters. :param enable: True to enable the widgets, else False to disable. :type enable: bool \"\"\" self . sb_num_years . setEnabled ( enable ) self . sb_discount . setEnabled ( enable ) self . tv_revenue_costs . setEnabled ( enable ) eventFilter \u00b6 eventFilter ( observed_object , event ) Captures events sent to specific widgets. Parameters: Name Type Description Default observed_object QObject Object receiving the event. required event QEvent The specific event being received by the observed object. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def eventFilter ( self , observed_object : QtCore . QObject , event : QtCore . QEvent ): \"\"\"Captures events sent to specific widgets. :param observed_object: Object receiving the event. :type observed_object: QtCore.QObject :param event: The specific event being received by the observed object. :type event: QtCore.QEvent \"\"\" # Resize table columns based on the size of the table view. if observed_object == self . tv_revenue_costs : if event . type () == QtCore . QEvent . Type . Resize : self . resize_column_widths () return super () . eventFilter ( observed_object , event ) is_valid \u00b6 is_valid () Verifies if the input data is valid. Returns: Type Description bool True if the user input is invalid, else False. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def is_valid ( self ) -> bool : \"\"\"Verifies if the input data is valid. :returns: True if the user input is invalid, else False. :rtype: bool \"\"\" status = True self . _message_bar . clearWidgets () if self . sb_min_normalize . value () > self . sb_max_normalize . value (): msg = tr ( \"Minimum normalization value cannot be greater than the \" \"maximum normalization value.\" ) self . _show_warning_message ( msg ) status = False missing_msg_tr = tr ( \"Missing values in Year\" ) for activity_mapping in self . _npv_collection . mappings : # Only validate enabled activity mappings if not activity_mapping . enabled : continue activity_name = activity_mapping . activity . name if activity_mapping . params . manual_npv : if activity_mapping . params . absolute is None : missing_value_tr = tr ( \"Manual NPV is missing\" ) msg = f \" { activity_name } : { missing_value_tr } .\" self . _show_warning_message ( msg ) else : # First check if size of yearly rates matches the numbers of years if activity_mapping . params . years != len ( activity_mapping . params . yearly_rates ): msg = tr ( \"Size of yearly rates and number of years do not match.\" ) self . _show_warning_message ( f \" { activity_name } : { msg } \" ) if status : status = False continue missing_value_rows = [] for i , rates_info in enumerate ( activity_mapping . params . yearly_rates ): if len ( rates_info ) < 3 or None in rates_info : missing_value_rows . append ( str ( i + 1 )) if len ( missing_value_rows ) > 0 : msg = f \" { activity_name } : { missing_msg_tr } { ', ' . join ( missing_value_rows ) } .\" self . _show_warning_message ( msg ) if status : status = False return status load_activity_npv \u00b6 load_activity_npv ( activity_npv ) Loads NPV parameters for an activity. Parameters: Name Type Description Default activity_npv ActivityNpv Container for the NPV parameters for an activity. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def load_activity_npv ( self , activity_npv : ActivityNpv ): \"\"\"Loads NPV parameters for an activity. :param activity_npv: Container for the NPV parameters for an activity. :type activity_npv: ActivityNpv \"\"\" self . _current_activity_identifier = activity_npv . activity_id npv_params = activity_npv . params saved_total_npv = npv_params . absolute self . gp_npv_pwl . setChecked ( activity_npv . enabled ) self . sb_num_years . blockSignals ( True ) self . sb_num_years . setValue ( npv_params . years ) self . sb_num_years . blockSignals ( False ) self . sb_discount . blockSignals ( True ) self . sb_discount . setValue ( npv_params . discount ) self . sb_discount . blockSignals ( False ) self . cb_manual_npv . setChecked ( npv_params . manual_npv ) if npv_params . manual_npv : self . _on_manual_npv_toggled ( True ) self . _npv_model . set_number_of_years ( npv_params . years ) # Update total NPV if auto-computed or manually defined for i , year_info in enumerate ( npv_params . yearly_rates ): if len ( year_info ) < 3 : continue revenue_index = self . _npv_model . index ( i , 1 ) self . _npv_model . setData ( revenue_index , year_info [ 0 ], QtCore . Qt . ItemDataRole . EditRole ) cost_index = self . _npv_model . index ( i , 2 ) self . _npv_model . setData ( cost_index , year_info [ 1 ], QtCore . Qt . ItemDataRole . EditRole ) self . update_all_discounted_values () if npv_params . manual_npv : self . sb_npv . setValue ( saved_total_npv ) on_activity_selection_changed \u00b6 on_activity_selection_changed ( selected , deselected ) Slot raised when the selection of activities changes. Parameters: Name Type Description Default selected QItemSelection Selected items. required deselected QItemSelection Deselected items. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 def on_activity_selection_changed ( self , selected : QtCore . QItemSelection , deselected : QtCore . QItemSelection ): \"\"\"Slot raised when the selection of activities changes. :param selected: Selected items. :type selected: QtCore.QItemSelection :param deselected: Deselected items. :type deselected: QtCore.QItemSelection \"\"\" self . _current_activity_identifier = None self . reset_npv_values () selected_indexes = selected . indexes () if len ( selected_indexes ) == 0 : return if not selected_indexes [ 0 ] . isValid (): return activity_item = self . _activity_model . itemFromIndex ( selected_indexes [ 0 ]) activity_npv = self . _npv_collection . activity_npv ( activity_item . uuid ) if activity_npv is None : return self . load_activity_npv ( activity_npv ) on_discount_rate_changed \u00b6 on_discount_rate_changed ( discount_rate ) Slot raised when discount rate has changed. Parameters: Name Type Description Default discount_rate float New discount rate. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 410 411 412 413 414 415 416 417 418 def on_discount_rate_changed ( self , discount_rate : float ): \"\"\"Slot raised when discount rate has changed. :param discount_rate: New discount rate. :type discount_rate: float \"\"\" # Recompute discounted values self . update_all_discounted_values () self . _update_current_activity_npv () on_npv_computation_item_changed \u00b6 on_npv_computation_item_changed ( item ) Slot raised when the data of an item has changed. Use this to compute discounted value as well as the NPV. Parameters: Name Type Description Default item QStandardItem Item whose value has changed. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def on_npv_computation_item_changed ( self , item : QtGui . QStandardItem ): \"\"\"Slot raised when the data of an item has changed. Use this to compute discounted value as well as the NPV. :param item: Item whose value has changed. :type item: QtGui.QStandardItem \"\"\" self . _message_bar . clearWidgets () # Update discounted value only if revenue or cost # have changed. column = item . column () if column == 1 or column == 2 : self . update_discounted_value ( item . row ()) self . _update_current_activity_npv () on_number_years_changed \u00b6 on_number_years_changed ( years ) Slot raised when the number of years change. Parameters: Name Type Description Default years int The number of years. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 313 314 315 316 317 318 319 320 def on_number_years_changed ( self , years : int ): \"\"\"Slot raised when the number of years change. :param years: The number of years. :type years: int \"\"\" self . _npv_model . set_number_of_years ( years ) self . _update_current_activity_npv () on_total_npv_value_changed \u00b6 on_total_npv_value_changed ( value ) Slot raised when the total NPV has changed either through automatic computation or manual input. Parameters: Name Type Description Default value float NPV value. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def on_total_npv_value_changed ( self , value : float ): \"\"\"Slot raised when the total NPV has changed either through automatic computation or manual input. :param value: NPV value. :type value: float \"\"\" if ( not self . _current_activity_identifier is None and self . cb_manual_npv . isChecked () ): activity_npv = self . _get_current_activity_npv () if activity_npv is not None : activity_npv . params . absolute = self . sb_npv . value () # Update NPV normalization range if self . cb_computed_npv . isChecked (): self . _compute_min_max_range () on_use_computed_npvs_toggled \u00b6 on_use_computed_npvs_toggled ( checked ) Slot raised when the checkbox for using computed min/max NPVs is toggled. Parameters: Name Type Description Default checked bool True to use computed NPVs else False for the user to manually define the min/max values. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def on_use_computed_npvs_toggled ( self , checked : bool ): \"\"\"Slot raised when the checkbox for using computed min/max NPVs is toggled. :param checked: True to use computed NPVs else False for the user to manually define the min/max values. :type checked: bool \"\"\" if checked : self . sb_min_normalize . setEnabled ( False ) self . sb_max_normalize . setEnabled ( False ) self . _compute_min_max_range () else : self . sb_min_normalize . setEnabled ( True ) self . sb_max_normalize . setEnabled ( True ) on_years_removed \u00b6 on_years_removed ( index , start , end ) Slot raised when the year rows have been removed. Parameters: Name Type Description Default index QModelIndex Reference item at the given location. required start int Start location of the items that have been removed. required end int End location of the items that have been removed. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def on_years_removed ( self , index : QtCore . QModelIndex , start : int , end : int ): \"\"\"Slot raised when the year rows have been removed. :param index: Reference item at the given location. :type index: QtCore.QModelIndex :param start: Start location of the items that have been removed. :type start: int :param end: End location of the items that have been removed. :type end: int \"\"\" # Recalculate the NPV self . compute_npv () open_help \u00b6 open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 273 274 275 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) reset_npv_values \u00b6 reset_npv_values () Resets the values for computing the NPV. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 583 584 585 586 587 588 589 590 591 592 593 def reset_npv_values ( self ): \"\"\"Resets the values for computing the NPV.\"\"\" # Set default values # We are resetting to zero to remove all previous user-defined values self . _npv_model . set_number_of_years ( 0 ) self . _npv_model . set_number_of_years ( self . DEFAULT_YEARS ) self . sb_num_years . setValue ( self . DEFAULT_YEARS ) self . sb_discount . setValue ( self . DEFAULT_DISCOUNT_RATE ) self . cb_manual_npv . setChecked ( False ) self . sb_npv . setValue ( 0.0 ) self . gp_npv_pwl . setChecked ( False ) resize_column_widths \u00b6 resize_column_widths () Resize column widths of the NPV revenue and cost table based on its current width. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 303 304 305 306 307 308 309 310 311 def resize_column_widths ( self ): \"\"\"Resize column widths of the NPV revenue and cost table based on its current width. \"\"\" table_width = self . tv_revenue_costs . width () self . tv_revenue_costs . setColumnWidth ( 0 , int ( table_width * 0.09 )) self . tv_revenue_costs . setColumnWidth ( 1 , int ( table_width * 0.33 )) self . tv_revenue_costs . setColumnWidth ( 2 , int ( table_width * 0.33 )) self . tv_revenue_costs . setColumnWidth ( 3 , int ( table_width * 0.24 )) selected_activity \u00b6 selected_activity () Gets the current selected activity. Returns: Type Description Activity Current selected activity or None if there is no selection. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def selected_activity ( self ) -> typing . Optional [ Activity ]: \"\"\"Gets the current selected activity. :returns: Current selected activity or None if there is no selection. :rtype: Activity \"\"\" selected_indexes = self . lst_activities . selectedIndexes () if len ( selected_indexes ) == 0 : return None if not selected_indexes [ 0 ] . isValid (): return None activity_item = self . _activity_model . itemFromIndex ( selected_indexes [ 0 ]) return activity_item . activity update_all_discounted_values \u00b6 update_all_discounted_values () Updates all discounted values that had already been computed using the revised discount rate. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 398 399 400 401 402 403 404 405 406 407 408 def update_all_discounted_values ( self ): \"\"\"Updates all discounted values that had already been computed using the revised discount rate. \"\"\" for row in range ( self . _npv_model . rowCount ()): discount_value = self . _npv_model . data ( self . _npv_model . index ( row , 3 ), QtCore . Qt . ItemDataRole . EditRole ) if discount_value is None : continue self . update_discounted_value ( row ) update_discounted_value \u00b6 update_discounted_value ( row ) Updated the discounted value for the given row number. Parameters: Name Type Description Default row int Row number to compute the discounted value. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def update_discounted_value ( self , row : int ): \"\"\"Updated the discounted value for the given row number. :param row: Row number to compute the discounted value. :type row: int \"\"\" # For computation purposes, any None value will be # translated to zero. revenue = self . _npv_model . data ( self . _npv_model . index ( row , 1 ), QtCore . Qt . ItemDataRole . EditRole ) cost = self . _npv_model . data ( self . _npv_model . index ( row , 2 ), QtCore . Qt . ItemDataRole . EditRole ) # No need to compute if both revenue and cost have not been defined if revenue is None and cost is None : return if revenue is None : revenue = 0.0 if cost is None : cost = 0.0 discounted_value = compute_discount_value ( revenue , cost , row + 1 , self . sb_discount . value () ) rounded_discounted_value = round ( discounted_value , self . NUM_DECIMAL_PLACES ) discounted_value_index = self . _npv_model . index ( row , 3 ) self . _npv_model . setData ( discounted_value_index , rounded_discounted_value , QtCore . Qt . ItemDataRole . EditRole , ) if not self . cb_manual_npv . isChecked (): self . compute_npv ()","title":"NPV PWL manager"},{"location":"developer/api/gui/api_npv_manager_dialog/#npv-priority-weighting-layer-manager-dialog","text":"Dialog for creating a new financial PWL.","title":"NPV Priority Weighting Layer Manager Dialog"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.DisplayValueFormatterItemDelegate","text":"Bases: QStyledItemDelegate Delegate for formatting numeric values using thousand comma separator, number of decimal places etc.","title":"DisplayValueFormatterItemDelegate"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.DisplayValueFormatterItemDelegate.displayText","text":"displayText ( value , locale ) Format the value to incorporate thousand comma separator. Parameters: Name Type Description Default value float Value of the display role provided by the model. required locale QLocale Locale for the value in the display role. required Returns: Type Description str Formatted value of the display role data. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def displayText ( self , value : float , locale : QtCore . QLocale ) -> str : \"\"\"Format the value to incorporate thousand comma separator. :param value: Value of the display role provided by the model. :type value: float :param locale: Locale for the value in the display role. :type locale: QtCore.QLocale :returns: Formatted value of the display role data. :rtype: str \"\"\" if value is None : return \"\" formatter = QgsBasicNumericFormat () formatter . setShowThousandsSeparator ( True ) formatter . setNumberDecimalPlaces ( DEFAULT_DECIMAL_PLACES ) return formatter . formatDouble ( float ( value ), QgsNumericFormatContext ())","title":"displayText"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.FinancialValueItemDelegate","text":"Bases: DisplayValueFormatterItemDelegate Delegate for ensuring only numbers are specified in financial value fields.","title":"FinancialValueItemDelegate"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.FinancialValueItemDelegate.createEditor","text":"createEditor ( parent , option , idx ) Creates a line edit control whose input value is limited to numbers only. Parameters: Name Type Description Default parent QWidget Parent widget. required option QStyleOptionViewItem Options for drawing the widget in the view. required idx QModelIndex Location of the request in the data model. required Returns: Type Description QtWidgets.QLineEdit The editor widget. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def createEditor ( self , parent : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ) -> QtWidgets . QLineEdit : \"\"\"Creates a line edit control whose input value is limited to numbers only. :param parent: Parent widget. :type parent: QtWidgets.QWidget :param option: Options for drawing the widget in the view. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the request in the data model. :type idx: QtCore.QModelIndex :returns: The editor widget. :rtype: QtWidgets.QLineEdit \"\"\" line_edit = QtWidgets . QLineEdit ( parent ) line_edit . setFrame ( False ) line_edit . setMaxLength ( 50 ) validator = QtGui . QDoubleValidator () validator . setDecimals ( 2 ) line_edit . setValidator ( validator ) return line_edit","title":"createEditor"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.FinancialValueItemDelegate.setEditorData","text":"setEditorData ( widget , idx ) Sets the data to be displayed and edited by the editor. Parameters: Name Type Description Default widget QWidget Editor widget. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def setEditorData ( self , widget : QtWidgets . QWidget , idx : QtCore . QModelIndex ): \"\"\"Sets the data to be displayed and edited by the editor. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" value = idx . model () . data ( idx , QtCore . Qt . ItemDataRole . EditRole ) if value is None : widget . setText ( \"\" ) else : widget . setText ( str ( value ))","title":"setEditorData"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.FinancialValueItemDelegate.setModelData","text":"setModelData ( widget , model , idx ) Gets data from the editor widget and stores it in the specified model at the item index. Parameters: Name Type Description Default widget QWidget Editor widget. required model QAbstractItemModel Model to store the editor data in. required idx QModelIndex Location in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def setModelData ( self , widget : QtWidgets . QWidget , model : QtCore . QAbstractItemModel , idx : QtCore . QModelIndex , ): \"\"\"Gets data from the editor widget and stores it in the specified model at the item index. :param widget: Editor widget. :type widget: QtWidgets.QWidget :param model: Model to store the editor data in. :type model: QtCore.QAbstractItemModel :param idx: Location in the data model. :type idx: QtCore.QModelIndex \"\"\" if not widget . text (): value = None else : value = float ( widget . text ()) model . setData ( idx , value , QtCore . Qt . ItemDataRole . EditRole )","title":"setModelData"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.FinancialValueItemDelegate.updateEditorGeometry","text":"updateEditorGeometry ( widget , option , idx ) Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. Parameters: Name Type Description Default widget QWidget Widget whose geometry will be updated. required option QStyleOptionViewItem Option containing the rectangle for updating the widget. required idx QModelIndex Location of the widget in the data model. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def updateEditorGeometry ( self , widget : QtWidgets . QWidget , option : QtWidgets . QStyleOptionViewItem , idx : QtCore . QModelIndex , ): \"\"\"Updates the geometry of the editor for the item with the given index, according to the rectangle specified in the option. :param widget: Widget whose geometry will be updated. :type widget: QtWidgets.QWidget :param option: Option containing the rectangle for updating the widget. :type option: QtWidgets.QStyleOptionViewItem :param idx: Location of the widget in the data model. :type idx: QtCore.QModelIndex \"\"\" widget . setGeometry ( option . rect )","title":"updateEditorGeometry"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog","text":"NpvPwlManagerDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for managing NPVs for activities. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _message_bar = QgsMessageBar () self . vl_notification . addWidget ( self . _message_bar ) self . sb_npv . setMaximum ( self . MAXIMUM_NPV_VALUE ) self . sb_npv . setMinimum ( self . MINIMUM_NPV_VALUE ) self . sb_npv . setDecimals ( self . NUM_DECIMAL_PLACES ) self . sb_npv . setReadOnly ( True ) # Initialize UI help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) copy_icon = FileUtils . get_icon ( \"mActionEditCopy.svg\" ) self . tb_copy_npv . setIcon ( copy_icon ) self . tb_copy_npv . clicked . connect ( self . copy_npv ) ok_button = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) ok_button . setText ( tr ( \"Update\" )) # Prevent button from being triggered when Enter is pressed # and use dummy interceptor below ok_button . setAutoDefault ( False ) ok_button . setDefault ( False ) ok_button . clicked . connect ( self . _on_accepted ) # Workaround for intercepting Enter triggers thus preventing the # dialog from being accepted. Not ideal but Qt issue self . _enter_interceptor_btn . setAutoDefault ( True ) self . _enter_interceptor_btn . setDefault ( True ) self . _enter_interceptor_btn . setVisible ( False ) self . _npv = None # Current selected activity identifier self . _current_activity_identifier : str = None icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . btn_help . clicked . connect ( self . open_help ) # Load activities self . _activity_model = ActivityItemModel ( load_pathways = False ) self . lst_activities . setModel ( self . _activity_model ) for activity in settings_manager . get_all_activities (): self . _activity_model . add_activity ( activity ) self . lst_activities . selectionModel () . selectionChanged . connect ( self . on_activity_selection_changed ) # Set view model self . _npv_model = NpvFinancialModel () self . tv_revenue_costs . setModel ( self . _npv_model ) self . _revenue_delegate = FinancialValueItemDelegate () self . _costs_delegate = FinancialValueItemDelegate () self . _discounted_value_delegate = DisplayValueFormatterItemDelegate () self . tv_revenue_costs . setItemDelegateForColumn ( 1 , self . _revenue_delegate ) self . tv_revenue_costs . setItemDelegateForColumn ( 2 , self . _costs_delegate ) self . tv_revenue_costs . setItemDelegateForColumn ( 3 , self . _discounted_value_delegate ) self . _npv_model . itemChanged . connect ( self . on_npv_computation_item_changed ) self . _npv_model . rowsRemoved . connect ( self . on_years_removed ) self . tv_revenue_costs . installEventFilter ( self ) self . sb_num_years . valueChanged . connect ( self . on_number_years_changed ) self . sb_discount . valueChanged . connect ( self . on_discount_rate_changed ) self . sb_npv . valueChanged . connect ( self . on_total_npv_value_changed ) # Set default values self . reset_npv_values () self . cb_computed_npv . toggled . connect ( self . on_use_computed_npvs_toggled ) self . _npv_collection = None # settings_manager.get_npv_collection() if self . _npv_collection is None : self . _npv_collection = ActivityNpvCollection ( 0.0 , 0.0 ) self . sb_min_normalize . setValue ( self . _npv_collection . min_value ) self . sb_max_normalize . setValue ( self . _npv_collection . max_value ) self . cb_computed_npv . setChecked ( self . _npv_collection . use_computed ) self . cb_remove_disabled . setChecked ( self . _npv_collection . remove_existing ) # Select first activity if self . _activity_model . rowCount () > 0 : activity_idx = self . _activity_model . index ( 0 , 0 ) if activity_idx . isValid (): self . lst_activities . selectionModel () . select ( activity_idx , QtCore . QItemSelectionModel . SelectionFlag . ClearAndSelect , ) self . gp_npv_pwl . toggled . connect ( self . _on_activity_npv_groupbox_toggled ) self . cb_manual_npv . toggled . connect ( self . _on_manual_npv_toggled )","title":"NpvPwlManagerDialog"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.npv_collection","text":"npv_collection Gets the activity NPV collection as defined by the user. Returns: Type Description ActivityNpvCollection The activity NPV collection containing the NPV parameters for activities.","title":"npv_collection"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.compute_npv","text":"compute_npv () Computes the NPV based on the total of the discounted value and sets it in the corresponding text control. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def compute_npv ( self ): \"\"\"Computes the NPV based on the total of the discounted value and sets it in the corresponding text control. \"\"\" npv = 0.0 self . _npv = None for row in range ( self . _npv_model . rowCount ()): discount_value = self . _npv_model . data ( self . _npv_model . index ( row , 3 ), QtCore . Qt . ItemDataRole . EditRole ) if discount_value is None : continue npv += discount_value self . _npv = npv self . sb_npv . setValue ( npv )","title":"compute_npv"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.copy_npv","text":"copy_npv () Copy NPV to the clipboard. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 453 454 455 def copy_npv ( self ): \"\"\"Copy NPV to the clipboard.\"\"\" QgsApplication . instance () . clipboard () . setText ( str ( self . sb_npv . value ()))","title":"copy_npv"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.enable_npv_parameters_widgets","text":"enable_npv_parameters_widgets ( enable ) Enable or disable the UI widgets for specifying NPV parameters. Parameters: Name Type Description Default enable bool True to enable the widgets, else False to disable. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 789 790 791 792 793 794 795 796 797 def enable_npv_parameters_widgets ( self , enable : bool ): \"\"\"Enable or disable the UI widgets for specifying NPV parameters. :param enable: True to enable the widgets, else False to disable. :type enable: bool \"\"\" self . sb_num_years . setEnabled ( enable ) self . sb_discount . setEnabled ( enable ) self . tv_revenue_costs . setEnabled ( enable )","title":"enable_npv_parameters_widgets"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.eventFilter","text":"eventFilter ( observed_object , event ) Captures events sent to specific widgets. Parameters: Name Type Description Default observed_object QObject Object receiving the event. required event QEvent The specific event being received by the observed object. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def eventFilter ( self , observed_object : QtCore . QObject , event : QtCore . QEvent ): \"\"\"Captures events sent to specific widgets. :param observed_object: Object receiving the event. :type observed_object: QtCore.QObject :param event: The specific event being received by the observed object. :type event: QtCore.QEvent \"\"\" # Resize table columns based on the size of the table view. if observed_object == self . tv_revenue_costs : if event . type () == QtCore . QEvent . Type . Resize : self . resize_column_widths () return super () . eventFilter ( observed_object , event )","title":"eventFilter"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.is_valid","text":"is_valid () Verifies if the input data is valid. Returns: Type Description bool True if the user input is invalid, else False. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 def is_valid ( self ) -> bool : \"\"\"Verifies if the input data is valid. :returns: True if the user input is invalid, else False. :rtype: bool \"\"\" status = True self . _message_bar . clearWidgets () if self . sb_min_normalize . value () > self . sb_max_normalize . value (): msg = tr ( \"Minimum normalization value cannot be greater than the \" \"maximum normalization value.\" ) self . _show_warning_message ( msg ) status = False missing_msg_tr = tr ( \"Missing values in Year\" ) for activity_mapping in self . _npv_collection . mappings : # Only validate enabled activity mappings if not activity_mapping . enabled : continue activity_name = activity_mapping . activity . name if activity_mapping . params . manual_npv : if activity_mapping . params . absolute is None : missing_value_tr = tr ( \"Manual NPV is missing\" ) msg = f \" { activity_name } : { missing_value_tr } .\" self . _show_warning_message ( msg ) else : # First check if size of yearly rates matches the numbers of years if activity_mapping . params . years != len ( activity_mapping . params . yearly_rates ): msg = tr ( \"Size of yearly rates and number of years do not match.\" ) self . _show_warning_message ( f \" { activity_name } : { msg } \" ) if status : status = False continue missing_value_rows = [] for i , rates_info in enumerate ( activity_mapping . params . yearly_rates ): if len ( rates_info ) < 3 or None in rates_info : missing_value_rows . append ( str ( i + 1 )) if len ( missing_value_rows ) > 0 : msg = f \" { activity_name } : { missing_msg_tr } { ', ' . join ( missing_value_rows ) } .\" self . _show_warning_message ( msg ) if status : status = False return status","title":"is_valid"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.load_activity_npv","text":"load_activity_npv ( activity_npv ) Loads NPV parameters for an activity. Parameters: Name Type Description Default activity_npv ActivityNpv Container for the NPV parameters for an activity. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def load_activity_npv ( self , activity_npv : ActivityNpv ): \"\"\"Loads NPV parameters for an activity. :param activity_npv: Container for the NPV parameters for an activity. :type activity_npv: ActivityNpv \"\"\" self . _current_activity_identifier = activity_npv . activity_id npv_params = activity_npv . params saved_total_npv = npv_params . absolute self . gp_npv_pwl . setChecked ( activity_npv . enabled ) self . sb_num_years . blockSignals ( True ) self . sb_num_years . setValue ( npv_params . years ) self . sb_num_years . blockSignals ( False ) self . sb_discount . blockSignals ( True ) self . sb_discount . setValue ( npv_params . discount ) self . sb_discount . blockSignals ( False ) self . cb_manual_npv . setChecked ( npv_params . manual_npv ) if npv_params . manual_npv : self . _on_manual_npv_toggled ( True ) self . _npv_model . set_number_of_years ( npv_params . years ) # Update total NPV if auto-computed or manually defined for i , year_info in enumerate ( npv_params . yearly_rates ): if len ( year_info ) < 3 : continue revenue_index = self . _npv_model . index ( i , 1 ) self . _npv_model . setData ( revenue_index , year_info [ 0 ], QtCore . Qt . ItemDataRole . EditRole ) cost_index = self . _npv_model . index ( i , 2 ) self . _npv_model . setData ( cost_index , year_info [ 1 ], QtCore . Qt . ItemDataRole . EditRole ) self . update_all_discounted_values () if npv_params . manual_npv : self . sb_npv . setValue ( saved_total_npv )","title":"load_activity_npv"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_activity_selection_changed","text":"on_activity_selection_changed ( selected , deselected ) Slot raised when the selection of activities changes. Parameters: Name Type Description Default selected QItemSelection Selected items. required deselected QItemSelection Deselected items. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 def on_activity_selection_changed ( self , selected : QtCore . QItemSelection , deselected : QtCore . QItemSelection ): \"\"\"Slot raised when the selection of activities changes. :param selected: Selected items. :type selected: QtCore.QItemSelection :param deselected: Deselected items. :type deselected: QtCore.QItemSelection \"\"\" self . _current_activity_identifier = None self . reset_npv_values () selected_indexes = selected . indexes () if len ( selected_indexes ) == 0 : return if not selected_indexes [ 0 ] . isValid (): return activity_item = self . _activity_model . itemFromIndex ( selected_indexes [ 0 ]) activity_npv = self . _npv_collection . activity_npv ( activity_item . uuid ) if activity_npv is None : return self . load_activity_npv ( activity_npv )","title":"on_activity_selection_changed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_discount_rate_changed","text":"on_discount_rate_changed ( discount_rate ) Slot raised when discount rate has changed. Parameters: Name Type Description Default discount_rate float New discount rate. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 410 411 412 413 414 415 416 417 418 def on_discount_rate_changed ( self , discount_rate : float ): \"\"\"Slot raised when discount rate has changed. :param discount_rate: New discount rate. :type discount_rate: float \"\"\" # Recompute discounted values self . update_all_discounted_values () self . _update_current_activity_npv ()","title":"on_discount_rate_changed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_npv_computation_item_changed","text":"on_npv_computation_item_changed ( item ) Slot raised when the data of an item has changed. Use this to compute discounted value as well as the NPV. Parameters: Name Type Description Default item QStandardItem Item whose value has changed. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 def on_npv_computation_item_changed ( self , item : QtGui . QStandardItem ): \"\"\"Slot raised when the data of an item has changed. Use this to compute discounted value as well as the NPV. :param item: Item whose value has changed. :type item: QtGui.QStandardItem \"\"\" self . _message_bar . clearWidgets () # Update discounted value only if revenue or cost # have changed. column = item . column () if column == 1 or column == 2 : self . update_discounted_value ( item . row ()) self . _update_current_activity_npv ()","title":"on_npv_computation_item_changed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_number_years_changed","text":"on_number_years_changed ( years ) Slot raised when the number of years change. Parameters: Name Type Description Default years int The number of years. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 313 314 315 316 317 318 319 320 def on_number_years_changed ( self , years : int ): \"\"\"Slot raised when the number of years change. :param years: The number of years. :type years: int \"\"\" self . _npv_model . set_number_of_years ( years ) self . _update_current_activity_npv ()","title":"on_number_years_changed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_total_npv_value_changed","text":"on_total_npv_value_changed ( value ) Slot raised when the total NPV has changed either through automatic computation or manual input. Parameters: Name Type Description Default value float NPV value. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def on_total_npv_value_changed ( self , value : float ): \"\"\"Slot raised when the total NPV has changed either through automatic computation or manual input. :param value: NPV value. :type value: float \"\"\" if ( not self . _current_activity_identifier is None and self . cb_manual_npv . isChecked () ): activity_npv = self . _get_current_activity_npv () if activity_npv is not None : activity_npv . params . absolute = self . sb_npv . value () # Update NPV normalization range if self . cb_computed_npv . isChecked (): self . _compute_min_max_range ()","title":"on_total_npv_value_changed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_use_computed_npvs_toggled","text":"on_use_computed_npvs_toggled ( checked ) Slot raised when the checkbox for using computed min/max NPVs is toggled. Parameters: Name Type Description Default checked bool True to use computed NPVs else False for the user to manually define the min/max values. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 521 522 523 524 525 526 527 528 529 530 531 532 533 534 def on_use_computed_npvs_toggled ( self , checked : bool ): \"\"\"Slot raised when the checkbox for using computed min/max NPVs is toggled. :param checked: True to use computed NPVs else False for the user to manually define the min/max values. :type checked: bool \"\"\" if checked : self . sb_min_normalize . setEnabled ( False ) self . sb_max_normalize . setEnabled ( False ) self . _compute_min_max_range () else : self . sb_min_normalize . setEnabled ( True ) self . sb_max_normalize . setEnabled ( True )","title":"on_use_computed_npvs_toggled"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.on_years_removed","text":"on_years_removed ( index , start , end ) Slot raised when the year rows have been removed. Parameters: Name Type Description Default index QModelIndex Reference item at the given location. required start int Start location of the items that have been removed. required end int End location of the items that have been removed. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def on_years_removed ( self , index : QtCore . QModelIndex , start : int , end : int ): \"\"\"Slot raised when the year rows have been removed. :param index: Reference item at the given location. :type index: QtCore.QModelIndex :param start: Start location of the items that have been removed. :type start: int :param end: End location of the items that have been removed. :type end: int \"\"\" # Recalculate the NPV self . compute_npv ()","title":"on_years_removed"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 273 274 275 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.reset_npv_values","text":"reset_npv_values () Resets the values for computing the NPV. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 583 584 585 586 587 588 589 590 591 592 593 def reset_npv_values ( self ): \"\"\"Resets the values for computing the NPV.\"\"\" # Set default values # We are resetting to zero to remove all previous user-defined values self . _npv_model . set_number_of_years ( 0 ) self . _npv_model . set_number_of_years ( self . DEFAULT_YEARS ) self . sb_num_years . setValue ( self . DEFAULT_YEARS ) self . sb_discount . setValue ( self . DEFAULT_DISCOUNT_RATE ) self . cb_manual_npv . setChecked ( False ) self . sb_npv . setValue ( 0.0 ) self . gp_npv_pwl . setChecked ( False )","title":"reset_npv_values"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.resize_column_widths","text":"resize_column_widths () Resize column widths of the NPV revenue and cost table based on its current width. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 303 304 305 306 307 308 309 310 311 def resize_column_widths ( self ): \"\"\"Resize column widths of the NPV revenue and cost table based on its current width. \"\"\" table_width = self . tv_revenue_costs . width () self . tv_revenue_costs . setColumnWidth ( 0 , int ( table_width * 0.09 )) self . tv_revenue_costs . setColumnWidth ( 1 , int ( table_width * 0.33 )) self . tv_revenue_costs . setColumnWidth ( 2 , int ( table_width * 0.33 )) self . tv_revenue_costs . setColumnWidth ( 3 , int ( table_width * 0.24 ))","title":"resize_column_widths"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.selected_activity","text":"selected_activity () Gets the current selected activity. Returns: Type Description Activity Current selected activity or None if there is no selection. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 def selected_activity ( self ) -> typing . Optional [ Activity ]: \"\"\"Gets the current selected activity. :returns: Current selected activity or None if there is no selection. :rtype: Activity \"\"\" selected_indexes = self . lst_activities . selectedIndexes () if len ( selected_indexes ) == 0 : return None if not selected_indexes [ 0 ] . isValid (): return None activity_item = self . _activity_model . itemFromIndex ( selected_indexes [ 0 ]) return activity_item . activity","title":"selected_activity"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.update_all_discounted_values","text":"update_all_discounted_values () Updates all discounted values that had already been computed using the revised discount rate. Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 398 399 400 401 402 403 404 405 406 407 408 def update_all_discounted_values ( self ): \"\"\"Updates all discounted values that had already been computed using the revised discount rate. \"\"\" for row in range ( self . _npv_model . rowCount ()): discount_value = self . _npv_model . data ( self . _npv_model . index ( row , 3 ), QtCore . Qt . ItemDataRole . EditRole ) if discount_value is None : continue self . update_discounted_value ( row )","title":"update_all_discounted_values"},{"location":"developer/api/gui/api_npv_manager_dialog/#src.cplus_plugin.gui.financials.npv_manager_dialog.NpvPwlManagerDialog.update_discounted_value","text":"update_discounted_value ( row ) Updated the discounted value for the given row number. Parameters: Name Type Description Default row int Row number to compute the discounted value. required Source code in src/cplus_plugin/gui/financials/npv_manager_dialog.py 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 def update_discounted_value ( self , row : int ): \"\"\"Updated the discounted value for the given row number. :param row: Row number to compute the discounted value. :type row: int \"\"\" # For computation purposes, any None value will be # translated to zero. revenue = self . _npv_model . data ( self . _npv_model . index ( row , 1 ), QtCore . Qt . ItemDataRole . EditRole ) cost = self . _npv_model . data ( self . _npv_model . index ( row , 2 ), QtCore . Qt . ItemDataRole . EditRole ) # No need to compute if both revenue and cost have not been defined if revenue is None and cost is None : return if revenue is None : revenue = 0.0 if cost is None : cost = 0.0 discounted_value = compute_discount_value ( revenue , cost , row + 1 , self . sb_discount . value () ) rounded_discounted_value = round ( discounted_value , self . NUM_DECIMAL_PLACES ) discounted_value_index = self . _npv_model . index ( row , 3 ) self . _npv_model . setData ( discounted_value_index , rounded_discounted_value , QtCore . Qt . ItemDataRole . EditRole , ) if not self . cb_manual_npv . isChecked (): self . compute_npv ()","title":"update_discounted_value"},{"location":"developer/api/gui/api_npv_progress_dialog/","text":"NPV Progress Dialog \u00b6 Dialog for showing the progress of creating NPV PWL layers. NpvPwlProgressDialog \u00b6 NpvPwlProgressDialog ( parent , feedback ) Bases: QProgressDialog Dialog for showing the progress of creating NPV PWL layers. Source code in src/cplus_plugin/gui/financials/npv_progress_dialog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , parent , feedback ): super () . __init__ ( tr ( \"Creating NPV priority weighting layers...\" ), tr ( \"Cancel\" ), 0 , 100 , parent , ) self . _feedback = feedback self . _feedback . progressChanged . connect ( self . _on_progress_changed ) self . canceled . connect ( self . _on_canceled ) self . setWindowTitle ( tr ( \"NPW PWL Progress\" ))","title":"NPV progress dialog"},{"location":"developer/api/gui/api_npv_progress_dialog/#npv-progress-dialog","text":"Dialog for showing the progress of creating NPV PWL layers.","title":"NPV Progress Dialog"},{"location":"developer/api/gui/api_npv_progress_dialog/#src.cplus_plugin.gui.financials.npv_progress_dialog.NpvPwlProgressDialog","text":"NpvPwlProgressDialog ( parent , feedback ) Bases: QProgressDialog Dialog for showing the progress of creating NPV PWL layers. Source code in src/cplus_plugin/gui/financials/npv_progress_dialog.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , parent , feedback ): super () . __init__ ( tr ( \"Creating NPV priority weighting layers...\" ), tr ( \"Cancel\" ), 0 , 100 , parent , ) self . _feedback = feedback self . _feedback . progressChanged . connect ( self . _on_progress_changed ) self . canceled . connect ( self . _on_canceled ) self . setWindowTitle ( tr ( \"NPW PWL Progress\" ))","title":"NpvPwlProgressDialog"},{"location":"developer/api/gui/api_pixel_value_editor/","text":"Style pixel value editor \u00b6 Dialog for setting the pixel value for styling activities. PixelValueEditorDialog \u00b6 PixelValueEditorDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for setting the pixel value for styling activities. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . _item_model = QtGui . QStandardItemModel ( self ) self . _item_model . setColumnCount ( 1 ) self . tv_activities . setModel ( self . _item_model ) self . tv_activities . setDragEnabled ( True ) self . tv_activities . setAcceptDrops ( True ) self . tv_activities . setShowGrid ( False ) self . tv_activities . setDragDropOverwriteMode ( False ) self . tv_activities . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . InternalMove ) self . tv_activities . horizontalHeader () . setSectionResizeMode ( QtWidgets . QHeaderView . ResizeMode . Stretch ) self . _load_items () item_mapping property \u00b6 item_mapping Returns a mapping of the activity position in the table and its corresponding unique identifier. We are using an OrderedDict to ensure consistency across different Python versions in the different platforms that QGIS runs on. Returns: Type Description OrderedDict The mapping of the activities' positions in the table and its corresponding unique identifier. open_help \u00b6 open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 70 71 72 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"Pixel Values editor"},{"location":"developer/api/gui/api_pixel_value_editor/#style-pixel-value-editor","text":"Dialog for setting the pixel value for styling activities.","title":"Style pixel value editor"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog","text":"PixelValueEditorDialog ( parent = None ) Bases: QDialog , WidgetUi Dialog for setting the pixel value for styling activities. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def __init__ ( self , parent = None ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) self . _item_model = QtGui . QStandardItemModel ( self ) self . _item_model . setColumnCount ( 1 ) self . tv_activities . setModel ( self . _item_model ) self . tv_activities . setDragEnabled ( True ) self . tv_activities . setAcceptDrops ( True ) self . tv_activities . setShowGrid ( False ) self . tv_activities . setDragDropOverwriteMode ( False ) self . tv_activities . setDragDropMode ( QtWidgets . QAbstractItemView . DragDropMode . InternalMove ) self . tv_activities . horizontalHeader () . setSectionResizeMode ( QtWidgets . QHeaderView . ResizeMode . Stretch ) self . _load_items ()","title":"PixelValueEditorDialog"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog.item_mapping","text":"item_mapping Returns a mapping of the activity position in the table and its corresponding unique identifier. We are using an OrderedDict to ensure consistency across different Python versions in the different platforms that QGIS runs on. Returns: Type Description OrderedDict The mapping of the activities' positions in the table and its corresponding unique identifier.","title":"item_mapping"},{"location":"developer/api/gui/api_pixel_value_editor/#src.cplus_plugin.gui.pixel_value_editor_dialog.PixelValueEditorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/pixel_value_editor_dialog.py 70 71 72 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_priority_group/","text":"Priority group \u00b6 Priority group item widget PriorityGroupWidget \u00b6 PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui () group_value \u00b6 group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value () initialize_ui \u00b6 initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider ) name \u00b6 name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" ) set_group \u00b6 set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ])) update_slider \u00b6 update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False ) update_spin_box \u00b6 update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False ) widgets \u00b6 widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#priority-group","text":"Priority group item widget","title":"Priority group"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget","text":"PriorityGroupWidget ( group , parent = None ) Bases: QWidget , WidgetUi Widget that provide UI for priority group details. Source code in src/cplus_plugin/gui/priority_group_widget.py 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , group , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . group = group self . initialize_ui ()","title":"PriorityGroupWidget"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.group_value","text":"group_value () Returns: name (dict): Priority group value Source code in src/cplus_plugin/gui/priority_group_widget.py 72 73 74 75 76 77 def group_value ( self ): \"\"\" Returns: name (dict): Priority group value \"\"\" return self . group_slider . value ()","title":"group_value"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the widget Source code in src/cplus_plugin/gui/priority_group_widget.py 40 41 42 43 44 45 46 47 48 49 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the widget\"\"\" if self . group is not None : self . group_la . setText ( self . group . get ( \"name\" )) self . group_slider . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_spin_box . setValue ( int ( self . group . get ( \"value\" , 0 ))) self . group_slider . valueChanged . connect ( self . update_spin_box ) self . group_spin_box . valueChanged . connect ( self . update_slider )","title":"initialize_ui"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.name","text":"name () Returns: name (dict): Priority group name Source code in src/cplus_plugin/gui/priority_group_widget.py 65 66 67 68 69 70 def name ( self ): \"\"\" Returns: name (dict): Priority group name \"\"\" return self . group . get ( \"name\" )","title":"name"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.set_group","text":"set_group ( group ) Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group Source code in src/cplus_plugin/gui/priority_group_widget.py 51 52 53 54 55 56 57 58 59 60 61 62 63 def set_group ( self , group ): \"\"\"Sets the priority layer group and updates the slider and input values Args: group (dict): Priority group \"\"\" if group is not None : self . group = group self . group_la . setText ( group . get ( \"name\" )) self . group_slider . setValue ( int ( group [ \"value\" ])) self . group_spin_box . setValue ( int ( group [ \"value\" ]))","title":"set_group"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_slider","text":"update_slider ( value ) Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 79 80 81 82 83 84 85 86 87 88 89 90 91 def update_slider ( self , value ): \"\"\"Changes the current slider value. Args: value (int): Value to be set on the slider Note: Emits input_value_changed signal \"\"\" if self . group is not None : self . input_value_changed . emit ( self . group [ \"name\" ], value ) self . group_slider . blockSignals ( True ) self . group_slider . setValue ( value ) self . group_slider . blockSignals ( False )","title":"update_slider"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.update_spin_box","text":"update_spin_box ( value ) Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal Source code in src/cplus_plugin/gui/priority_group_widget.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def update_spin_box ( self , value ): \"\"\"Changes the input value of the spin box Args: value (int): Value to be set on the spin box. Note: Emits slider_value_changed signal \"\"\" if self . group is not None : self . slider_value_changed . emit ( self . group [ \"name\" ], value ) self . group_spin_box . blockSignals ( True ) self . group_spin_box . setValue ( value ) self . group_spin_box . blockSignals ( False )","title":"update_spin_box"},{"location":"developer/api/gui/api_priority_group/#src.cplus_plugin.gui.priority_group_widget.PriorityGroupWidget.widgets","text":"widgets () Returns widget_list (list): List of component widgets for the priority group widget Source code in src/cplus_plugin/gui/priority_group_widget.py 108 109 110 111 112 113 114 def widgets ( self ) -> typing . List [ QtWidgets . QWidget ]: \"\"\" Returns widget_list (list): List of component widgets for the priority group widget \"\"\" return [ self . group_la , self . group_slider , self . group_spin_box ]","title":"widgets"},{"location":"developer/api/gui/api_priority_layer/","text":"Priority weighting layer dialog \u00b6 Priority layer dialog PriorityLayerDialog \u00b6 PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , self . cbo_default_layer . currentIndexChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . _user_defined = True self . ncs_pathways = [] self . initialize_ui () accept \u00b6 accept () Handles logic for adding new priority layer and an edit existing one. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def accept ( self ): \"\"\"Handles logic for adding new priority layer and an edit existing one.\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} layer_type = PriorityLayerType . DEFAULT . value if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer_type = self . layer . get ( \"type\" , PriorityLayerType . DEFAULT . value ) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"is_carbon\" ] = self . carbon_enabled . isChecked () layer [ \"groups\" ] = layer_groups default_layer = self . _get_selected_default_layer () if default_layer : layer [ \"path\" ] = \"cplus://\" + default_layer . get ( \"layer_uuid\" ) else : layer [ \"path\" ] = self . map_layer_file_widget . filePath () layer [ \"type\" ] = layer_type layer [ USER_DEFINED_ATTRIBUTE ] = self . _user_defined settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_items ( self . ncs_pathways ) super () . accept () initialize_ui \u00b6 initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents_green.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_pathways_btn . clicked . connect ( self . open_layer_select_dialog ) default_priority_layers = settings_manager . get_default_layers ( \"priority_layer\" ) self . cbo_default_layer . addItem ( \"\" ) self . cbo_default_layer . addItems ([ p [ \"name\" ] for p in default_priority_layers ]) self . cbo_default_layer . setCurrentIndex ( 0 ) self . cbo_default_layer . currentIndexChanged . connect ( self . _on_default_layer_selection_changed ) if self . layer is not None : # If its an NPV PWL, then disable controls as the information is managed # through the NPV manager. Only the description can be updated. pwl_type = self . layer . get ( \"type\" , PriorityLayerType . DEFAULT . value ) if pwl_type == PriorityLayerType . NPV : self . _disable_input_controls () layer_path = self . layer . get ( \"path\" ) if layer_path . startswith ( \"cplus://\" ): layer_uuid = layer_path . replace ( \"cplus://\" , \"\" ) for i , layer in enumerate ( default_priority_layers ): if layer [ \"layer_uuid\" ] == layer_uuid : self . cbo_default_layer . setCurrentIndex ( i + 1 ) break else : layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if ( not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids ): base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . map_layer_file_widget . setFilePath ( layer_path ) self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . carbon_enabled . setChecked ( self . layer . get ( \"is_carbon\" , False )) all_pathways = settings_manager . get_all_ncs_pathways () for pathway in all_pathways : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in pathway . priority_layers if layer is not None ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . ncs_pathways . append ( pathway ) self . set_selected_items ( self . ncs_pathways ) self . _user_defined = self . layer . get ( USER_DEFINED_ATTRIBUTE , True ) map_layer_changed \u00b6 map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 70 71 72 73 74 75 76 77 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ()) open_help \u00b6 open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 268 269 270 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE ) open_layer_select_dialog \u00b6 open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 170 171 172 173 174 175 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" pathway_select_dialog = ItemsSelectionDialog ( self , self . layer , self . ncs_pathways ) pathway_select_dialog . exec () set_selected_items \u00b6 set_selected_items ( pathways , removed_pathways = None ) Adds this dialog layer into the passed pathways and removes it from the unselected pathways passed as removed_pathways. Parameters: Name Type Description Default pathways list Selected pathways. required removed_pathways list Pathways that dialog layer should be removed from. None Source code in src/cplus_plugin/gui/priority_layer_dialog.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def set_selected_items ( self , pathways , removed_pathways = None ): \"\"\"Adds this dialog layer into the passed pathways and removes it from the unselected pathways passed as removed_pathways. :param pathways: Selected pathways. :type pathways: list :param removed_pathways: Pathways that dialog layer should be removed from. :type removed_pathways: list \"\"\" removed_pathways = removed_pathways or [] self . ncs_pathways = pathways pathway_names = [ pathway . name for pathway in pathways ] self . selected_pathways_le . setText ( \", \" . join ( pathway_names )) if not self . layer : return if len ( removed_pathways ) <= 0 : all_pathways = settings_manager . get_all_ncs_pathways () removed_pathways = [ pathway for pathway in all_pathways if pathway . name not in pathway_names ] for pathway in pathways : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in pathway . priority_layers if layer is not None ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids ): pathway . priority_layers . append ( self . layer ) settings_manager . save_ncs_pathway ( pathway ) # remove redundant priority layers for layer in pathway . priority_layers : if layer is not None : layer_settings = settings_manager . get_priority_layer ( str ( layer . get ( \"uuid\" )) ) if layer_settings is None : pathway . priority_layers . remove ( layer ) settings_manager . save_ncs_pathway ( pathway ) for pathway in removed_pathways : for layer in pathway . priority_layers : if layer is None : continue if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): pathway . priority_layers . remove ( layer ) settings_manager . save_ncs_pathway ( pathway ) update_ok_buttons \u00b6 update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) or self . _get_selected_default_layer () != {} ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) . setEnabled ( enabled_state )","title":"Priority layer dialog"},{"location":"developer/api/gui/api_priority_layer/#priority-weighting-layer-dialog","text":"Priority layer dialog","title":"Priority weighting layer dialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog","text":"PriorityLayerDialog ( layer = None , parent = None ) Bases: QDialog , DialogUi Dialog that provide UI for priority layer details. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , layer = None , parent = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . layer = layer self . button_box . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) . setEnabled ( False ) self . map_layer_box . layerChanged . connect ( self . map_layer_changed ) ok_signals = [ self . layer_name . textChanged , self . layer_description . textChanged , self . map_layer_file_widget . fileChanged , self . map_layer_box . layerChanged , self . cbo_default_layer . currentIndexChanged , ] for signal in ok_signals : signal . connect ( self . update_ok_buttons ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) self . _user_defined = True self . ncs_pathways = [] self . initialize_ui ()","title":"PriorityLayerDialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.accept","text":"accept () Handles logic for adding new priority layer and an edit existing one. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def accept ( self ): \"\"\"Handles logic for adding new priority layer and an edit existing one.\"\"\" layer_id = uuid . uuid4 () layer_groups = [] layer = {} layer_type = PriorityLayerType . DEFAULT . value if self . layer is not None : layer_id = self . layer . get ( \"uuid\" ) layer_groups = self . layer . get ( \"groups\" , []) layer_type = self . layer . get ( \"type\" , PriorityLayerType . DEFAULT . value ) layer [ \"uuid\" ] = str ( layer_id ) layer [ \"name\" ] = self . layer_name . text () layer [ \"description\" ] = self . layer_description . toPlainText () layer [ \"is_carbon\" ] = self . carbon_enabled . isChecked () layer [ \"groups\" ] = layer_groups default_layer = self . _get_selected_default_layer () if default_layer : layer [ \"path\" ] = \"cplus://\" + default_layer . get ( \"layer_uuid\" ) else : layer [ \"path\" ] = self . map_layer_file_widget . filePath () layer [ \"type\" ] = layer_type layer [ USER_DEFINED_ATTRIBUTE ] = self . _user_defined settings_manager . save_priority_layer ( layer ) self . layer = layer self . set_selected_items ( self . ncs_pathways ) super () . accept ()","title":"accept"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.initialize_ui","text":"initialize_ui () Populate UI inputs when loading the dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def initialize_ui ( self ): \"\"\"Populate UI inputs when loading the dialog\"\"\" self . btn_help . setIcon ( FileUtils . get_icon ( \"mActionHelpContents_green.svg\" )) self . btn_help . clicked . connect ( self . open_help ) self . map_layer_file_widget . setStorageMode ( QgsFileWidget . StorageMode . GetFile ) self . select_pathways_btn . clicked . connect ( self . open_layer_select_dialog ) default_priority_layers = settings_manager . get_default_layers ( \"priority_layer\" ) self . cbo_default_layer . addItem ( \"\" ) self . cbo_default_layer . addItems ([ p [ \"name\" ] for p in default_priority_layers ]) self . cbo_default_layer . setCurrentIndex ( 0 ) self . cbo_default_layer . currentIndexChanged . connect ( self . _on_default_layer_selection_changed ) if self . layer is not None : # If its an NPV PWL, then disable controls as the information is managed # through the NPV manager. Only the description can be updated. pwl_type = self . layer . get ( \"type\" , PriorityLayerType . DEFAULT . value ) if pwl_type == PriorityLayerType . NPV : self . _disable_input_controls () layer_path = self . layer . get ( \"path\" ) if layer_path . startswith ( \"cplus://\" ): layer_uuid = layer_path . replace ( \"cplus://\" , \"\" ) for i , layer in enumerate ( default_priority_layers ): if layer [ \"layer_uuid\" ] == layer_uuid : self . cbo_default_layer . setCurrentIndex ( i + 1 ) break else : layer_uuids = [ layer . get ( \"uuid\" ) for layer in PRIORITY_LAYERS ] if ( not os . path . isabs ( layer_path ) and self . layer . get ( \"uuid\" ) in layer_uuids ): base_dir = settings_manager . get_value ( Settings . BASE_DIR ) layer_path = f \" { base_dir } / { PRIORITY_LAYERS_SEGMENT } / { layer_path } \" self . map_layer_file_widget . setFilePath ( layer_path ) self . layer_name . setText ( self . layer [ \"name\" ]) self . layer_description . setText ( self . layer [ \"description\" ]) self . carbon_enabled . setChecked ( self . layer . get ( \"is_carbon\" , False )) all_pathways = settings_manager . get_all_ncs_pathways () for pathway in all_pathways : model_layer_uuids = [ layer . get ( \"uuid\" ) for layer in pathway . priority_layers if layer is not None ] if str ( self . layer . get ( \"uuid\" )) in model_layer_uuids : self . ncs_pathways . append ( pathway ) self . set_selected_items ( self . ncs_pathways ) self . _user_defined = self . layer . get ( USER_DEFINED_ATTRIBUTE , True )","title":"initialize_ui"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.map_layer_changed","text":"map_layer_changed ( layer ) Sets the file path of the selected layer in file path input Parameters: Name Type Description Default layer QgsMapLayer Qgis map layer required Source code in src/cplus_plugin/gui/priority_layer_dialog.py 70 71 72 73 74 75 76 77 def map_layer_changed ( self , layer ): \"\"\"Sets the file path of the selected layer in file path input :param layer: Qgis map layer :type layer: QgsMapLayer \"\"\" if layer is not None : self . map_layer_file_widget . setFilePath ( layer . source ())","title":"map_layer_changed"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_help","text":"open_help () Opens the user documentation for the plugin in a browser Source code in src/cplus_plugin/gui/priority_layer_dialog.py 268 269 270 def open_help ( self ): \"\"\"Opens the user documentation for the plugin in a browser\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.open_layer_select_dialog","text":"open_layer_select_dialog () Opens priority layer item selection dialog Source code in src/cplus_plugin/gui/priority_layer_dialog.py 170 171 172 173 174 175 def open_layer_select_dialog ( self ): \"\"\"Opens priority layer item selection dialog\"\"\" pathway_select_dialog = ItemsSelectionDialog ( self , self . layer , self . ncs_pathways ) pathway_select_dialog . exec ()","title":"open_layer_select_dialog"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.set_selected_items","text":"set_selected_items ( pathways , removed_pathways = None ) Adds this dialog layer into the passed pathways and removes it from the unselected pathways passed as removed_pathways. Parameters: Name Type Description Default pathways list Selected pathways. required removed_pathways list Pathways that dialog layer should be removed from. None Source code in src/cplus_plugin/gui/priority_layer_dialog.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def set_selected_items ( self , pathways , removed_pathways = None ): \"\"\"Adds this dialog layer into the passed pathways and removes it from the unselected pathways passed as removed_pathways. :param pathways: Selected pathways. :type pathways: list :param removed_pathways: Pathways that dialog layer should be removed from. :type removed_pathways: list \"\"\" removed_pathways = removed_pathways or [] self . ncs_pathways = pathways pathway_names = [ pathway . name for pathway in pathways ] self . selected_pathways_le . setText ( \", \" . join ( pathway_names )) if not self . layer : return if len ( removed_pathways ) <= 0 : all_pathways = settings_manager . get_all_ncs_pathways () removed_pathways = [ pathway for pathway in all_pathways if pathway . name not in pathway_names ] for pathway in pathways : models_layer_uuids = [ str ( layer . get ( \"uuid\" )) for layer in pathway . priority_layers if layer is not None ] if ( self . layer is not None and str ( self . layer . get ( \"uuid\" )) not in models_layer_uuids ): pathway . priority_layers . append ( self . layer ) settings_manager . save_ncs_pathway ( pathway ) # remove redundant priority layers for layer in pathway . priority_layers : if layer is not None : layer_settings = settings_manager . get_priority_layer ( str ( layer . get ( \"uuid\" )) ) if layer_settings is None : pathway . priority_layers . remove ( layer ) settings_manager . save_ncs_pathway ( pathway ) for pathway in removed_pathways : for layer in pathway . priority_layers : if layer is None : continue if str ( layer . get ( \"uuid\" )) == str ( self . layer . get ( \"uuid\" )): pathway . priority_layers . remove ( layer ) settings_manager . save_ncs_pathway ( pathway )","title":"set_selected_items"},{"location":"developer/api/gui/api_priority_layer/#src.cplus_plugin.gui.priority_layer_dialog.PriorityLayerDialog.update_ok_buttons","text":"update_ok_buttons () Responsible for changing the state of the dialog OK button. Source code in src/cplus_plugin/gui/priority_layer_dialog.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def update_ok_buttons ( self ): \"\"\"Responsible for changing the state of the dialog OK button. \"\"\" enabled_state = ( self . layer_name . text () != \"\" and self . layer_description . toPlainText () != \"\" and ( ( self . map_layer_box . currentLayer () is not None or ( self . map_layer_file_widget . filePath () is not None and self . map_layer_file_widget . filePath () is not \"\" ) ) or self . _get_selected_default_layer () != {} ) ) self . button_box . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) . setEnabled ( enabled_state )","title":"update_ok_buttons"},{"location":"developer/api/gui/api_progress_dialog/","text":"Progress dialog \u00b6 Analysis progress dialog file OnlineProgressDialog \u00b6 OnlineProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: Ui_DlgOnlineProgress , ProgressDialog Source code in src/cplus_plugin/gui/progress_dialog.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( message , minimum , maximum , main_widget , parent , scenario_id , scenario_name ) # Connections self . btn_hide . clicked . connect ( self . hide_clicked ) change_status_message \u00b6 change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message == \"Uploading layers with concurrent request\" : self . btn_hide . setEnabled ( False ) self . btn_hide . setToolTip ( \"Cannot minimize task when uploading layers\" ) else : self . btn_hide . setEnabled ( True ) self . btn_hide . setToolTip ( \"Run online scenario in background\" ) if message : self . lbl_status . setText ( message ) hide_clicked \u00b6 hide_clicked () User clicked hide. QGIS processing will be stopped, but online processing will be continued. Source code in src/cplus_plugin/gui/progress_dialog.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def hide_clicked ( self ) -> None : \"\"\"User clicked hide. QGIS processing will be stopped, but online processing will be continued. \"\"\" self . analysis_task . hide_task = True self . analysis_cancelled . emit () self . main_widget . view_status_btn . setEnabled ( True ) self . main_widget . processing_type . setEnabled ( False ) self . main_widget . processing_type . setToolTip ( \"Cannot choose online processing due to user having active online processing\" ) self . cancel_reporting () if self . analysis_running : self . analysis_task . hide_task = True # If cancelled is clicked self . stop_processing ( hide = True ) try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass super () . close () ProgressDialog \u00b6 ProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: QDialog , Ui_DlgProgress Progress dialog class Source code in src/cplus_plugin/gui/progress_dialog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_id = scenario_id self . scenario_name = scenario_name self . main_widget = main_widget self . report_manager = report_manager self . analysis_task = None # Dialog window flags flags = ( QtCore . Qt . WindowType . WindowMinimizeButtonHint | QtCore . Qt . WindowType . WindowCloseButtonHint ) self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True if message is None : self . change_status_message ( tr ( \"Starting processing\" )) else : self . change_status_message ( message ) if scenario_name : self . title . setText ( f \" { self . title . text () } for scenario <b> { self . scenario_name } </b>\" ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignmentFlag . AlignLeft | QtCore . Qt . AlignmentFlag . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for report_templates action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" ) cancel_clicked \u00b6 cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . analysis_cancelled . emit () self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass else : # If close has been clicked. In this case processing were already stopped super () . close () cancel_reporting \u00b6 cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 234 235 236 237 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id ) change_status_message \u00b6 change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 157 158 159 160 161 162 163 164 165 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message : self . lbl_status . setText ( message ) get_processing_status \u00b6 get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 127 128 129 130 131 132 133 134 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running get_progress_bar \u00b6 get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 136 137 138 139 140 141 142 143 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar open_report_help \u00b6 open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 204 205 206 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION ) processing_cancelled \u00b6 processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 272 273 274 275 276 277 278 279 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) processing_finished \u00b6 processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 281 282 283 284 285 286 287 288 289 290 291 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . StandardPixmap . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon ) reject \u00b6 reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" self . analysis_cancelled . emit () if self . analysis_running : # Stops analysis if it is still running self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass self . cancel_reporting () super () . reject () run_dialog \u00b6 run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 119 120 121 122 123 124 125 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show () set_report_complete \u00b6 set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 167 168 169 170 171 172 173 174 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished () stop_processing \u00b6 stop_processing ( hide = False ) The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 259 260 261 262 263 264 265 266 267 268 269 270 def stop_processing ( self , hide = False ) -> None : \"\"\"The user cancelled the processing.\"\"\" if hide : self . change_status_message ( tr ( \"Processing has been minimized by the user\" )) else : self . change_status_message ( tr ( \"Processing has been cancelled by the user\" )) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled () update_progress_bar \u00b6 update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 145 146 147 148 149 150 151 152 153 154 155 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False ) view_report_layout_designer \u00b6 view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 190 191 192 193 194 195 196 197 198 199 200 201 202 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" ) view_report_pdf \u00b6 view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 176 177 178 179 180 181 182 183 184 185 186 187 188 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" ) ReportProgressDialog \u00b6 ReportProgressDialog ( message , submit_result , parent = None ) Bases: ProgressDialog Shows progress for standalone report generation operations. Source code in src/cplus_plugin/gui/progress_dialog.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def __init__ ( self , message , submit_result , parent = None ): super () . __init__ ( message = message , parent = parent ) self . analysis_running = False self . report_running = True self . _submit_result = submit_result self . setWindowTitle ( tr ( \"Report Progress\" )) self . title . setText ( tr ( \"Reporting progress\" )) self . _task = None if submit_result . identifier : self . _task = self . report_manager . task_by_id ( int ( submit_result . identifier )) if self . _task is not None : self . _task . taskCompleted . connect ( self . reporting_finished ) self . _task . taskTerminated . connect ( self . reporting_error ) if submit_result . feedback : submit_result . feedback . progressChanged . connect ( self . update_progress_bar ) report_result property \u00b6 report_result Gets the report result. Returns: Type Description ReportResult The report result based on the submit status or None if the task is not found or the task is not complete or an error occurred. cancel_clicked \u00b6 cancel_clicked () Slot raised when the cancel button is clicked. Will stop reporting process. Source code in src/cplus_plugin/gui/progress_dialog.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def cancel_clicked ( self ) -> None : \"\"\"Slot raised when the cancel button is clicked. Will stop reporting process. \"\"\" if self . report_running : self . cancel_reporting () # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) self . btn_hide . setEnabled ( False ) self . change_status_message ( tr ( \"Report generation canceled.\" )) else : # If close has been clicked. super () . close () cancel_reporting \u00b6 cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 417 418 419 420 421 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" status = self . report_manager . remove_task_by_result ( self . _submit_result ) if not status : self . report_running = False reporting_error \u00b6 reporting_error () Executed when a report generation error has occurred. Source code in src/cplus_plugin/gui/progress_dialog.py 438 439 440 441 442 443 444 445 446 447 448 449 def reporting_error ( self ): \"\"\"Executed when a report generation error has occurred.\"\"\" self . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) self . btn_hide . setEnabled ( False ) self . report_running = False reporting_finished \u00b6 reporting_finished () Executed when report generation has been successfully completed. Source code in src/cplus_plugin/gui/progress_dialog.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def reporting_finished ( self ) -> None : \"\"\"Executed when report generation has been successfully completed.\"\"\" self . set_report_complete () self . change_status_message ( tr ( \"Report generation complete.\" )) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . StandardPixmap . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon ) self . btn_hide . setEnabled ( False ) self . report_running = False view_report_layout_designer \u00b6 view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 393 394 395 396 397 398 399 400 401 def view_report_layout_designer ( self ): \"\"\"Opens the report in layout designer\"\"\" if self . report_result is None : log ( \"Report result not found.\" ) return status = self . report_manager . open_layout_designer ( self . report_result ) if not status : log ( \"Unable to open layout designer.\" ) view_report_pdf \u00b6 view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 383 384 385 386 387 388 389 390 391 def view_report_pdf ( self ): \"\"\"Opens a PDF version of the report\"\"\" if self . report_result is None : log ( \"Report result not found.\" ) return status = self . report_manager . view_pdf ( self . report_result ) if not status : log ( \"Unable to open PDF report.\" )","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#progress-dialog","text":"Analysis progress dialog file","title":"Progress dialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.OnlineProgressDialog","text":"OnlineProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: Ui_DlgOnlineProgress , ProgressDialog Source code in src/cplus_plugin/gui/progress_dialog.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( message , minimum , maximum , main_widget , parent , scenario_id , scenario_name ) # Connections self . btn_hide . clicked . connect ( self . hide_clicked )","title":"OnlineProgressDialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.OnlineProgressDialog.change_status_message","text":"change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message == \"Uploading layers with concurrent request\" : self . btn_hide . setEnabled ( False ) self . btn_hide . setToolTip ( \"Cannot minimize task when uploading layers\" ) else : self . btn_hide . setEnabled ( True ) self . btn_hide . setToolTip ( \"Run online scenario in background\" ) if message : self . lbl_status . setText ( message )","title":"change_status_message"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.OnlineProgressDialog.hide_clicked","text":"hide_clicked () User clicked hide. QGIS processing will be stopped, but online processing will be continued. Source code in src/cplus_plugin/gui/progress_dialog.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def hide_clicked ( self ) -> None : \"\"\"User clicked hide. QGIS processing will be stopped, but online processing will be continued. \"\"\" self . analysis_task . hide_task = True self . analysis_cancelled . emit () self . main_widget . view_status_btn . setEnabled ( True ) self . main_widget . processing_type . setEnabled ( False ) self . main_widget . processing_type . setToolTip ( \"Cannot choose online processing due to user having active online processing\" ) self . cancel_reporting () if self . analysis_running : self . analysis_task . hide_task = True # If cancelled is clicked self . stop_processing ( hide = True ) try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass super () . close ()","title":"hide_clicked"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog","text":"ProgressDialog ( message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None ) Bases: QDialog , Ui_DlgProgress Progress dialog class Source code in src/cplus_plugin/gui/progress_dialog.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def __init__ ( self , message = None , minimum = 0 , maximum = 100 , main_widget = None , parent = None , scenario_id = None , scenario_name = None , ): super () . __init__ ( parent ) self . setupUi ( self ) self . scenario_id = scenario_id self . scenario_name = scenario_name self . main_widget = main_widget self . report_manager = report_manager self . analysis_task = None # Dialog window flags flags = ( QtCore . Qt . WindowType . WindowMinimizeButtonHint | QtCore . Qt . WindowType . WindowCloseButtonHint ) self . setWindowFlags ( flags ) # Dialog statuses self . analysis_running = True if message is None : self . change_status_message ( tr ( \"Starting processing\" )) else : self . change_status_message ( message ) if scenario_name : self . title . setText ( f \" { self . title . text () } for scenario <b> { self . scenario_name } </b>\" ) # Report status self . report_running = False # Progress bar self . progress_bar . setAlignment ( QtCore . Qt . AlignmentFlag . AlignLeft | QtCore . Qt . AlignmentFlag . AlignVCenter ) self . progress_bar . setMinimum ( minimum ) self . progress_bar . setMaximum ( maximum ) # Report menu self . menu = QMenu ( \"&View Report\" ) self . btn_view_report . setMenu ( self . menu ) self . btn_view_report . setIcon ( QIcon ( ICON_REPORT )) # Menu button to open report in Layout designer self . designer_action = QAction ( QIcon ( ICON_LAYOUT ), \"Layout designer\" , parent = self ) self . designer_action . triggered . connect ( self . view_report_layout_designer ) self . designer_action . setEnabled ( False ) self . menu . addAction ( self . designer_action ) # Open a PDF version of the report self . pdf_action = QAction ( QIcon ( ICON_PDF ), \"Open PDF\" , parent = self ) self . pdf_action . triggered . connect ( self . view_report_pdf ) self . pdf_action . setEnabled ( False ) self . menu . addAction ( self . pdf_action ) # Open a Help for report_templates action = QAction ( QIcon ( ICON_HELP ), \"Help\" , parent = self ) action . triggered . connect ( self . open_report_help ) action . setEnabled ( True ) self . menu . addAction ( action ) # Connections self . btn_cancel . clicked . connect ( self . cancel_clicked ) self . analysis_finished_message = tr ( \"Analysis has finished.\" )","title":"ProgressDialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_clicked","text":"cancel_clicked () User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. Source code in src/cplus_plugin/gui/progress_dialog.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def cancel_clicked ( self ) -> None : \"\"\"User clicked cancel. Processing will be stopped, and the UI will be updated to accommodate the processing status. \"\"\" self . analysis_cancelled . emit () self . cancel_reporting () if self . analysis_running : # If cancelled is clicked self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass else : # If close has been clicked. In this case processing were already stopped super () . close ()","title":"cancel_clicked"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.cancel_reporting","text":"cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 234 235 236 237 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" if self . report_running : self . report_manager . remove_report_task ( self . scenario_id )","title":"cancel_reporting"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.change_status_message","text":"change_status_message ( message = None ) Updates the status message Parameters: Name Type Description Default message str Message to show on the status bar None Source code in src/cplus_plugin/gui/progress_dialog.py 157 158 159 160 161 162 163 164 165 def change_status_message ( self , message = None ) -> None : \"\"\"Updates the status message :param message: Message to show on the status bar :type message: str \"\"\" if message : self . lbl_status . setText ( message )","title":"change_status_message"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_processing_status","text":"get_processing_status () Returns the status of the processing. Returns: Type Description bool Status of processing. Source code in src/cplus_plugin/gui/progress_dialog.py 127 128 129 130 131 132 133 134 def get_processing_status ( self ) -> bool : \"\"\"Returns the status of the processing. :returns: Status of processing. :rtype: bool \"\"\" return self . analysis_running","title":"get_processing_status"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.get_progress_bar","text":"get_progress_bar () Returns a reference to the Progress bar object. Returns: Type Description QProgressBar Progress bar Source code in src/cplus_plugin/gui/progress_dialog.py 136 137 138 139 140 141 142 143 def get_progress_bar ( self ) -> QProgressBar : \"\"\"Returns a reference to the Progress bar object. :returns: Progress bar :rtype: QProgressBar \"\"\" return self . progress_bar","title":"get_progress_bar"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.open_report_help","text":"open_report_help () Opens the Report guide in a browser Source code in src/cplus_plugin/gui/progress_dialog.py 204 205 206 def open_report_help ( self ) -> None : \"\"\"Opens the Report guide in a browser\"\"\" open_documentation ( REPORT_DOCUMENTATION )","title":"open_report_help"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_cancelled","text":"processing_cancelled () Post-steps when processing were cancelled. Source code in src/cplus_plugin/gui/progress_dialog.py 272 273 274 275 276 277 278 279 def processing_cancelled ( self ) -> None : \"\"\"Post-steps when processing were cancelled.\"\"\" self . analysis_running = False # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False )","title":"processing_cancelled"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.processing_finished","text":"processing_finished () Post-steps when processing succeeded. Source code in src/cplus_plugin/gui/progress_dialog.py 281 282 283 284 285 286 287 288 289 290 291 def processing_finished ( self ) -> None : \"\"\"Post-steps when processing succeeded.\"\"\" self . analysis_running = False self . change_status_message ( self . analysis_finished_message ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . StandardPixmap . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon )","title":"processing_finished"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.reject","text":"reject () Called when the dialog is closed Source code in src/cplus_plugin/gui/progress_dialog.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 def reject ( self ) -> None : \"\"\"Called when the dialog is closed\"\"\" self . analysis_cancelled . emit () if self . analysis_running : # Stops analysis if it is still running self . stop_processing () try : if self . analysis_task : self . analysis_task . processing_cancelled = True self . analysis_task . cancel () except RuntimeError as e : # The analysis task should have been removed after # scenario analyis is done, this is the only way to find # out if the analysis has been completed. pass self . cancel_reporting () super () . reject ()","title":"reject"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.run_dialog","text":"run_dialog () Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. Source code in src/cplus_plugin/gui/progress_dialog.py 119 120 121 122 123 124 125 def run_dialog ( self ): \"\"\"Runs/opens the dialog. Sets modal to modeless. This will allow the dialog to display and not interfere with other processes. \"\"\" self . setModal ( False ) self . show ()","title":"run_dialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.set_report_complete","text":"set_report_complete () Enable layout designer and PDF report buttons. Source code in src/cplus_plugin/gui/progress_dialog.py 167 168 169 170 171 172 173 174 def set_report_complete ( self ): \"\"\"Enable layout designer and PDF report buttons.\"\"\" self . btn_view_report . setEnabled ( True ) self . designer_action . setEnabled ( True ) self . pdf_action . setEnabled ( True ) self . report_running = False self . processing_finished ()","title":"set_report_complete"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.stop_processing","text":"stop_processing ( hide = False ) The user cancelled the processing. Source code in src/cplus_plugin/gui/progress_dialog.py 259 260 261 262 263 264 265 266 267 268 269 270 def stop_processing ( self , hide = False ) -> None : \"\"\"The user cancelled the processing.\"\"\" if hide : self . change_status_message ( tr ( \"Processing has been minimized by the user\" )) else : self . change_status_message ( tr ( \"Processing has been cancelled by the user\" )) # Stops the processing task if self . main_widget : self . main_widget . cancel_processing_task () self . processing_cancelled ()","title":"stop_processing"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.update_progress_bar","text":"update_progress_bar ( value ) Sets the value of the progress bar Parameters: Name Type Description Default value float Value to be set on the progress bar required Source code in src/cplus_plugin/gui/progress_dialog.py 145 146 147 148 149 150 151 152 153 154 155 def update_progress_bar ( self , value ) -> None : \"\"\"Sets the value of the progress bar :param value: Value to be set on the progress bar :type value: float \"\"\" if self . progress_bar : try : self . progress_bar . setValue ( int ( value )) except RuntimeError : log ( tr ( \"Error setting value to a progress bar\" ), notify = False )","title":"update_progress_bar"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_layout_designer","text":"view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 190 191 192 193 194 195 196 197 198 199 200 201 202 def view_report_layout_designer ( self ) -> None : \"\"\"Opens the report in layout designer\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . open_layout_designer ( result ) if not status : log ( \"Unable to open layout designer.\" )","title":"view_report_layout_designer"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ProgressDialog.view_report_pdf","text":"view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 176 177 178 179 180 181 182 183 184 185 186 187 188 def view_report_pdf ( self ) -> None : \"\"\"Opens a PDF version of the report\"\"\" if not self . scenario_id : log ( \"Scenario ID has not been set.\" ) return result = self . report_manager . report_result ( self . scenario_id ) if result is None : log ( \"Report result not found.\" ) else : status = self . report_manager . view_pdf ( result ) if not status : log ( \"Unable to open PDF report.\" )","title":"view_report_pdf"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog","text":"ReportProgressDialog ( message , submit_result , parent = None ) Bases: ProgressDialog Shows progress for standalone report generation operations. Source code in src/cplus_plugin/gui/progress_dialog.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 def __init__ ( self , message , submit_result , parent = None ): super () . __init__ ( message = message , parent = parent ) self . analysis_running = False self . report_running = True self . _submit_result = submit_result self . setWindowTitle ( tr ( \"Report Progress\" )) self . title . setText ( tr ( \"Reporting progress\" )) self . _task = None if submit_result . identifier : self . _task = self . report_manager . task_by_id ( int ( submit_result . identifier )) if self . _task is not None : self . _task . taskCompleted . connect ( self . reporting_finished ) self . _task . taskTerminated . connect ( self . reporting_error ) if submit_result . feedback : submit_result . feedback . progressChanged . connect ( self . update_progress_bar )","title":"ReportProgressDialog"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.report_result","text":"report_result Gets the report result. Returns: Type Description ReportResult The report result based on the submit status or None if the task is not found or the task is not complete or an error occurred.","title":"report_result"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.cancel_clicked","text":"cancel_clicked () Slot raised when the cancel button is clicked. Will stop reporting process. Source code in src/cplus_plugin/gui/progress_dialog.py 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def cancel_clicked ( self ) -> None : \"\"\"Slot raised when the cancel button is clicked. Will stop reporting process. \"\"\" if self . report_running : self . cancel_reporting () # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) self . btn_hide . setEnabled ( False ) self . change_status_message ( tr ( \"Report generation canceled.\" )) else : # If close has been clicked. super () . close ()","title":"cancel_clicked"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.cancel_reporting","text":"cancel_reporting () Cancel the report generation process. Source code in src/cplus_plugin/gui/progress_dialog.py 417 418 419 420 421 def cancel_reporting ( self ): \"\"\"Cancel the report generation process.\"\"\" status = self . report_manager . remove_task_by_result ( self . _submit_result ) if not status : self . report_running = False","title":"cancel_reporting"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.reporting_error","text":"reporting_error () Executed when a report generation error has occurred. Source code in src/cplus_plugin/gui/progress_dialog.py 438 439 440 441 442 443 444 445 446 447 448 449 def reporting_error ( self ): \"\"\"Executed when a report generation error has occurred.\"\"\" self . change_status_message ( tr ( \"Error generating report, see logs for more info.\" ) ) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( False ) self . btn_hide . setEnabled ( False ) self . report_running = False","title":"reporting_error"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.reporting_finished","text":"reporting_finished () Executed when report generation has been successfully completed. Source code in src/cplus_plugin/gui/progress_dialog.py 423 424 425 426 427 428 429 430 431 432 433 434 435 436 def reporting_finished ( self ) -> None : \"\"\"Executed when report generation has been successfully completed.\"\"\" self . set_report_complete () self . change_status_message ( tr ( \"Report generation complete.\" )) # Change cancel button to the close button status self . btn_cancel . setText ( tr ( \"Close\" )) self . btn_view_report . setEnabled ( True ) icon = self . style () . standardIcon ( QStyle . StandardPixmap . SP_DialogCloseButton ) self . btn_cancel . setIcon ( icon ) self . btn_hide . setEnabled ( False ) self . report_running = False","title":"reporting_finished"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.view_report_layout_designer","text":"view_report_layout_designer () Opens the report in layout designer Source code in src/cplus_plugin/gui/progress_dialog.py 393 394 395 396 397 398 399 400 401 def view_report_layout_designer ( self ): \"\"\"Opens the report in layout designer\"\"\" if self . report_result is None : log ( \"Report result not found.\" ) return status = self . report_manager . open_layout_designer ( self . report_result ) if not status : log ( \"Unable to open layout designer.\" )","title":"view_report_layout_designer"},{"location":"developer/api/gui/api_progress_dialog/#src.cplus_plugin.gui.progress_dialog.ReportProgressDialog.view_report_pdf","text":"view_report_pdf () Opens a PDF version of the report Source code in src/cplus_plugin/gui/progress_dialog.py 383 384 385 386 387 388 389 390 391 def view_report_pdf ( self ): \"\"\"Opens a PDF version of the report\"\"\" if self . report_result is None : log ( \"Report result not found.\" ) return status = self . report_manager . view_pdf ( self . report_result ) if not status : log ( \"Unable to open PDF report.\" )","title":"view_report_pdf"},{"location":"developer/api/gui/api_validation_inspector_dialog/","text":"Validation Inspector Dialog \u00b6 Dialog for viewing NCS validation results. ValidationInspectorDialog \u00b6 ValidationInspectorDialog ( parent = None , result = None ) Bases: QDialog , WidgetUi Dialog for showing validation results. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , parent = None , result = None ): super () . __init__ ( parent ) self . setupUi ( self ) flags = self . windowFlags () | QtCore . Qt . WindowType . WindowMinimizeButtonHint self . setWindowFlags ( flags ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) expand_icon = FileUtils . get_icon ( \"mActionExpandTree.svg\" ) self . btn_expand . setIcon ( expand_icon ) self . btn_expand . clicked . connect ( self . on_expand_all_result_items ) collapse_icon = FileUtils . get_icon ( \"mActionCollapseTree.svg\" ) self . btn_collapse . setIcon ( collapse_icon ) self . btn_collapse . clicked . connect ( self . on_collapse_all_result_items ) revalidate_icon = FileUtils . get_icon ( \"reload_one_direction.svg\" ) self . btn_revalidate . setIcon ( revalidate_icon ) self . btn_revalidate . clicked . connect ( self . on_revalidate_datasets ) self . tw_results . setColumnCount ( 1 ) self . tw_results . setContextMenuPolicy ( QtCore . Qt . CustomContextMenu ) self . tw_results . customContextMenuRequested . connect ( self . on_custom_menu_requested ) self . _revalidation_submit_result = None self . _validation_result = result if self . _validation_result is not None : self . _update () result property writable \u00b6 result Returns the validation result used to show results. Returns: Type Description ValidationResult The validation result in the current view or None if not specified. on_collapse_all_result_items \u00b6 on_collapse_all_result_items () Slot raised to collapse all rule result tree items Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 112 113 114 def on_collapse_all_result_items ( self ): \"\"\"Slot raised to collapse all rule result tree items\"\"\" self . _expand_collapse_all_items ( False ) on_copy_detailed_results \u00b6 on_copy_detailed_results ( copy_text ) Slot raised to copy detailed error/warning text. Parameters: Name Type Description Default copy_text str Text to be copied to the clipboard. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 156 157 158 159 160 161 162 163 def on_copy_detailed_results ( self , copy_text : str ): \"\"\"Slot raised to copy detailed error/warning text. :param copy_text: Text to be copied to the clipboard. :type copy_text: str \"\"\" # Copy details to the clipboard QgsApplication . instance () . clipboard () . setText ( copy_text ) on_custom_menu_requested \u00b6 on_custom_menu_requested ( point ) Slot raised when a custom menu has been requested. Parameters: Name Type Description Default point QPoint Position of the context menu event. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def on_custom_menu_requested ( self , point : QtCore . QPoint ): \"\"\"Slot raised when a custom menu has been requested. :param point: Position of the context menu event. :type point: QtCore.QPoint \"\"\" item = self . tw_results . itemAt ( point ) if item . type () != DETAILED_RESULT_TYPE : return # Action for copying detailed result item copy_action = QtWidgets . QAction () copy_action . setText ( tr ( \"Copy\" )) copy_action . setIcon ( FileUtils . get_icon ( \"mActionEditCopy.svg\" )) copy_action . triggered . connect ( lambda : self . on_copy_detailed_results ( item . text ( 0 )) ) menu = QtWidgets . QMenu ( self ) menu . addAction ( copy_action ) menu . exec ( self . tw_results . mapToGlobal ( point )) on_expand_all_result_items \u00b6 on_expand_all_result_items () Slot raised to expand all rule result tree items. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 108 109 110 def on_expand_all_result_items ( self ): \"\"\"Slot raised to expand all rule result tree items.\"\"\" self . _expand_collapse_all_items ( True ) on_revalidate_datasets \u00b6 on_revalidate_datasets () Revalidate the datasets. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def on_revalidate_datasets ( self ): \"\"\"Revalidate the datasets.\"\"\" ncs_pathways = settings_manager . get_all_ncs_pathways () # No need for validating if there are no NCS pathways. if len ( ncs_pathways ) == 0 : log ( message = \"No datasets for validation.\" , info = False ) return self . _revalidation_submit_result = validation_manager . validate_ncs_pathways ( ncs_pathways ) if not self . _revalidation_submit_result . success : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Revalidate NCS Pathways\" ), self . tr ( \"Unable to re-submit NCS pathways for validation\" ), ) log ( message = \"Unable to re-submit NCS pathways for validation\" , info = False ) self . reject () self . btn_collapse . setEnabled ( False ) self . btn_expand . setEnabled ( False ) self . btn_revalidate . setEnabled ( False ) self . tw_results . clear () status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Revalidating NCS pathways...\" )) loading_icon = FileUtils . get_icon ( \"loading.svg\" ) status_item . setIcon ( 0 , loading_icon ) self . tw_results . addTopLevelItem ( status_item ) self . progress_dialog = ValidationProgressDialog ( self . _revalidation_submit_result , self , hide_details_button = True , close_on_completion = True , cancel_mode = True , ) self . progress_dialog . feedback . validation_completed . connect ( self . on_validation_complete ) self . progress_dialog . dialog_closed . connect ( self . on_revalidation_dialog_closed ) self . progress_dialog . setModal ( False ) self . progress_dialog . show () on_revalidation_dialog_closed \u00b6 on_revalidation_dialog_closed () Cancel the revalidation process. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def on_revalidation_dialog_closed ( self ): \"\"\"Cancel the revalidation process.\"\"\" if not validation_manager . is_validation_complete ( self . _revalidation_submit_result ): validation_manager . cancel ( self . _revalidation_submit_result ) self . tw_results . clear () status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Validation canceled!\" )) cancel_icon = FileUtils . get_icon ( \"mTaskCancel.svg\" ) status_item . setIcon ( 0 , cancel_icon ) self . tw_results . addTopLevelItem ( status_item ) self . btn_revalidate . setEnabled ( True ) on_validation_complete \u00b6 on_validation_complete ( validation_result ) Slot raised when validation has completed. Parameters: Name Type Description Default validation_result ValidationResult Result of the validation process. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def on_validation_complete ( self , validation_result : ValidationResult ): \"\"\"Slot raised when validation has completed. :param validation_result: Result of the validation process. :type validation_result: ValidationResult \"\"\" self . tw_results . clear () if validation_result is None : status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Error occurred in the validation process!\" )) error_icon = FileUtils . get_icon ( \"mIconDelete.svg\" ) status_item . setIcon ( 0 , error_icon ) self . tw_results . addTopLevelItem ( status_item ) else : self . _validation_result = validation_result self . _update () self . btn_collapse . setEnabled ( True ) self . btn_expand . setEnabled ( True ) self . btn_revalidate . setEnabled ( True ) open_help \u00b6 open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 92 93 94 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"Inspector dialog"},{"location":"developer/api/gui/api_validation_inspector_dialog/#validation-inspector-dialog","text":"Dialog for viewing NCS validation results.","title":"Validation Inspector Dialog"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog","text":"ValidationInspectorDialog ( parent = None , result = None ) Bases: QDialog , WidgetUi Dialog for showing validation results. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def __init__ ( self , parent = None , result = None ): super () . __init__ ( parent ) self . setupUi ( self ) flags = self . windowFlags () | QtCore . Qt . WindowType . WindowMinimizeButtonHint self . setWindowFlags ( flags ) QgsGui . enableAutoGeometryRestore ( self ) icon_pixmap = QtGui . QPixmap ( ICON_PATH ) self . icon_la . setPixmap ( icon_pixmap ) help_icon = FileUtils . get_icon ( \"mActionHelpContents_green.svg\" ) self . btn_help . setIcon ( help_icon ) self . btn_help . clicked . connect ( self . open_help ) expand_icon = FileUtils . get_icon ( \"mActionExpandTree.svg\" ) self . btn_expand . setIcon ( expand_icon ) self . btn_expand . clicked . connect ( self . on_expand_all_result_items ) collapse_icon = FileUtils . get_icon ( \"mActionCollapseTree.svg\" ) self . btn_collapse . setIcon ( collapse_icon ) self . btn_collapse . clicked . connect ( self . on_collapse_all_result_items ) revalidate_icon = FileUtils . get_icon ( \"reload_one_direction.svg\" ) self . btn_revalidate . setIcon ( revalidate_icon ) self . btn_revalidate . clicked . connect ( self . on_revalidate_datasets ) self . tw_results . setColumnCount ( 1 ) self . tw_results . setContextMenuPolicy ( QtCore . Qt . CustomContextMenu ) self . tw_results . customContextMenuRequested . connect ( self . on_custom_menu_requested ) self . _revalidation_submit_result = None self . _validation_result = result if self . _validation_result is not None : self . _update ()","title":"ValidationInspectorDialog"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.result","text":"result Returns the validation result used to show results. Returns: Type Description ValidationResult The validation result in the current view or None if not specified.","title":"result"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_collapse_all_result_items","text":"on_collapse_all_result_items () Slot raised to collapse all rule result tree items Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 112 113 114 def on_collapse_all_result_items ( self ): \"\"\"Slot raised to collapse all rule result tree items\"\"\" self . _expand_collapse_all_items ( False )","title":"on_collapse_all_result_items"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_copy_detailed_results","text":"on_copy_detailed_results ( copy_text ) Slot raised to copy detailed error/warning text. Parameters: Name Type Description Default copy_text str Text to be copied to the clipboard. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 156 157 158 159 160 161 162 163 def on_copy_detailed_results ( self , copy_text : str ): \"\"\"Slot raised to copy detailed error/warning text. :param copy_text: Text to be copied to the clipboard. :type copy_text: str \"\"\" # Copy details to the clipboard QgsApplication . instance () . clipboard () . setText ( copy_text )","title":"on_copy_detailed_results"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_custom_menu_requested","text":"on_custom_menu_requested ( point ) Slot raised when a custom menu has been requested. Parameters: Name Type Description Default point QPoint Position of the context menu event. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def on_custom_menu_requested ( self , point : QtCore . QPoint ): \"\"\"Slot raised when a custom menu has been requested. :param point: Position of the context menu event. :type point: QtCore.QPoint \"\"\" item = self . tw_results . itemAt ( point ) if item . type () != DETAILED_RESULT_TYPE : return # Action for copying detailed result item copy_action = QtWidgets . QAction () copy_action . setText ( tr ( \"Copy\" )) copy_action . setIcon ( FileUtils . get_icon ( \"mActionEditCopy.svg\" )) copy_action . triggered . connect ( lambda : self . on_copy_detailed_results ( item . text ( 0 )) ) menu = QtWidgets . QMenu ( self ) menu . addAction ( copy_action ) menu . exec ( self . tw_results . mapToGlobal ( point ))","title":"on_custom_menu_requested"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_expand_all_result_items","text":"on_expand_all_result_items () Slot raised to expand all rule result tree items. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 108 109 110 def on_expand_all_result_items ( self ): \"\"\"Slot raised to expand all rule result tree items.\"\"\" self . _expand_collapse_all_items ( True )","title":"on_expand_all_result_items"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_revalidate_datasets","text":"on_revalidate_datasets () Revalidate the datasets. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def on_revalidate_datasets ( self ): \"\"\"Revalidate the datasets.\"\"\" ncs_pathways = settings_manager . get_all_ncs_pathways () # No need for validating if there are no NCS pathways. if len ( ncs_pathways ) == 0 : log ( message = \"No datasets for validation.\" , info = False ) return self . _revalidation_submit_result = validation_manager . validate_ncs_pathways ( ncs_pathways ) if not self . _revalidation_submit_result . success : QtWidgets . QMessageBox . critical ( self , self . tr ( \"Revalidate NCS Pathways\" ), self . tr ( \"Unable to re-submit NCS pathways for validation\" ), ) log ( message = \"Unable to re-submit NCS pathways for validation\" , info = False ) self . reject () self . btn_collapse . setEnabled ( False ) self . btn_expand . setEnabled ( False ) self . btn_revalidate . setEnabled ( False ) self . tw_results . clear () status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Revalidating NCS pathways...\" )) loading_icon = FileUtils . get_icon ( \"loading.svg\" ) status_item . setIcon ( 0 , loading_icon ) self . tw_results . addTopLevelItem ( status_item ) self . progress_dialog = ValidationProgressDialog ( self . _revalidation_submit_result , self , hide_details_button = True , close_on_completion = True , cancel_mode = True , ) self . progress_dialog . feedback . validation_completed . connect ( self . on_validation_complete ) self . progress_dialog . dialog_closed . connect ( self . on_revalidation_dialog_closed ) self . progress_dialog . setModal ( False ) self . progress_dialog . show ()","title":"on_revalidate_datasets"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_revalidation_dialog_closed","text":"on_revalidation_dialog_closed () Cancel the revalidation process. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 def on_revalidation_dialog_closed ( self ): \"\"\"Cancel the revalidation process.\"\"\" if not validation_manager . is_validation_complete ( self . _revalidation_submit_result ): validation_manager . cancel ( self . _revalidation_submit_result ) self . tw_results . clear () status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Validation canceled!\" )) cancel_icon = FileUtils . get_icon ( \"mTaskCancel.svg\" ) status_item . setIcon ( 0 , cancel_icon ) self . tw_results . addTopLevelItem ( status_item ) self . btn_revalidate . setEnabled ( True )","title":"on_revalidation_dialog_closed"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.on_validation_complete","text":"on_validation_complete ( validation_result ) Slot raised when validation has completed. Parameters: Name Type Description Default validation_result ValidationResult Result of the validation process. required Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 def on_validation_complete ( self , validation_result : ValidationResult ): \"\"\"Slot raised when validation has completed. :param validation_result: Result of the validation process. :type validation_result: ValidationResult \"\"\" self . tw_results . clear () if validation_result is None : status_item = QtWidgets . QTreeWidgetItem () status_item . setText ( 0 , tr ( \"Error occurred in the validation process!\" )) error_icon = FileUtils . get_icon ( \"mIconDelete.svg\" ) status_item . setIcon ( 0 , error_icon ) self . tw_results . addTopLevelItem ( status_item ) else : self . _validation_result = validation_result self . _update () self . btn_collapse . setEnabled ( True ) self . btn_expand . setEnabled ( True ) self . btn_revalidate . setEnabled ( True )","title":"on_validation_complete"},{"location":"developer/api/gui/api_validation_inspector_dialog/#src.cplus_plugin.gui.validation.inspector_dialog.ValidationInspectorDialog.open_help","text":"open_help ( activated ) Opens the user documentation for the plugin in a browser. Source code in src/cplus_plugin/gui/validation/inspector_dialog.py 92 93 94 def open_help ( self , activated : bool ): \"\"\"Opens the user documentation for the plugin in a browser.\"\"\" open_documentation ( USER_DOCUMENTATION_SITE )","title":"open_help"},{"location":"developer/api/gui/api_validation_progress_dialog/","text":"Validation Progress Dialog \u00b6 Dialog for showing the progress of the validation process. ValidationProgressDialog \u00b6 ValidationProgressDialog ( submit_result , parent = None , hide_details_button = False , close_on_completion = False , cancel_mode = False ) Bases: QDialog , WidgetUi Dialog for showing the progress of the validation process. Source code in src/cplus_plugin/gui/validation/progress_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , submit_result : SubmitResult , parent = None , hide_details_button = False , close_on_completion = False , cancel_mode = False , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _submit_result = submit_result self . _feedback = self . _submit_result . feedback self . _feedback . rule_validation_started . connect ( self . _on_rule_validation_started ) self . _feedback . progressChanged . connect ( self . _on_progress_changed ) self . _feedback . validation_completed . connect ( self . _on_validation_completed ) self . _close_on_completion = close_on_completion self . btn_show_details = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) if hide_details_button : self . btn_show_details . setVisible ( False ) self . btn_close = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Close ) if cancel_mode : self . btn_close . setText ( tr ( \"Cancel\" )) self . _initialize_ui () feedback property \u00b6 feedback Gets the feedback object used in the progress dialog. Returns: Type Description ValidationFeedback Feedback objects used in the progress dialog. hide_results_button \u00b6 hide_results_button ( hide ) Hides or shows the button for showing the validation inspector. By default, the button is visible. Parameters: Name Type Description Default hide bool True to hide the 'Show Results' button else False to make it visible again. required Source code in src/cplus_plugin/gui/validation/progress_dialog.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def hide_results_button ( self , hide : bool ): \"\"\"Hides or shows the button for showing the validation inspector. By default, the button is visible. :param hide: True to hide the 'Show Results' button else False to make it visible again. :type hide: bool \"\"\" if hide and self . btn_show_details . isVisible (): self . btn_show_details . setVisible ( False ) elif not hide and not self . btn_show_details . isVisible (): self . btn_show_details . setVisible ( True ) on_closed \u00b6 on_closed () Slot raised when the Close button has been clicked. Source code in src/cplus_plugin/gui/validation/progress_dialog.py 164 165 166 def on_closed ( self ): \"\"\"Slot raised when the Close button has been clicked.\"\"\" self . dialog_closed . emit ()","title":"Progress dialog"},{"location":"developer/api/gui/api_validation_progress_dialog/#validation-progress-dialog","text":"Dialog for showing the progress of the validation process.","title":"Validation Progress Dialog"},{"location":"developer/api/gui/api_validation_progress_dialog/#src.cplus_plugin.gui.validation.progress_dialog.ValidationProgressDialog","text":"ValidationProgressDialog ( submit_result , parent = None , hide_details_button = False , close_on_completion = False , cancel_mode = False ) Bases: QDialog , WidgetUi Dialog for showing the progress of the validation process. Source code in src/cplus_plugin/gui/validation/progress_dialog.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def __init__ ( self , submit_result : SubmitResult , parent = None , hide_details_button = False , close_on_completion = False , cancel_mode = False , ): super () . __init__ ( parent ) self . setupUi ( self ) QgsGui . enableAutoGeometryRestore ( self ) self . _submit_result = submit_result self . _feedback = self . _submit_result . feedback self . _feedback . rule_validation_started . connect ( self . _on_rule_validation_started ) self . _feedback . progressChanged . connect ( self . _on_progress_changed ) self . _feedback . validation_completed . connect ( self . _on_validation_completed ) self . _close_on_completion = close_on_completion self . btn_show_details = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Ok ) if hide_details_button : self . btn_show_details . setVisible ( False ) self . btn_close = self . buttonBox . button ( QtWidgets . QDialogButtonBox . StandardButton . Close ) if cancel_mode : self . btn_close . setText ( tr ( \"Cancel\" )) self . _initialize_ui ()","title":"ValidationProgressDialog"},{"location":"developer/api/gui/api_validation_progress_dialog/#src.cplus_plugin.gui.validation.progress_dialog.ValidationProgressDialog.feedback","text":"feedback Gets the feedback object used in the progress dialog. Returns: Type Description ValidationFeedback Feedback objects used in the progress dialog.","title":"feedback"},{"location":"developer/api/gui/api_validation_progress_dialog/#src.cplus_plugin.gui.validation.progress_dialog.ValidationProgressDialog.hide_results_button","text":"hide_results_button ( hide ) Hides or shows the button for showing the validation inspector. By default, the button is visible. Parameters: Name Type Description Default hide bool True to hide the 'Show Results' button else False to make it visible again. required Source code in src/cplus_plugin/gui/validation/progress_dialog.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def hide_results_button ( self , hide : bool ): \"\"\"Hides or shows the button for showing the validation inspector. By default, the button is visible. :param hide: True to hide the 'Show Results' button else False to make it visible again. :type hide: bool \"\"\" if hide and self . btn_show_details . isVisible (): self . btn_show_details . setVisible ( False ) elif not hide and not self . btn_show_details . isVisible (): self . btn_show_details . setVisible ( True )","title":"hide_results_button"},{"location":"developer/api/gui/api_validation_progress_dialog/#src.cplus_plugin.gui.validation.progress_dialog.ValidationProgressDialog.on_closed","text":"on_closed () Slot raised when the Close button has been clicked. Source code in src/cplus_plugin/gui/validation/progress_dialog.py 164 165 166 def on_closed ( self ): \"\"\"Slot raised when the Close button has been clicked.\"\"\" self . dialog_closed . emit ()","title":"on_closed"},{"location":"developer/api/gui/api_validation_result_items/","text":"Tree Result Items \u00b6 Tree items for rule and aggregated validation results. RuleResultItem \u00b6 RuleResultItem ( parent = None , rule_result = None ) Bases: QTreeWidgetItem Tree widget item for showing rule result details. Source code in src/cplus_plugin/gui/validation/result_items.py 21 22 23 24 25 26 27 def __init__ ( self , parent = None , rule_result : RuleResult = None ): super () . __init__ ( parent , RULE_RESULT_TYPE ) self . _result = rule_result self . _description_item = None if self . _result is not None : self . _update () result property writable \u00b6 result Gets the rule result used to show result details. Returns: Type Description RuleResult Returns the rule result used to show result details. expand_description \u00b6 expand_description ( expand ) Expand or collapse the result description tree node. Parameters: Name Type Description Default expand bool True to expand the result description node else False. required Source code in src/cplus_plugin/gui/validation/result_items.py 96 97 98 99 100 101 102 103 def expand_description ( self , expand : bool ): \"\"\"Expand or collapse the result description tree node. :param expand: True to expand the result description node else False. :type expand: bool \"\"\" if self . _description_item is not None : self . _description_item . setExpanded ( expand )","title":"Tree items"},{"location":"developer/api/gui/api_validation_result_items/#tree-result-items","text":"Tree items for rule and aggregated validation results.","title":"Tree Result Items"},{"location":"developer/api/gui/api_validation_result_items/#src.cplus_plugin.gui.validation.result_items.RuleResultItem","text":"RuleResultItem ( parent = None , rule_result = None ) Bases: QTreeWidgetItem Tree widget item for showing rule result details. Source code in src/cplus_plugin/gui/validation/result_items.py 21 22 23 24 25 26 27 def __init__ ( self , parent = None , rule_result : RuleResult = None ): super () . __init__ ( parent , RULE_RESULT_TYPE ) self . _result = rule_result self . _description_item = None if self . _result is not None : self . _update ()","title":"RuleResultItem"},{"location":"developer/api/gui/api_validation_result_items/#src.cplus_plugin.gui.validation.result_items.RuleResultItem.result","text":"result Gets the rule result used to show result details. Returns: Type Description RuleResult Returns the rule result used to show result details.","title":"result"},{"location":"developer/api/gui/api_validation_result_items/#src.cplus_plugin.gui.validation.result_items.RuleResultItem.expand_description","text":"expand_description ( expand ) Expand or collapse the result description tree node. Parameters: Name Type Description Default expand bool True to expand the result description node else False. required Source code in src/cplus_plugin/gui/validation/result_items.py 96 97 98 99 100 101 102 103 def expand_description ( self , expand : bool ): \"\"\"Expand or collapse the result description tree node. :param expand: True to expand the result description node else False. :type expand: bool \"\"\" if self . _description_item is not None : self . _description_item . setExpanded ( expand )","title":"expand_description"},{"location":"developer/api/models/api_base/","text":"Model base \u00b6 QGIS CPLUS plugin models. Activity dataclass \u00b6 Activity ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False , pathways = list (), layer_styles = dict (), mask_paths = list (), style_pixel_value =- 1 ) Bases: LayerModelComponent Contains information about an activity used in a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property. __post_init__ \u00b6 __post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in activity\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = [] activity_layer_style_info \u00b6 activity_layer_style_info () Returns the color ramp properties for styling the activity layer resulting from a scenario run. Returns: Type Description dict Color ramp properties for the activity styling or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 def activity_layer_style_info ( self ) -> dict : \"\"\"Returns the color ramp properties for styling the activity layer resulting from a scenario run. :returns: Color ramp properties for the activity styling or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or ACTIVITY_LAYER_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ ACTIVITY_LAYER_STYLE_ATTRIBUTE ] add_ncs_pathway \u00b6 add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the activity. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the activity. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True clear_layer \u00b6 clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 499 500 501 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\" color_ramp \u00b6 color_ramp () Create a color ramp for styling the activity layer resulting from a scenario run. Returns: Type Description QgsColorRamp A color ramp for styling the activity layer or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def color_ramp ( self ) -> typing . Union [ QgsColorRamp , None ]: \"\"\"Create a color ramp for styling the activity layer resulting from a scenario run. :returns: A color ramp for styling the activity layer or None if there was no definition found. :rtype: QgsColorRamp \"\"\" model_layer_info = self . activity_layer_style_info () if len ( model_layer_info ) == 0 : return None ramp_info = model_layer_info . get ( COLOR_RAMP_PROPERTIES_ATTRIBUTE , None ) if ramp_info is None or len ( ramp_info ) == 0 : return None ramp_type = model_layer_info . get ( COLOR_RAMP_TYPE_ATTRIBUTE , None ) if ramp_type is None : return None # New ramp types will need to be added here manually if ramp_type == QgsColorBrewerColorRamp . typeString (): return QgsColorBrewerColorRamp . create ( ramp_info ) elif ramp_type == QgsCptCityColorRamp . typeString (): return QgsCptCityColorRamp . create ( ramp_info ) elif ramp_type == QgsGradientColorRamp . typeString (): return QgsGradientColorRamp . create ( ramp_info ) elif ramp_type == QgsLimitedRandomColorRamp . typeString (): return QgsLimitedRandomColorRamp . create ( ramp_info ) elif ramp_type == QgsPresetSchemeColorRamp . typeString (): return QgsPresetSchemeColorRamp . create ( ramp_info ) elif ramp_type == QgsRandomColorRamp . typeString (): return QgsRandomColorRamp () return None contains_pathway \u00b6 contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True from_dict classmethod \u00b6 from_dict ( activity_dict ) Create an Activity object from Activity dict. Source code in src/cplus_plugin/models/base.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 @classmethod def from_dict ( cls , activity_dict : typing . Dict ): \"\"\"Create an Activity object from Activity dict.\"\"\" pathways = [] for pathway in activity_dict [ \"pathways\" ]: del pathway [ \"layer_uuid\" ] if \"carbon_paths\" in pathway : del pathway [ \"carbon_paths\" ] if \"carbon_uuids\" in pathway : del pathway [ \"carbon_uuids\" ] pathways . append ( NcsPathway ( ** pathway )) activity_dict [ \"pathways\" ] = pathways # delete mask_uuids using pop activity_dict . pop ( \"mask_uuids\" , None ) activity_dict . pop ( \"priority_layers\" , None ) return Activity ( ** activity_dict ) is_valid \u00b6 is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False return True pathway_by_uuid \u00b6 pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ] remove_ncs_pathway \u00b6 remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True scenario_fill_symbol \u00b6 scenario_fill_symbol () Creates a fill symbol for the activity in the scenario. Returns: Type Description QgsFillSymbol Fill symbol for the activity in the scenario or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 589 590 591 592 593 594 595 596 597 598 599 600 def scenario_fill_symbol ( self ) -> typing . Union [ QgsFillSymbol , None ]: \"\"\"Creates a fill symbol for the activity in the scenario. :returns: Fill symbol for the activity in the scenario or None if there was no definition found. :rtype: QgsFillSymbol \"\"\" scenario_style_info = self . scenario_layer_style_info () if len ( scenario_style_info ) == 0 : return None return QgsFillSymbol . createSimple ( scenario_style_info ) scenario_layer_style_info \u00b6 scenario_layer_style_info () Returns the fill symbol properties for styling the activity layer in the final scenario result. Returns: Type Description dict Fill symbol properties for the activity layer styling in the scenario layer or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 def scenario_layer_style_info ( self ) -> dict : \"\"\"Returns the fill symbol properties for styling the activity layer in the final scenario result. :returns: Fill symbol properties for the activity layer styling in the scenario layer or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or ACTIVITY_SCENARIO_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ ACTIVITY_SCENARIO_STYLE_ATTRIBUTE ] type \u00b6 type () Returns the type of this model component. Returns: Type Description ModelComponentType ModelComponentType.ACTIVITY Source code in src/cplus_plugin/models/base.py 638 639 640 641 642 643 644 def type ( self ) -> ModelComponentType : \"\"\"Returns the type of this model component. :returns: ModelComponentType.ACTIVITY :rtype: ModelComponentType \"\"\" return ModelComponentType . ACTIVITY AreaOfInterestSource \u00b6 Bases: Enum Defines the area of inteterest sources BaseModelComponent dataclass \u00b6 BaseModelComponent ( uuid , name , description ) Base class for common model item properties. __eq__ \u00b6 __eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True __hash__ \u00b6 __hash__ () Use the uuid so that the component can be used in sets or dictionaries. Returns: Type Description int Returns a unique identifier based on the uuid attribute. Source code in src/cplus_plugin/models/base.py 94 95 96 97 98 99 100 101 102 def __hash__ ( self ) -> int : \"\"\"Use the `uuid` so that the component can be used in sets or dictionaries. :returns: Returns a unique identifier based on the `uuid` attribute. :rtype: int \"\"\" return hash ( self . uuid ) DataSourceType \u00b6 Bases: IntEnum Specifies whether a data source is from a local or online source. from_int staticmethod \u00b6 from_int ( int_enum ) Creates an enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the data source type. required Returns: Type Description DataSourceType Data source type enum corresponding to the given integer else unknown if not found. Source code in src/cplus_plugin/models/base.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 @staticmethod def from_int ( int_enum : int ) -> \"DataSourceType\" : \"\"\"Creates an enum from the corresponding int equivalent. :param int_enum: Integer representing the data source type. :type int_enum: int :returns: Data source type enum corresponding to the given integer else unknown if not found. :rtype: DataSourceType \"\"\" return { 0 : DataSourceType . LOCAL , 1 : DataSourceType . ONLINE , - 1 : DataSourceType . UNDEFINED , }[ int_enum ] LayerModelComponent dataclass \u00b6 LayerModelComponent ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False ) Bases: BaseModelComponent Base class for model components that support a map layer. layer_uuid property \u00b6 layer_uuid Return Layer UUID for default layer. Default layer's path will start with 'cplus://'. Returns: Type Description str Server Layer UUID __eq__ \u00b6 __eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 229 230 231 232 233 234 235 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" if self . layer_uuid : return self . layer_uuid == other . layer_uuid return super () . __eq__ ( other ) __post_init__ \u00b6 __post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 156 157 158 159 160 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" if self . layer_uuid : return self . update_layer_type () is_default_layer \u00b6 is_default_layer () Check if layer is a default layer Returns: Type Description bool True if layer comes from server API Source code in src/cplus_plugin/models/base.py 237 238 239 240 241 242 243 def is_default_layer ( self ) -> bool : \"\"\"Check if layer is a default layer :return: True if layer comes from server API :rtype: bool \"\"\" return self . layer_uuid is not None is_valid \u00b6 is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . layer_uuid : return True layer = self . to_map_layer () if layer is None : return False return layer . isValid () to_map_layer \u00b6 to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer update_layer_type \u00b6 update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR LayerSource \u00b6 Bases: Enum Specify if a layer source is cplus or naturebase. LayerType \u00b6 Bases: IntEnum QGIS spatial layer type. ModelComponentType \u00b6 Bases: Enum Type of model component i.e. NCS pathway or activity. from_string staticmethod \u00b6 from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"activity\" : return ModelComponentType . ACTIVITY return ModelComponentType . UNKNOWN NcsPathway dataclass \u00b6 NcsPathway ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False , pathway_type = NcsPathwayType . UNDEFINED , priority_layers = list (), carbon_impact_value = None , suitability_index = 0.0 , type_options = dict ()) Bases: LayerModelComponent Contains information about an NCS pathway layer. __eq__ \u00b6 __eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True is_pwls_valid \u00b6 is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid pw_layers \u00b6 pw_layers () Returns the list of priority weighting layers defined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers defined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers if layer . get ( \"path\" ) ] supports_extra_options \u00b6 supports_extra_options () Checks if the pathway supports extra options. Returns: Type Description bool True if the selected pathway type support extra options else False. Source code in src/cplus_plugin/models/base.py 396 397 398 399 400 401 402 403 404 405 406 def supports_extra_options ( self ) -> bool : \"\"\"Checks if the pathway supports extra options. :returns: True if the selected pathway type support extra options else False. :rtype: bool \"\"\" if self . pathway_type == NcsPathwayType . MANAGE : return True return False type \u00b6 type () Returns the type of this model component. Returns: Type Description ModelComponentType ModelComponentType.NCS_PATHWAY Source code in src/cplus_plugin/models/base.py 408 409 410 411 412 413 414 def type ( self ) -> ModelComponentType : \"\"\"Returns the type of this model component. :returns: ModelComponentType.NCS_PATHWAY :rtype: ModelComponentType \"\"\" return ModelComponentType . NCS_PATHWAY NcsPathwayType \u00b6 Bases: IntEnum Type of NCS pathway. from_int staticmethod \u00b6 from_int ( int_enum ) Creates an enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the NCS pathway type. required Returns: Type Description NcsPathwayType NCS pathway type enum corresponding to the given integer else unknown if not found. Source code in src/cplus_plugin/models/base.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 @staticmethod def from_int ( int_enum : int ) -> \"NcsPathwayType\" : \"\"\"Creates an enum from the corresponding int equivalent. :param int_enum: Integer representing the NCS pathway type. :type int_enum: int :returns: NCS pathway type enum corresponding to the given integer else unknown if not found. :rtype: NcsPathwayType \"\"\" return { 0 : NcsPathwayType . PROTECT , 1 : NcsPathwayType . RESTORE , 2 : NcsPathwayType . MANAGE , - 1 : NcsPathwayType . UNDEFINED , }[ int_enum ] PRIORITY_GROUP \u00b6 Bases: Enum Represents priority groups types PriorityLayer dataclass \u00b6 PriorityLayer ( uuid , name , description , groups , selected = False , path = '' , type = PriorityLayerType . DEFAULT ) Bases: BaseModelComponent Base class for model components storing priority weighting layers. layer_uuid property \u00b6 layer_uuid Return Layer UUID for default layer. Default layer's path will start with 'cplus://'. Returns: Type Description str Server Layer UUID __eq__ \u00b6 __eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 279 280 281 282 283 284 285 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" if self . layer_uuid : return self . layer_uuid == other . layer_uuid return super () . __eq__ ( other ) is_default_layer \u00b6 is_default_layer () Check if layer is a default layer Returns: Type Description bool True if layer comes from server API Source code in src/cplus_plugin/models/base.py 287 288 289 290 291 292 293 def is_default_layer ( self ) -> bool : \"\"\"Check if layer is a default layer :return: True if layer comes from server API :rtype: bool \"\"\" return self . layer_uuid is not None PriorityLayerType \u00b6 Bases: IntEnum Type of priority weighting layer. ResultInfo dataclass \u00b6 ResultInfo ( result_collection , updated_date ) Simple generic container for result collection and when it was last updated. Use cases can include results from online processing. The updated_date is assumed to be in UTC in this format %Y-%m-%dT%H:%M:%SZ. to_local_time \u00b6 to_local_time () Convenience function that converts the updated_date to more friendly display in the local time. Returns: Type Description str Friendly date/time display in local date/time and format, or an empty string if the date/time is invalid. Source code in src/cplus_plugin/models/base.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def to_local_time ( self ) -> str : \"\"\"Convenience function that converts the `updated_date` to more friendly display in the local time. :returns: Friendly date/time display in local date/time and format, or an empty string if the date/time is invalid. :rtype: str \"\"\" if not self . updated_date : return \"\" updated_date_time = QDateTime . fromString ( self . updated_date , Qt . DateFormat . ISODate ) if not updated_date_time . isValid (): return \"\" updated_date_time . setTimeSpec ( Qt . TimeSpec . UTC ) local_date_time = updated_date_time . toLocalTime () return QLocale . system () . toString ( local_date_time , QLocale . FormatType . LongFormat ) Scenario dataclass \u00b6 Scenario ( uuid , name , description , extent , activities , priority_layer_groups , state = ScenarioState . IDLE , server_uuid = None , clip_to_studyarea = False , studyarea_path = None , crs = None , constant_raster_collection = None ) Bases: BaseModelComponent Object for the handling workflow scenario information. ScenarioResult dataclass \u00b6 ScenarioResult ( scenario , created_date = datetime . datetime . now (), analysis_output = None , output_layer_name = '' , scenario_directory = '' ) Scenario result details. ScenarioState \u00b6 Bases: Enum Defines scenario analysis process states SpatialExtent dataclass \u00b6 SpatialExtent ( bbox , crs = None ) Extent object that stores the coordinates of the area of interest and the analysis coordinate reference system (CRS).","title":"Model base"},{"location":"developer/api/models/api_base/#model-base","text":"QGIS CPLUS plugin models.","title":"Model base"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity","text":"Activity ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False , pathways = list (), layer_styles = dict (), mask_paths = list (), style_pixel_value =- 1 ) Bases: LayerModelComponent Contains information about an activity used in a scenario. If the layer has been set then it will not be possible to add NCS pathways unless the layer is cleared. Priority will be given to the layer property.","title":"Activity"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.__post_init__","text":"__post_init__ () Pre-checks on initialization. Source code in src/cplus_plugin/models/base.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 def __post_init__ ( self ): \"\"\"Pre-checks on initialization.\"\"\" super () . __post_init__ () # Ensure there are no duplicate pathways. uuids = [ str ( p . uuid ) for p in self . pathways ] if len ( set ( uuids )) != len ( uuids ): msg = \"Duplicate pathways found in activity\" raise ValueError ( f \" { msg } { self . name } .\" ) # Reset pathways if layer has also been set. if self . to_map_layer () is not None and len ( self . pathways ) > 0 : self . pathways = []","title":"__post_init__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.activity_layer_style_info","text":"activity_layer_style_info () Returns the color ramp properties for styling the activity layer resulting from a scenario run. Returns: Type Description dict Color ramp properties for the activity styling or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 def activity_layer_style_info ( self ) -> dict : \"\"\"Returns the color ramp properties for styling the activity layer resulting from a scenario run. :returns: Color ramp properties for the activity styling or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or ACTIVITY_LAYER_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ ACTIVITY_LAYER_STYLE_ATTRIBUTE ]","title":"activity_layer_style_info"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.add_ncs_pathway","text":"add_ncs_pathway ( ncs ) Adds an NCS pathway object to the collection. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to be added to the activity. required Returns: Type Description bool True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. Source code in src/cplus_plugin/models/base.py 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def add_ncs_pathway ( self , ncs : NcsPathway ) -> bool : \"\"\"Adds an NCS pathway object to the collection. :param ncs: NCS pathway to be added to the activity. :type ncs: NcsPathway :returns: True if the NCS pathway was successfully added, else False if there was an existing NCS pathway object with a similar UUID or the layer property had already been set. \"\"\" if not ncs . is_valid (): return False if self . contains_pathway ( str ( ncs . uuid )): return False self . pathways . append ( ncs ) return True","title":"add_ncs_pathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.clear_layer","text":"clear_layer () Removes a reference to the layer URI defined in the path attribute. Source code in src/cplus_plugin/models/base.py 499 500 501 def clear_layer ( self ): \"\"\"Removes a reference to the layer URI defined in the path attribute.\"\"\" self . path = \"\"","title":"clear_layer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.color_ramp","text":"color_ramp () Create a color ramp for styling the activity layer resulting from a scenario run. Returns: Type Description QgsColorRamp A color ramp for styling the activity layer or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def color_ramp ( self ) -> typing . Union [ QgsColorRamp , None ]: \"\"\"Create a color ramp for styling the activity layer resulting from a scenario run. :returns: A color ramp for styling the activity layer or None if there was no definition found. :rtype: QgsColorRamp \"\"\" model_layer_info = self . activity_layer_style_info () if len ( model_layer_info ) == 0 : return None ramp_info = model_layer_info . get ( COLOR_RAMP_PROPERTIES_ATTRIBUTE , None ) if ramp_info is None or len ( ramp_info ) == 0 : return None ramp_type = model_layer_info . get ( COLOR_RAMP_TYPE_ATTRIBUTE , None ) if ramp_type is None : return None # New ramp types will need to be added here manually if ramp_type == QgsColorBrewerColorRamp . typeString (): return QgsColorBrewerColorRamp . create ( ramp_info ) elif ramp_type == QgsCptCityColorRamp . typeString (): return QgsCptCityColorRamp . create ( ramp_info ) elif ramp_type == QgsGradientColorRamp . typeString (): return QgsGradientColorRamp . create ( ramp_info ) elif ramp_type == QgsLimitedRandomColorRamp . typeString (): return QgsLimitedRandomColorRamp . create ( ramp_info ) elif ramp_type == QgsPresetSchemeColorRamp . typeString (): return QgsPresetSchemeColorRamp . create ( ramp_info ) elif ramp_type == QgsRandomColorRamp . typeString (): return QgsRandomColorRamp () return None","title":"color_ramp"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.contains_pathway","text":"contains_pathway ( pathway_uuid ) Checks if there is an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID to search for in the collection. required Returns: Type Description bool True if there is a matching NCS pathway, else False. Source code in src/cplus_plugin/models/base.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 def contains_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Checks if there is an NCS pathway matching the given UUID. :param pathway_uuid: UUID to search for in the collection. :type pathway_uuid: str :returns: True if there is a matching NCS pathway, else False. :rtype: bool \"\"\" ncs_pathway = self . pathway_by_uuid ( pathway_uuid ) if ncs_pathway is None : return False return True","title":"contains_pathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.from_dict","text":"from_dict ( activity_dict ) Create an Activity object from Activity dict. Source code in src/cplus_plugin/models/base.py 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 @classmethod def from_dict ( cls , activity_dict : typing . Dict ): \"\"\"Create an Activity object from Activity dict.\"\"\" pathways = [] for pathway in activity_dict [ \"pathways\" ]: del pathway [ \"layer_uuid\" ] if \"carbon_paths\" in pathway : del pathway [ \"carbon_paths\" ] if \"carbon_uuids\" in pathway : del pathway [ \"carbon_uuids\" ] pathways . append ( NcsPathway ( ** pathway )) activity_dict [ \"pathways\" ] = pathways # delete mask_uuids using pop activity_dict . pop ( \"mask_uuids\" , None ) activity_dict . pop ( \"priority_layers\" , None ) return Activity ( ** activity_dict )","title":"from_dict"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.is_valid","text":"is_valid () Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. Source code in src/cplus_plugin/models/base.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 def is_valid ( self ) -> bool : \"\"\"Includes an additional check to assert if NCS pathways have been specified if the layer has not been set or is not valid. Does not check for validity of individual NCS pathways in the collection. \"\"\" if self . to_map_layer () is not None : return super () . is_valid () else : if len ( self . pathways ) == 0 : return False return True","title":"is_valid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.pathway_by_uuid","text":"pathway_by_uuid ( pathway_uuid ) Returns an NCS pathway matching the given UUID. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to retrieve. required Returns: Type Description NcsPathway NCS pathway object matching the given UUID else None if not found. Source code in src/cplus_plugin/models/base.py 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def pathway_by_uuid ( self , pathway_uuid : str ) -> typing . Union [ NcsPathway , None ]: \"\"\"Returns an NCS pathway matching the given UUID. :param pathway_uuid: UUID for the NCS pathway to retrieve. :type pathway_uuid: str :returns: NCS pathway object matching the given UUID else None if not found. :rtype: NcsPathway \"\"\" pathways = [ p for p in self . pathways if str ( p . uuid ) == pathway_uuid ] if len ( pathways ) == 0 : return None return pathways [ 0 ]","title":"pathway_by_uuid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.remove_ncs_pathway","text":"remove_ncs_pathway ( pathway_uuid ) Removes the NCS pathway with a matching UUID from the collection. Parameters: Name Type Description Default pathway_uuid str UUID for the NCS pathway to be removed. required Returns: Type Description bool True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. Source code in src/cplus_plugin/models/base.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 def remove_ncs_pathway ( self , pathway_uuid : str ) -> bool : \"\"\"Removes the NCS pathway with a matching UUID from the collection. :param pathway_uuid: UUID for the NCS pathway to be removed. :type pathway_uuid: str :returns: True if the NCS pathway object was successfully removed, else False if there is no object matching the given UUID. :rtype: bool \"\"\" idxs = [ i for i , p in enumerate ( self . pathways ) if str ( p . uuid ) == pathway_uuid ] if len ( idxs ) == 0 : return False rem_idx = idxs [ 0 ] _ = self . pathways . pop ( rem_idx ) return True","title":"remove_ncs_pathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.scenario_fill_symbol","text":"scenario_fill_symbol () Creates a fill symbol for the activity in the scenario. Returns: Type Description QgsFillSymbol Fill symbol for the activity in the scenario or None if there was no definition found. Source code in src/cplus_plugin/models/base.py 589 590 591 592 593 594 595 596 597 598 599 600 def scenario_fill_symbol ( self ) -> typing . Union [ QgsFillSymbol , None ]: \"\"\"Creates a fill symbol for the activity in the scenario. :returns: Fill symbol for the activity in the scenario or None if there was no definition found. :rtype: QgsFillSymbol \"\"\" scenario_style_info = self . scenario_layer_style_info () if len ( scenario_style_info ) == 0 : return None return QgsFillSymbol . createSimple ( scenario_style_info )","title":"scenario_fill_symbol"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.scenario_layer_style_info","text":"scenario_layer_style_info () Returns the fill symbol properties for styling the activity layer in the final scenario result. Returns: Type Description dict Fill symbol properties for the activity layer styling in the scenario layer or an empty dictionary if there was no definition found in the root style. Source code in src/cplus_plugin/models/base.py 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 def scenario_layer_style_info ( self ) -> dict : \"\"\"Returns the fill symbol properties for styling the activity layer in the final scenario result. :returns: Fill symbol properties for the activity layer styling in the scenario layer or an empty dictionary if there was no definition found in the root style. :rtype: dict \"\"\" if ( len ( self . layer_styles ) == 0 or ACTIVITY_SCENARIO_STYLE_ATTRIBUTE not in self . layer_styles ): return dict () return self . layer_styles [ ACTIVITY_SCENARIO_STYLE_ATTRIBUTE ]","title":"scenario_layer_style_info"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Activity.type","text":"type () Returns the type of this model component. Returns: Type Description ModelComponentType ModelComponentType.ACTIVITY Source code in src/cplus_plugin/models/base.py 638 639 640 641 642 643 644 def type ( self ) -> ModelComponentType : \"\"\"Returns the type of this model component. :returns: ModelComponentType.ACTIVITY :rtype: ModelComponentType \"\"\" return ModelComponentType . ACTIVITY","title":"type"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.AreaOfInterestSource","text":"Bases: Enum Defines the area of inteterest sources","title":"AreaOfInterestSource"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent","text":"BaseModelComponent ( uuid , name , description ) Base class for common model item properties.","title":"BaseModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent.__eq__","text":"__eq__ ( other ) Test equality of object with another BaseModelComponent object using the attributes. Parameters: Name Type Description Default other BaseModelComponent BaseModelComponent object to compare with this object. required Returns: Type Description bool True if the all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def __eq__ ( self , other : \"BaseModelComponent\" ) -> bool : \"\"\"Test equality of object with another BaseModelComponent object using the attributes. :param other: BaseModelComponent object to compare with this object. :type other: BaseModelComponent :returns: True if the all the attribute values match, else False. :rtype: bool \"\"\" if self . uuid != other . uuid : return False if self . name != other . name : return False if self . description != other . description : return False return True","title":"__eq__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.BaseModelComponent.__hash__","text":"__hash__ () Use the uuid so that the component can be used in sets or dictionaries. Returns: Type Description int Returns a unique identifier based on the uuid attribute. Source code in src/cplus_plugin/models/base.py 94 95 96 97 98 99 100 101 102 def __hash__ ( self ) -> int : \"\"\"Use the `uuid` so that the component can be used in sets or dictionaries. :returns: Returns a unique identifier based on the `uuid` attribute. :rtype: int \"\"\" return hash ( self . uuid )","title":"__hash__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.DataSourceType","text":"Bases: IntEnum Specifies whether a data source is from a local or online source.","title":"DataSourceType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.DataSourceType.from_int","text":"from_int ( int_enum ) Creates an enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the data source type. required Returns: Type Description DataSourceType Data source type enum corresponding to the given integer else unknown if not found. Source code in src/cplus_plugin/models/base.py 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 @staticmethod def from_int ( int_enum : int ) -> \"DataSourceType\" : \"\"\"Creates an enum from the corresponding int equivalent. :param int_enum: Integer representing the data source type. :type int_enum: int :returns: Data source type enum corresponding to the given integer else unknown if not found. :rtype: DataSourceType \"\"\" return { 0 : DataSourceType . LOCAL , 1 : DataSourceType . ONLINE , - 1 : DataSourceType . UNDEFINED , }[ int_enum ]","title":"from_int"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent","text":"LayerModelComponent ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False ) Bases: BaseModelComponent Base class for model components that support a map layer.","title":"LayerModelComponent"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.layer_uuid","text":"layer_uuid Return Layer UUID for default layer. Default layer's path will start with 'cplus://'. Returns: Type Description str Server Layer UUID","title":"layer_uuid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__eq__","text":"__eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 229 230 231 232 233 234 235 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" if self . layer_uuid : return self . layer_uuid == other . layer_uuid return super () . __eq__ ( other )","title":"__eq__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.__post_init__","text":"__post_init__ () Try to set the layer and layer type properties. Source code in src/cplus_plugin/models/base.py 156 157 158 159 160 def __post_init__ ( self ): \"\"\"Try to set the layer and layer type properties.\"\"\" if self . layer_uuid : return self . update_layer_type ()","title":"__post_init__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.is_default_layer","text":"is_default_layer () Check if layer is a default layer Returns: Type Description bool True if layer comes from server API Source code in src/cplus_plugin/models/base.py 237 238 239 240 241 242 243 def is_default_layer ( self ) -> bool : \"\"\"Check if layer is a default layer :return: True if layer comes from server API :rtype: bool \"\"\" return self . layer_uuid is not None","title":"is_default_layer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.is_valid","text":"is_valid () Checks if the corresponding map layer is valid. Returns: Type Description bool True if the map layer is valid, else False if map layer is invalid or of None type. Source code in src/cplus_plugin/models/base.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def is_valid ( self ) -> bool : \"\"\"Checks if the corresponding map layer is valid. :returns: True if the map layer is valid, else False if map layer is invalid or of None type. :rtype: bool \"\"\" if self . layer_uuid : return True layer = self . to_map_layer () if layer is None : return False return layer . isValid ()","title":"is_valid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.to_map_layer","text":"to_map_layer () Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. Returns: Type Description QgsMapLayer Map layer corresponding to the set layer property or specified path. Source code in src/cplus_plugin/models/base.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 def to_map_layer ( self ) -> typing . Union [ QgsMapLayer , None ]: \"\"\"Constructs a map layer from the specified path. It will first check if the layer property has been set else try to construct the layer from the path else return None. :returns: Map layer corresponding to the set layer property or specified path. :rtype: QgsMapLayer \"\"\" if not os . path . exists ( self . path ): return None layer = None if self . layer_type == LayerType . RASTER : layer = QgsRasterLayer ( self . path , self . name ) elif self . layer_type == LayerType . VECTOR : layer = QgsVectorLayer ( self . path , self . name ) return layer","title":"to_map_layer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerModelComponent.update_layer_type","text":"update_layer_type () Update the layer type if either the layer or path properties have been set. Source code in src/cplus_plugin/models/base.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def update_layer_type ( self ): \"\"\"Update the layer type if either the layer or path properties have been set. \"\"\" layer = self . to_map_layer () if layer is None : return if not layer . isValid (): return if isinstance ( layer , QgsRasterLayer ): self . layer_type = LayerType . RASTER elif isinstance ( layer , QgsVectorLayer ): self . layer_type = LayerType . VECTOR","title":"update_layer_type"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerSource","text":"Bases: Enum Specify if a layer source is cplus or naturebase.","title":"LayerSource"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.LayerType","text":"Bases: IntEnum QGIS spatial layer type.","title":"LayerType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType","text":"Bases: Enum Type of model component i.e. NCS pathway or activity.","title":"ModelComponentType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ModelComponentType.from_string","text":"from_string ( str_enum ) Creates an enum from the corresponding string equivalent. Parameters: Name Type Description Default str_enum str String representing the model component type. required Returns: Type Description ModelComponentType Component type enum corresponding to the given string else unknown if not found. Source code in src/cplus_plugin/models/base.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @staticmethod def from_string ( str_enum : str ) -> \"ModelComponentType\" : \"\"\"Creates an enum from the corresponding string equivalent. :param str_enum: String representing the model component type. :type str_enum: str :returns: Component type enum corresponding to the given string else unknown if not found. :rtype: ModelComponentType \"\"\" if str_enum . lower () == \"ncs_pathway\" : return ModelComponentType . NCS_PATHWAY elif str_enum . lower () == \"activity\" : return ModelComponentType . ACTIVITY return ModelComponentType . UNKNOWN","title":"from_string"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway","text":"NcsPathway ( uuid , name , description , path = '' , layer_type = LayerType . UNDEFINED , user_defined = False , pathway_type = NcsPathwayType . UNDEFINED , priority_layers = list (), carbon_impact_value = None , suitability_index = 0.0 , type_options = dict ()) Bases: LayerModelComponent Contains information about an NCS pathway layer.","title":"NcsPathway"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.__eq__","text":"__eq__ ( other ) Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. Parameters: Name Type Description Default other NcsPathway NcsPathway object to compare with this object. required Returns: Type Description bool True if all the attribute values match, else False. Source code in src/cplus_plugin/models/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def __eq__ ( self , other : \"NcsPathway\" ) -> bool : \"\"\"Test equality of NcsPathway object with another NcsPathway object using the attributes. Excludes testing the map layer for equality. :param other: NcsPathway object to compare with this object. :type other: NcsPathway :returns: True if all the attribute values match, else False. :rtype: bool \"\"\" base_equality = super () . __eq__ ( other ) if not base_equality : return False if self . path != other . path : return False if self . layer_type != other . layer_type : return False if self . user_defined != other . user_defined : return False return True","title":"__eq__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.is_pwls_valid","text":"is_pwls_valid () Checks if the priority layers are valid. Returns: Type Description bool True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. Source code in src/cplus_plugin/models/base.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 def is_pwls_valid ( self ) -> bool : \"\"\"Checks if the priority layers are valid. :returns: True if all priority layers are valid, else False if even one is invalid. If there are no priority layers defined, it will always return True. :rtype: bool \"\"\" is_valid = True for cl in self . pw_layers (): if not cl . isValid (): is_valid = False break return is_valid","title":"is_pwls_valid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.pw_layers","text":"pw_layers () Returns the list of priority weighting layers defined under the :py:attr: ~priority_layers attribute. Returns: Type Description list Priority layers for the implementation or an empty list if the path is not defined. Source code in src/cplus_plugin/models/base.py 366 367 368 369 370 371 372 373 374 375 376 377 378 def pw_layers ( self ) -> typing . List [ QgsRasterLayer ]: \"\"\"Returns the list of priority weighting layers defined under the :py:attr:`~priority_layers` attribute. :returns: Priority layers for the implementation or an empty list if the path is not defined. :rtype: list \"\"\" return [ QgsRasterLayer ( layer . get ( \"path\" )) for layer in self . priority_layers if layer . get ( \"path\" ) ]","title":"pw_layers"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.supports_extra_options","text":"supports_extra_options () Checks if the pathway supports extra options. Returns: Type Description bool True if the selected pathway type support extra options else False. Source code in src/cplus_plugin/models/base.py 396 397 398 399 400 401 402 403 404 405 406 def supports_extra_options ( self ) -> bool : \"\"\"Checks if the pathway supports extra options. :returns: True if the selected pathway type support extra options else False. :rtype: bool \"\"\" if self . pathway_type == NcsPathwayType . MANAGE : return True return False","title":"supports_extra_options"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathway.type","text":"type () Returns the type of this model component. Returns: Type Description ModelComponentType ModelComponentType.NCS_PATHWAY Source code in src/cplus_plugin/models/base.py 408 409 410 411 412 413 414 def type ( self ) -> ModelComponentType : \"\"\"Returns the type of this model component. :returns: ModelComponentType.NCS_PATHWAY :rtype: ModelComponentType \"\"\" return ModelComponentType . NCS_PATHWAY","title":"type"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathwayType","text":"Bases: IntEnum Type of NCS pathway.","title":"NcsPathwayType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.NcsPathwayType.from_int","text":"from_int ( int_enum ) Creates an enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the NCS pathway type. required Returns: Type Description NcsPathwayType NCS pathway type enum corresponding to the given integer else unknown if not found. Source code in src/cplus_plugin/models/base.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 @staticmethod def from_int ( int_enum : int ) -> \"NcsPathwayType\" : \"\"\"Creates an enum from the corresponding int equivalent. :param int_enum: Integer representing the NCS pathway type. :type int_enum: int :returns: NCS pathway type enum corresponding to the given integer else unknown if not found. :rtype: NcsPathwayType \"\"\" return { 0 : NcsPathwayType . PROTECT , 1 : NcsPathwayType . RESTORE , 2 : NcsPathwayType . MANAGE , - 1 : NcsPathwayType . UNDEFINED , }[ int_enum ]","title":"from_int"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PRIORITY_GROUP","text":"Bases: Enum Represents priority groups types","title":"PRIORITY_GROUP"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer","text":"PriorityLayer ( uuid , name , description , groups , selected = False , path = '' , type = PriorityLayerType . DEFAULT ) Bases: BaseModelComponent Base class for model components storing priority weighting layers.","title":"PriorityLayer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer.layer_uuid","text":"layer_uuid Return Layer UUID for default layer. Default layer's path will start with 'cplus://'. Returns: Type Description str Server Layer UUID","title":"layer_uuid"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer.__eq__","text":"__eq__ ( other ) Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. Source code in src/cplus_plugin/models/base.py 279 280 281 282 283 284 285 def __eq__ ( self , other ) -> bool : \"\"\"Uses BaseModelComponent equality test rather than what the dataclass default implementation will provide. \"\"\" if self . layer_uuid : return self . layer_uuid == other . layer_uuid return super () . __eq__ ( other )","title":"__eq__"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayer.is_default_layer","text":"is_default_layer () Check if layer is a default layer Returns: Type Description bool True if layer comes from server API Source code in src/cplus_plugin/models/base.py 287 288 289 290 291 292 293 def is_default_layer ( self ) -> bool : \"\"\"Check if layer is a default layer :return: True if layer comes from server API :rtype: bool \"\"\" return self . layer_uuid is not None","title":"is_default_layer"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.PriorityLayerType","text":"Bases: IntEnum Type of priority weighting layer.","title":"PriorityLayerType"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ResultInfo","text":"ResultInfo ( result_collection , updated_date ) Simple generic container for result collection and when it was last updated. Use cases can include results from online processing. The updated_date is assumed to be in UTC in this format %Y-%m-%dT%H:%M:%SZ.","title":"ResultInfo"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ResultInfo.to_local_time","text":"to_local_time () Convenience function that converts the updated_date to more friendly display in the local time. Returns: Type Description str Friendly date/time display in local date/time and format, or an empty string if the date/time is invalid. Source code in src/cplus_plugin/models/base.py 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 def to_local_time ( self ) -> str : \"\"\"Convenience function that converts the `updated_date` to more friendly display in the local time. :returns: Friendly date/time display in local date/time and format, or an empty string if the date/time is invalid. :rtype: str \"\"\" if not self . updated_date : return \"\" updated_date_time = QDateTime . fromString ( self . updated_date , Qt . DateFormat . ISODate ) if not updated_date_time . isValid (): return \"\" updated_date_time . setTimeSpec ( Qt . TimeSpec . UTC ) local_date_time = updated_date_time . toLocalTime () return QLocale . system () . toString ( local_date_time , QLocale . FormatType . LongFormat )","title":"to_local_time"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.Scenario","text":"Scenario ( uuid , name , description , extent , activities , priority_layer_groups , state = ScenarioState . IDLE , server_uuid = None , clip_to_studyarea = False , studyarea_path = None , crs = None , constant_raster_collection = None ) Bases: BaseModelComponent Object for the handling workflow scenario information.","title":"Scenario"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioResult","text":"ScenarioResult ( scenario , created_date = datetime . datetime . now (), analysis_output = None , output_layer_name = '' , scenario_directory = '' ) Scenario result details.","title":"ScenarioResult"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.ScenarioState","text":"Bases: Enum Defines scenario analysis process states","title":"ScenarioState"},{"location":"developer/api/models/api_base/#src.cplus_plugin.models.base.SpatialExtent","text":"SpatialExtent ( bbox , crs = None ) Extent object that stores the coordinates of the area of interest and the analysis coordinate reference system (CRS).","title":"SpatialExtent"},{"location":"developer/api/models/api_financials/","text":"Financial Data Classes \u00b6 Data models for the financial elements of the tool. ActivityNpv dataclass \u00b6 ActivityNpv ( value_info = None , component = None , prefix = '' , base_name = '' , suffix = '' , path = '' , skip_raster = False , enabled = True ) Bases: ConstantRasterComponent Mapping of the NPV parameters to the corresponding activity. activity property writable \u00b6 activity Wrapper for legacy support returning the activity model. Returns: Type Description Activity The activity if defined else None. activity_id property \u00b6 activity_id Gets the identifier of the activity model. Returns: Type Description str The unique identifier of the activity model else an empty string if no activity has been set. computed_base_name property \u00b6 computed_base_name Returns a proposed name for the activity NPV. An empty string will be return id the activity attribute is not set. Returns: Type Description str Proposed base name for the activity NPV. params property writable \u00b6 params Wrapper for legacy support returning the activity's parameters object. Returns: Type Description NpvParameters The activity's parameters object or None if not specified. ActivityNpvCollection dataclass \u00b6 ActivityNpvCollection ( min_value = 0.0 , max_value = 1.0 , component_type = None , components = list (), skip_raster = False , allowable_max = sys . float_info . max , allowable_min = 0.0 , last_updated = '' , use_manual = False ) Bases: ConstantRasterCollection Collection for all ActivityNpv configurations that have been specified by the user. mappings property writable \u00b6 mappings Get the mapping of activity NPVs. This is a wrapper only used for legacy support. Returns: Type Description typing.List[ActivityNpv] List of activity NPV mappings. activity_npv \u00b6 activity_npv ( activity_identifier ) Gets the mapping of an activity's NPV mapping if defined. Parameters: Name Type Description Default activity_identifier str Unique identifier of an activity whose NPV mapping is to be retrieved. required Returns: Type Description ActivityNpv The activity's NPV mapping else None if not found. Source code in src/cplus_plugin/models/financial.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def activity_npv ( self , activity_identifier : str ) -> typing . Optional [ ActivityNpv ]: \"\"\"Gets the mapping of an activity's NPV mapping if defined. :param activity_identifier: Unique identifier of an activity whose NPV mapping is to be retrieved. :type activity_identifier: str :returns: The activity's NPV mapping else None if not found. :rtype: ActivityNpv \"\"\" matching_mapping = [ activity_npv for activity_npv in self . mappings if activity_npv . activity_id == activity_identifier ] return None if len ( matching_mapping ) == 0 else matching_mapping [ 0 ] normalize \u00b6 normalize () Normalize minimum and maximum values of the valid mappings in the collection. Overrides base class implementation. Source code in src/cplus_plugin/models/financial.py 198 199 200 201 202 203 204 205 def normalize ( self ): \"\"\"Normalize minimum and maximum values of the valid mappings in the collection. Overrides base class implementation. \"\"\" self . update_computed_normalization_range () _ = self . normalize_npvs () normalize_npvs \u00b6 normalize_npvs () Normalize the NPV values of activity using the specified normalization range. If the absolute NPV values are less than or greater than the normalization range, then they will be truncated to 0.0 and 1.0 respectively. To avoid such a situation from occurring, it is recommended to make sure that the ranges are synchronized using the latest absolute NPV values by calling update_computed_normalization_range before normalizing the NPVs. If there is only one NPV mapping, then assign a normalized value of 1.0. Returns: Type Description bool True if the NPVs were successfully normalized else False due to various reasons such as if the minimum value is greater than the maximum value, if the min/max values are the same, or if there are no NPV mappings. Source code in src/cplus_plugin/models/financial.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def normalize_npvs ( self ) -> bool : \"\"\"Normalize the NPV values of activity using the specified normalization range. If the absolute NPV values are less than or greater than the normalization range, then they will be truncated to 0.0 and 1.0 respectively. To avoid such a situation from occurring, it is recommended to make sure that the ranges are synchronized using the latest absolute NPV values by calling `update_computed_normalization_range` before normalizing the NPVs. If there is only one NPV mapping, then assign a normalized value of 1.0. :returns: True if the NPVs were successfully normalized else False due to various reasons such as if the minimum value is greater than the maximum value, if the min/max values are the same, or if there are no NPV mappings. \"\"\" valid_npv_mappings = self . _valid_npv_mappings () if len ( valid_npv_mappings ) == 0 : return False if len ( valid_npv_mappings ) == 1 : activity_npv = self . mappings [ 0 ] activity_npv . params . normalized = 1.0 return True if self . min_value > self . max_value : return False norm_range = float ( self . max_value - self . min_value ) if norm_range == 0.0 : return False for activity_npv in valid_npv_mappings : absolute_npv = activity_npv . params . absolute if not absolute_npv : continue if absolute_npv <= self . min_value : normalized_npv = 0.0 elif absolute_npv >= self . max_value : normalized_npv = 1.0 else : normalized_npv = ( absolute_npv - self . min_value ) / norm_range activity_npv . params . normalized = normalized_npv return True update_computed_normalization_range \u00b6 update_computed_normalization_range () Update the minimum and maximum normalization values based on the absolute values of the existing ActivityNpv objects. Values for disabled activity NPVs will be excluded from the computation. Returns: Type Description bool True if the min/max values were updated else False if there are no mappings or valid absolute NPV values defined. Source code in src/cplus_plugin/models/financial.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def update_computed_normalization_range ( self ) -> bool : \"\"\"Update the minimum and maximum normalization values based on the absolute values of the existing ActivityNpv objects. Values for disabled activity NPVs will be excluded from the computation. :returns: True if the min/max values were updated else False if there are no mappings or valid absolute NPV values defined. \"\"\" if len ( self . mappings ) == 0 : return False valid_npv_values = [ activity_npv . params . absolute for activity_npv in self . _valid_npv_mappings () ] if len ( valid_npv_values ) == 0 : return False self . min_value = min ( valid_npv_values ) self . max_value = max ( valid_npv_values ) return True NpvParameters dataclass \u00b6 NpvParameters ( normalized = 0.0 , absolute = 0.0 , years = 0 , discount = 0.0 , yearly_rates = list (), manual_npv = False ) Bases: ConstantRasterInfo Parameters for computing an activity's NPV. __post_init__ \u00b6 __post_init__ () Ensure yearly_rates has length equal to years. Source code in src/cplus_plugin/models/financial.py 26 27 28 29 30 def __post_init__ ( self ): \"\"\"Ensure yearly_rates has length equal to years.\"\"\" year_diff = self . years - len ( self . yearly_rates ) if year_diff > 0 : self . yearly_rates . extend ([( None , None , None )] * year_diff )","title":"Financials"},{"location":"developer/api/models/api_financials/#financial-data-classes","text":"Data models for the financial elements of the tool.","title":"Financial Data Classes"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpv","text":"ActivityNpv ( value_info = None , component = None , prefix = '' , base_name = '' , suffix = '' , path = '' , skip_raster = False , enabled = True ) Bases: ConstantRasterComponent Mapping of the NPV parameters to the corresponding activity.","title":"ActivityNpv"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpv.activity","text":"activity Wrapper for legacy support returning the activity model. Returns: Type Description Activity The activity if defined else None.","title":"activity"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpv.activity_id","text":"activity_id Gets the identifier of the activity model. Returns: Type Description str The unique identifier of the activity model else an empty string if no activity has been set.","title":"activity_id"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpv.computed_base_name","text":"computed_base_name Returns a proposed name for the activity NPV. An empty string will be return id the activity attribute is not set. Returns: Type Description str Proposed base name for the activity NPV.","title":"computed_base_name"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpv.params","text":"params Wrapper for legacy support returning the activity's parameters object. Returns: Type Description NpvParameters The activity's parameters object or None if not specified.","title":"params"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection","text":"ActivityNpvCollection ( min_value = 0.0 , max_value = 1.0 , component_type = None , components = list (), skip_raster = False , allowable_max = sys . float_info . max , allowable_min = 0.0 , last_updated = '' , use_manual = False ) Bases: ConstantRasterCollection Collection for all ActivityNpv configurations that have been specified by the user.","title":"ActivityNpvCollection"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection.mappings","text":"mappings Get the mapping of activity NPVs. This is a wrapper only used for legacy support. Returns: Type Description typing.List[ActivityNpv] List of activity NPV mappings.","title":"mappings"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection.activity_npv","text":"activity_npv ( activity_identifier ) Gets the mapping of an activity's NPV mapping if defined. Parameters: Name Type Description Default activity_identifier str Unique identifier of an activity whose NPV mapping is to be retrieved. required Returns: Type Description ActivityNpv The activity's NPV mapping else None if not found. Source code in src/cplus_plugin/models/financial.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 def activity_npv ( self , activity_identifier : str ) -> typing . Optional [ ActivityNpv ]: \"\"\"Gets the mapping of an activity's NPV mapping if defined. :param activity_identifier: Unique identifier of an activity whose NPV mapping is to be retrieved. :type activity_identifier: str :returns: The activity's NPV mapping else None if not found. :rtype: ActivityNpv \"\"\" matching_mapping = [ activity_npv for activity_npv in self . mappings if activity_npv . activity_id == activity_identifier ] return None if len ( matching_mapping ) == 0 else matching_mapping [ 0 ]","title":"activity_npv"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection.normalize","text":"normalize () Normalize minimum and maximum values of the valid mappings in the collection. Overrides base class implementation. Source code in src/cplus_plugin/models/financial.py 198 199 200 201 202 203 204 205 def normalize ( self ): \"\"\"Normalize minimum and maximum values of the valid mappings in the collection. Overrides base class implementation. \"\"\" self . update_computed_normalization_range () _ = self . normalize_npvs ()","title":"normalize"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection.normalize_npvs","text":"normalize_npvs () Normalize the NPV values of activity using the specified normalization range. If the absolute NPV values are less than or greater than the normalization range, then they will be truncated to 0.0 and 1.0 respectively. To avoid such a situation from occurring, it is recommended to make sure that the ranges are synchronized using the latest absolute NPV values by calling update_computed_normalization_range before normalizing the NPVs. If there is only one NPV mapping, then assign a normalized value of 1.0. Returns: Type Description bool True if the NPVs were successfully normalized else False due to various reasons such as if the minimum value is greater than the maximum value, if the min/max values are the same, or if there are no NPV mappings. Source code in src/cplus_plugin/models/financial.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def normalize_npvs ( self ) -> bool : \"\"\"Normalize the NPV values of activity using the specified normalization range. If the absolute NPV values are less than or greater than the normalization range, then they will be truncated to 0.0 and 1.0 respectively. To avoid such a situation from occurring, it is recommended to make sure that the ranges are synchronized using the latest absolute NPV values by calling `update_computed_normalization_range` before normalizing the NPVs. If there is only one NPV mapping, then assign a normalized value of 1.0. :returns: True if the NPVs were successfully normalized else False due to various reasons such as if the minimum value is greater than the maximum value, if the min/max values are the same, or if there are no NPV mappings. \"\"\" valid_npv_mappings = self . _valid_npv_mappings () if len ( valid_npv_mappings ) == 0 : return False if len ( valid_npv_mappings ) == 1 : activity_npv = self . mappings [ 0 ] activity_npv . params . normalized = 1.0 return True if self . min_value > self . max_value : return False norm_range = float ( self . max_value - self . min_value ) if norm_range == 0.0 : return False for activity_npv in valid_npv_mappings : absolute_npv = activity_npv . params . absolute if not absolute_npv : continue if absolute_npv <= self . min_value : normalized_npv = 0.0 elif absolute_npv >= self . max_value : normalized_npv = 1.0 else : normalized_npv = ( absolute_npv - self . min_value ) / norm_range activity_npv . params . normalized = normalized_npv return True","title":"normalize_npvs"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.ActivityNpvCollection.update_computed_normalization_range","text":"update_computed_normalization_range () Update the minimum and maximum normalization values based on the absolute values of the existing ActivityNpv objects. Values for disabled activity NPVs will be excluded from the computation. Returns: Type Description bool True if the min/max values were updated else False if there are no mappings or valid absolute NPV values defined. Source code in src/cplus_plugin/models/financial.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def update_computed_normalization_range ( self ) -> bool : \"\"\"Update the minimum and maximum normalization values based on the absolute values of the existing ActivityNpv objects. Values for disabled activity NPVs will be excluded from the computation. :returns: True if the min/max values were updated else False if there are no mappings or valid absolute NPV values defined. \"\"\" if len ( self . mappings ) == 0 : return False valid_npv_values = [ activity_npv . params . absolute for activity_npv in self . _valid_npv_mappings () ] if len ( valid_npv_values ) == 0 : return False self . min_value = min ( valid_npv_values ) self . max_value = max ( valid_npv_values ) return True","title":"update_computed_normalization_range"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.NpvParameters","text":"NpvParameters ( normalized = 0.0 , absolute = 0.0 , years = 0 , discount = 0.0 , yearly_rates = list (), manual_npv = False ) Bases: ConstantRasterInfo Parameters for computing an activity's NPV.","title":"NpvParameters"},{"location":"developer/api/models/api_financials/#src.cplus_plugin.models.financial.NpvParameters.__post_init__","text":"__post_init__ () Ensure yearly_rates has length equal to years. Source code in src/cplus_plugin/models/financial.py 26 27 28 29 30 def __post_init__ ( self ): \"\"\"Ensure yearly_rates has length equal to years.\"\"\" year_diff = self . years - len ( self . yearly_rates ) if year_diff > 0 : self . yearly_rates . extend ([( None , None , None )] * year_diff )","title":"__post_init__"},{"location":"developer/api/models/api_helpers/","text":"Helpers \u00b6 Helper functions for supporting model management. activity_metric_to_dict \u00b6 activity_metric_to_dict ( activity_metric ) Converts an activity column metric to a dictionary representation. Parameters: Name Type Description Default activity_metric ActivityColumnMetric Activity column metric to be serialized to a dictionary. required Returns: Type Description dict A dictionary containing attribute values of an activity column metric. Source code in src/cplus_plugin/models/helpers.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def activity_metric_to_dict ( activity_metric : ActivityColumnMetric ) -> dict : \"\"\"Converts an activity column metric to a dictionary representation. :param activity_metric: Activity column metric to be serialized to a dictionary. :type activity_metric: ActivityColumnMetric :returns: A dictionary containing attribute values of an activity column metric. :rtype: dict \"\"\" return { ACTIVITY_IDENTIFIER_PROPERTY : str ( activity_metric . activity . uuid ), METRIC_IDENTIFIER_PROPERTY : activity_metric . metric_column . name , METRIC_TYPE_ATTRIBUTE : activity_metric . metric_type . value , EXPRESSION_ATTRIBUTE : activity_metric . expression , } activity_npv_collection_to_dict \u00b6 activity_npv_collection_to_dict ( activity_collection ) Converts the activity NPV collection object to the dictionary representation. Parameters: Name Type Description Default activity_collection ActivityNpvCollection Activity collection to serialize to a dictionary. required Returns: Type Description dict A dictionary containing the attribute name-value pairs of an activity NPV collection object Source code in src/cplus_plugin/models/helpers.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 def activity_npv_collection_to_dict ( activity_collection : ActivityNpvCollection , ) -> dict : \"\"\"Converts the activity NPV collection object to the dictionary representation. :param activity_collection: Activity collection to serialize to a dictionary. :type activity_collection: ActivityNpvCollection :returns: A dictionary containing the attribute name-value pairs of an activity NPV collection object :rtype: dict \"\"\" if activity_collection is None : return {} activity_collection_dict = constant_raster_collection_to_dict ( activity_collection ) mapping_dict = list ( map ( activity_npv_to_dict , activity_collection . mappings )) activity_collection_dict [ COMPONENTS_ATTRIBUTE ] = mapping_dict return activity_collection_dict activity_npv_to_dict \u00b6 activity_npv_to_dict ( activity_npv ) Converts an ActivityNpv object to a dictionary representation. Returns: Type Description dict A dictionary containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def activity_npv_to_dict ( activity_npv : ActivityNpv ) -> dict : \"\"\"Converts an ActivityNpv object to a dictionary representation. :returns: A dictionary containing attribute name-value pairs. :rtype: dict \"\"\" # NPV parameters npv_params_dict = constant_raster_info_to_dict ( activity_npv . value_info ) npv_params_dict [ YEARS_ATTRIBUTE ] = activity_npv . params . years npv_params_dict [ DISCOUNT_ATTRIBUTE ] = activity_npv . params . discount npv_params_dict [ YEARLY_RATES_ATTRIBUTE ] = activity_npv . params . yearly_rates npv_params_dict [ MANUAL_NPV_ATTRIBUTE ] = activity_npv . params . manual_npv # Activity NPV raster_component_dict = constant_raster_component_to_dict ( activity_npv ) # Replace value info raster_component_dict [ VALUE_INFO_ATTRIBUTE ] = npv_params_dict return raster_component_dict clone_activity \u00b6 clone_activity ( activity ) Creates a deep copy of the given activity. Parameters: Name Type Description Default activity Activity activity to clone. required Returns: Type Description Activity A deep copy of the original activity object. Source code in src/cplus_plugin/models/helpers.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def clone_activity ( activity : Activity , ) -> Activity : \"\"\"Creates a deep copy of the given activity. :param activity: activity to clone. :type activity: Activity :returns: A deep copy of the original activity object. :rtype: Activity \"\"\" activity = clone_layer_component ( activity , Activity ) if activity is None : return None pathways = activity . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) activity . pathways = cloned_pathways return activity clone_layer_component \u00b6 clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component clone_metric_configuration_profile \u00b6 clone_metric_configuration_profile ( metric_config_profile , referenced_activities ) Creates a deep copy version of the specified metric configuration profile. Parameters: Name Type Description Default metric_config_profile MetricConfigurationProfile Metric configuration profile to be cloned. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration profile. required Returns: Type Description MetricConfigurationProfile Cloned metric configuration profile or None if the input metric configuration profile was invalid. Source code in src/cplus_plugin/models/helpers.py 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 def clone_metric_configuration_profile ( metric_config_profile : MetricConfigurationProfile , referenced_activities : typing . List [ Activity ], ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Creates a deep copy version of the specified metric configuration profile. :param metric_config_profile: Metric configuration profile to be cloned. :type metric_config_profile: MetricConfigurationProfile :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration profile. :type referenced_activities: typing.List[Activity] :returns: Cloned metric configuration profile or None if the input metric configuration profile was invalid. :rtype: MetricConfigurationProfile \"\"\" if not metric_config_profile . is_valid (): return None metric_profile_config_dict = metric_configuration_profile_to_dict ( metric_config_profile ) if not metric_profile_config_dict : return None return create_metric_configuration_profile ( metric_profile_config_dict , referenced_activities ) clone_ncs_pathway \u00b6 clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 388 389 390 391 392 393 394 395 396 397 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway ) constant_raster_collection_from_dict \u00b6 constant_raster_collection_from_dict ( collection_dict , model_components ) Creates a ConstantRasterCollection object from a dictionary. Parameters: Name Type Description Default collection_dict dict Dictionary containing the collection data required model_components List [ LayerModelComponent ] List of LayerModelComponent objects (NcsPathway or Activity) required Returns: Type Description ConstantRasterCollection Constant raster collection object or None if deserialization failed Source code in src/cplus_plugin/models/helpers.py 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def constant_raster_collection_from_dict ( collection_dict : dict , model_components : typing . List [ LayerModelComponent ] ) -> typing . Optional [ \"ConstantRasterCollection\" ]: \"\"\"Creates a ConstantRasterCollection object from a dictionary. :param collection_dict: Dictionary containing the collection data :type collection_dict: dict :param model_components: List of LayerModelComponent objects (NcsPathway or Activity) :type model_components: typing.List[LayerModelComponent] :returns: Constant raster collection object or None if deserialization failed :rtype: ConstantRasterCollection \"\"\" if not collection_dict : return None # Create a lookup function for component access component_lookup_dict = { str ( comp . uuid ): comp for comp in model_components } def component_lookup ( uuid_str : str ) -> typing . Optional [ LayerModelComponent ]: return component_lookup_dict . get ( uuid_str ) # Deserialize components using helper function components = [ create_constant_raster_component ( comp_dict , component_lookup ) for comp_dict in collection_dict . get ( COMPONENTS_ATTRIBUTE , []) ] # Parse component_type if present component_type = None component_type_str = collection_dict . get ( COMPONENT_TYPE_ATTRIBUTE ) if component_type_str : component_type = ModelComponentType . from_string ( component_type_str ) return ConstantRasterCollection ( min_value = collection_dict . get ( MIN_VALUE_ATTRIBUTE_KEY , 0.0 ), max_value = collection_dict . get ( MAX_VALUE_ATTRIBUTE_KEY , 1.0 ), component_type = component_type , components = components , skip_raster = collection_dict . get ( SKIP_RASTER_ATTRIBUTE , False ), allowable_max = collection_dict . get ( ALLOWABLE_MAX_ATTRIBUTE , sys . float_info . max ), allowable_min = collection_dict . get ( ALLOWABLE_MIN_ATTRIBUTE , 0.0 ), last_updated = collection_dict . get ( LAST_UPDATED_ATTRIBUTE , \"\" ), ) constant_raster_collection_to_dict \u00b6 constant_raster_collection_to_dict ( collection ) Serializes a ConstantRasterCollection object into a dictionary. Parameters: Name Type Description Default collection ConstantRasterCollection Constant raster collection object required Returns: Type Description dict Dictionary representation of the collection Source code in src/cplus_plugin/models/helpers.py 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 def constant_raster_collection_to_dict ( collection : \"ConstantRasterCollection\" , ) -> dict : \"\"\"Serializes a ConstantRasterCollection object into a dictionary. :param collection: Constant raster collection object :type collection: ConstantRasterCollection :returns: Dictionary representation of the collection :rtype: dict \"\"\" if collection is None : return {} return { MIN_VALUE_ATTRIBUTE_KEY : collection . min_value , MAX_VALUE_ATTRIBUTE_KEY : collection . max_value , COMPONENT_TYPE_ATTRIBUTE : ( collection . component_type . value if collection . component_type else None ), ALLOWABLE_MIN_ATTRIBUTE : collection . allowable_min , ALLOWABLE_MAX_ATTRIBUTE : collection . allowable_max , SKIP_RASTER_ATTRIBUTE : collection . skip_raster , LAST_UPDATED_ATTRIBUTE : collection . last_updated , COMPONENTS_ATTRIBUTE : [ constant_raster_component_to_dict ( c ) for c in collection . components ], } constant_raster_component_to_dict \u00b6 constant_raster_component_to_dict ( constant_raster_component ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterComponent object. Parameters: Name Type Description Default constant_raster_component ConstantRasterComponent ConstantRasterComponent instance to serialize required Returns: Type Description dict Dictionary representation of the component Source code in src/cplus_plugin/models/helpers.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 def constant_raster_component_to_dict ( constant_raster_component : ConstantRasterComponent , ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterComponent object. :param constant_raster_component: ConstantRasterComponent instance to serialize :type constant_raster_component: ConstantRasterComponent :returns: Dictionary representation of the component :rtype: dict \"\"\" return { VALUE_INFO_ATTRIBUTE : ( constant_raster_info_to_dict ( constant_raster_component . value_info ) if constant_raster_component . value_info else {} ), COMPONENT_UUID_ATTRIBUTE : ( str ( constant_raster_component . component . uuid ) if constant_raster_component . component else \"\" ), PREFIX_ATTRIBUTE : constant_raster_component . prefix , BASE_NAME_ATTRIBUTE : constant_raster_component . base_name , SUFFIX_ATTRIBUTE : constant_raster_component . suffix , PATH_ATTRIBUTE : constant_raster_component . path , SKIP_RASTER_ATTRIBUTE : constant_raster_component . skip_raster , ENABLED_ATTRIBUTE : constant_raster_component . enabled , COMPONENT_ID_ATTRIBUTE : constant_raster_component . component_id , COMPONENT_TYPE_ATTRIBUTE : ( constant_raster_component . component_type . value if constant_raster_component . component_type else ModelComponentType . UNKNOWN . value ), } constant_raster_info_to_dict \u00b6 constant_raster_info_to_dict ( constant_raster_info ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterInfo object. Parameters: Name Type Description Default constant_raster_info ConstantRasterInfo ConstantRasterInfo instance to serialize required Returns: Type Description dict Dictionary with normalized and absolute values Source code in src/cplus_plugin/models/helpers.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 def constant_raster_info_to_dict ( constant_raster_info : ConstantRasterInfo ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterInfo object. :param constant_raster_info: ConstantRasterInfo instance to serialize :type constant_raster_info: ConstantRasterInfo :returns: Dictionary with normalized and absolute values :rtype: dict \"\"\" return { NORMALIZED_ATTRIBUTE : constant_raster_info . normalized , ABSOLUTE_ATTRIBUTE : constant_raster_info . absolute , } constant_raster_metadata_from_dict \u00b6 constant_raster_metadata_from_dict ( metadata_dict , collection_deserializer = None , activities = None ) Creates a constant raster metadata object from the dictionary representation. Parameters: Name Type Description Default metadata_dict dict Dictionary representation of the metadata object. required collection_deserializer Callable Callable for deserializing. If not specified, the raster collection will be None. None activities List [ Activity ] List of activities to lookup and link to constant raster component. None Returns: Type Description ConstantRasterMetadata Constant raster metadata object or None if the dictionary is empty. Source code in src/cplus_plugin/models/helpers.py 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 def constant_raster_metadata_from_dict ( metadata_dict , collection_deserializer : typing . Callable = None , activities : typing . List [ Activity ] = None , ) -> typing . Optional [ ConstantRasterMetadata ]: \"\"\"Creates a constant raster metadata object from the dictionary representation. :param metadata_dict: Dictionary representation of the metadata object. :type metadata_dict: dict :param collection_deserializer: Callable for deserializing. If not specified, the raster collection will be None. :type collection_deserializer: typing.Callable :param activities: List of activities to lookup and link to constant raster component. :type activities: typing.List[Activity] :returns: Constant raster metadata object or None if the dictionary is empty. :rtype: ConstantRasterMetadata \"\"\" if not metadata_dict : return None kwargs = {} if ID_ATTRIBUTE in metadata_dict : kwargs [ ID_ATTRIBUTE ] = metadata_dict [ ID_ATTRIBUTE ] if DISPLAY_NAME_ATTRIBUTE in metadata_dict : kwargs [ DISPLAY_NAME_ATTRIBUTE ] = metadata_dict [ DISPLAY_NAME_ATTRIBUTE ] if USER_DEFINED_ATTRIBUTE in metadata_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = metadata_dict [ USER_DEFINED_ATTRIBUTE ] if COMPONENT_TYPE_ATTRIBUTE in metadata_dict : kwargs [ COMPONENT_TYPE_ATTRIBUTE ] = ModelComponentType . from_string ( metadata_dict [ COMPONENT_TYPE_ATTRIBUTE ] ) raster_collection = None if RASTER_COLLECTION_ATTRIBUTE in metadata_dict and collection_deserializer : raster_collection = collection_deserializer ( metadata_dict [ RASTER_COLLECTION_ATTRIBUTE ], activities ) kwargs [ RASTER_COLLECTION_ATTRIBUTE ] = raster_collection return ConstantRasterMetadata ( ** kwargs ) constant_raster_metadata_to_dict \u00b6 constant_raster_metadata_to_dict ( metadata , collection_serializer = None ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterMetadata object. Parameters: Name Type Description Default metadata ConstantRasterMetadata ConstantRasterMetadata instance to serialize required collection_serializer Callable Callable for serializing. If not specified, an empty dictionary will be used. None Returns: Type Description dict Dictionary representation of the metadata Source code in src/cplus_plugin/models/helpers.py 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def constant_raster_metadata_to_dict ( metadata : ConstantRasterMetadata , collection_serializer : typing . Callable = None ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterMetadata object. :param metadata: ConstantRasterMetadata instance to serialize :type metadata: ConstantRasterMetadata :param collection_serializer: Callable for serializing. If not specified, an empty dictionary will be used. :type collection_serializer: typing.Callable :returns: Dictionary representation of the metadata :rtype: dict \"\"\" collection_dict = ( collection_serializer ( metadata . raster_collection ) if collection_serializer else {} ) return { ID_ATTRIBUTE : metadata . id , DISPLAY_NAME_ATTRIBUTE : metadata . display_name , RASTER_COLLECTION_ATTRIBUTE : collection_dict , COMPONENT_TYPE_ATTRIBUTE : ( metadata . component_type . value if metadata . component_type else None ), USER_DEFINED_ATTRIBUTE : metadata . user_defined , } copy_layer_component_attributes \u00b6 copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target create_activity \u00b6 create_activity ( source_dict ) Factory method for creating an activity using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description Activity activity with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def create_activity ( source_dict ) -> typing . Union [ Activity , None ]: \"\"\"Factory method for creating an activity using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: activity with property values set from the dictionary. :rtype: Activity \"\"\" activity = create_layer_component ( source_dict , Activity ) if MASK_PATHS_SEGMENT in source_dict . keys (): activity . mask_paths = source_dict [ MASK_PATHS_SEGMENT ] # Set style if STYLE_ATTRIBUTE in source_dict . keys (): activity . layer_styles = source_dict [ STYLE_ATTRIBUTE ] # Set styling pixel value if PIXEL_VALUE_ATTRIBUTE in source_dict . keys (): activity . style_pixel_value = source_dict [ PIXEL_VALUE_ATTRIBUTE ] return activity create_activity_metric \u00b6 create_activity_metric ( activity_metric_dict , activity , metric_column ) Creates a metric column from the equivalent dictionary representation. Parameters: Name Type Description Default activity_metric_dict dict Dictionary containing information for deserializing the dict to a metric column. required activity Activity Referenced activity matching the saved UUID. required metric_column MetricColumn Referenced metric column matching the saved name. required Returns: Type Description MetricColumn Metric column object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def create_activity_metric ( activity_metric_dict : dict , activity : Activity , metric_column : MetricColumn ) -> typing . Optional [ ActivityColumnMetric ]: \"\"\"Creates a metric column from the equivalent dictionary representation. :param activity_metric_dict: Dictionary containing information for deserializing the dict to a metric column. :type activity_metric_dict: dict :param activity: Referenced activity matching the saved UUID. :type activity: str :param metric_column: Referenced metric column matching the saved name. :type metric_column: MetricColumn :returns: Metric column object or None if the deserialization failed. :rtype: MetricColumn \"\"\" return ActivityColumnMetric ( activity , metric_column , MetricType . from_int ( activity_metric_dict [ METRIC_TYPE_ATTRIBUTE ]), activity_metric_dict [ EXPRESSION_ATTRIBUTE ], ) create_activity_npv \u00b6 create_activity_npv ( activity_npv_dict ) Creates an ActivityNpv object from the equivalent dictionary representation. Please note that the activity attribute will be None hence, will have to be set manually by extracting the corresponding Activity from the activity UUID. Parameters: Name Type Description Default activity_npv_dict dict Dictionary containing information for deserializing the ActivityNpv object. required Returns: Type Description ActivityNpv ActivityNpv deserialized from the dictionary representation. Source code in src/cplus_plugin/models/helpers.py 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 def create_activity_npv ( activity_npv_dict : dict ) -> typing . Optional [ ActivityNpv ]: \"\"\"Creates an ActivityNpv object from the equivalent dictionary representation. Please note that the `activity` attribute will be `None` hence, will have to be set manually by extracting the corresponding `Activity` from the activity UUID. :param activity_npv_dict: Dictionary containing information for deserializing the ActivityNpv object. :type activity_npv_dict: dict :returns: ActivityNpv deserialized from the dictionary representation. :rtype: ActivityNpv \"\"\" kwargs = {} npv_params = None if VALUE_INFO_ATTRIBUTE in activity_npv_dict : npv_params_dict = activity_npv_dict [ VALUE_INFO_ATTRIBUTE ] # Create base constant raster info constant_raster_info = create_constant_raster_info ( npv_params_dict ) kwargs = asdict ( constant_raster_info ) if YEARS_ATTRIBUTE in npv_params_dict : kwargs [ YEARS_ATTRIBUTE ] = npv_params_dict [ YEARS_ATTRIBUTE ] if DISCOUNT_ATTRIBUTE in npv_params_dict : kwargs [ DISCOUNT_ATTRIBUTE ] = npv_params_dict [ DISCOUNT_ATTRIBUTE ] if ABSOLUTE_NPV_ATTRIBUTE in npv_params_dict : kwargs [ ABSOLUTE_NPV_ATTRIBUTE ] = npv_params_dict [ ABSOLUTE_NPV_ATTRIBUTE ] if NORMALIZED_NPV_ATTRIBUTE in npv_params_dict : kwargs [ NORMALIZED_NPV_ATTRIBUTE ] = npv_params_dict [ NORMALIZED_NPV_ATTRIBUTE ] if MANUAL_NPV_ATTRIBUTE in npv_params_dict : kwargs [ MANUAL_NPV_ATTRIBUTE ] = npv_params_dict [ MANUAL_NPV_ATTRIBUTE ] if YEARLY_RATES_ATTRIBUTE in npv_params_dict : kwargs [ YEARLY_RATES_ATTRIBUTE ] = npv_params_dict [ YEARLY_RATES_ATTRIBUTE ] npv_params = NpvParameters ( ** kwargs ) constant_raster_component = create_constant_raster_component ( activity_npv_dict ) npv_kwargs = asdict ( constant_raster_component ) npv_kwargs [ VALUE_INFO_ATTRIBUTE ] = npv_params return ActivityNpv ( ** npv_kwargs ) create_activity_npv_collection \u00b6 create_activity_npv_collection ( activity_collection_dict , reference_activities = None ) Creates an activity NPV collection object from the corresponding dictionary representation. Parameters: Name Type Description Default activity_collection_dict dict Dictionary representation containing information of an activity NPV collection object. required reference_activities List [ Activity ] Optional list of activities that will be used to lookup when deserializing the ActivityNpv objects. None Returns: Type Description ActivityNpvCollection Activity NPV collection object from the dictionary representation or None if the source dictionary is invalid. Source code in src/cplus_plugin/models/helpers.py 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 def create_activity_npv_collection ( activity_collection_dict : dict , reference_activities : typing . List [ Activity ] = None ) -> typing . Optional [ ActivityNpvCollection ]: \"\"\"Creates an activity NPV collection object from the corresponding dictionary representation. :param activity_collection_dict: Dictionary representation containing information of an activity NPV collection object. :type activity_collection_dict: dict :param reference_activities: Optional list of activities that will be used to lookup when deserializing the ActivityNpv objects. :type reference_activities: list :returns: Activity NPV collection object from the dictionary representation or None if the source dictionary is invalid. :rtype: ActivityNpvCollection \"\"\" if not activity_collection_dict : return None ref_activities_by_uuid = { str ( activity . uuid ): activity for activity in reference_activities } raster_collection = constant_raster_collection_from_dict ( activity_collection_dict , reference_activities ) kwargs = asdict ( raster_collection ) if COMPONENTS_ATTRIBUTE in activity_collection_dict : mappings_dict = activity_collection_dict [ COMPONENTS_ATTRIBUTE ] npv_mappings = [] for md in mappings_dict : activity_npv = create_activity_npv ( md ) if activity_npv is None : continue # Get the corresponding activity from the unique # identifier if COMPONENT_ID_ATTRIBUTE in md : activity_id = md [ COMPONENT_ID_ATTRIBUTE ] if activity_id in ref_activities_by_uuid : activity = ref_activities_by_uuid [ activity_id ] activity_npv . activity = activity npv_mappings . append ( activity_npv ) kwargs [ COMPONENTS_ATTRIBUTE ] = npv_mappings return ActivityNpvCollection ( ** kwargs ) create_constant_raster_component \u00b6 create_constant_raster_component ( source_dict , component_lookup = None ) Factory method for creating a ConstantRasterComponent from dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values required component_lookup Callable [[ str ], LayerModelComponent ] Function to retrieve LayerModelComponent by UUID None Returns: Type Description ConstantRasterComponent ConstantRasterComponent instance with values from dictionary Source code in src/cplus_plugin/models/helpers.py 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def create_constant_raster_component ( source_dict : dict , component_lookup : typing . Callable [[ str ], LayerModelComponent ] = None , ) -> ConstantRasterComponent : \"\"\"Factory method for creating a ConstantRasterComponent from dictionary. :param source_dict: Dictionary containing property values :type source_dict: dict :param component_lookup: Function to retrieve LayerModelComponent by UUID :type component_lookup: Callable :returns: ConstantRasterComponent instance with values from dictionary :rtype: ConstantRasterComponent \"\"\" component = None component_uuid = source_dict . get ( COMPONENT_UUID_ATTRIBUTE ) if component_uuid and component_lookup : component = component_lookup ( component_uuid ) value_info_data = source_dict . get ( VALUE_INFO_ATTRIBUTE , {}) value_info = ( create_constant_raster_info ( value_info_data ) if value_info_data else ConstantRasterInfo () ) return ConstantRasterComponent ( value_info = value_info , component = component , prefix = source_dict . get ( PREFIX_ATTRIBUTE , \"\" ), base_name = source_dict . get ( BASE_NAME_ATTRIBUTE , \"\" ), suffix = source_dict . get ( SUFFIX_ATTRIBUTE , \"\" ), path = source_dict . get ( PATH_ATTRIBUTE , \"\" ), skip_raster = bool ( source_dict . get ( SKIP_RASTER_ATTRIBUTE , False )), enabled = bool ( source_dict . get ( ENABLED_ATTRIBUTE , True )), ) create_constant_raster_info \u00b6 create_constant_raster_info ( source_dict ) Factory method for creating a ConstantRasterInfo object from dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values required Returns: Type Description ConstantRasterInfo ConstantRasterInfo instance with values from dictionary Source code in src/cplus_plugin/models/helpers.py 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 def create_constant_raster_info ( source_dict : dict ) -> ConstantRasterInfo : \"\"\"Factory method for creating a ConstantRasterInfo object from dictionary. :param source_dict: Dictionary containing property values :type source_dict: dict :returns: ConstantRasterInfo instance with values from dictionary :rtype: ConstantRasterInfo \"\"\" return ConstantRasterInfo ( normalized = float ( source_dict . get ( NORMALIZED_ATTRIBUTE , 0.0 )), absolute = float ( source_dict . get ( ABSOLUTE_ATTRIBUTE , 0.0 )), ) create_layer_component \u00b6 create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs , ) create_metric_column \u00b6 create_metric_column ( metric_column_dict ) Creates a metric column from the equivalent dictionary representation. Parameters: Name Type Description Default metric_column_dict dict Dictionary containing information for deserializing the dict to a metric column. required Returns: Type Description MetricColumn Metric column object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def create_metric_column ( metric_column_dict : dict ) -> typing . Optional [ MetricColumn ]: \"\"\"Creates a metric column from the equivalent dictionary representation. :param metric_column_dict: Dictionary containing information for deserializing the dict to a metric column. :type metric_column_dict: dict :returns: Metric column object or None if the deserialization failed. :rtype: MetricColumn \"\"\" number_formatter = QgsApplication . numericFormatRegistry () . create ( metric_column_dict [ NUMBER_FORMATTER_ID_ATTRIBUTE ], metric_column_dict [ NUMBER_FORMATTER_PROPS_ATTRIBUTE ], QgsReadWriteContext (), ) return MetricColumn ( metric_column_dict [ NAME_ATTRIBUTE ], metric_column_dict [ HEADER_ATTRIBUTE ], metric_column_dict [ EXPRESSION_ATTRIBUTE ], metric_column_dict [ ALIGNMENT_ATTRIBUTE ], metric_column_dict [ AUTO_CALCULATED_ATTRIBUTE ], metric_column_dict [ NUMBER_FORMATTER_ENABLED_ATTRIBUTE ], number_formatter , ) create_metric_configuration \u00b6 create_metric_configuration ( metric_configuration_dict , referenced_activities ) Creates a metric configuration from the equivalent dictionary representation. Parameters: Name Type Description Default metric_configuration_dict dict Dictionary containing information for deserializing a metric configuration object. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration. required Returns: Type Description MetricConfiguration Metric configuration object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def create_metric_configuration ( metric_configuration_dict : dict , referenced_activities : typing . List [ Activity ] ) -> typing . Optional [ MetricConfiguration ]: \"\"\"Creates a metric configuration from the equivalent dictionary representation. :param metric_configuration_dict: Dictionary containing information for deserializing a metric configuration object. :type metric_configuration_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration. :type referenced_activities: typing.List[Activity] :returns: Metric configuration object or None if the deserialization failed. :rtype: MetricConfiguration \"\"\" if len ( metric_configuration_dict ) == 0 : return None metric_column_dicts = metric_configuration_dict [ METRIC_COLUMNS_PROPERTY ] metric_columns = [ create_metric_column ( mc_dict ) for mc_dict in metric_column_dicts ] indexed_metric_columns = { mc . name : mc for mc in metric_columns } indexed_activities = { str ( activity . uuid ): activity for activity in referenced_activities } activity_column_metrics = [] activity_column_metric_dicts = metric_configuration_dict [ ACTIVITY_METRICS_PROPERTY ] for activity_row_dict in activity_column_metric_dicts : if len ( activity_row_dict ) == 0 : continue # Check if the activity exists activity_id = activity_row_dict [ 0 ][ ACTIVITY_IDENTIFIER_PROPERTY ] if activity_id not in indexed_activities : # Most likely the activity in the metric config has been deleted continue activity_row_metrics = [] for activity_metric_dict in activity_row_dict : name = activity_metric_dict [ METRIC_IDENTIFIER_PROPERTY ] activity = indexed_activities [ activity_id ] metric_column = indexed_metric_columns [ name ] activity_row_metrics . append ( create_activity_metric ( activity_metric_dict , activity , metric_column ) ) activity_column_metrics . append ( activity_row_metrics ) return MetricConfiguration ( metric_columns , activity_column_metrics ) create_metric_configuration_profile \u00b6 create_metric_configuration_profile ( metric_configuration_profile_dict , referenced_activities ) Creates a metric configuration profile from the equivalent dictionary representation. Parameters: Name Type Description Default metric_configuration_profile_dict dict Dictionary containing information for deserializing a metric configuration profile. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration profile. required Returns: Type Description MetricConfiguration Metric configuration profile object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 def create_metric_configuration_profile ( metric_configuration_profile_dict : dict , referenced_activities : typing . List [ Activity ], ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Creates a metric configuration profile from the equivalent dictionary representation. :param metric_configuration_profile_dict: Dictionary containing information for deserializing a metric configuration profile. :type metric_configuration_profile_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration profile. :type referenced_activities: typing.List[Activity] :returns: Metric configuration profile object or None if the deserialization failed. :rtype: MetricConfiguration \"\"\" if not metric_configuration_profile_dict : return None if NAME_ATTRIBUTE not in metric_configuration_profile_dict : return None if METRIC_CONFIGURATION_PROPERTY not in metric_configuration_profile_dict : return None name = metric_configuration_profile_dict [ NAME_ATTRIBUTE ] config = create_metric_configuration ( metric_configuration_profile_dict [ METRIC_CONFIGURATION_PROPERTY ], referenced_activities , ) if config is None : return None return MetricConfigurationProfile ( name , config ) create_metrics_profile_collection \u00b6 create_metrics_profile_collection ( metric_profile_collection_dict , referenced_activities ) Deserializes a metric profile collection from the equivalent dictionary representation. Parameters: Name Type Description Default metric_profile_collection_dict dict Dictionary containing information about the profile collection. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration objects that correspond to the respective profiles. required Returns: Type Description MetricProfileCollection Metric profile configuration object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 def create_metrics_profile_collection ( metric_profile_collection_dict , referenced_activities : typing . List [ Activity ] ) -> typing . Optional [ MetricProfileCollection ]: \"\"\"Deserializes a metric profile collection from the equivalent dictionary representation. :param metric_profile_collection_dict: Dictionary containing information about the profile collection. :type metric_profile_collection_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration objects that correspond to the respective profiles. :type referenced_activities: typing.List[Activity] :returns: Metric profile configuration object or None if the deserialization failed. :rtype: MetricProfileCollection \"\"\" if not metric_profile_collection_dict : return None if PROFILES_ATTRIBUTE not in metric_profile_collection_dict : return None current_profile_id = metric_profile_collection_dict . get ( CURRENT_PROFILE_PROPERTY , \"\" ) metric_profiles = [] for profile_dict in metric_profile_collection_dict [ PROFILES_ATTRIBUTE ]: profile = create_metric_configuration_profile ( profile_dict , referenced_activities ) if profile is None : continue metric_profiles . append ( profile ) return MetricProfileCollection ( current_profile_id , metric_profiles ) create_model_component \u00b6 create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ) create_ncs_pathway \u00b6 create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if PATHWAY_TYPE_ATTRIBUTE in source_dict : ncs . pathway_type = NcsPathwayType . from_int ( source_dict [ PATHWAY_TYPE_ATTRIBUTE ]) else : # Assign undefined ncs . pathway_type = NcsPathwayType . UNDEFINED if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): ncs . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] if PATHWAY_TYPE_OPTIONS_ATTRIBUTE in source_dict : ncs . type_options = source_dict [ PATHWAY_TYPE_OPTIONS_ATTRIBUTE ] if PATHWAY_SUITABILITY_INDEX_ATTRIBUTE in source_dict : ncs . suitability_index = source_dict [ PATHWAY_SUITABILITY_INDEX_ATTRIBUTE ] return ncs create_result_info \u00b6 create_result_info ( result_info_dict ) Creates a ResultInfo object from the dictionary representation. Parameters: Name Type Description Default result_info_dict dict Representation of ResultInfo object. required Returns: Type Description ResultInfo A representation of the result info or None if there is missing information in the dictionary. Source code in src/cplus_plugin/models/helpers.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 def create_result_info ( result_info_dict : dict ) -> typing . Optional [ ResultInfo ]: \"\"\"Creates a ResultInfo object from the dictionary representation. :param result_info_dict: Representation of ResultInfo object. :type result_info_dict: dict :returns: A representation of the result info or None if there is missing information in the dictionary. :rtype: ResultInfo \"\"\" args = [] if RESULT_COLLECTION_ATTRIBUTE in result_info_dict : args . append ( result_info_dict . get ( RESULT_COLLECTION_ATTRIBUTE )) if LAST_UPDATED_DATE_ATTRIBUTE in result_info_dict : args . append ( result_info_dict . get ( LAST_UPDATED_DATE_ATTRIBUTE )) if len ( args ) < 2 : return None return ResultInfo ( * args ) extent_to_project_crs_extent \u00b6 extent_to_project_crs_extent ( spatial_extent , project = None , source_crs = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None source_crs QgsCoordinateReferenceSystem Specify a source CRS to use for the transformation otherwise it will revert to the default which is WGS84. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None , source_crs : QgsCoordinateReferenceSystem = None , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :param source_crs: Specify a source CRS to use for the transformation otherwise it will revert to the default which is WGS84. :type source_crs: QgsCoordinateReferenceSystem :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = source_crs or QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect try : coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect ) except Exception as e : log ( f \" { e } , using the default input extent.\" ) return input_rect extent_to_qgs_rectangle \u00b6 extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], ) extent_to_url_param \u00b6 extent_to_url_param ( rect_extent ) Converts the bounding box in a QgsRectangle object to the equivalent param for use in a URL. 'bbox' is appended as a prefix in the URL query part. Parameters: Name Type Description Default rect_extent QgsRectangle Spatial extent that defines the AOI. required Returns: Type Description str String representing the param defining the extents of the AOI. If the extent is empty, it will return an empty string. Source code in src/cplus_plugin/models/helpers.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def extent_to_url_param ( rect_extent : QgsRectangle ) -> str : \"\"\"Converts the bounding box in a QgsRectangle object to the equivalent param for use in a URL. 'bbox' is appended as a prefix in the URL query part. :param rect_extent: Spatial extent that defines the AOI. :type rect_extent: QgsRectangle :returns: String representing the param defining the extents of the AOI. If the extent is empty, it will return an empty string. :rtype: str \"\"\" if rect_extent . isEmpty (): return \"\" url_query = QtCore . QUrlQuery () url_query . addQueryItem ( \"bbox\" , f \" { rect_extent . xMinimum () !s} , { rect_extent . yMinimum () !s} , { rect_extent . xMaximum () !s} , { rect_extent . yMaximum () !s} \" , ) return url_query . toString () layer_component_to_dict \u00b6 layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path try : base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) except TypeError : if base_attrs [ \"path\" ] . endswith ( \".tif\" ): base_attrs [ LAYER_TYPE_ATTRIBUTE ] = 0 elif base_attrs [ \"path\" ] . endswith ( \".shp\" ): base_attrs [ LAYER_TYPE_ATTRIBUTE ] = 1 base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs layer_from_scenario_result \u00b6 layer_from_scenario_result ( result ) Gets the scenario output layer from the results of the analysis. Returns: Type Description QgsRasterLayer Raster layer corresponding to the output scenario path or None if the file does not exist or if the raster layer is invalid. Source code in src/cplus_plugin/models/helpers.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 def layer_from_scenario_result ( result : ScenarioResult , ) -> typing . Optional [ QgsRasterLayer ]: \"\"\"Gets the scenario output layer from the results of the analysis. :returns: Raster layer corresponding to the output scenario path or None if the file does not exist or if the raster layer is invalid. :rtype: QgsRasterLayer \"\"\" layer_file = result . analysis_output . get ( \"OUTPUT\" ) layer = QgsRasterLayer ( layer_file , result . scenario . name , QGIS_GDAL_PROVIDER ) if not layer . isValid (): return None return layer metric_column_to_dict \u00b6 metric_column_to_dict ( metric_column ) Converts a metric column object to a dictionary representation. Parameters: Name Type Description Default metric_column MetricColumn Metric column to be serialized to a dictionary. required Returns: Type Description dict A dictionary containing attribute values of a metric column. Source code in src/cplus_plugin/models/helpers.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def metric_column_to_dict ( metric_column : MetricColumn ) -> dict : \"\"\"Converts a metric column object to a dictionary representation. :param metric_column: Metric column to be serialized to a dictionary. :type metric_column: MetricColumn :returns: A dictionary containing attribute values of a metric column. :rtype: dict \"\"\" formatter_props = metric_column . number_formatter . configuration ( QgsReadWriteContext () ) formatter_id = metric_column . number_formatter . id () if formatter_id == \"default\" : formatter_props = {} return { NAME_ATTRIBUTE : metric_column . name , HEADER_ATTRIBUTE : metric_column . header , EXPRESSION_ATTRIBUTE : metric_column . expression , ALIGNMENT_ATTRIBUTE : metric_column . alignment , AUTO_CALCULATED_ATTRIBUTE : metric_column . auto_calculated , NUMBER_FORMATTER_ENABLED_ATTRIBUTE : metric_column . format_as_number , NUMBER_FORMATTER_ID_ATTRIBUTE : formatter_id , NUMBER_FORMATTER_PROPS_ATTRIBUTE : formatter_props , } metric_configuration_profile_to_dict \u00b6 metric_configuration_profile_to_dict ( metric_config_profile ) Serializes a metric configuration profile to a dictionary. Parameters: Name Type Description Default metric_config_profile MetricConfigurationProfile Metric configuration profile to be serialized. required Returns: Type Description dict A dictionary representing a metric configuration profile. Source code in src/cplus_plugin/models/helpers.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def metric_configuration_profile_to_dict ( metric_config_profile : MetricConfigurationProfile , ) -> dict : \"\"\"Serializes a metric configuration profile to a dictionary. :param metric_config_profile: Metric configuration profile to be serialized. :type metric_config_profile: MetricConfigurationProfile :returns: A dictionary representing a metric configuration profile. :rtype: dict \"\"\" return { NAME_ATTRIBUTE : metric_config_profile . name , METRIC_CONFIGURATION_PROPERTY : metric_configuration_to_dict ( metric_config_profile . config ), } metric_configuration_to_dict \u00b6 metric_configuration_to_dict ( metric_configuration ) Serializes a metric configuration to dict. Parameters: Name Type Description Default metric_configuration MetricConfiguration Metric configuration to tbe serialized. required Returns: Type Description dict A dictionary representing a metric configuration. Source code in src/cplus_plugin/models/helpers.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 def metric_configuration_to_dict ( metric_configuration : MetricConfiguration ) -> dict : \"\"\"Serializes a metric configuration to dict. :param metric_configuration: Metric configuration to tbe serialized. :type metric_configuration: MetricConfiguration :returns: A dictionary representing a metric configuration. :rtype: dict \"\"\" metric_config_dict = {} metric_column_dicts = [ metric_column_to_dict ( mc ) for mc in metric_configuration . metric_columns ] metric_config_dict [ METRIC_COLUMNS_PROPERTY ] = metric_column_dicts activity_column_metrics = [] for activity_columns in metric_configuration . activity_metrics : column_metrics = [] for activity_column_metric in activity_columns : column_metrics . append ( activity_metric_to_dict ( activity_column_metric )) activity_column_metrics . append ( column_metrics ) metric_config_dict [ ACTIVITY_METRICS_PROPERTY ] = activity_column_metrics activity_identifiers = [ str ( activity . uuid ) for activity in metric_configuration . activities ] metric_config_dict [ MULTI_ACTIVITY_IDENTIFIER_PROPERTY ] = activity_identifiers return metric_config_dict metric_profile_collection_to_dict \u00b6 metric_profile_collection_to_dict ( metric_profile_collection ) Serializes a metric configuration profile to a dictionary. Parameters: Name Type Description Default metric_profile_collection MetricProfileCollection Metric profile collection to be serialized. required Returns: Type Description dict A dictionary representing a metric profile collection. Source code in src/cplus_plugin/models/helpers.py 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 def metric_profile_collection_to_dict ( metric_profile_collection : MetricProfileCollection , ) -> dict : \"\"\"Serializes a metric configuration profile to a dictionary. :param metric_profile_collection: Metric profile collection to be serialized. :type metric_profile_collection: MetricProfileCollection :returns: A dictionary representing a metric profile collection. :rtype: dict \"\"\" return { CURRENT_PROFILE_PROPERTY : metric_profile_collection . current_profile , PROFILES_ATTRIBUTE : [ metric_configuration_profile_to_dict ( mp ) for mp in metric_profile_collection . profiles ], } model_component_to_dict \u00b6 model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , } ncs_pathway_to_dict \u00b6 ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ PATHWAY_TYPE_ATTRIBUTE ] = ncs_pathway . pathway_type base_ncs_dict [ PRIORITY_LAYERS_SEGMENT ] = ncs_pathway . priority_layers base_ncs_dict [ PATHWAY_TYPE_OPTIONS_ATTRIBUTE ] = ncs_pathway . type_options base_ncs_dict [ PATHWAY_SUITABILITY_INDEX_ATTRIBUTE ] = ncs_pathway . suitability_index return base_ncs_dict result_info_to_dict \u00b6 result_info_to_dict ( result_info ) Serializes a ResultInfo object to a dictionary. The result collection should contain simple types that can be decoded to string by the json library. Parameters: Name Type Description Default result_info ResultInfo Result info object to serialize. required Returns: Type Description dict A dictionary representation of the ResultInfo object. Source code in src/cplus_plugin/models/helpers.py 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 def result_info_to_dict ( result_info : ResultInfo ) -> dict : \"\"\"Serializes a ResultInfo object to a dictionary. The result collection should contain simple types that can be decoded to string by the `json` library. :param result_info: Result info object to serialize. :type result_info: ResultInfo :returns: A dictionary representation of the ResultInfo object. :rtype: dict \"\"\" return { RESULT_COLLECTION_ATTRIBUTE : result_info . result_collection , LAST_UPDATED_DATE_ATTRIBUTE : result_info . updated_date , }","title":"Helpers"},{"location":"developer/api/models/api_helpers/#helpers","text":"Helper functions for supporting model management.","title":"Helpers"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.activity_metric_to_dict","text":"activity_metric_to_dict ( activity_metric ) Converts an activity column metric to a dictionary representation. Parameters: Name Type Description Default activity_metric ActivityColumnMetric Activity column metric to be serialized to a dictionary. required Returns: Type Description dict A dictionary containing attribute values of an activity column metric. Source code in src/cplus_plugin/models/helpers.py 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 def activity_metric_to_dict ( activity_metric : ActivityColumnMetric ) -> dict : \"\"\"Converts an activity column metric to a dictionary representation. :param activity_metric: Activity column metric to be serialized to a dictionary. :type activity_metric: ActivityColumnMetric :returns: A dictionary containing attribute values of an activity column metric. :rtype: dict \"\"\" return { ACTIVITY_IDENTIFIER_PROPERTY : str ( activity_metric . activity . uuid ), METRIC_IDENTIFIER_PROPERTY : activity_metric . metric_column . name , METRIC_TYPE_ATTRIBUTE : activity_metric . metric_type . value , EXPRESSION_ATTRIBUTE : activity_metric . expression , }","title":"activity_metric_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.activity_npv_collection_to_dict","text":"activity_npv_collection_to_dict ( activity_collection ) Converts the activity NPV collection object to the dictionary representation. Parameters: Name Type Description Default activity_collection ActivityNpvCollection Activity collection to serialize to a dictionary. required Returns: Type Description dict A dictionary containing the attribute name-value pairs of an activity NPV collection object Source code in src/cplus_plugin/models/helpers.py 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 def activity_npv_collection_to_dict ( activity_collection : ActivityNpvCollection , ) -> dict : \"\"\"Converts the activity NPV collection object to the dictionary representation. :param activity_collection: Activity collection to serialize to a dictionary. :type activity_collection: ActivityNpvCollection :returns: A dictionary containing the attribute name-value pairs of an activity NPV collection object :rtype: dict \"\"\" if activity_collection is None : return {} activity_collection_dict = constant_raster_collection_to_dict ( activity_collection ) mapping_dict = list ( map ( activity_npv_to_dict , activity_collection . mappings )) activity_collection_dict [ COMPONENTS_ATTRIBUTE ] = mapping_dict return activity_collection_dict","title":"activity_npv_collection_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.activity_npv_to_dict","text":"activity_npv_to_dict ( activity_npv ) Converts an ActivityNpv object to a dictionary representation. Returns: Type Description dict A dictionary containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 def activity_npv_to_dict ( activity_npv : ActivityNpv ) -> dict : \"\"\"Converts an ActivityNpv object to a dictionary representation. :returns: A dictionary containing attribute name-value pairs. :rtype: dict \"\"\" # NPV parameters npv_params_dict = constant_raster_info_to_dict ( activity_npv . value_info ) npv_params_dict [ YEARS_ATTRIBUTE ] = activity_npv . params . years npv_params_dict [ DISCOUNT_ATTRIBUTE ] = activity_npv . params . discount npv_params_dict [ YEARLY_RATES_ATTRIBUTE ] = activity_npv . params . yearly_rates npv_params_dict [ MANUAL_NPV_ATTRIBUTE ] = activity_npv . params . manual_npv # Activity NPV raster_component_dict = constant_raster_component_to_dict ( activity_npv ) # Replace value info raster_component_dict [ VALUE_INFO_ATTRIBUTE ] = npv_params_dict return raster_component_dict","title":"activity_npv_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_activity","text":"clone_activity ( activity ) Creates a deep copy of the given activity. Parameters: Name Type Description Default activity Activity activity to clone. required Returns: Type Description Activity A deep copy of the original activity object. Source code in src/cplus_plugin/models/helpers.py 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def clone_activity ( activity : Activity , ) -> Activity : \"\"\"Creates a deep copy of the given activity. :param activity: activity to clone. :type activity: Activity :returns: A deep copy of the original activity object. :rtype: Activity \"\"\" activity = clone_layer_component ( activity , Activity ) if activity is None : return None pathways = activity . pathways cloned_pathways = [] for p in pathways : cloned_ncs = clone_ncs_pathway ( p ) if cloned_ncs is not None : cloned_pathways . append ( cloned_ncs ) activity . pathways = cloned_pathways return activity","title":"clone_activity"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_layer_component","text":"clone_layer_component ( layer_component , model_cls ) Clones a layer-based model component. Parameters: Name Type Description Default layer_component LayerModelComponent Layer-based model component to clone. required model_cls Callable [[ UUID , str , str ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent A new instance of the cloned model component. It will return None if the input is not a layer-based model component. Source code in src/cplus_plugin/models/helpers.py 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 def clone_layer_component ( layer_component : LayerModelComponent , model_cls : typing . Callable [[ uuid . UUID , str , str ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Clones a layer-based model component. :param layer_component: Layer-based model component to clone. :type layer_component: LayerModelComponent :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: A new instance of the cloned model component. It will return None if the input is not a layer-based model component. :rtype: LayerModelComponent \"\"\" if not isinstance ( layer_component , LayerModelComponent ): return None cloned_component = model_cls ( layer_component . uuid , layer_component . name , layer_component . description ) for f in fields ( layer_component ): attr_val = getattr ( layer_component , f . name ) setattr ( cloned_component , f . name , attr_val ) return cloned_component","title":"clone_layer_component"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_metric_configuration_profile","text":"clone_metric_configuration_profile ( metric_config_profile , referenced_activities ) Creates a deep copy version of the specified metric configuration profile. Parameters: Name Type Description Default metric_config_profile MetricConfigurationProfile Metric configuration profile to be cloned. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration profile. required Returns: Type Description MetricConfigurationProfile Cloned metric configuration profile or None if the input metric configuration profile was invalid. Source code in src/cplus_plugin/models/helpers.py 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 def clone_metric_configuration_profile ( metric_config_profile : MetricConfigurationProfile , referenced_activities : typing . List [ Activity ], ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Creates a deep copy version of the specified metric configuration profile. :param metric_config_profile: Metric configuration profile to be cloned. :type metric_config_profile: MetricConfigurationProfile :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration profile. :type referenced_activities: typing.List[Activity] :returns: Cloned metric configuration profile or None if the input metric configuration profile was invalid. :rtype: MetricConfigurationProfile \"\"\" if not metric_config_profile . is_valid (): return None metric_profile_config_dict = metric_configuration_profile_to_dict ( metric_config_profile ) if not metric_profile_config_dict : return None return create_metric_configuration_profile ( metric_profile_config_dict , referenced_activities )","title":"clone_metric_configuration_profile"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.clone_ncs_pathway","text":"clone_ncs_pathway ( ncs ) Creates a deep copy of the given NCS pathway. Parameters: Name Type Description Default ncs NcsPathway NCS pathway to clone. required Returns: Type Description NcsPathway A deep copy of the original NCS pathway object. Source code in src/cplus_plugin/models/helpers.py 388 389 390 391 392 393 394 395 396 397 def clone_ncs_pathway ( ncs : NcsPathway ) -> NcsPathway : \"\"\"Creates a deep copy of the given NCS pathway. :param ncs: NCS pathway to clone. :type ncs: NcsPathway :returns: A deep copy of the original NCS pathway object. :rtype: NcsPathway \"\"\" return clone_layer_component ( ncs , NcsPathway )","title":"clone_ncs_pathway"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_collection_from_dict","text":"constant_raster_collection_from_dict ( collection_dict , model_components ) Creates a ConstantRasterCollection object from a dictionary. Parameters: Name Type Description Default collection_dict dict Dictionary containing the collection data required model_components List [ LayerModelComponent ] List of LayerModelComponent objects (NcsPathway or Activity) required Returns: Type Description ConstantRasterCollection Constant raster collection object or None if deserialization failed Source code in src/cplus_plugin/models/helpers.py 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 def constant_raster_collection_from_dict ( collection_dict : dict , model_components : typing . List [ LayerModelComponent ] ) -> typing . Optional [ \"ConstantRasterCollection\" ]: \"\"\"Creates a ConstantRasterCollection object from a dictionary. :param collection_dict: Dictionary containing the collection data :type collection_dict: dict :param model_components: List of LayerModelComponent objects (NcsPathway or Activity) :type model_components: typing.List[LayerModelComponent] :returns: Constant raster collection object or None if deserialization failed :rtype: ConstantRasterCollection \"\"\" if not collection_dict : return None # Create a lookup function for component access component_lookup_dict = { str ( comp . uuid ): comp for comp in model_components } def component_lookup ( uuid_str : str ) -> typing . Optional [ LayerModelComponent ]: return component_lookup_dict . get ( uuid_str ) # Deserialize components using helper function components = [ create_constant_raster_component ( comp_dict , component_lookup ) for comp_dict in collection_dict . get ( COMPONENTS_ATTRIBUTE , []) ] # Parse component_type if present component_type = None component_type_str = collection_dict . get ( COMPONENT_TYPE_ATTRIBUTE ) if component_type_str : component_type = ModelComponentType . from_string ( component_type_str ) return ConstantRasterCollection ( min_value = collection_dict . get ( MIN_VALUE_ATTRIBUTE_KEY , 0.0 ), max_value = collection_dict . get ( MAX_VALUE_ATTRIBUTE_KEY , 1.0 ), component_type = component_type , components = components , skip_raster = collection_dict . get ( SKIP_RASTER_ATTRIBUTE , False ), allowable_max = collection_dict . get ( ALLOWABLE_MAX_ATTRIBUTE , sys . float_info . max ), allowable_min = collection_dict . get ( ALLOWABLE_MIN_ATTRIBUTE , 0.0 ), last_updated = collection_dict . get ( LAST_UPDATED_ATTRIBUTE , \"\" ), )","title":"constant_raster_collection_from_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_collection_to_dict","text":"constant_raster_collection_to_dict ( collection ) Serializes a ConstantRasterCollection object into a dictionary. Parameters: Name Type Description Default collection ConstantRasterCollection Constant raster collection object required Returns: Type Description dict Dictionary representation of the collection Source code in src/cplus_plugin/models/helpers.py 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 def constant_raster_collection_to_dict ( collection : \"ConstantRasterCollection\" , ) -> dict : \"\"\"Serializes a ConstantRasterCollection object into a dictionary. :param collection: Constant raster collection object :type collection: ConstantRasterCollection :returns: Dictionary representation of the collection :rtype: dict \"\"\" if collection is None : return {} return { MIN_VALUE_ATTRIBUTE_KEY : collection . min_value , MAX_VALUE_ATTRIBUTE_KEY : collection . max_value , COMPONENT_TYPE_ATTRIBUTE : ( collection . component_type . value if collection . component_type else None ), ALLOWABLE_MIN_ATTRIBUTE : collection . allowable_min , ALLOWABLE_MAX_ATTRIBUTE : collection . allowable_max , SKIP_RASTER_ATTRIBUTE : collection . skip_raster , LAST_UPDATED_ATTRIBUTE : collection . last_updated , COMPONENTS_ATTRIBUTE : [ constant_raster_component_to_dict ( c ) for c in collection . components ], }","title":"constant_raster_collection_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_component_to_dict","text":"constant_raster_component_to_dict ( constant_raster_component ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterComponent object. Parameters: Name Type Description Default constant_raster_component ConstantRasterComponent ConstantRasterComponent instance to serialize required Returns: Type Description dict Dictionary representation of the component Source code in src/cplus_plugin/models/helpers.py 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 def constant_raster_component_to_dict ( constant_raster_component : ConstantRasterComponent , ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterComponent object. :param constant_raster_component: ConstantRasterComponent instance to serialize :type constant_raster_component: ConstantRasterComponent :returns: Dictionary representation of the component :rtype: dict \"\"\" return { VALUE_INFO_ATTRIBUTE : ( constant_raster_info_to_dict ( constant_raster_component . value_info ) if constant_raster_component . value_info else {} ), COMPONENT_UUID_ATTRIBUTE : ( str ( constant_raster_component . component . uuid ) if constant_raster_component . component else \"\" ), PREFIX_ATTRIBUTE : constant_raster_component . prefix , BASE_NAME_ATTRIBUTE : constant_raster_component . base_name , SUFFIX_ATTRIBUTE : constant_raster_component . suffix , PATH_ATTRIBUTE : constant_raster_component . path , SKIP_RASTER_ATTRIBUTE : constant_raster_component . skip_raster , ENABLED_ATTRIBUTE : constant_raster_component . enabled , COMPONENT_ID_ATTRIBUTE : constant_raster_component . component_id , COMPONENT_TYPE_ATTRIBUTE : ( constant_raster_component . component_type . value if constant_raster_component . component_type else ModelComponentType . UNKNOWN . value ), }","title":"constant_raster_component_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_info_to_dict","text":"constant_raster_info_to_dict ( constant_raster_info ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterInfo object. Parameters: Name Type Description Default constant_raster_info ConstantRasterInfo ConstantRasterInfo instance to serialize required Returns: Type Description dict Dictionary with normalized and absolute values Source code in src/cplus_plugin/models/helpers.py 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 def constant_raster_info_to_dict ( constant_raster_info : ConstantRasterInfo ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterInfo object. :param constant_raster_info: ConstantRasterInfo instance to serialize :type constant_raster_info: ConstantRasterInfo :returns: Dictionary with normalized and absolute values :rtype: dict \"\"\" return { NORMALIZED_ATTRIBUTE : constant_raster_info . normalized , ABSOLUTE_ATTRIBUTE : constant_raster_info . absolute , }","title":"constant_raster_info_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_metadata_from_dict","text":"constant_raster_metadata_from_dict ( metadata_dict , collection_deserializer = None , activities = None ) Creates a constant raster metadata object from the dictionary representation. Parameters: Name Type Description Default metadata_dict dict Dictionary representation of the metadata object. required collection_deserializer Callable Callable for deserializing. If not specified, the raster collection will be None. None activities List [ Activity ] List of activities to lookup and link to constant raster component. None Returns: Type Description ConstantRasterMetadata Constant raster metadata object or None if the dictionary is empty. Source code in src/cplus_plugin/models/helpers.py 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 def constant_raster_metadata_from_dict ( metadata_dict , collection_deserializer : typing . Callable = None , activities : typing . List [ Activity ] = None , ) -> typing . Optional [ ConstantRasterMetadata ]: \"\"\"Creates a constant raster metadata object from the dictionary representation. :param metadata_dict: Dictionary representation of the metadata object. :type metadata_dict: dict :param collection_deserializer: Callable for deserializing. If not specified, the raster collection will be None. :type collection_deserializer: typing.Callable :param activities: List of activities to lookup and link to constant raster component. :type activities: typing.List[Activity] :returns: Constant raster metadata object or None if the dictionary is empty. :rtype: ConstantRasterMetadata \"\"\" if not metadata_dict : return None kwargs = {} if ID_ATTRIBUTE in metadata_dict : kwargs [ ID_ATTRIBUTE ] = metadata_dict [ ID_ATTRIBUTE ] if DISPLAY_NAME_ATTRIBUTE in metadata_dict : kwargs [ DISPLAY_NAME_ATTRIBUTE ] = metadata_dict [ DISPLAY_NAME_ATTRIBUTE ] if USER_DEFINED_ATTRIBUTE in metadata_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = metadata_dict [ USER_DEFINED_ATTRIBUTE ] if COMPONENT_TYPE_ATTRIBUTE in metadata_dict : kwargs [ COMPONENT_TYPE_ATTRIBUTE ] = ModelComponentType . from_string ( metadata_dict [ COMPONENT_TYPE_ATTRIBUTE ] ) raster_collection = None if RASTER_COLLECTION_ATTRIBUTE in metadata_dict and collection_deserializer : raster_collection = collection_deserializer ( metadata_dict [ RASTER_COLLECTION_ATTRIBUTE ], activities ) kwargs [ RASTER_COLLECTION_ATTRIBUTE ] = raster_collection return ConstantRasterMetadata ( ** kwargs )","title":"constant_raster_metadata_from_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.constant_raster_metadata_to_dict","text":"constant_raster_metadata_to_dict ( metadata , collection_serializer = None ) Creates a dictionary containing attribute name-value pairs from a ConstantRasterMetadata object. Parameters: Name Type Description Default metadata ConstantRasterMetadata ConstantRasterMetadata instance to serialize required collection_serializer Callable Callable for serializing. If not specified, an empty dictionary will be used. None Returns: Type Description dict Dictionary representation of the metadata Source code in src/cplus_plugin/models/helpers.py 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 def constant_raster_metadata_to_dict ( metadata : ConstantRasterMetadata , collection_serializer : typing . Callable = None ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a ConstantRasterMetadata object. :param metadata: ConstantRasterMetadata instance to serialize :type metadata: ConstantRasterMetadata :param collection_serializer: Callable for serializing. If not specified, an empty dictionary will be used. :type collection_serializer: typing.Callable :returns: Dictionary representation of the metadata :rtype: dict \"\"\" collection_dict = ( collection_serializer ( metadata . raster_collection ) if collection_serializer else {} ) return { ID_ATTRIBUTE : metadata . id , DISPLAY_NAME_ATTRIBUTE : metadata . display_name , RASTER_COLLECTION_ATTRIBUTE : collection_dict , COMPONENT_TYPE_ATTRIBUTE : ( metadata . component_type . value if metadata . component_type else None ), USER_DEFINED_ATTRIBUTE : metadata . user_defined , }","title":"constant_raster_metadata_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.copy_layer_component_attributes","text":"copy_layer_component_attributes ( target , source ) Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. Parameters: Name Type Description Default target LayerModelComponent Target object whose attribute values will be updated. required source LayerModelComponent Source object whose attribute values will be copied to the target. required Returns: Type Description LayerModelComponent Target object containing the updated attribute values apart for the uuid whose value will not change. Source code in src/cplus_plugin/models/helpers.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 def copy_layer_component_attributes ( target : LayerModelComponent , source : LayerModelComponent ) -> LayerModelComponent : \"\"\"Copies the attribute values of source to target. The uuid attribute value is not copied as well as the layer attribute. However, for the latter, the path is copied. :param target: Target object whose attribute values will be updated. :type target: LayerModelComponent :param source: Source object whose attribute values will be copied to the target. :type source: LayerModelComponent :returns: Target object containing the updated attribute values apart for the uuid whose value will not change. :rtype: LayerModelComponent \"\"\" if not isinstance ( target , LayerModelComponent ) or not isinstance ( source , LayerModelComponent ): raise TypeError ( \"Source or target objects are not of type 'LayerModelComponent'\" ) for f in fields ( source ): # Exclude uuid if f . name == UUID_ATTRIBUTE : continue attr_val = getattr ( source , f . name ) setattr ( target , f . name , attr_val ) # Force layer to be set/updated target . update_layer_type () return target","title":"copy_layer_component_attributes"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_activity","text":"create_activity ( source_dict ) Factory method for creating an activity using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description Activity activity with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def create_activity ( source_dict ) -> typing . Union [ Activity , None ]: \"\"\"Factory method for creating an activity using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: activity with property values set from the dictionary. :rtype: Activity \"\"\" activity = create_layer_component ( source_dict , Activity ) if MASK_PATHS_SEGMENT in source_dict . keys (): activity . mask_paths = source_dict [ MASK_PATHS_SEGMENT ] # Set style if STYLE_ATTRIBUTE in source_dict . keys (): activity . layer_styles = source_dict [ STYLE_ATTRIBUTE ] # Set styling pixel value if PIXEL_VALUE_ATTRIBUTE in source_dict . keys (): activity . style_pixel_value = source_dict [ PIXEL_VALUE_ATTRIBUTE ] return activity","title":"create_activity"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_activity_metric","text":"create_activity_metric ( activity_metric_dict , activity , metric_column ) Creates a metric column from the equivalent dictionary representation. Parameters: Name Type Description Default activity_metric_dict dict Dictionary containing information for deserializing the dict to a metric column. required activity Activity Referenced activity matching the saved UUID. required metric_column MetricColumn Referenced metric column matching the saved name. required Returns: Type Description MetricColumn Metric column object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 def create_activity_metric ( activity_metric_dict : dict , activity : Activity , metric_column : MetricColumn ) -> typing . Optional [ ActivityColumnMetric ]: \"\"\"Creates a metric column from the equivalent dictionary representation. :param activity_metric_dict: Dictionary containing information for deserializing the dict to a metric column. :type activity_metric_dict: dict :param activity: Referenced activity matching the saved UUID. :type activity: str :param metric_column: Referenced metric column matching the saved name. :type metric_column: MetricColumn :returns: Metric column object or None if the deserialization failed. :rtype: MetricColumn \"\"\" return ActivityColumnMetric ( activity , metric_column , MetricType . from_int ( activity_metric_dict [ METRIC_TYPE_ATTRIBUTE ]), activity_metric_dict [ EXPRESSION_ATTRIBUTE ], )","title":"create_activity_metric"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_activity_npv","text":"create_activity_npv ( activity_npv_dict ) Creates an ActivityNpv object from the equivalent dictionary representation. Please note that the activity attribute will be None hence, will have to be set manually by extracting the corresponding Activity from the activity UUID. Parameters: Name Type Description Default activity_npv_dict dict Dictionary containing information for deserializing the ActivityNpv object. required Returns: Type Description ActivityNpv ActivityNpv deserialized from the dictionary representation. Source code in src/cplus_plugin/models/helpers.py 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 def create_activity_npv ( activity_npv_dict : dict ) -> typing . Optional [ ActivityNpv ]: \"\"\"Creates an ActivityNpv object from the equivalent dictionary representation. Please note that the `activity` attribute will be `None` hence, will have to be set manually by extracting the corresponding `Activity` from the activity UUID. :param activity_npv_dict: Dictionary containing information for deserializing the ActivityNpv object. :type activity_npv_dict: dict :returns: ActivityNpv deserialized from the dictionary representation. :rtype: ActivityNpv \"\"\" kwargs = {} npv_params = None if VALUE_INFO_ATTRIBUTE in activity_npv_dict : npv_params_dict = activity_npv_dict [ VALUE_INFO_ATTRIBUTE ] # Create base constant raster info constant_raster_info = create_constant_raster_info ( npv_params_dict ) kwargs = asdict ( constant_raster_info ) if YEARS_ATTRIBUTE in npv_params_dict : kwargs [ YEARS_ATTRIBUTE ] = npv_params_dict [ YEARS_ATTRIBUTE ] if DISCOUNT_ATTRIBUTE in npv_params_dict : kwargs [ DISCOUNT_ATTRIBUTE ] = npv_params_dict [ DISCOUNT_ATTRIBUTE ] if ABSOLUTE_NPV_ATTRIBUTE in npv_params_dict : kwargs [ ABSOLUTE_NPV_ATTRIBUTE ] = npv_params_dict [ ABSOLUTE_NPV_ATTRIBUTE ] if NORMALIZED_NPV_ATTRIBUTE in npv_params_dict : kwargs [ NORMALIZED_NPV_ATTRIBUTE ] = npv_params_dict [ NORMALIZED_NPV_ATTRIBUTE ] if MANUAL_NPV_ATTRIBUTE in npv_params_dict : kwargs [ MANUAL_NPV_ATTRIBUTE ] = npv_params_dict [ MANUAL_NPV_ATTRIBUTE ] if YEARLY_RATES_ATTRIBUTE in npv_params_dict : kwargs [ YEARLY_RATES_ATTRIBUTE ] = npv_params_dict [ YEARLY_RATES_ATTRIBUTE ] npv_params = NpvParameters ( ** kwargs ) constant_raster_component = create_constant_raster_component ( activity_npv_dict ) npv_kwargs = asdict ( constant_raster_component ) npv_kwargs [ VALUE_INFO_ATTRIBUTE ] = npv_params return ActivityNpv ( ** npv_kwargs )","title":"create_activity_npv"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_activity_npv_collection","text":"create_activity_npv_collection ( activity_collection_dict , reference_activities = None ) Creates an activity NPV collection object from the corresponding dictionary representation. Parameters: Name Type Description Default activity_collection_dict dict Dictionary representation containing information of an activity NPV collection object. required reference_activities List [ Activity ] Optional list of activities that will be used to lookup when deserializing the ActivityNpv objects. None Returns: Type Description ActivityNpvCollection Activity NPV collection object from the dictionary representation or None if the source dictionary is invalid. Source code in src/cplus_plugin/models/helpers.py 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 def create_activity_npv_collection ( activity_collection_dict : dict , reference_activities : typing . List [ Activity ] = None ) -> typing . Optional [ ActivityNpvCollection ]: \"\"\"Creates an activity NPV collection object from the corresponding dictionary representation. :param activity_collection_dict: Dictionary representation containing information of an activity NPV collection object. :type activity_collection_dict: dict :param reference_activities: Optional list of activities that will be used to lookup when deserializing the ActivityNpv objects. :type reference_activities: list :returns: Activity NPV collection object from the dictionary representation or None if the source dictionary is invalid. :rtype: ActivityNpvCollection \"\"\" if not activity_collection_dict : return None ref_activities_by_uuid = { str ( activity . uuid ): activity for activity in reference_activities } raster_collection = constant_raster_collection_from_dict ( activity_collection_dict , reference_activities ) kwargs = asdict ( raster_collection ) if COMPONENTS_ATTRIBUTE in activity_collection_dict : mappings_dict = activity_collection_dict [ COMPONENTS_ATTRIBUTE ] npv_mappings = [] for md in mappings_dict : activity_npv = create_activity_npv ( md ) if activity_npv is None : continue # Get the corresponding activity from the unique # identifier if COMPONENT_ID_ATTRIBUTE in md : activity_id = md [ COMPONENT_ID_ATTRIBUTE ] if activity_id in ref_activities_by_uuid : activity = ref_activities_by_uuid [ activity_id ] activity_npv . activity = activity npv_mappings . append ( activity_npv ) kwargs [ COMPONENTS_ATTRIBUTE ] = npv_mappings return ActivityNpvCollection ( ** kwargs )","title":"create_activity_npv_collection"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_constant_raster_component","text":"create_constant_raster_component ( source_dict , component_lookup = None ) Factory method for creating a ConstantRasterComponent from dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values required component_lookup Callable [[ str ], LayerModelComponent ] Function to retrieve LayerModelComponent by UUID None Returns: Type Description ConstantRasterComponent ConstantRasterComponent instance with values from dictionary Source code in src/cplus_plugin/models/helpers.py 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 def create_constant_raster_component ( source_dict : dict , component_lookup : typing . Callable [[ str ], LayerModelComponent ] = None , ) -> ConstantRasterComponent : \"\"\"Factory method for creating a ConstantRasterComponent from dictionary. :param source_dict: Dictionary containing property values :type source_dict: dict :param component_lookup: Function to retrieve LayerModelComponent by UUID :type component_lookup: Callable :returns: ConstantRasterComponent instance with values from dictionary :rtype: ConstantRasterComponent \"\"\" component = None component_uuid = source_dict . get ( COMPONENT_UUID_ATTRIBUTE ) if component_uuid and component_lookup : component = component_lookup ( component_uuid ) value_info_data = source_dict . get ( VALUE_INFO_ATTRIBUTE , {}) value_info = ( create_constant_raster_info ( value_info_data ) if value_info_data else ConstantRasterInfo () ) return ConstantRasterComponent ( value_info = value_info , component = component , prefix = source_dict . get ( PREFIX_ATTRIBUTE , \"\" ), base_name = source_dict . get ( BASE_NAME_ATTRIBUTE , \"\" ), suffix = source_dict . get ( SUFFIX_ATTRIBUTE , \"\" ), path = source_dict . get ( PATH_ATTRIBUTE , \"\" ), skip_raster = bool ( source_dict . get ( SKIP_RASTER_ATTRIBUTE , False )), enabled = bool ( source_dict . get ( ENABLED_ATTRIBUTE , True )), )","title":"create_constant_raster_component"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_constant_raster_info","text":"create_constant_raster_info ( source_dict ) Factory method for creating a ConstantRasterInfo object from dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values required Returns: Type Description ConstantRasterInfo ConstantRasterInfo instance with values from dictionary Source code in src/cplus_plugin/models/helpers.py 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 def create_constant_raster_info ( source_dict : dict ) -> ConstantRasterInfo : \"\"\"Factory method for creating a ConstantRasterInfo object from dictionary. :param source_dict: Dictionary containing property values :type source_dict: dict :returns: ConstantRasterInfo instance with values from dictionary :rtype: ConstantRasterInfo \"\"\" return ConstantRasterInfo ( normalized = float ( source_dict . get ( NORMALIZED_ATTRIBUTE , 0.0 )), absolute = float ( source_dict . get ( ABSOLUTE_ATTRIBUTE , 0.0 )), )","title":"create_constant_raster_info"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_layer_component","text":"create_layer_component ( source_dict , model_cls ) Factory method for creating a layer model component using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required model_cls Callable [[ UUID , str , str , str , LayerType , bool ], LayerModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description LayerModelComponent Layer model component object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 def create_layer_component ( source_dict , model_cls : typing . Callable [ [ uuid . UUID , str , str , str , LayerType , bool ], LayerModelComponentType ], ) -> typing . Union [ LayerModelComponent , None ]: \"\"\"Factory method for creating a layer model component using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: LayerModelComponent :returns: Layer model component object with property values set from the dictionary. :rtype: LayerModelComponent \"\"\" if UUID_ATTRIBUTE not in source_dict : return None source_uuid = source_dict [ UUID_ATTRIBUTE ] if isinstance ( source_uuid , str ): source_uuid = uuid . UUID ( source_uuid ) kwargs = {} if PATH_ATTRIBUTE in source_dict : kwargs [ PATH_ATTRIBUTE ] = source_dict [ PATH_ATTRIBUTE ] if LAYER_TYPE_ATTRIBUTE in source_dict : kwargs [ LAYER_TYPE_ATTRIBUTE ] = LayerType ( int ( source_dict [ LAYER_TYPE_ATTRIBUTE ])) if USER_DEFINED_ATTRIBUTE in source_dict : kwargs [ USER_DEFINED_ATTRIBUTE ] = bool ( source_dict [ USER_DEFINED_ATTRIBUTE ]) return model_cls ( source_uuid , source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], ** kwargs , )","title":"create_layer_component"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_metric_column","text":"create_metric_column ( metric_column_dict ) Creates a metric column from the equivalent dictionary representation. Parameters: Name Type Description Default metric_column_dict dict Dictionary containing information for deserializing the dict to a metric column. required Returns: Type Description MetricColumn Metric column object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 def create_metric_column ( metric_column_dict : dict ) -> typing . Optional [ MetricColumn ]: \"\"\"Creates a metric column from the equivalent dictionary representation. :param metric_column_dict: Dictionary containing information for deserializing the dict to a metric column. :type metric_column_dict: dict :returns: Metric column object or None if the deserialization failed. :rtype: MetricColumn \"\"\" number_formatter = QgsApplication . numericFormatRegistry () . create ( metric_column_dict [ NUMBER_FORMATTER_ID_ATTRIBUTE ], metric_column_dict [ NUMBER_FORMATTER_PROPS_ATTRIBUTE ], QgsReadWriteContext (), ) return MetricColumn ( metric_column_dict [ NAME_ATTRIBUTE ], metric_column_dict [ HEADER_ATTRIBUTE ], metric_column_dict [ EXPRESSION_ATTRIBUTE ], metric_column_dict [ ALIGNMENT_ATTRIBUTE ], metric_column_dict [ AUTO_CALCULATED_ATTRIBUTE ], metric_column_dict [ NUMBER_FORMATTER_ENABLED_ATTRIBUTE ], number_formatter , )","title":"create_metric_column"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_metric_configuration","text":"create_metric_configuration ( metric_configuration_dict , referenced_activities ) Creates a metric configuration from the equivalent dictionary representation. Parameters: Name Type Description Default metric_configuration_dict dict Dictionary containing information for deserializing a metric configuration object. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration. required Returns: Type Description MetricConfiguration Metric configuration object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 def create_metric_configuration ( metric_configuration_dict : dict , referenced_activities : typing . List [ Activity ] ) -> typing . Optional [ MetricConfiguration ]: \"\"\"Creates a metric configuration from the equivalent dictionary representation. :param metric_configuration_dict: Dictionary containing information for deserializing a metric configuration object. :type metric_configuration_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration. :type referenced_activities: typing.List[Activity] :returns: Metric configuration object or None if the deserialization failed. :rtype: MetricConfiguration \"\"\" if len ( metric_configuration_dict ) == 0 : return None metric_column_dicts = metric_configuration_dict [ METRIC_COLUMNS_PROPERTY ] metric_columns = [ create_metric_column ( mc_dict ) for mc_dict in metric_column_dicts ] indexed_metric_columns = { mc . name : mc for mc in metric_columns } indexed_activities = { str ( activity . uuid ): activity for activity in referenced_activities } activity_column_metrics = [] activity_column_metric_dicts = metric_configuration_dict [ ACTIVITY_METRICS_PROPERTY ] for activity_row_dict in activity_column_metric_dicts : if len ( activity_row_dict ) == 0 : continue # Check if the activity exists activity_id = activity_row_dict [ 0 ][ ACTIVITY_IDENTIFIER_PROPERTY ] if activity_id not in indexed_activities : # Most likely the activity in the metric config has been deleted continue activity_row_metrics = [] for activity_metric_dict in activity_row_dict : name = activity_metric_dict [ METRIC_IDENTIFIER_PROPERTY ] activity = indexed_activities [ activity_id ] metric_column = indexed_metric_columns [ name ] activity_row_metrics . append ( create_activity_metric ( activity_metric_dict , activity , metric_column ) ) activity_column_metrics . append ( activity_row_metrics ) return MetricConfiguration ( metric_columns , activity_column_metrics )","title":"create_metric_configuration"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_metric_configuration_profile","text":"create_metric_configuration_profile ( metric_configuration_profile_dict , referenced_activities ) Creates a metric configuration profile from the equivalent dictionary representation. Parameters: Name Type Description Default metric_configuration_profile_dict dict Dictionary containing information for deserializing a metric configuration profile. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration profile. required Returns: Type Description MetricConfiguration Metric configuration profile object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 def create_metric_configuration_profile ( metric_configuration_profile_dict : dict , referenced_activities : typing . List [ Activity ], ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Creates a metric configuration profile from the equivalent dictionary representation. :param metric_configuration_profile_dict: Dictionary containing information for deserializing a metric configuration profile. :type metric_configuration_profile_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration profile. :type referenced_activities: typing.List[Activity] :returns: Metric configuration profile object or None if the deserialization failed. :rtype: MetricConfiguration \"\"\" if not metric_configuration_profile_dict : return None if NAME_ATTRIBUTE not in metric_configuration_profile_dict : return None if METRIC_CONFIGURATION_PROPERTY not in metric_configuration_profile_dict : return None name = metric_configuration_profile_dict [ NAME_ATTRIBUTE ] config = create_metric_configuration ( metric_configuration_profile_dict [ METRIC_CONFIGURATION_PROPERTY ], referenced_activities , ) if config is None : return None return MetricConfigurationProfile ( name , config )","title":"create_metric_configuration_profile"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_metrics_profile_collection","text":"create_metrics_profile_collection ( metric_profile_collection_dict , referenced_activities ) Deserializes a metric profile collection from the equivalent dictionary representation. Parameters: Name Type Description Default metric_profile_collection_dict dict Dictionary containing information about the profile collection. required referenced_activities List [ Activity ] Activities which will be used to extract those referenced in the metric configuration objects that correspond to the respective profiles. required Returns: Type Description MetricProfileCollection Metric profile configuration object or None if the deserialization failed. Source code in src/cplus_plugin/models/helpers.py 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 def create_metrics_profile_collection ( metric_profile_collection_dict , referenced_activities : typing . List [ Activity ] ) -> typing . Optional [ MetricProfileCollection ]: \"\"\"Deserializes a metric profile collection from the equivalent dictionary representation. :param metric_profile_collection_dict: Dictionary containing information about the profile collection. :type metric_profile_collection_dict: dict :param referenced_activities: Activities which will be used to extract those referenced in the metric configuration objects that correspond to the respective profiles. :type referenced_activities: typing.List[Activity] :returns: Metric profile configuration object or None if the deserialization failed. :rtype: MetricProfileCollection \"\"\" if not metric_profile_collection_dict : return None if PROFILES_ATTRIBUTE not in metric_profile_collection_dict : return None current_profile_id = metric_profile_collection_dict . get ( CURRENT_PROFILE_PROPERTY , \"\" ) metric_profiles = [] for profile_dict in metric_profile_collection_dict [ PROFILES_ATTRIBUTE ]: profile = create_metric_configuration_profile ( profile_dict , referenced_activities ) if profile is None : continue metric_profiles . append ( profile ) return MetricProfileCollection ( current_profile_id , metric_profiles )","title":"create_metrics_profile_collection"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_model_component","text":"create_model_component ( source_dict , model_cls ) Factory method for creating and setting attribute values for a base model component object. Parameters: Name Type Description Default source_dict dict Dictionary containing attribute values. required model_cls Callable [[ UUID , str , str ], BaseModelComponentType ] Callable class that will be created based on the input argument values from the dictionary. required Returns: Type Description BaseModelComponent Base model component object with property values derived from the dictionary. Source code in src/cplus_plugin/models/helpers.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def create_model_component ( source_dict : dict , model_cls : typing . Callable [[ uuid . UUID , str , str ], BaseModelComponentType ], ) -> typing . Union [ BaseModelComponentType , None ]: \"\"\"Factory method for creating and setting attribute values for a base model component object. :param source_dict: Dictionary containing attribute values. :type source_dict: dict :param model_cls: Callable class that will be created based on the input argument values from the dictionary. :type model_cls: BaseModelComponent :returns: Base model component object with property values derived from the dictionary. :rtype: BaseModelComponent \"\"\" if not issubclass ( model_cls , BaseModelComponent ): return None return model_cls ( uuid . UUID ( source_dict [ UUID_ATTRIBUTE ]), source_dict [ NAME_ATTRIBUTE ], source_dict [ DESCRIPTION_ATTRIBUTE ], )","title":"create_model_component"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_ncs_pathway","text":"create_ncs_pathway ( source_dict ) Factory method for creating an NcsPathway object using attribute values defined in a dictionary. Parameters: Name Type Description Default source_dict dict Dictionary containing property values. required Returns: Type Description NcsPathway NCS pathway object with property values set from the dictionary. Source code in src/cplus_plugin/models/helpers.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def create_ncs_pathway ( source_dict ) -> typing . Union [ NcsPathway , None ]: \"\"\"Factory method for creating an NcsPathway object using attribute values defined in a dictionary. :param source_dict: Dictionary containing property values. :type source_dict: dict :returns: NCS pathway object with property values set from the dictionary. :rtype: NcsPathway \"\"\" ncs = create_layer_component ( source_dict , NcsPathway ) # We are checking because of the various iterations of the attributes # in the NcsPathway class where some of these attributes might # be missing. if PATHWAY_TYPE_ATTRIBUTE in source_dict : ncs . pathway_type = NcsPathwayType . from_int ( source_dict [ PATHWAY_TYPE_ATTRIBUTE ]) else : # Assign undefined ncs . pathway_type = NcsPathwayType . UNDEFINED if PRIORITY_LAYERS_SEGMENT in source_dict . keys (): ncs . priority_layers = source_dict [ PRIORITY_LAYERS_SEGMENT ] if PATHWAY_TYPE_OPTIONS_ATTRIBUTE in source_dict : ncs . type_options = source_dict [ PATHWAY_TYPE_OPTIONS_ATTRIBUTE ] if PATHWAY_SUITABILITY_INDEX_ATTRIBUTE in source_dict : ncs . suitability_index = source_dict [ PATHWAY_SUITABILITY_INDEX_ATTRIBUTE ] return ncs","title":"create_ncs_pathway"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.create_result_info","text":"create_result_info ( result_info_dict ) Creates a ResultInfo object from the dictionary representation. Parameters: Name Type Description Default result_info_dict dict Representation of ResultInfo object. required Returns: Type Description ResultInfo A representation of the result info or None if there is missing information in the dictionary. Source code in src/cplus_plugin/models/helpers.py 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 def create_result_info ( result_info_dict : dict ) -> typing . Optional [ ResultInfo ]: \"\"\"Creates a ResultInfo object from the dictionary representation. :param result_info_dict: Representation of ResultInfo object. :type result_info_dict: dict :returns: A representation of the result info or None if there is missing information in the dictionary. :rtype: ResultInfo \"\"\" args = [] if RESULT_COLLECTION_ATTRIBUTE in result_info_dict : args . append ( result_info_dict . get ( RESULT_COLLECTION_ATTRIBUTE )) if LAST_UPDATED_DATE_ATTRIBUTE in result_info_dict : args . append ( result_info_dict . get ( LAST_UPDATED_DATE_ATTRIBUTE )) if len ( args ) < 2 : return None return ResultInfo ( * args )","title":"create_result_info"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_project_crs_extent","text":"extent_to_project_crs_extent ( spatial_extent , project = None , source_crs = None ) Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required project QgsProject Project whose CRS will be used to determine the values of the output extent. None source_crs QgsCoordinateReferenceSystem Specify a source CRS to use for the transformation otherwise it will revert to the default which is WGS84. None Returns: Type Description QgsRectangle Output extent in the project's CRS. If the input extent is invalid, this function will return None. Source code in src/cplus_plugin/models/helpers.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 def extent_to_project_crs_extent ( spatial_extent : SpatialExtent , project : QgsProject = None , source_crs : QgsCoordinateReferenceSystem = None , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Transforms SpatialExtent model to an QGIS extent based on the CRS of the given project. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :param project: Project whose CRS will be used to determine the values of the output extent. :type project: QgsProject :param source_crs: Specify a source CRS to use for the transformation otherwise it will revert to the default which is WGS84. :type source_crs: QgsCoordinateReferenceSystem :returns: Output extent in the project's CRS. If the input extent is invalid, this function will return None. :rtype: QgsRectangle \"\"\" input_rect = extent_to_qgs_rectangle ( spatial_extent ) if input_rect is None : return None default_crs = source_crs or QgsCoordinateReferenceSystem . fromEpsgId ( DEFAULT_CRS_ID ) if not default_crs . isValid (): return None if project is None : project = QgsProject . instance () target_crs = project . crs () if default_crs == target_crs : # No need for transformation return input_rect try : coordinate_xform = QgsCoordinateTransform ( default_crs , project . crs (), project ) return coordinate_xform . transformBoundingBox ( input_rect ) except Exception as e : log ( f \" { e } , using the default input extent.\" ) return input_rect","title":"extent_to_project_crs_extent"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_qgs_rectangle","text":"extent_to_qgs_rectangle ( spatial_extent ) Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. Parameters: Name Type Description Default spatial_extent SpatialExtent Spatial extent data model that defines the scenario bounds. required Returns: Type Description QgsRectangle QGIS rectangle defining the bounds for the scenario. Source code in src/cplus_plugin/models/helpers.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 def extent_to_qgs_rectangle ( spatial_extent : SpatialExtent , ) -> typing . Union [ QgsRectangle , None ]: \"\"\"Returns a QgsRectangle object from the SpatialExtent object. If the SpatialExtent is invalid (i.e. less than four items) then it will return None. :param spatial_extent: Spatial extent data model that defines the scenario bounds. :type spatial_extent: SpatialExtent :returns: QGIS rectangle defining the bounds for the scenario. :rtype: QgsRectangle \"\"\" if len ( spatial_extent . bbox ) < 4 : return None return QgsRectangle ( spatial_extent . bbox [ 0 ], spatial_extent . bbox [ 2 ], spatial_extent . bbox [ 1 ], spatial_extent . bbox [ 3 ], )","title":"extent_to_qgs_rectangle"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.extent_to_url_param","text":"extent_to_url_param ( rect_extent ) Converts the bounding box in a QgsRectangle object to the equivalent param for use in a URL. 'bbox' is appended as a prefix in the URL query part. Parameters: Name Type Description Default rect_extent QgsRectangle Spatial extent that defines the AOI. required Returns: Type Description str String representing the param defining the extents of the AOI. If the extent is empty, it will return an empty string. Source code in src/cplus_plugin/models/helpers.py 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 def extent_to_url_param ( rect_extent : QgsRectangle ) -> str : \"\"\"Converts the bounding box in a QgsRectangle object to the equivalent param for use in a URL. 'bbox' is appended as a prefix in the URL query part. :param rect_extent: Spatial extent that defines the AOI. :type rect_extent: QgsRectangle :returns: String representing the param defining the extents of the AOI. If the extent is empty, it will return an empty string. :rtype: str \"\"\" if rect_extent . isEmpty (): return \"\" url_query = QtCore . QUrlQuery () url_query . addQueryItem ( \"bbox\" , f \" { rect_extent . xMinimum () !s} , { rect_extent . yMinimum () !s} , { rect_extent . xMaximum () !s} , { rect_extent . yMaximum () !s} \" , ) return url_query . toString ()","title":"extent_to_url_param"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.layer_component_to_dict","text":"layer_component_to_dict ( layer_component , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from a layer model component object. Parameters: Name Type Description Default layer_component LayerModelComponentType Source layer model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 def layer_component_to_dict ( layer_component : LayerModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from a layer model component object. :param layer_component: Source layer model component object whose values are to be mapped to the corresponding attribute names. :type layer_component: LayerModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_attrs = model_component_to_dict ( layer_component , uuid_to_str ) base_attrs [ PATH_ATTRIBUTE ] = layer_component . path try : base_attrs [ LAYER_TYPE_ATTRIBUTE ] = int ( layer_component . layer_type ) except TypeError : if base_attrs [ \"path\" ] . endswith ( \".tif\" ): base_attrs [ LAYER_TYPE_ATTRIBUTE ] = 0 elif base_attrs [ \"path\" ] . endswith ( \".shp\" ): base_attrs [ LAYER_TYPE_ATTRIBUTE ] = 1 base_attrs [ USER_DEFINED_ATTRIBUTE ] = layer_component . user_defined return base_attrs","title":"layer_component_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.layer_from_scenario_result","text":"layer_from_scenario_result ( result ) Gets the scenario output layer from the results of the analysis. Returns: Type Description QgsRasterLayer Raster layer corresponding to the output scenario path or None if the file does not exist or if the raster layer is invalid. Source code in src/cplus_plugin/models/helpers.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 def layer_from_scenario_result ( result : ScenarioResult , ) -> typing . Optional [ QgsRasterLayer ]: \"\"\"Gets the scenario output layer from the results of the analysis. :returns: Raster layer corresponding to the output scenario path or None if the file does not exist or if the raster layer is invalid. :rtype: QgsRasterLayer \"\"\" layer_file = result . analysis_output . get ( \"OUTPUT\" ) layer = QgsRasterLayer ( layer_file , result . scenario . name , QGIS_GDAL_PROVIDER ) if not layer . isValid (): return None return layer","title":"layer_from_scenario_result"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.metric_column_to_dict","text":"metric_column_to_dict ( metric_column ) Converts a metric column object to a dictionary representation. Parameters: Name Type Description Default metric_column MetricColumn Metric column to be serialized to a dictionary. required Returns: Type Description dict A dictionary containing attribute values of a metric column. Source code in src/cplus_plugin/models/helpers.py 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 def metric_column_to_dict ( metric_column : MetricColumn ) -> dict : \"\"\"Converts a metric column object to a dictionary representation. :param metric_column: Metric column to be serialized to a dictionary. :type metric_column: MetricColumn :returns: A dictionary containing attribute values of a metric column. :rtype: dict \"\"\" formatter_props = metric_column . number_formatter . configuration ( QgsReadWriteContext () ) formatter_id = metric_column . number_formatter . id () if formatter_id == \"default\" : formatter_props = {} return { NAME_ATTRIBUTE : metric_column . name , HEADER_ATTRIBUTE : metric_column . header , EXPRESSION_ATTRIBUTE : metric_column . expression , ALIGNMENT_ATTRIBUTE : metric_column . alignment , AUTO_CALCULATED_ATTRIBUTE : metric_column . auto_calculated , NUMBER_FORMATTER_ENABLED_ATTRIBUTE : metric_column . format_as_number , NUMBER_FORMATTER_ID_ATTRIBUTE : formatter_id , NUMBER_FORMATTER_PROPS_ATTRIBUTE : formatter_props , }","title":"metric_column_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.metric_configuration_profile_to_dict","text":"metric_configuration_profile_to_dict ( metric_config_profile ) Serializes a metric configuration profile to a dictionary. Parameters: Name Type Description Default metric_config_profile MetricConfigurationProfile Metric configuration profile to be serialized. required Returns: Type Description dict A dictionary representing a metric configuration profile. Source code in src/cplus_plugin/models/helpers.py 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 def metric_configuration_profile_to_dict ( metric_config_profile : MetricConfigurationProfile , ) -> dict : \"\"\"Serializes a metric configuration profile to a dictionary. :param metric_config_profile: Metric configuration profile to be serialized. :type metric_config_profile: MetricConfigurationProfile :returns: A dictionary representing a metric configuration profile. :rtype: dict \"\"\" return { NAME_ATTRIBUTE : metric_config_profile . name , METRIC_CONFIGURATION_PROPERTY : metric_configuration_to_dict ( metric_config_profile . config ), }","title":"metric_configuration_profile_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.metric_configuration_to_dict","text":"metric_configuration_to_dict ( metric_configuration ) Serializes a metric configuration to dict. Parameters: Name Type Description Default metric_configuration MetricConfiguration Metric configuration to tbe serialized. required Returns: Type Description dict A dictionary representing a metric configuration. Source code in src/cplus_plugin/models/helpers.py 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 def metric_configuration_to_dict ( metric_configuration : MetricConfiguration ) -> dict : \"\"\"Serializes a metric configuration to dict. :param metric_configuration: Metric configuration to tbe serialized. :type metric_configuration: MetricConfiguration :returns: A dictionary representing a metric configuration. :rtype: dict \"\"\" metric_config_dict = {} metric_column_dicts = [ metric_column_to_dict ( mc ) for mc in metric_configuration . metric_columns ] metric_config_dict [ METRIC_COLUMNS_PROPERTY ] = metric_column_dicts activity_column_metrics = [] for activity_columns in metric_configuration . activity_metrics : column_metrics = [] for activity_column_metric in activity_columns : column_metrics . append ( activity_metric_to_dict ( activity_column_metric )) activity_column_metrics . append ( column_metrics ) metric_config_dict [ ACTIVITY_METRICS_PROPERTY ] = activity_column_metrics activity_identifiers = [ str ( activity . uuid ) for activity in metric_configuration . activities ] metric_config_dict [ MULTI_ACTIVITY_IDENTIFIER_PROPERTY ] = activity_identifiers return metric_config_dict","title":"metric_configuration_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.metric_profile_collection_to_dict","text":"metric_profile_collection_to_dict ( metric_profile_collection ) Serializes a metric configuration profile to a dictionary. Parameters: Name Type Description Default metric_profile_collection MetricProfileCollection Metric profile collection to be serialized. required Returns: Type Description dict A dictionary representing a metric profile collection. Source code in src/cplus_plugin/models/helpers.py 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 def metric_profile_collection_to_dict ( metric_profile_collection : MetricProfileCollection , ) -> dict : \"\"\"Serializes a metric configuration profile to a dictionary. :param metric_profile_collection: Metric profile collection to be serialized. :type metric_profile_collection: MetricProfileCollection :returns: A dictionary representing a metric profile collection. :rtype: dict \"\"\" return { CURRENT_PROFILE_PROPERTY : metric_profile_collection . current_profile , PROFILES_ATTRIBUTE : [ metric_configuration_profile_to_dict ( mp ) for mp in metric_profile_collection . profiles ], }","title":"metric_profile_collection_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.model_component_to_dict","text":"model_component_to_dict ( model_component , uuid_to_str = True ) Creates a dictionary containing the base attribute name-value pairs from a model component object. Parameters: Name Type Description Default model_component BaseModelComponentType Source model component object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 def model_component_to_dict ( model_component : BaseModelComponentType , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing the base attribute name-value pairs from a model component object. :param model_component: Source model component object whose values are to be mapped to the corresponding attribute names. :type model_component: BaseModelComponent :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" model_uuid = model_component . uuid if uuid_to_str : model_uuid = str ( model_uuid ) return { UUID_ATTRIBUTE : model_uuid , NAME_ATTRIBUTE : model_component . name , DESCRIPTION_ATTRIBUTE : model_component . description , }","title":"model_component_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.ncs_pathway_to_dict","text":"ncs_pathway_to_dict ( ncs_pathway , uuid_to_str = True ) Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. Parameters: Name Type Description Default ncs_pathway NcsPathway Source NCS pathway object whose values are to be mapped to the corresponding attribute names. required uuid_to_str bool Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. True Returns: Type Description dict Returns a dictionary item containing attribute name-value pairs. Source code in src/cplus_plugin/models/helpers.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def ncs_pathway_to_dict ( ncs_pathway : NcsPathway , uuid_to_str = True ) -> dict : \"\"\"Creates a dictionary containing attribute name-value pairs from an NCS pathway object. This function has been retained for legacy support. :param ncs_pathway: Source NCS pathway object whose values are to be mapped to the corresponding attribute names. :type ncs_pathway: NcsPathway :param uuid_to_str: Set True to convert the UUID to a string equivalent, else False. Some serialization engines such as JSON are unable to handle UUID objects hence the need to convert to string. :type uuid_to_str: bool :returns: Returns a dictionary item containing attribute name-value pairs. :rtype: dict \"\"\" base_ncs_dict = layer_component_to_dict ( ncs_pathway , uuid_to_str ) base_ncs_dict [ PATHWAY_TYPE_ATTRIBUTE ] = ncs_pathway . pathway_type base_ncs_dict [ PRIORITY_LAYERS_SEGMENT ] = ncs_pathway . priority_layers base_ncs_dict [ PATHWAY_TYPE_OPTIONS_ATTRIBUTE ] = ncs_pathway . type_options base_ncs_dict [ PATHWAY_SUITABILITY_INDEX_ATTRIBUTE ] = ncs_pathway . suitability_index return base_ncs_dict","title":"ncs_pathway_to_dict"},{"location":"developer/api/models/api_helpers/#src.cplus_plugin.models.helpers.result_info_to_dict","text":"result_info_to_dict ( result_info ) Serializes a ResultInfo object to a dictionary. The result collection should contain simple types that can be decoded to string by the json library. Parameters: Name Type Description Default result_info ResultInfo Result info object to serialize. required Returns: Type Description dict A dictionary representation of the ResultInfo object. Source code in src/cplus_plugin/models/helpers.py 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 def result_info_to_dict ( result_info : ResultInfo ) -> dict : \"\"\"Serializes a ResultInfo object to a dictionary. The result collection should contain simple types that can be decoded to string by the `json` library. :param result_info: Result info object to serialize. :type result_info: ResultInfo :returns: A dictionary representation of the ResultInfo object. :rtype: dict \"\"\" return { RESULT_COLLECTION_ATTRIBUTE : result_info . result_collection , LAST_UPDATED_DATE_ATTRIBUTE : result_info . updated_date , }","title":"result_info_to_dict"},{"location":"developer/api/models/api_report/","text":"Report \u00b6 Data models for report production. ActivityColumnMetric dataclass \u00b6 ActivityColumnMetric ( activity , metric_column , metric_type = MetricType . NOT_SET , expression = '' ) This class provides granular control of the metric applied in each activity's column. is_valid \u00b6 is_valid () Checks if the activity column metric is valid. Returns: Type Description bool True if the activity column metric is valid else False. Source code in src/cplus_plugin/models/report.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def is_valid ( self ) -> bool : \"\"\"Checks if the activity column metric is valid. :returns: True if the activity column metric is valid else False. :rtype: bool \"\"\" if self . activity is None or self . metric_column is None : return False if self . metric_type == MetricType . NOT_SET : return False if not self . expression : return False return True ActivityContextInfo dataclass \u00b6 ActivityContextInfo ( activity , area , total_naturebase_carbon =- 1.0 ) Contains information about an activity for use in an expression context. BaseReportContext dataclass \u00b6 BaseReportContext ( template_path , name , project_file , feedback ) Common context information for generating a scenario report. MetricColumn dataclass \u00b6 MetricColumn ( name , header , expression , alignment = QtCore . Qt . AlignmentFlag . AlignHCenter , auto_calculated = False , format_as_number = True , number_formatter = QgsFallbackNumericFormat ) This class contains information required to create custom columns for the activity table in a scenario analysis report. create_default_column staticmethod \u00b6 create_default_column ( name , header , expression = '' ) Creates a default metric column. :py:attr: ~format_as_number is set to True and :py:attr: ~number_formatter is set to two decimals places with a thousands' comma separator. Parameters: Name Type Description Default name str Unique column name. required header str Label that will be used in the activity metrics table. required expression str Column expression. Default is an empty string. '' Returns: Type Description MetricColumn Metric column object. Source code in src/cplus_plugin/models/report.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @staticmethod def create_default_column ( name : str , header : str , expression : str = \"\" ) -> \"MetricColumn\" : \"\"\"Creates a default metric column. :py:attr:`~format_as_number` is set to True and :py:attr:`~number_formatter` is set to two decimals places with a thousands' comma separator. :param name: Unique column name. :type name: str :param header: Label that will be used in the activity metrics table. :type header: str :param expression: Column expression. Default is an empty string. :type expression: str :returns: Metric column object. :rtype: MetricColumn \"\"\" number_formatter = MetricColumn . default_formatter () column = MetricColumn ( name , header , expression ) column . number_formatter = number_formatter return column default_formatter staticmethod \u00b6 default_formatter () Returns a default number formatter with two decimals places and a comma for thousands' separator. Returns: Type Description QgsNumericFormat Basic number formatter. Source code in src/cplus_plugin/models/report.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @staticmethod def default_formatter () -> QgsNumericFormat : \"\"\"Returns a default number formatter with two decimals places and a comma for thousands' separator. :returns: Basic number formatter. :rtype: QgsNumericFormat \"\"\" number_formatter = QgsBasicNumericFormat () number_formatter . setThousandsSeparator ( \",\" ) number_formatter . setShowTrailingZeros ( True ) number_formatter . setNumberDecimalPlaces ( 2 ) return number_formatter to_qgs_column \u00b6 to_qgs_column () Convenience function that converts this object to a QgsLayoutTableColumn for use in a QgsLayoutTable. Returns: Type Description QgsLayoutTableColumn A layout column object containing the heading, horizontal alignment and width specified. Source code in src/cplus_plugin/models/report.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def to_qgs_column ( self ) -> QgsLayoutTableColumn : \"\"\"Convenience function that converts this object to a QgsLayoutTableColumn for use in a QgsLayoutTable. :returns: A layout column object containing the heading, horizontal alignment and width specified. :rtype: QgsLayoutTableColumn \"\"\" layout_column = QgsLayoutTableColumn ( self . header ) # Convert int to Qt.AlignmentFlag enum if needed (Qt6 compatibility) alignment = self . alignment if isinstance ( alignment , int ): alignment_map = { 1 : QtCore . Qt . AlignmentFlag . AlignLeft , 2 : QtCore . Qt . AlignmentFlag . AlignRight , 4 : QtCore . Qt . AlignmentFlag . AlignHCenter , 8 : QtCore . Qt . AlignmentFlag . AlignJustify , } alignment = alignment_map . get ( alignment , QtCore . Qt . AlignmentFlag . AlignHCenter ) layout_column . setHAlignment ( alignment ) layout_column . setWidth ( 0 ) return layout_column MetricConfiguration dataclass \u00b6 MetricConfiguration ( metric_columns , activity_metrics ) Container for metric column and activity column metric data models. activities property \u00b6 activities Gets the activity models in the configuration. Returns: Type Description typing.List[Activity] Activity models in the configuration. create staticmethod \u00b6 create () Creates an empty metric configuration. Returns: Type Description MetricConfiguration An empty metric configuration. Source code in src/cplus_plugin/models/report.py 293 294 295 296 297 298 299 300 @staticmethod def create () -> \"MetricConfiguration\" : \"\"\"Creates an empty metric configuration. :returns: An empty metric configuration. :rtype: MetricConfiguration \"\"\" return MetricConfiguration ([], [[]]) find \u00b6 find ( activity_id , name_header ) Returns a matching activity column metric model for the activity with the given UUID and the corresponding metric column name or header label. Parameters: Name Type Description Default activity_id str The activity's unique identifier. required name_header str The metric column name or header to match. required Returns: Type Description typing.Optional[ActivityColumnMetric] Matching column metric or None if not found. Source code in src/cplus_plugin/models/report.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def find ( self , activity_id : str , name_header : str ) -> typing . Optional [ ActivityColumnMetric ]: \"\"\"Returns a matching activity column metric model for the activity with the given UUID and the corresponding metric column name or header label. :param activity_id: The activity's unique identifier. :type activity_id: str :param name_header: The metric column name or header to match. :type name_header: str :returns: Matching column metric or None if not found. :rtype: typing.Optional[ActivityColumnMetric] \"\"\" def _search_list ( model_list : typing . List , activity_identifier : str , name : str ): for model in model_list : if isinstance ( model , list ): yield from _search_list ( model , activity_identifier , name ) else : if str ( model . activity . uuid ) == activity_identifier and ( model . metric_column . name == name or model . metric_column . name == name ): yield model match = next ( _search_list ( self . activity_metrics , activity_id , name_header ), - 1 ) return match if match != - 1 else None is_valid \u00b6 is_valid () Checks the validity of the configuration. It verifies if the number of metric columns matches the column mappings for activity metrics. Returns: Type Description bool True if the configuration is valid, else False. Source code in src/cplus_plugin/models/report.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def is_valid ( self ) -> bool : \"\"\"Checks the validity of the configuration. It verifies if the number of metric columns matches the column mappings for activity metrics. :returns: True if the configuration is valid, else False. :rtype: bool \"\"\" column_metrics_len = 0 if len ( self . activity_metrics ) > 0 : column_metrics_len = len ( self . activity_metrics [ 0 ]) return len ( self . metric_columns ) == column_metrics_len MetricConfigurationProfile dataclass \u00b6 MetricConfigurationProfile ( name , config ) Profile with unique identifiers for a metrics configuration. id property \u00b6 id Gets a cleaned profile name that has been stripped of spaces, special characters and in lower case. Returns: Type Description str Cleaned version of the name attribute. is_valid \u00b6 is_valid () Checks if the profile is valid. Checks if the name is specified or if the metric configuration is valid. Returns: Type Description bool True if the profile is valid else False. Source code in src/cplus_plugin/models/report.py 373 374 375 376 377 378 379 380 381 382 383 384 385 def is_valid ( self ) -> bool : \"\"\"Checks if the profile is valid. Checks if the name is specified or if the metric configuration is valid. :returns: True if the profile is valid else False. :rtype: bool \"\"\" if not self . name . strip () or not self . config . is_valid (): return False return True MetricEvalResult dataclass \u00b6 MetricEvalResult ( success , value ) Result of evaluating a metric. MetricProfileCollection dataclass \u00b6 MetricProfileCollection ( current_profile = '' , profiles = list ()) Collection of MetricConfigurationProfile objects. identifiers property \u00b6 identifiers Gets a collection of profile IDs and corresponding names. Invalid profiles are excluded from the collection. Returns: Type Description dict A collection of profile IDs and corresponding names. add_profile \u00b6 add_profile ( profile ) Add a metric profile to the collection. It checks if there is an existing profile with a similar ID and if the profile is valid. Parameters: Name Type Description Default profile MetricConfigurationProfile Metric profile to be added to the collection. required Returns: Type Description bool True if the metric profile was successfully added else False if the profile is invalid or there exists one with a similar ID in the collection. Source code in src/cplus_plugin/models/report.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def add_profile ( self , profile : MetricConfigurationProfile ) -> bool : \"\"\"Add a metric profile to the collection. It checks if there is an existing profile with a similar ID and if the profile is valid. :param profile: Metric profile to be added to the collection. :type profile: MetricConfigurationProfile :returns: True if the metric profile was successfully added else False if the profile is invalid or there exists one with a similar ID in the collection. :rtype: bool \"\"\" if not profile . is_valid () or self . profile_exists ( profile . id ): return False self . profiles . append ( profile ) return True get_current_profile \u00b6 get_current_profile () Helper function that retrieves the current metric profile if it has been specified in the attribute. Returns: Type Description MetricConfigurationProfile Current metric profile object or None if not specified or not found in the collection. Source code in src/cplus_plugin/models/report.py 473 474 475 476 477 478 479 480 481 482 483 484 def get_current_profile ( self ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Helper function that retrieves the current metric profile if it has been specified in the attribute. :returns: Current metric profile object or None if not specified or not found in the collection. :rtype: MetricConfigurationProfile \"\"\" if not self . current_profile : return None return self . get_profile ( self . current_profile ) get_profile \u00b6 get_profile ( profile_id ) Gets a metric profile with the given ID. Parameters: Name Type Description Default profile_id str ID of the metric profile to retrieve. required Returns: Type Description MetricConfigurationProfile Metric profile matching the given ID or None if not found. Source code in src/cplus_plugin/models/report.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def get_profile ( self , profile_id : str ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Gets a metric profile with the given ID. :param profile_id: ID of the metric profile to retrieve. :type profile_id: str :returns: Metric profile matching the given ID or None if not found. :rtype: MetricConfigurationProfile \"\"\" profiles = [ profile for profile in self . profiles if profile . id == profile_id ] return profiles [ 0 ] if profiles else None profile_exists \u00b6 profile_exists ( profile_id ) Checks if a profile with the given ID exists in the collection. Returns: Type Description bool True if the profile ID exists else False. Source code in src/cplus_plugin/models/report.py 411 412 413 414 415 416 417 def profile_exists ( self , profile_id : str ) -> bool : \"\"\"Checks if a profile with the given ID exists in the collection. :returns: True if the profile ID exists else False. :rtype: bool \"\"\" return profile_id in self . identifiers remove_profile \u00b6 remove_profile ( profile_id ) Remove a metric profile from the collection. Returns: Type Description bool True if the profile was successfully removed else False if the profile with the given ID does not exist in the collection. Source code in src/cplus_plugin/models/report.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def remove_profile ( self , profile_id : str ) -> bool : \"\"\"Remove a metric profile from the collection. :returns: True if the profile was successfully removed else False if the profile with the given ID does not exist in the collection. :rtype: bool \"\"\" if not self . profile_exists ( profile_id ): return False self . profiles = [ profile for profile in self . profiles if profile . id != profile_id ] return True MetricType \u00b6 Bases: IntEnum Type of metric or expression. from_int staticmethod \u00b6 from_int ( int_enum ) Creates the metric type enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the metric type. required Returns: Type Description MetricType Metric type enum corresponding to the given int else unknown if not found. Source code in src/cplus_plugin/models/report.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @staticmethod def from_int ( int_enum : int ) -> \"MetricType\" : \"\"\"Creates the metric type enum from the corresponding int equivalent. :param int_enum: Integer representing the metric type. :type int_enum: int :returns: Metric type enum corresponding to the given int else unknown if not found. :rtype: MetricType \"\"\" if int_enum == 0 : return MetricType . COLUMN elif int_enum == 1 : return MetricType . CELL elif int_enum == 2 : return MetricType . NOT_SET else : return MetricType . UNKNOWN RepeatAreaDimension dataclass \u00b6 RepeatAreaDimension ( rows , columns , width , height ) Contains information for rendering repeat model items such as scenarios or activities in a CPlus repeat item. ReportContext dataclass \u00b6 ReportContext ( template_path , name , project_file , feedback , scenario , scenario_output_dir , output_layer_name , custom_metrics ) Bases: BaseReportContext Context information for generating a scenario analysis report. ReportResult dataclass \u00b6 ReportResult ( success , scenario_id , output_dir , messages = tuple (), name = '' , base_file_name = '' ) Detailed result information from a report generation run. pdf_path property \u00b6 pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string. ReportSubmitStatus dataclass \u00b6 ReportSubmitStatus ( status , feedback , identifier ) Result of report submission process. ScenarioAreaInfo dataclass \u00b6 ScenarioAreaInfo ( name , identifier , area = dict ()) Contains information on the result of calculating a scenario's area. ScenarioComparisonReportContext dataclass \u00b6 ScenarioComparisonReportContext ( template_path , name , project_file , feedback , results , output_dir ) Bases: BaseReportContext Contextual information related to the generation of scenario comparison report.","title":"Report"},{"location":"developer/api/models/api_report/#report","text":"Data models for report production.","title":"Report"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ActivityColumnMetric","text":"ActivityColumnMetric ( activity , metric_column , metric_type = MetricType . NOT_SET , expression = '' ) This class provides granular control of the metric applied in each activity's column.","title":"ActivityColumnMetric"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ActivityColumnMetric.is_valid","text":"is_valid () Checks if the activity column metric is valid. Returns: Type Description bool True if the activity column metric is valid else False. Source code in src/cplus_plugin/models/report.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def is_valid ( self ) -> bool : \"\"\"Checks if the activity column metric is valid. :returns: True if the activity column metric is valid else False. :rtype: bool \"\"\" if self . activity is None or self . metric_column is None : return False if self . metric_type == MetricType . NOT_SET : return False if not self . expression : return False return True","title":"is_valid"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ActivityContextInfo","text":"ActivityContextInfo ( activity , area , total_naturebase_carbon =- 1.0 ) Contains information about an activity for use in an expression context.","title":"ActivityContextInfo"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.BaseReportContext","text":"BaseReportContext ( template_path , name , project_file , feedback ) Common context information for generating a scenario report.","title":"BaseReportContext"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricColumn","text":"MetricColumn ( name , header , expression , alignment = QtCore . Qt . AlignmentFlag . AlignHCenter , auto_calculated = False , format_as_number = True , number_formatter = QgsFallbackNumericFormat ) This class contains information required to create custom columns for the activity table in a scenario analysis report.","title":"MetricColumn"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricColumn.create_default_column","text":"create_default_column ( name , header , expression = '' ) Creates a default metric column. :py:attr: ~format_as_number is set to True and :py:attr: ~number_formatter is set to two decimals places with a thousands' comma separator. Parameters: Name Type Description Default name str Unique column name. required header str Label that will be used in the activity metrics table. required expression str Column expression. Default is an empty string. '' Returns: Type Description MetricColumn Metric column object. Source code in src/cplus_plugin/models/report.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @staticmethod def create_default_column ( name : str , header : str , expression : str = \"\" ) -> \"MetricColumn\" : \"\"\"Creates a default metric column. :py:attr:`~format_as_number` is set to True and :py:attr:`~number_formatter` is set to two decimals places with a thousands' comma separator. :param name: Unique column name. :type name: str :param header: Label that will be used in the activity metrics table. :type header: str :param expression: Column expression. Default is an empty string. :type expression: str :returns: Metric column object. :rtype: MetricColumn \"\"\" number_formatter = MetricColumn . default_formatter () column = MetricColumn ( name , header , expression ) column . number_formatter = number_formatter return column","title":"create_default_column"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricColumn.default_formatter","text":"default_formatter () Returns a default number formatter with two decimals places and a comma for thousands' separator. Returns: Type Description QgsNumericFormat Basic number formatter. Source code in src/cplus_plugin/models/report.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 @staticmethod def default_formatter () -> QgsNumericFormat : \"\"\"Returns a default number formatter with two decimals places and a comma for thousands' separator. :returns: Basic number formatter. :rtype: QgsNumericFormat \"\"\" number_formatter = QgsBasicNumericFormat () number_formatter . setThousandsSeparator ( \",\" ) number_formatter . setShowTrailingZeros ( True ) number_formatter . setNumberDecimalPlaces ( 2 ) return number_formatter","title":"default_formatter"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricColumn.to_qgs_column","text":"to_qgs_column () Convenience function that converts this object to a QgsLayoutTableColumn for use in a QgsLayoutTable. Returns: Type Description QgsLayoutTableColumn A layout column object containing the heading, horizontal alignment and width specified. Source code in src/cplus_plugin/models/report.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def to_qgs_column ( self ) -> QgsLayoutTableColumn : \"\"\"Convenience function that converts this object to a QgsLayoutTableColumn for use in a QgsLayoutTable. :returns: A layout column object containing the heading, horizontal alignment and width specified. :rtype: QgsLayoutTableColumn \"\"\" layout_column = QgsLayoutTableColumn ( self . header ) # Convert int to Qt.AlignmentFlag enum if needed (Qt6 compatibility) alignment = self . alignment if isinstance ( alignment , int ): alignment_map = { 1 : QtCore . Qt . AlignmentFlag . AlignLeft , 2 : QtCore . Qt . AlignmentFlag . AlignRight , 4 : QtCore . Qt . AlignmentFlag . AlignHCenter , 8 : QtCore . Qt . AlignmentFlag . AlignJustify , } alignment = alignment_map . get ( alignment , QtCore . Qt . AlignmentFlag . AlignHCenter ) layout_column . setHAlignment ( alignment ) layout_column . setWidth ( 0 ) return layout_column","title":"to_qgs_column"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfiguration","text":"MetricConfiguration ( metric_columns , activity_metrics ) Container for metric column and activity column metric data models.","title":"MetricConfiguration"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfiguration.activities","text":"activities Gets the activity models in the configuration. Returns: Type Description typing.List[Activity] Activity models in the configuration.","title":"activities"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfiguration.create","text":"create () Creates an empty metric configuration. Returns: Type Description MetricConfiguration An empty metric configuration. Source code in src/cplus_plugin/models/report.py 293 294 295 296 297 298 299 300 @staticmethod def create () -> \"MetricConfiguration\" : \"\"\"Creates an empty metric configuration. :returns: An empty metric configuration. :rtype: MetricConfiguration \"\"\" return MetricConfiguration ([], [[]])","title":"create"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfiguration.find","text":"find ( activity_id , name_header ) Returns a matching activity column metric model for the activity with the given UUID and the corresponding metric column name or header label. Parameters: Name Type Description Default activity_id str The activity's unique identifier. required name_header str The metric column name or header to match. required Returns: Type Description typing.Optional[ActivityColumnMetric] Matching column metric or None if not found. Source code in src/cplus_plugin/models/report.py 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def find ( self , activity_id : str , name_header : str ) -> typing . Optional [ ActivityColumnMetric ]: \"\"\"Returns a matching activity column metric model for the activity with the given UUID and the corresponding metric column name or header label. :param activity_id: The activity's unique identifier. :type activity_id: str :param name_header: The metric column name or header to match. :type name_header: str :returns: Matching column metric or None if not found. :rtype: typing.Optional[ActivityColumnMetric] \"\"\" def _search_list ( model_list : typing . List , activity_identifier : str , name : str ): for model in model_list : if isinstance ( model , list ): yield from _search_list ( model , activity_identifier , name ) else : if str ( model . activity . uuid ) == activity_identifier and ( model . metric_column . name == name or model . metric_column . name == name ): yield model match = next ( _search_list ( self . activity_metrics , activity_id , name_header ), - 1 ) return match if match != - 1 else None","title":"find"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfiguration.is_valid","text":"is_valid () Checks the validity of the configuration. It verifies if the number of metric columns matches the column mappings for activity metrics. Returns: Type Description bool True if the configuration is valid, else False. Source code in src/cplus_plugin/models/report.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def is_valid ( self ) -> bool : \"\"\"Checks the validity of the configuration. It verifies if the number of metric columns matches the column mappings for activity metrics. :returns: True if the configuration is valid, else False. :rtype: bool \"\"\" column_metrics_len = 0 if len ( self . activity_metrics ) > 0 : column_metrics_len = len ( self . activity_metrics [ 0 ]) return len ( self . metric_columns ) == column_metrics_len","title":"is_valid"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfigurationProfile","text":"MetricConfigurationProfile ( name , config ) Profile with unique identifiers for a metrics configuration.","title":"MetricConfigurationProfile"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfigurationProfile.id","text":"id Gets a cleaned profile name that has been stripped of spaces, special characters and in lower case. Returns: Type Description str Cleaned version of the name attribute.","title":"id"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricConfigurationProfile.is_valid","text":"is_valid () Checks if the profile is valid. Checks if the name is specified or if the metric configuration is valid. Returns: Type Description bool True if the profile is valid else False. Source code in src/cplus_plugin/models/report.py 373 374 375 376 377 378 379 380 381 382 383 384 385 def is_valid ( self ) -> bool : \"\"\"Checks if the profile is valid. Checks if the name is specified or if the metric configuration is valid. :returns: True if the profile is valid else False. :rtype: bool \"\"\" if not self . name . strip () or not self . config . is_valid (): return False return True","title":"is_valid"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricEvalResult","text":"MetricEvalResult ( success , value ) Result of evaluating a metric.","title":"MetricEvalResult"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection","text":"MetricProfileCollection ( current_profile = '' , profiles = list ()) Collection of MetricConfigurationProfile objects.","title":"MetricProfileCollection"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.identifiers","text":"identifiers Gets a collection of profile IDs and corresponding names. Invalid profiles are excluded from the collection. Returns: Type Description dict A collection of profile IDs and corresponding names.","title":"identifiers"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.add_profile","text":"add_profile ( profile ) Add a metric profile to the collection. It checks if there is an existing profile with a similar ID and if the profile is valid. Parameters: Name Type Description Default profile MetricConfigurationProfile Metric profile to be added to the collection. required Returns: Type Description bool True if the metric profile was successfully added else False if the profile is invalid or there exists one with a similar ID in the collection. Source code in src/cplus_plugin/models/report.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 def add_profile ( self , profile : MetricConfigurationProfile ) -> bool : \"\"\"Add a metric profile to the collection. It checks if there is an existing profile with a similar ID and if the profile is valid. :param profile: Metric profile to be added to the collection. :type profile: MetricConfigurationProfile :returns: True if the metric profile was successfully added else False if the profile is invalid or there exists one with a similar ID in the collection. :rtype: bool \"\"\" if not profile . is_valid () or self . profile_exists ( profile . id ): return False self . profiles . append ( profile ) return True","title":"add_profile"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.get_current_profile","text":"get_current_profile () Helper function that retrieves the current metric profile if it has been specified in the attribute. Returns: Type Description MetricConfigurationProfile Current metric profile object or None if not specified or not found in the collection. Source code in src/cplus_plugin/models/report.py 473 474 475 476 477 478 479 480 481 482 483 484 def get_current_profile ( self ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Helper function that retrieves the current metric profile if it has been specified in the attribute. :returns: Current metric profile object or None if not specified or not found in the collection. :rtype: MetricConfigurationProfile \"\"\" if not self . current_profile : return None return self . get_profile ( self . current_profile )","title":"get_current_profile"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.get_profile","text":"get_profile ( profile_id ) Gets a metric profile with the given ID. Parameters: Name Type Description Default profile_id str ID of the metric profile to retrieve. required Returns: Type Description MetricConfigurationProfile Metric profile matching the given ID or None if not found. Source code in src/cplus_plugin/models/report.py 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 def get_profile ( self , profile_id : str ) -> typing . Optional [ MetricConfigurationProfile ]: \"\"\"Gets a metric profile with the given ID. :param profile_id: ID of the metric profile to retrieve. :type profile_id: str :returns: Metric profile matching the given ID or None if not found. :rtype: MetricConfigurationProfile \"\"\" profiles = [ profile for profile in self . profiles if profile . id == profile_id ] return profiles [ 0 ] if profiles else None","title":"get_profile"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.profile_exists","text":"profile_exists ( profile_id ) Checks if a profile with the given ID exists in the collection. Returns: Type Description bool True if the profile ID exists else False. Source code in src/cplus_plugin/models/report.py 411 412 413 414 415 416 417 def profile_exists ( self , profile_id : str ) -> bool : \"\"\"Checks if a profile with the given ID exists in the collection. :returns: True if the profile ID exists else False. :rtype: bool \"\"\" return profile_id in self . identifiers","title":"profile_exists"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricProfileCollection.remove_profile","text":"remove_profile ( profile_id ) Remove a metric profile from the collection. Returns: Type Description bool True if the profile was successfully removed else False if the profile with the given ID does not exist in the collection. Source code in src/cplus_plugin/models/report.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 def remove_profile ( self , profile_id : str ) -> bool : \"\"\"Remove a metric profile from the collection. :returns: True if the profile was successfully removed else False if the profile with the given ID does not exist in the collection. :rtype: bool \"\"\" if not self . profile_exists ( profile_id ): return False self . profiles = [ profile for profile in self . profiles if profile . id != profile_id ] return True","title":"remove_profile"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricType","text":"Bases: IntEnum Type of metric or expression.","title":"MetricType"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.MetricType.from_int","text":"from_int ( int_enum ) Creates the metric type enum from the corresponding int equivalent. Parameters: Name Type Description Default int_enum int Integer representing the metric type. required Returns: Type Description MetricType Metric type enum corresponding to the given int else unknown if not found. Source code in src/cplus_plugin/models/report.py 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @staticmethod def from_int ( int_enum : int ) -> \"MetricType\" : \"\"\"Creates the metric type enum from the corresponding int equivalent. :param int_enum: Integer representing the metric type. :type int_enum: int :returns: Metric type enum corresponding to the given int else unknown if not found. :rtype: MetricType \"\"\" if int_enum == 0 : return MetricType . COLUMN elif int_enum == 1 : return MetricType . CELL elif int_enum == 2 : return MetricType . NOT_SET else : return MetricType . UNKNOWN","title":"from_int"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.RepeatAreaDimension","text":"RepeatAreaDimension ( rows , columns , width , height ) Contains information for rendering repeat model items such as scenarios or activities in a CPlus repeat item.","title":"RepeatAreaDimension"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportContext","text":"ReportContext ( template_path , name , project_file , feedback , scenario , scenario_output_dir , output_layer_name , custom_metrics ) Bases: BaseReportContext Context information for generating a scenario analysis report.","title":"ReportContext"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult","text":"ReportResult ( success , scenario_id , output_dir , messages = tuple (), name = '' , base_file_name = '' ) Detailed result information from a report generation run.","title":"ReportResult"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportResult.pdf_path","text":"pdf_path Returns the absolute path to the PDF file if the process completed successfully. Caller needs to verify if the file actually exists in the given location. :returns: Absolute path to the PDF file if the process completed successfully else an empty string.","title":"pdf_path"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ReportSubmitStatus","text":"ReportSubmitStatus ( status , feedback , identifier ) Result of report submission process.","title":"ReportSubmitStatus"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ScenarioAreaInfo","text":"ScenarioAreaInfo ( name , identifier , area = dict ()) Contains information on the result of calculating a scenario's area.","title":"ScenarioAreaInfo"},{"location":"developer/api/models/api_report/#src.cplus_plugin.models.report.ScenarioComparisonReportContext","text":"ScenarioComparisonReportContext ( template_path , name , project_file , feedback , results , output_dir ) Bases: BaseReportContext Contextual information related to the generation of scenario comparison report.","title":"ScenarioComparisonReportContext"},{"location":"developer/api/models/api_validation/","text":"Validation Data Classes \u00b6 Data models for validation of input datasets for generating scenarios. RuleConfiguration dataclass \u00b6 RuleConfiguration ( category , description , rule_name , recommendation = '' ) Context information for configuring a data validator. RuleInfo dataclass \u00b6 RuleInfo ( type , name ) Contains summary information on the rule type and corresponding friendly rule name (which is synced with the one in the RuleConfiguration object). RuleResult dataclass \u00b6 RuleResult ( config , recommendation , summary , validate_info = list ()) Contains information on the result of validating a single rule. category property \u00b6 category Returns the validation category of the specified rule. Returns: Type Description ValidationCategory Validation category of the specified rule. success property \u00b6 success Whether the result contains any warnings or errors depending on the rule configuration. :returns: True if there are no errors or warnings depending on the rule configuration, else False. RuleType \u00b6 Bases: IntEnum Types of validation that will be performed on the data. SubmitResult dataclass \u00b6 SubmitResult ( identifier , success , feedback = None ) Contains information on the status of submitting a set of layers for validation. ValidationCategory \u00b6 Bases: IntEnum Classification type of the validation. ValidationResult dataclass \u00b6 ValidationResult ( rule_results = list (), component_type = ModelComponentType . UNKNOWN ) Contains information on the result of validating multiple rules i.e. an aggregation of RuleResult objects. errors property \u00b6 errors Returns RuleResult objects that are of ERROR category and contain one or more error messages. Returns: Type Description list RuleResult objects that are of ERROR category and contain one or mor error messages. success property \u00b6 success Whether the result contains any warnings or errors based on the individual rule results. :returns: True if there are no errors or warnings for any of the RuleResult objects, else False. warnings property \u00b6 warnings Returns RuleResult objects that are of WARNING category and contain one or more error messages. Returns: Type Description list RuleResult objects that are of WARNING category and contain one or mor error messages. __iter__ \u00b6 __iter__ () Returns an iterable object containing the individual rule results. Source code in src/cplus_plugin/models/validation.py 155 156 157 def __iter__ ( self ): \"\"\"Returns an iterable object containing the individual rule results.\"\"\" return iter ( self . rule_results ) __len__ \u00b6 __len__ () Gets the number of rule results in the object. Returns: Type Description int The number of rule results in the object. Source code in src/cplus_plugin/models/validation.py 147 148 149 150 151 152 153 def __len__ ( self ) -> int : \"\"\"Gets the number of rule results in the object. :returns: The number of rule results in the object. :rtype: int \"\"\" return len ( self . rule_results )","title":"Validation"},{"location":"developer/api/models/api_validation/#validation-data-classes","text":"Data models for validation of input datasets for generating scenarios.","title":"Validation Data Classes"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleConfiguration","text":"RuleConfiguration ( category , description , rule_name , recommendation = '' ) Context information for configuring a data validator.","title":"RuleConfiguration"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleInfo","text":"RuleInfo ( type , name ) Contains summary information on the rule type and corresponding friendly rule name (which is synced with the one in the RuleConfiguration object).","title":"RuleInfo"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleResult","text":"RuleResult ( config , recommendation , summary , validate_info = list ()) Contains information on the result of validating a single rule.","title":"RuleResult"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleResult.category","text":"category Returns the validation category of the specified rule. Returns: Type Description ValidationCategory Validation category of the specified rule.","title":"category"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleResult.success","text":"success Whether the result contains any warnings or errors depending on the rule configuration. :returns: True if there are no errors or warnings depending on the rule configuration, else False.","title":"success"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.RuleType","text":"Bases: IntEnum Types of validation that will be performed on the data.","title":"RuleType"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.SubmitResult","text":"SubmitResult ( identifier , success , feedback = None ) Contains information on the status of submitting a set of layers for validation.","title":"SubmitResult"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationCategory","text":"Bases: IntEnum Classification type of the validation.","title":"ValidationCategory"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult","text":"ValidationResult ( rule_results = list (), component_type = ModelComponentType . UNKNOWN ) Contains information on the result of validating multiple rules i.e. an aggregation of RuleResult objects.","title":"ValidationResult"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult.errors","text":"errors Returns RuleResult objects that are of ERROR category and contain one or more error messages. Returns: Type Description list RuleResult objects that are of ERROR category and contain one or mor error messages.","title":"errors"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult.success","text":"success Whether the result contains any warnings or errors based on the individual rule results. :returns: True if there are no errors or warnings for any of the RuleResult objects, else False.","title":"success"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult.warnings","text":"warnings Returns RuleResult objects that are of WARNING category and contain one or more error messages. Returns: Type Description list RuleResult objects that are of WARNING category and contain one or mor error messages.","title":"warnings"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult.__iter__","text":"__iter__ () Returns an iterable object containing the individual rule results. Source code in src/cplus_plugin/models/validation.py 155 156 157 def __iter__ ( self ): \"\"\"Returns an iterable object containing the individual rule results.\"\"\" return iter ( self . rule_results )","title":"__iter__"},{"location":"developer/api/models/api_validation/#src.cplus_plugin.models.validation.ValidationResult.__len__","text":"__len__ () Gets the number of rule results in the object. Returns: Type Description int The number of rule results in the object. Source code in src/cplus_plugin/models/validation.py 147 148 149 150 151 152 153 def __len__ ( self ) -> int : \"\"\"Gets the number of rule results in the object. :returns: The number of rule results in the object. :rtype: int \"\"\" return len ( self . rule_results )","title":"__len__"},{"location":"developer/architecture/","text":"Architecture \u00b6 Frameworks used \u00b6 High-level system architecture \u00b6 Data model \u00b6","title":"Architecture"},{"location":"developer/architecture/#architecture","text":"","title":"Architecture"},{"location":"developer/architecture/#frameworks-used","text":"","title":"Frameworks used"},{"location":"developer/architecture/#high-level-system-architecture","text":"","title":"High-level system architecture"},{"location":"developer/architecture/#data-model","text":"","title":"Data model"},{"location":"developer/documentation/","text":"Working with documentation \u00b6 Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings . Install mkdocs \u00b6 Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements Creating a new project \u00b6 This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file Updating the mkdocs.yml file \u00b6 Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focuses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly mkdocstrings \u00b6 This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A detailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result: mkdocstrings options \u00b6 The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here . Serving the pages locally \u00b6 This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page Errors \u00b6 When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes. GitHub pages \u00b6 This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://ConservationInternational.github.io/cplus-plugin/","title":"Documentation"},{"location":"developer/documentation/#working-with-documentation","text":"Documentation is written using mkdocs . A detailed description on getting-started with mkdocs is available here . Developer documentation will be created and generated using mkdocstrings .","title":"Working with documentation"},{"location":"developer/documentation/#install-mkdocs","text":"Open the terminal Run \"pip install mkdocs\" This should install mkdocs and all requirements","title":"Install mkdocs"},{"location":"developer/documentation/#creating-a-new-project","text":"This should not be required as the mkdocs has been created already, but serves more of a guide for a user whom are new to mkdocs. Open the terminal Run \"mkdocs new .\" This will generate the documents folder with the home page index markdown file","title":"Creating a new project"},{"location":"developer/documentation/#updating-the-mkdocsyml-file","text":"Mostly, the only changes a user will need to make is to the nav section in the mkdocs.yml file ( Figure 1 ). Other options, such as the themes, plugins and extensions, should require no changes. Figure 1: Navigation example of mkdocs Here is an explanation on how the nav should be updated: It is important to keep to the structure of the mkdocs Each section focuses on a particular aspect, for example User will provide information on installing the plugin, a guide on how to use the plugin, etc. The order in which the nav is structured will determine the tabs order on the site, as shown in Figure 2 Figure 2: Tabs in a generated site Each tab, or group, will then be structured as in Figure 3 Figure 3: Structure created by markdown headings The additional titles (in the Plugin guide section in the above example) is based on the headings provided in the guide markdown file ( cplus_ui_guide.md in this case) Headings for each section should be short, but descriptive The section itself can have a more detailed description Add screenshots where possible. This will make the guide(s) user-friendly","title":"Updating the mkdocs.yml file"},{"location":"developer/documentation/#mkdocstrings","text":"This is an important aspect of documenting code. Using mkdocstrings is an easy and effective way of keeping track of classes, functions, etc. Any changes to the code will automatically update here, but the developer needs to make the changes in the code (comments) for this to happen. The comments for mkdocstrings is three sections: Description: A description on what the function does. A detailed description are welcome param: List of parameters for the function. Type and description should be included returns: A list of values which the function would return. Type should be included, with a description Here is an example of the end-result:","title":"mkdocstrings"},{"location":"developer/documentation/#mkdocstrings-options","text":"The user can also do fine-tuning of the resulting site. Here is a list of important options to be aware of: members, show_root_directory, show_source, and heading_level. heading_level : The header level of the content (functions, etc.) which will be added members : Only these function/classes will be shown show_root_directory : The root directory of the code Best will be to disable this, as it looks neater Here is an example of show_root_directory enabled, followed by an example when it is disabled: show_source : Shows the directory of the source code and a snippet of the code More information on this can be found here .","title":"mkdocstrings options"},{"location":"developer/documentation/#serving-the-pages-locally","text":"This step is useful when making changes and the user wants to test and review their changes to the mkdocs before creating a pull request. Open the terminal Run \"mkdocs serve\" Figure 4 shows an example of the result Figure 4: Console example of serving mkdocs On default, mkdocs is served to localhost:8000. But if the port is already in use, the user needs to provide a port number Run \"mkdocs serve -a localhost:8001\". The user can use a port number of their choosing Open the URL in a browser: localhost:8000 The Home page should be similar to Figure 5 Figure 5: Site example. This is the Home page","title":"Serving the pages locally"},{"location":"developer/documentation/#errors","text":"When performing the serve, mkdocs will automatically check for any errors. An example will be when a file linked in the documentation cannot be found ( Figure 6 ). Figure 6: Missing file example when serving mkdocs Be sure to check for such errors in the console prior to creating a pull request for your documentation changes.","title":"Errors"},{"location":"developer/documentation/#github-pages","text":"This is only required if it has not been set up on GitHub for the repository, or if it has been disabled. Only a user with admin rights to the repository will be able to do this. Go to the repository and click on Settings Click on Pages Set the branch to \"gh-pages\" Click Save Select the action Select Deploy Open the Run mkdocs gh-deploy section The URL should be https://ConservationInternational.github.io/cplus-plugin/","title":"GitHub pages"},{"location":"developer/setup/","text":"Setup \u00b6 To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/ Create virtual environment \u00b6 Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Setup"},{"location":"developer/setup/#setup","text":"To use the plugin for development purposes, clone the repository locally, install pip, a python dependencies management tool see https://pypi.org/project/pip/","title":"Setup"},{"location":"developer/setup/#create-virtual-environment","text":"Using any python virtual environment manager create project environment. Recommending to use virtualenv-wrapper . It can be installed using python pip pip install virtualenvwrapper Create virtual environment mkvirtualenv cplus Using the pip, install plugin development dependencies by running pip install -r requirements-dev.txt To install the plugin into the QGIS application, activate virtual environment and then use the below command python admin.py install","title":"Create virtual environment"},{"location":"user/","text":"Users \u00b6 The following sections aim to guide and help a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Conservation International"},{"location":"user/#users","text":"The following sections aim to guide and help a user on how to use the plugin. This is split into three sections: The quickstart tutorial shows how to install the plugin and help the user to get familiar with the platform. The user guide details common workflows in a tutorial format. The user manual describes the user interface and the various options of the plugin.","title":"Users"},{"location":"user/guide/","text":"CPLUS User Guide \u00b6 Welcome to the CPLUS user guide. In this section of the documentation, we aim to show users how to utilise the plugin effectively, customise their settings and so forth. Here is a brief overview of the content provided here: Complete Steps and Report: This section guides users on completing the steps of the analysis process and generating a comprehensive report based on the results. Preparing Data: Here, users can learn about preparing the data for analysis. Settings: The Settings section offers users the ability to customise various aspects of the plugin and reporting according to their preferences and requirements, such as configuring report information and advanced analysis parameters. Step 1: Step 1 documentation covers the initial setup phase of the analysis, including defining scenario details and parameters, selecting the area of interest, and setting up the map canvas extent. Step 2: Step 2 guides users through the process of defining NCS pathways and creating activities, including adding pathways to activities, editing activities, and configuring the ordering of pixel values for scenario output. Step 3: In Step 3, users learn how to prioritise activities by assigning raster layers depicting weighting factors like biodiversity to the activities using groups that can be assigned in order of importance. Step 4: Step 4 guides users in selecting outputs for saving into the file system to generate reports and choosing the processing option for processing the analysis. Logs: Access the comprehensive logs for the analysis in the Log option.","title":"Conservation International"},{"location":"user/guide/#cplus-user-guide","text":"Welcome to the CPLUS user guide. In this section of the documentation, we aim to show users how to utilise the plugin effectively, customise their settings and so forth. Here is a brief overview of the content provided here: Complete Steps and Report: This section guides users on completing the steps of the analysis process and generating a comprehensive report based on the results. Preparing Data: Here, users can learn about preparing the data for analysis. Settings: The Settings section offers users the ability to customise various aspects of the plugin and reporting according to their preferences and requirements, such as configuring report information and advanced analysis parameters. Step 1: Step 1 documentation covers the initial setup phase of the analysis, including defining scenario details and parameters, selecting the area of interest, and setting up the map canvas extent. Step 2: Step 2 guides users through the process of defining NCS pathways and creating activities, including adding pathways to activities, editing activities, and configuring the ordering of pixel values for scenario output. Step 3: In Step 3, users learn how to prioritise activities by assigning raster layers depicting weighting factors like biodiversity to the activities using groups that can be assigned in order of importance. Step 4: Step 4 guides users in selecting outputs for saving into the file system to generate reports and choosing the processing option for processing the analysis. Logs: Access the comprehensive logs for the analysis in the Log option.","title":"CPLUS User Guide"},{"location":"user/guide/complete-steps-and-report/","text":"Steps 1 to 3 example \u00b6 The following recording ( Figure 1 ) shows an example of how to do steps 1, 2 and 3. This is based on the pilot study area. Figure 1: Shows how to implement Steps 1, 2 and 3 in QGIS Processing \u00b6 Once the user has provided all desired parameters, click Run Scenario . The processing dialog will open ( Figure 2 ). The processing will take a while, depending on the number of activities and pathways provided for each activity. Click the Cancel button to stop the processing. Figure 2: Processing dialog while the algorithm is running Figure 3 will be the result of the processing if successful. The user should take note that the View Report button is now available. Figure 3: Processing dialog if successful Processing results \u00b6 The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 4 ): A group containing the Scenario results. Activity Maps : Non-weighted activities created by the user in Step 2. Weighted Activity Maps : Weighted activities based on the activities added in Step 2 and weighing set in Step 3. NCS Pathways Maps : Pathways used for each activity in Step 2. If an activity layer were provided as the activity in Step 2, this would contain no pathways. Figure 4: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed in Figure 5 Figure 5: A recording example of an example scenario Report generating \u00b6 Click the View Report button. The user will have the following options: Layout designer : Opens the report in the QGIS layout designer. Open PDF : Opens the report in PDF format. Help : Open the help documentation related to the reports. Figure 6: Report options Figure 7 shows an example of a report opened in the layout designer. Figure 7: Report opened in the QGIS layout designer Figure 8 shows a report in PDF format. Figure 8: PDF version of a report Generated report example \u00b6 Here is an example of how to open a report in the QGIS layout designer, or as a PDF ( Figure 9 ). Figure 9: Example of a generated report in PDF and layout designer formats","title":"Complete Steps and Report"},{"location":"user/guide/complete-steps-and-report/#steps-1-to-3-example","text":"The following recording ( Figure 1 ) shows an example of how to do steps 1, 2 and 3. This is based on the pilot study area. Figure 1: Shows how to implement Steps 1, 2 and 3 in QGIS","title":"Steps 1 to 3 example"},{"location":"user/guide/complete-steps-and-report/#processing","text":"Once the user has provided all desired parameters, click Run Scenario . The processing dialog will open ( Figure 2 ). The processing will take a while, depending on the number of activities and pathways provided for each activity. Click the Cancel button to stop the processing. Figure 2: Processing dialog while the algorithm is running Figure 3 will be the result of the processing if successful. The user should take note that the View Report button is now available. Figure 3: Processing dialog if successful","title":"Processing"},{"location":"user/guide/complete-steps-and-report/#processing-results","text":"The following groups and layers will be added to the QGIS canvas once the processing finishes (see Figure 4 ): A group containing the Scenario results. Activity Maps : Non-weighted activities created by the user in Step 2. Weighted Activity Maps : Weighted activities based on the activities added in Step 2 and weighing set in Step 3. NCS Pathways Maps : Pathways used for each activity in Step 2. If an activity layer were provided as the activity in Step 2, this would contain no pathways. Figure 4: Groups and layers added to the QGIS canvas An example of output results in QGIS is detailed in Figure 5 Figure 5: A recording example of an example scenario","title":"Processing results"},{"location":"user/guide/complete-steps-and-report/#report-generating","text":"Click the View Report button. The user will have the following options: Layout designer : Opens the report in the QGIS layout designer. Open PDF : Opens the report in PDF format. Help : Open the help documentation related to the reports. Figure 6: Report options Figure 7 shows an example of a report opened in the layout designer. Figure 7: Report opened in the QGIS layout designer Figure 8 shows a report in PDF format. Figure 8: PDF version of a report","title":"Report generating"},{"location":"user/guide/complete-steps-and-report/#generated-report-example","text":"Here is an example of how to open a report in the QGIS layout designer, or as a PDF ( Figure 9 ). Figure 9: Example of a generated report in PDF and layout designer formats","title":"Generated report example"},{"location":"user/guide/logs/","text":"Log \u00b6 Welcome to the Log Tab! This section provides comprehensive insights into scenario history and processing logs. Here is a quick guide to navigating this feature. Click on the 1\ufe0f\u20e3 Log option to access the log tab. Scenario History \u00b6 This section displays a record of past scenarios executed within the system. Offline Scenarios \u00b6 In this scenario, reports are stored locally and can be accessed even when the system is offline. To view the offline report, the user has to select the report and then click on refresh button, this will load the scenario. Online Scenarios \u00b6 In this scenario, reports are generated and stored on the server. To view the online report, the user has to select the report and then click on the refresh button, this will load the scenario. After the successful completion of report generation via running the scenario online, the user will receive an email confirming the successful completion of the report. Buttons Available \u00b6 Plus Icon: Click this button to save the scenario to the history section for review and analysis. Refresh Button: This button loads the selected scenario details into step 1. Information Icon: Click here to access helpful information and tips related to the selected scenario. Scenario Comparison Report: This button allows you to generate comparison report based on the selected scenarios. Minus Icon: Remove specific scenarios from the history section to streamline displayed records. Processing Log \u00b6 Here, you can view detailed logs of the current processing scenario. This log provides real-time insights into actions, events, and outcomes within the ongoing scenario. Usage Tips \u00b6 Use the scenario history to review past activities and performance trends. Utilise the processing log to monitor the progress of current scenarios and diagnose any issues. Take advantage of the available buttons to manage and customise your log viewing experience. By leveraging the Log Tab effectively, you can gain valuable insights into system activities, optimise performance, and streamline workflow processes. If you have any questions or need assistance, don't hesitate to reach out to our support team. Where reports will be stored? \u00b6 You can locate the report in the base directory folder. Within this folder, you will find all the scenario folders. Simply access the desired scenario folder to view the reports associated with that specific scenario. This organised structure allows for easy access to scenario-specific reports, facilitating efficient analysis and decision-making. How to Generate a Comparison Report \u00b6 This feature allows users to compare different scenarios and generate comprehensive reports that are saved in the base data directory specified in the CPLUS plugin settings. Steps to Generate a Comparison Report \u00b6 Step 1 Run the Scenario: Ensure the scenario you want to save runs successfully. Only successful scenarios can be saved and used for comparison. Step 2 Save Scenario History: After the scenario runs successfully, click on the 1\ufe0f\u20e3 plus icon to save the scenario history into the logs. Step 3 Select Scenarios for Comparison: Choose the scenarios you want to compare from the list of available logs. To select more than one scenario, hold down the Ctrl button while clicking on each scenario. Step 4 Initiate Comparison: Click on the 1\ufe0f\u20e3 Comparison icon to start the comparison. Upon clicking the icon, the comparison report generation will commence. A popup will appear showing a progress bar indicating the status of the report generation process. Step 5 Access the Comparison Report: Once the comparison report is generated, it will be saved in the base data directory specified in the CPLUS plugin settings. Go to the base data directory to access your comparison report. Components of the Comparison Report \u00b6 The comparison report includes the following key components: Scenario Activity Area Comparison Table: This table provides a detailed comparison of activity areas across the selected scenarios. It offers insights into how different activities perform in various areas, highlighting similarities and differences between scenarios. Scenario Maps: These maps provide a side-by-side comparison of the different scenarios selected for the report. They represent the final output of the highest position analysis done for each scenario, indicating which activities are best suited to each area in the stated area of interest. Following these steps will help you successfully generate a comparison report. Ensure your scenarios run successfully and are saved correctly to utilise the comparison functionality effectively.","title":"Logs"},{"location":"user/guide/logs/#log","text":"Welcome to the Log Tab! This section provides comprehensive insights into scenario history and processing logs. Here is a quick guide to navigating this feature. Click on the 1\ufe0f\u20e3 Log option to access the log tab.","title":"Log"},{"location":"user/guide/logs/#scenario-history","text":"This section displays a record of past scenarios executed within the system.","title":"Scenario History"},{"location":"user/guide/logs/#offline-scenarios","text":"In this scenario, reports are stored locally and can be accessed even when the system is offline. To view the offline report, the user has to select the report and then click on refresh button, this will load the scenario.","title":"Offline Scenarios"},{"location":"user/guide/logs/#online-scenarios","text":"In this scenario, reports are generated and stored on the server. To view the online report, the user has to select the report and then click on the refresh button, this will load the scenario. After the successful completion of report generation via running the scenario online, the user will receive an email confirming the successful completion of the report.","title":"Online Scenarios"},{"location":"user/guide/logs/#buttons-available","text":"Plus Icon: Click this button to save the scenario to the history section for review and analysis. Refresh Button: This button loads the selected scenario details into step 1. Information Icon: Click here to access helpful information and tips related to the selected scenario. Scenario Comparison Report: This button allows you to generate comparison report based on the selected scenarios. Minus Icon: Remove specific scenarios from the history section to streamline displayed records.","title":"Buttons Available"},{"location":"user/guide/logs/#processing-log","text":"Here, you can view detailed logs of the current processing scenario. This log provides real-time insights into actions, events, and outcomes within the ongoing scenario.","title":"Processing Log"},{"location":"user/guide/logs/#usage-tips","text":"Use the scenario history to review past activities and performance trends. Utilise the processing log to monitor the progress of current scenarios and diagnose any issues. Take advantage of the available buttons to manage and customise your log viewing experience. By leveraging the Log Tab effectively, you can gain valuable insights into system activities, optimise performance, and streamline workflow processes. If you have any questions or need assistance, don't hesitate to reach out to our support team.","title":"Usage Tips"},{"location":"user/guide/logs/#where-reports-will-be-stored","text":"You can locate the report in the base directory folder. Within this folder, you will find all the scenario folders. Simply access the desired scenario folder to view the reports associated with that specific scenario. This organised structure allows for easy access to scenario-specific reports, facilitating efficient analysis and decision-making.","title":"Where reports will be stored?"},{"location":"user/guide/logs/#how-to-generate-a-comparison-report","text":"This feature allows users to compare different scenarios and generate comprehensive reports that are saved in the base data directory specified in the CPLUS plugin settings.","title":"How to Generate a Comparison Report"},{"location":"user/guide/logs/#steps-to-generate-a-comparison-report","text":"Step 1 Run the Scenario: Ensure the scenario you want to save runs successfully. Only successful scenarios can be saved and used for comparison. Step 2 Save Scenario History: After the scenario runs successfully, click on the 1\ufe0f\u20e3 plus icon to save the scenario history into the logs. Step 3 Select Scenarios for Comparison: Choose the scenarios you want to compare from the list of available logs. To select more than one scenario, hold down the Ctrl button while clicking on each scenario. Step 4 Initiate Comparison: Click on the 1\ufe0f\u20e3 Comparison icon to start the comparison. Upon clicking the icon, the comparison report generation will commence. A popup will appear showing a progress bar indicating the status of the report generation process. Step 5 Access the Comparison Report: Once the comparison report is generated, it will be saved in the base data directory specified in the CPLUS plugin settings. Go to the base data directory to access your comparison report.","title":"Steps to Generate a Comparison Report"},{"location":"user/guide/logs/#components-of-the-comparison-report","text":"The comparison report includes the following key components: Scenario Activity Area Comparison Table: This table provides a detailed comparison of activity areas across the selected scenarios. It offers insights into how different activities perform in various areas, highlighting similarities and differences between scenarios. Scenario Maps: These maps provide a side-by-side comparison of the different scenarios selected for the report. They represent the final output of the highest position analysis done for each scenario, indicating which activities are best suited to each area in the stated area of interest. Following these steps will help you successfully generate a comparison report. Ensure your scenarios run successfully and are saved correctly to utilise the comparison functionality effectively.","title":"Components of the Comparison Report"},{"location":"user/guide/preparing-data/","text":"Preparing Data \u00b6 Data preparation is an important step before performing data analysis. This is especially true for spatial data (rasters and vector layers), as many factors play a role in the result. Here are some factors that need to be considered: The data should cover the same spatial extent or overlap each other. Coordinate systems are very important when it comes to the accuracy of your spatial analysis. For most analysis, a projected coordinate system (e.g. UTM, Albers Equal Area Conic, South African LO-system, etc.) is preferred, but also mandatory for the input raster datasets, above a geographic coordinate system (WGS84, Hartebeesthoek84, etc.). This is because calculating distances and areas is much more accurate with projected coordinate systems. The best practice will be to make use of the same coordinate system for each layer. Having a geographic coordinate for some layers, and projected coordinate systems for others, can have negative impacts on your results. When working with rasters, be sure that the nodata value is set correctly, otherwise, the nodata value will be unknown during analysis and will be considered as a normal pixel value. This value should be -9999. The plugin can only work with raster layers. If you have data in vector format, convert it to raster. The only applied vector datasets are the masking layers. Any outlier values need to be removed from the spatial data before performing analysis. Taking into account the above can greatly improve the analysis and the results produced from the analysis. This section will further deal with how to prepare your data using tools available in QGIS. Click Processing -> Toolbox to open the QGIS toolbox. The toolbox will be used for each section. Priority weighted layers \u00b6 Priority weighted layers (PWL) should not contain any nodata values. If the nodata pixels are not removed from the rasters, the user's analysis will be less efficient and likely result in a reduction in results (e.g. all nodata pixels will end up as nodata ). Figure 1 shows a Carbon raster with nodata pixels. Figure 1: Raster with nodata pixels Follow these easy steps to remove nodata pixels from a raster: In the toolbox search, type \"fill nodata \". Open the tool Fill nodata cells . Provide the parameters as follows: Raster input : Raster layer with nodata pixels which should be removed Fill value : Zero should suffice for most cases Output raster : Directory to which the filled raster should be stored Figure 2: QGIS Fill nodata cells Click Run Figure 3 shows a nodata filled raster. Figure 3: Raster with nodata pixels removed/filled Coordinate systems \u00b6 Fix layers with an undefined CRS \u00b6 Sometimes a spatial dataset might not have its coordinate system defined. This can cause issues and needs to be resolved before performing analysis. An unknown coordinate system can be identified as follows: Open the layer in QGIS. QGIS will show a warning next to the layer. This warning will explain that the coordinate system is not defined. Figure 4: Unknown CRS for a layer in QGIS Further investigation can be done by right-clicking on the layer and selecting Properties Click on the Information tab Scroll down to Coordinate Reference System (CRS) Unknown will be shown if the CRS is not set Figure 5: QGIS layer properties To define the CRS, do the following: Type \"assign projection\" in the toolbox search. Open the Assign Projection tool in the Raster Projections section. If it's a vector layer, open the Assign Projection tool in the Vector general section. Set the parameters as follows: Input layer : Layer which has an undefined CRS. Desired CRS : CRS which the layer coordinates are using. Click Run . Check if the layer is at its correct position in the QGIS canvas. Figure 6: QGIS Assign projection tool Be sure you are using the correct coordinate system when defining an unknown coordinate system to a layer. If the incorrect coordinate system is selected, the data will likely not be at the correct position spatially. Reprojecting (Warping) \u00b6 The best will be to convert each dataset in a geographic coordinate system to a projected coordinate system. Type warp in the QGIS toolbox search. Under Raster projections , select Warp . Figure 7: QGIS Warp tool Provide the following parameters: Input layer : Layer the user wants to reproject. Source CRS : Current CRS of the layer. Target CRS : The CRS to what the layer should be projected. Resampling method to use : Nearest Neighbour. Using other options will change pixel values, which we don't want. nodata value : Leave empty, except if the user wants to change the nodata value. Reprojected : The output file. Click Run . Do this for all geographic coordinate system rasters. As mentioned above, the best will be for all layers to make use of the same coordinate system. nodata value \u00b6 If a nodata value for a raster is not set correctly, it will be considered as a pixel value which is part of the analysis. This can have a negative impact on the analysis results. How to check if a raster's nodata is set correctly? Right-click on the raster in QGIS. Select Properties . Select the Information tab. Scroll down to the Bands section. Under No-data there should be a value i.e. -9999 If there is no value, this means that the nodata is not set correctly and therefore needs to be fixed. Figure 8: Layer properties to check for nodata value To fix a nodata issue, do the following: Type Translate in the toolbox search. Open the Translate tool under Raster Conversion . Figure 9: QGIS Translate tool Provide the following parameters: Input layer : Raster layer. Assign a specific nodata value to output bands : Provide a desired value here. -9999 will suffice for most cases. Converted : Output raster. This should solve a nodata issue with a raster. The Translate tool is to convert a raster to another format, but the user can still make use of the same format. This tool is useful to correctly set nodata values when needed. Outlier pixels/values \u00b6 A user must check if the raster data only includes pixel values within the range it should be. If there are any pixel values outside the range of accepted values, those pixels need to be removed. This can be accomplished using the Reclassify by table tool. Type reclassify by table in the QGIS toolbox search. Select the Reclassify by table tool. Set the parameters as follows: Raster layer : Layer to be reclassed. Band number : Like the first band. Reclassified raster : Output raster. Reclassification table : Rules for the reclassification (explanation follows). Figure 10: QGIS Reclassify by Table tool Open the Reclassification table so that the user can set the value of the reclassification. At least one row needs to be provided. Click Add Row . Provide a Minimum and Maximum value. Consider the following: The minimum must be less than the maximum if providing a range. If only a single value needs to be reclassified, set the Minimum and Maximum to the same value. Set the new Value for each row: Value has to be numeric. If a user wants to remove a pixel/value from the analysis, the value needs to be set to the nodata value of the raster (e.g. -9999). See the above section on the nodata value on how to find the nodata value of a raster. Figure 11: Reclassify table Click Run . An example of the resulting raster compared to the original raster is shown in Figure 12 . Figure 12: Reclassified raster compared to the original raster Vector to raster \u00b6 As mentioned above, the plugin can only work with raster layers. But often a user might have some data in vector format. This can easily be resolved by converting the vector layer to a raster, which can then be used as input to the plugin. Firstly, we want to convert the vector layer to make use of the same projected coordinate system as other data. This can be done as follows: Type Reproject layer in the QGIS toolbox search. Select the Reproject layer tool in the 'Vector general' section. Figure 13: QGIS Reproject tool for vector layers Set the parameters as follows: Input layer : Vector layer that needs to be reprojected. Target CRS : Coordinate system to which the layer should be reprojected, preferably a projected coordinate system. Reprojected : The output layer. Click Run Now that the vector layer is in the correct coordinate system, the user can convert the vector layer to a raster: Type rasterize in the QGIS toolbox search. Select Rasterize (vector to raster) . Figure 14: QGIS Rasterize tool Set the parameters as follows: Input layer : The vector layer to convert to a raster. Field to use to burn : Attribute field to use as the raster pixel values. A fixed value to burn : A default value for empty fields for a feature. Otherwise, leave as is. Output raster size units : Georeferenced units. Width and Height : Spatial resolution in meters. If the vector layer is in geographical coordinates, this distance will be degrees, not meters. Output extent : Leave as is, except if the user wants to limit the output to an extent Assign a specific nodata value to output bands : -9999 will suffice for most cases Rasterized : The output raster. Click Run . The user's data should now be ready for analysis.","title":"Preparing Data"},{"location":"user/guide/preparing-data/#preparing-data","text":"Data preparation is an important step before performing data analysis. This is especially true for spatial data (rasters and vector layers), as many factors play a role in the result. Here are some factors that need to be considered: The data should cover the same spatial extent or overlap each other. Coordinate systems are very important when it comes to the accuracy of your spatial analysis. For most analysis, a projected coordinate system (e.g. UTM, Albers Equal Area Conic, South African LO-system, etc.) is preferred, but also mandatory for the input raster datasets, above a geographic coordinate system (WGS84, Hartebeesthoek84, etc.). This is because calculating distances and areas is much more accurate with projected coordinate systems. The best practice will be to make use of the same coordinate system for each layer. Having a geographic coordinate for some layers, and projected coordinate systems for others, can have negative impacts on your results. When working with rasters, be sure that the nodata value is set correctly, otherwise, the nodata value will be unknown during analysis and will be considered as a normal pixel value. This value should be -9999. The plugin can only work with raster layers. If you have data in vector format, convert it to raster. The only applied vector datasets are the masking layers. Any outlier values need to be removed from the spatial data before performing analysis. Taking into account the above can greatly improve the analysis and the results produced from the analysis. This section will further deal with how to prepare your data using tools available in QGIS. Click Processing -> Toolbox to open the QGIS toolbox. The toolbox will be used for each section.","title":"Preparing Data"},{"location":"user/guide/preparing-data/#priority-weighted-layers","text":"Priority weighted layers (PWL) should not contain any nodata values. If the nodata pixels are not removed from the rasters, the user's analysis will be less efficient and likely result in a reduction in results (e.g. all nodata pixels will end up as nodata ). Figure 1 shows a Carbon raster with nodata pixels. Figure 1: Raster with nodata pixels Follow these easy steps to remove nodata pixels from a raster: In the toolbox search, type \"fill nodata \". Open the tool Fill nodata cells . Provide the parameters as follows: Raster input : Raster layer with nodata pixels which should be removed Fill value : Zero should suffice for most cases Output raster : Directory to which the filled raster should be stored Figure 2: QGIS Fill nodata cells Click Run Figure 3 shows a nodata filled raster. Figure 3: Raster with nodata pixels removed/filled","title":"Priority weighted layers"},{"location":"user/guide/preparing-data/#coordinate-systems","text":"","title":"Coordinate systems"},{"location":"user/guide/preparing-data/#fix-layers-with-an-undefined-crs","text":"Sometimes a spatial dataset might not have its coordinate system defined. This can cause issues and needs to be resolved before performing analysis. An unknown coordinate system can be identified as follows: Open the layer in QGIS. QGIS will show a warning next to the layer. This warning will explain that the coordinate system is not defined. Figure 4: Unknown CRS for a layer in QGIS Further investigation can be done by right-clicking on the layer and selecting Properties Click on the Information tab Scroll down to Coordinate Reference System (CRS) Unknown will be shown if the CRS is not set Figure 5: QGIS layer properties To define the CRS, do the following: Type \"assign projection\" in the toolbox search. Open the Assign Projection tool in the Raster Projections section. If it's a vector layer, open the Assign Projection tool in the Vector general section. Set the parameters as follows: Input layer : Layer which has an undefined CRS. Desired CRS : CRS which the layer coordinates are using. Click Run . Check if the layer is at its correct position in the QGIS canvas. Figure 6: QGIS Assign projection tool Be sure you are using the correct coordinate system when defining an unknown coordinate system to a layer. If the incorrect coordinate system is selected, the data will likely not be at the correct position spatially.","title":"Fix layers with an undefined CRS"},{"location":"user/guide/preparing-data/#reprojecting-warping","text":"The best will be to convert each dataset in a geographic coordinate system to a projected coordinate system. Type warp in the QGIS toolbox search. Under Raster projections , select Warp . Figure 7: QGIS Warp tool Provide the following parameters: Input layer : Layer the user wants to reproject. Source CRS : Current CRS of the layer. Target CRS : The CRS to what the layer should be projected. Resampling method to use : Nearest Neighbour. Using other options will change pixel values, which we don't want. nodata value : Leave empty, except if the user wants to change the nodata value. Reprojected : The output file. Click Run . Do this for all geographic coordinate system rasters. As mentioned above, the best will be for all layers to make use of the same coordinate system.","title":"Reprojecting (Warping)"},{"location":"user/guide/preparing-data/#nodata-value","text":"If a nodata value for a raster is not set correctly, it will be considered as a pixel value which is part of the analysis. This can have a negative impact on the analysis results. How to check if a raster's nodata is set correctly? Right-click on the raster in QGIS. Select Properties . Select the Information tab. Scroll down to the Bands section. Under No-data there should be a value i.e. -9999 If there is no value, this means that the nodata is not set correctly and therefore needs to be fixed. Figure 8: Layer properties to check for nodata value To fix a nodata issue, do the following: Type Translate in the toolbox search. Open the Translate tool under Raster Conversion . Figure 9: QGIS Translate tool Provide the following parameters: Input layer : Raster layer. Assign a specific nodata value to output bands : Provide a desired value here. -9999 will suffice for most cases. Converted : Output raster. This should solve a nodata issue with a raster. The Translate tool is to convert a raster to another format, but the user can still make use of the same format. This tool is useful to correctly set nodata values when needed.","title":"nodata value"},{"location":"user/guide/preparing-data/#outlier-pixelsvalues","text":"A user must check if the raster data only includes pixel values within the range it should be. If there are any pixel values outside the range of accepted values, those pixels need to be removed. This can be accomplished using the Reclassify by table tool. Type reclassify by table in the QGIS toolbox search. Select the Reclassify by table tool. Set the parameters as follows: Raster layer : Layer to be reclassed. Band number : Like the first band. Reclassified raster : Output raster. Reclassification table : Rules for the reclassification (explanation follows). Figure 10: QGIS Reclassify by Table tool Open the Reclassification table so that the user can set the value of the reclassification. At least one row needs to be provided. Click Add Row . Provide a Minimum and Maximum value. Consider the following: The minimum must be less than the maximum if providing a range. If only a single value needs to be reclassified, set the Minimum and Maximum to the same value. Set the new Value for each row: Value has to be numeric. If a user wants to remove a pixel/value from the analysis, the value needs to be set to the nodata value of the raster (e.g. -9999). See the above section on the nodata value on how to find the nodata value of a raster. Figure 11: Reclassify table Click Run . An example of the resulting raster compared to the original raster is shown in Figure 12 . Figure 12: Reclassified raster compared to the original raster","title":"Outlier pixels/values"},{"location":"user/guide/preparing-data/#vector-to-raster","text":"As mentioned above, the plugin can only work with raster layers. But often a user might have some data in vector format. This can easily be resolved by converting the vector layer to a raster, which can then be used as input to the plugin. Firstly, we want to convert the vector layer to make use of the same projected coordinate system as other data. This can be done as follows: Type Reproject layer in the QGIS toolbox search. Select the Reproject layer tool in the 'Vector general' section. Figure 13: QGIS Reproject tool for vector layers Set the parameters as follows: Input layer : Vector layer that needs to be reprojected. Target CRS : Coordinate system to which the layer should be reprojected, preferably a projected coordinate system. Reprojected : The output layer. Click Run Now that the vector layer is in the correct coordinate system, the user can convert the vector layer to a raster: Type rasterize in the QGIS toolbox search. Select Rasterize (vector to raster) . Figure 14: QGIS Rasterize tool Set the parameters as follows: Input layer : The vector layer to convert to a raster. Field to use to burn : Attribute field to use as the raster pixel values. A fixed value to burn : A default value for empty fields for a feature. Otherwise, leave as is. Output raster size units : Georeferenced units. Width and Height : Spatial resolution in meters. If the vector layer is in geographical coordinates, this distance will be degrees, not meters. Output extent : Leave as is, except if the user wants to limit the output to an extent Assign a specific nodata value to output bands : -9999 will suffice for most cases Rasterized : The output raster. Click Run . The user's data should now be ready for analysis.","title":"Vector to raster"},{"location":"user/guide/settings/","text":"How to apply CPLUS settings? \u00b6 The CPLUS settings provide users with a customizable interface to configure various aspects of the platform according to their needs and preferences. Users can access the CPLUS settings through either the QGIS options or the CPLUS toolbar. Accessing CPLUS Settings \u00b6 QGIS options ( Figure 1 ): Click on Settings -> Options Figure 1: QGIS settings Select the CPLUS tab to the left. This will open the CPLUS settings dialog. See Figure 2 for an example. Figure 2: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 3 ): Click on the CPLUS toolbar drop-down. Select Settings . This will take you directly to the CPLUS settings dialog in the QGIS options. Figure 3: CPLUS toolbar button A short description of each available setting a user can change. Most are optional, but the user needs to set the base directory as it's a requirement for the processing to work (e.g. outputs are stored in the base directory). Another important option to consider is snapping, as it will improve analysis results. Overview of Available Settings \u00b6 Configure Analysis: Settings will be added as the plugin development continues. Click on the CPLUS Tab to view the setting options \u00b6 Once you click on the CPLUS Tab you will see the all available setting options. Click on the arrow to expand the setting options. General \u00b6 Click on the 1\ufe0f\u20e3 Three dots to select a file from your system to set as the base directory. Scenario Analysis \u00b6 Enter the 1\ufe0f\u20e3 Coefficient for carbon layers which will be applied to carbon layers during processing. Enter the 2\ufe0f\u20e3 Pathway suitability index the index multiplied to the pathways. Lower values mean the pathway is less important, and higher values mean it's more important. Snapping \u00b6 Snapping will set the rasters to match the cell alignment of a reference layer. Resampling performed on pixel values. You can choose the method of your choice from the dropdown. Click on the 3\ufe0f\u20e3 Resample method dropdown to choose the method. The reference layer to which the cell alignment will be applied. You can select a file from the system, by clicking on the 4\ufe0f\u20e3 Three dots . Rescale values according to cell size. You can check or uncheck the 5\ufe0f\u20e3 CheckBox . Naturebase CRS Snapping \u00b6 The Naturebase dataset should be automatically reprojected so that it can be used properly in analysis within the plugin. This automatic reprojection happens as when the user activates the Snapping option. When a user attempts to run an analysis the plugin verifies CRS compatibility before allowing the analysis. If there is a non-compatibility issue the user receives a notification that the CRS needs to be adjusted in the Validation Inspector window that appears when a user starts an analysis. Sieve Function \u00b6 The Sieve function is a tool designed to filter raster data based on a specified pixel size. This function allows users to define a minimum area threshold, ensuring that any contiguous area in the raster dataset smaller than the specified size will be removed or filtered out. This feature is particularly useful for projects requiring a minimum spatial extent to be meaningful or practical. Steps to Use the Sieve Function \u00b6 Navigate to the settings where the sieve function can be configured. Check the 1\ufe0f\u20e3 checkbox available in front of the Sieve option to enable the sieve function. Enter the desired threshold value in the 2\ufe0f\u20e3 Threshold field. This value represents the minimum number of connected pixels that should be preserved when sieving. Any contiguous area smaller than this threshold will be filtered out. Select the 3\ufe0f\u20e3 Reference Layer from the system to which the sieve function will be applied. Click on the 4\ufe0f\u20e3 OK button to apply the sieve function settings. This will filter the raster data based on the specified pixel size and reference layer. Click on the Cancel button to close the dialog without applying any changes. Practical Use Cases \u00b6 The sieve function is particularly useful in scenarios where a minimum spatial extent is necessary for practical or meaningful activities. For example: Land Management: Ensuring that only parcels of land larger than a hectare are considered for agricultural projects. Environmental Studies: Filtering out small, insignificant areas from raster data to focus on larger, more relevant features. By setting the desired pixel size, users can streamline their data analysis, ensuring that only relevant spatial entities are considered for further processing or analysis. Mask Layer \u00b6 Masking layers are used to specify areas that should be excluded from further analysis. You can use the available buttons to add, edit and remove the layers. Click on the Plus icon to add the layer. Click on the Edit icon to edit the layer. Click on the Minus icon to remove the layer. Irrecoverable Carbon Reference Layer \u00b6 The Irrecoverable Carbon layer is used in a calculation with the protected pathways to calculate the total irrecoverable carbon per activity. Local Path To use the Local path you are required to click on the 1\ufe0f\u20e3 Local path radio button, after this enter the local path of the irrecoverable carbon layer in the 2\ufe0f\u20e3 Input field manually or click on the 3\ufe0f\u20e3 Three dots to select the file from the system. Online Source To use the Online source , you are required to click on the 1\ufe0f\u20e3 Online source radio button. After that, enter the source URL in the 2\ufe0f\u20e3 URL field and provide the location and name of the source in the 3\ufe0f\u20e3 Save as field manually, or click on the 4\ufe0f\u20e3 Three dots to select the location from the file explorer. After filling in the details, click on the 5\ufe0f\u20e3 Start download button to download the Irrecoverable Carbon layer. You can track the download progress in the 6\ufe0f\u20e3 Download progress field. There are three phases in the download process: Download not started , Download ongoing , and Download successful . If the Irrecoverable Carbon is not found then you will receive the following error. If the download process is interrupted, you will encounter an error message. Trends.Earth Account Information \u00b6 NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. Trends.Earth Registration \u00b6 Click on the Register for Trends.Earth (Step 1) button to initiate the registration process for Trends.Earth. Upon clicking, a registration form will open. Enter the required details and click on the OK button to submit the form. After clicking the OK button, a success message will pop up. You will receive an email at the email address entered in the form. This email will contain the username and password needed to complete the setup. Set Master Authentication Password \u00b6 After successful registration, a pop-up will prompt you to set a new master authentication password. Always enable the Store/Update master password in your Wallet/Keyring option to save the password securely in the Wallet/Keyring of your computer. Once set, the master password can be reset; however, the current master password will be needed prior to resetting. During the reset process, there is an option to generate a complete backup of the current database. Important: If the user forgets the master password, there is no way to retrieve or override it. There is also no means of retrieving encrypted information without knowing the master password. If a user inputs their existing password incorrectly three times, the dialog will offer to erase the database. Reminder: Do not forget your master password and store it securely for later use, as it is not retrievable. Enter the password in the Required field and again in the Verify password field for confirmation. Enable the Store/Update master password in your Wallet/KeyRing checkbox to save the password securely in your computer's Wallet/KeyRing. Click the OK button to submit and set the master password. Trends.Earth Login \u00b6 Click on the Enter username and password (step 2) button to log in to Trends.Earth account. Upon clicking on this button the Trends.Earth login form will open. To log in enter the email and password in the respective fields. Click on the OK button to log in to the Trends.Earth account. After successful submission, the success message will pop up. Update profile \u00b6 Click on the Update profile button to update the profile. Upon clicking the update profile form will open. You can update the fields you want to change by editing the respective fields. Click on the Save button to save the changes. After successful updating, a success message will pop up. Reset password \u00b6 Click on the Reset Password button to reset the password. Upon clicking the reset password form will open. Enter the email address in the provided field. Click the OK button to submit the email address and request a password reset. Click the Cancel button to cancel the password reset request and exit the form. Upon clicking the OK button, a confirmation popup will open with the following message: Are you sure you want to reset your password for xyz@gmail.com? Your new password will be mailed to you. Click the No button to cancel the password reset and close the confirmation popup. Click the Yes button to confirm the password reset. An email with your new password will be sent to you. On successful submission, the success message popup will be shown to the user. The user will receive an email with the new password. Delete user \u00b6 Click on the Delete user button to delete the user. Upon clicking the button, the Delete user confirmation pop up will open. The pop up will have text saying, \"Are you sure you want to delete the user xyz@gmail.com? All your tasks will be lost and you will no longer be able to process data online using Trends.Earth.\" Click the No button to cancel the deletion and close the form. Click the Yes button to confirm the deletion of the user. This will permanently delete your account and all associated tasks. Reports \u00b6 Click on the Reporting option for reports-related settings. Under the Reporting settings, users can configure the information to be included in the generated reports. These settings include: Organisation : (optional) Organisation or institute name. Contact email : (optional) Contact email of the user. Website : (optional) Link to the website of your company or institute. Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.). Logo preview : Visual preview of the default CI logo, or the custom logo a user selected. Footer : (optional) Will be added to the report. Disclaimer : Change as desired, otherwise use the default disclaimer. License : Change as desired, otherwise use the default license description. List of stakeholders and relationships : Enter the stakeholder's name and a brief description of the relationship separated by a dash i.e. Stakeholder's name - Relationship description Each entry should be in a new line. Cultural considerations : Enter the cultural considerations and a brief description separated by a dash i.e. Cultural considerations - description Each entry should be in a new line. Cultural Policies : Enter the cultural policies and a brief description separated by a dash i.e. Cultural policies - description Each entry should be in a new line. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes. Overall, the CPLUS settings offer users the flexibility to tailor the platform to their specific requirements and optimise their workflow for conducting analyses and generating reports.","title":"Settings"},{"location":"user/guide/settings/#how-to-apply-cplus-settings","text":"The CPLUS settings provide users with a customizable interface to configure various aspects of the platform according to their needs and preferences. Users can access the CPLUS settings through either the QGIS options or the CPLUS toolbar.","title":"How to apply CPLUS settings?"},{"location":"user/guide/settings/#accessing-cplus-settings","text":"QGIS options ( Figure 1 ): Click on Settings -> Options Figure 1: QGIS settings Select the CPLUS tab to the left. This will open the CPLUS settings dialog. See Figure 2 for an example. Figure 2: CPLUS section as loaded in the QGIS settings dialog CPLUS toolbar ( Figure 3 ): Click on the CPLUS toolbar drop-down. Select Settings . This will take you directly to the CPLUS settings dialog in the QGIS options. Figure 3: CPLUS toolbar button A short description of each available setting a user can change. Most are optional, but the user needs to set the base directory as it's a requirement for the processing to work (e.g. outputs are stored in the base directory). Another important option to consider is snapping, as it will improve analysis results.","title":"Accessing CPLUS Settings"},{"location":"user/guide/settings/#overview-of-available-settings","text":"Configure Analysis: Settings will be added as the plugin development continues.","title":"Overview of Available Settings"},{"location":"user/guide/settings/#click-on-the-cplus-tab-to-view-the-setting-options","text":"Once you click on the CPLUS Tab you will see the all available setting options. Click on the arrow to expand the setting options.","title":"Click on the CPLUS Tab to view the setting options"},{"location":"user/guide/settings/#general","text":"Click on the 1\ufe0f\u20e3 Three dots to select a file from your system to set as the base directory.","title":"General"},{"location":"user/guide/settings/#scenario-analysis","text":"Enter the 1\ufe0f\u20e3 Coefficient for carbon layers which will be applied to carbon layers during processing. Enter the 2\ufe0f\u20e3 Pathway suitability index the index multiplied to the pathways. Lower values mean the pathway is less important, and higher values mean it's more important.","title":"Scenario Analysis"},{"location":"user/guide/settings/#snapping","text":"Snapping will set the rasters to match the cell alignment of a reference layer. Resampling performed on pixel values. You can choose the method of your choice from the dropdown. Click on the 3\ufe0f\u20e3 Resample method dropdown to choose the method. The reference layer to which the cell alignment will be applied. You can select a file from the system, by clicking on the 4\ufe0f\u20e3 Three dots . Rescale values according to cell size. You can check or uncheck the 5\ufe0f\u20e3 CheckBox .","title":"Snapping"},{"location":"user/guide/settings/#naturebase-crs-snapping","text":"The Naturebase dataset should be automatically reprojected so that it can be used properly in analysis within the plugin. This automatic reprojection happens as when the user activates the Snapping option. When a user attempts to run an analysis the plugin verifies CRS compatibility before allowing the analysis. If there is a non-compatibility issue the user receives a notification that the CRS needs to be adjusted in the Validation Inspector window that appears when a user starts an analysis.","title":"Naturebase CRS Snapping"},{"location":"user/guide/settings/#sieve-function","text":"The Sieve function is a tool designed to filter raster data based on a specified pixel size. This function allows users to define a minimum area threshold, ensuring that any contiguous area in the raster dataset smaller than the specified size will be removed or filtered out. This feature is particularly useful for projects requiring a minimum spatial extent to be meaningful or practical.","title":"Sieve Function"},{"location":"user/guide/settings/#steps-to-use-the-sieve-function","text":"Navigate to the settings where the sieve function can be configured. Check the 1\ufe0f\u20e3 checkbox available in front of the Sieve option to enable the sieve function. Enter the desired threshold value in the 2\ufe0f\u20e3 Threshold field. This value represents the minimum number of connected pixels that should be preserved when sieving. Any contiguous area smaller than this threshold will be filtered out. Select the 3\ufe0f\u20e3 Reference Layer from the system to which the sieve function will be applied. Click on the 4\ufe0f\u20e3 OK button to apply the sieve function settings. This will filter the raster data based on the specified pixel size and reference layer. Click on the Cancel button to close the dialog without applying any changes.","title":"Steps to Use the Sieve Function"},{"location":"user/guide/settings/#practical-use-cases","text":"The sieve function is particularly useful in scenarios where a minimum spatial extent is necessary for practical or meaningful activities. For example: Land Management: Ensuring that only parcels of land larger than a hectare are considered for agricultural projects. Environmental Studies: Filtering out small, insignificant areas from raster data to focus on larger, more relevant features. By setting the desired pixel size, users can streamline their data analysis, ensuring that only relevant spatial entities are considered for further processing or analysis.","title":"Practical Use Cases"},{"location":"user/guide/settings/#mask-layer","text":"Masking layers are used to specify areas that should be excluded from further analysis. You can use the available buttons to add, edit and remove the layers. Click on the Plus icon to add the layer. Click on the Edit icon to edit the layer. Click on the Minus icon to remove the layer.","title":"Mask Layer"},{"location":"user/guide/settings/#irrecoverable-carbon-reference-layer","text":"The Irrecoverable Carbon layer is used in a calculation with the protected pathways to calculate the total irrecoverable carbon per activity. Local Path To use the Local path you are required to click on the 1\ufe0f\u20e3 Local path radio button, after this enter the local path of the irrecoverable carbon layer in the 2\ufe0f\u20e3 Input field manually or click on the 3\ufe0f\u20e3 Three dots to select the file from the system. Online Source To use the Online source , you are required to click on the 1\ufe0f\u20e3 Online source radio button. After that, enter the source URL in the 2\ufe0f\u20e3 URL field and provide the location and name of the source in the 3\ufe0f\u20e3 Save as field manually, or click on the 4\ufe0f\u20e3 Three dots to select the location from the file explorer. After filling in the details, click on the 5\ufe0f\u20e3 Start download button to download the Irrecoverable Carbon layer. You can track the download progress in the 6\ufe0f\u20e3 Download progress field. There are three phases in the download process: Download not started , Download ongoing , and Download successful . If the Irrecoverable Carbon is not found then you will receive the following error. If the download process is interrupted, you will encounter an error message.","title":"Irrecoverable Carbon Reference Layer"},{"location":"user/guide/settings/#trendsearth-account-information","text":"NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS.","title":"Trends.Earth Account Information"},{"location":"user/guide/settings/#trendsearth-registration","text":"Click on the Register for Trends.Earth (Step 1) button to initiate the registration process for Trends.Earth. Upon clicking, a registration form will open. Enter the required details and click on the OK button to submit the form. After clicking the OK button, a success message will pop up. You will receive an email at the email address entered in the form. This email will contain the username and password needed to complete the setup.","title":"Trends.Earth Registration"},{"location":"user/guide/settings/#set-master-authentication-password","text":"After successful registration, a pop-up will prompt you to set a new master authentication password. Always enable the Store/Update master password in your Wallet/Keyring option to save the password securely in the Wallet/Keyring of your computer. Once set, the master password can be reset; however, the current master password will be needed prior to resetting. During the reset process, there is an option to generate a complete backup of the current database. Important: If the user forgets the master password, there is no way to retrieve or override it. There is also no means of retrieving encrypted information without knowing the master password. If a user inputs their existing password incorrectly three times, the dialog will offer to erase the database. Reminder: Do not forget your master password and store it securely for later use, as it is not retrievable. Enter the password in the Required field and again in the Verify password field for confirmation. Enable the Store/Update master password in your Wallet/KeyRing checkbox to save the password securely in your computer's Wallet/KeyRing. Click the OK button to submit and set the master password.","title":"Set Master Authentication Password"},{"location":"user/guide/settings/#trendsearth-login","text":"Click on the Enter username and password (step 2) button to log in to Trends.Earth account. Upon clicking on this button the Trends.Earth login form will open. To log in enter the email and password in the respective fields. Click on the OK button to log in to the Trends.Earth account. After successful submission, the success message will pop up.","title":"Trends.Earth Login"},{"location":"user/guide/settings/#update-profile","text":"Click on the Update profile button to update the profile. Upon clicking the update profile form will open. You can update the fields you want to change by editing the respective fields. Click on the Save button to save the changes. After successful updating, a success message will pop up.","title":"Update profile"},{"location":"user/guide/settings/#reset-password","text":"Click on the Reset Password button to reset the password. Upon clicking the reset password form will open. Enter the email address in the provided field. Click the OK button to submit the email address and request a password reset. Click the Cancel button to cancel the password reset request and exit the form. Upon clicking the OK button, a confirmation popup will open with the following message: Are you sure you want to reset your password for xyz@gmail.com? Your new password will be mailed to you. Click the No button to cancel the password reset and close the confirmation popup. Click the Yes button to confirm the password reset. An email with your new password will be sent to you. On successful submission, the success message popup will be shown to the user. The user will receive an email with the new password.","title":"Reset password"},{"location":"user/guide/settings/#delete-user","text":"Click on the Delete user button to delete the user. Upon clicking the button, the Delete user confirmation pop up will open. The pop up will have text saying, \"Are you sure you want to delete the user xyz@gmail.com? All your tasks will be lost and you will no longer be able to process data online using Trends.Earth.\" Click the No button to cancel the deletion and close the form. Click the Yes button to confirm the deletion of the user. This will permanently delete your account and all associated tasks.","title":"Delete user"},{"location":"user/guide/settings/#reports","text":"Click on the Reporting option for reports-related settings. Under the Reporting settings, users can configure the information to be included in the generated reports. These settings include: Organisation : (optional) Organisation or institute name. Contact email : (optional) Contact email of the user. Website : (optional) Link to the website of your company or institute. Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.). Logo preview : Visual preview of the default CI logo, or the custom logo a user selected. Footer : (optional) Will be added to the report. Disclaimer : Change as desired, otherwise use the default disclaimer. License : Change as desired, otherwise use the default license description. List of stakeholders and relationships : Enter the stakeholder's name and a brief description of the relationship separated by a dash i.e. Stakeholder's name - Relationship description Each entry should be in a new line. Cultural considerations : Enter the cultural considerations and a brief description separated by a dash i.e. Cultural considerations - description Each entry should be in a new line. Cultural Policies : Enter the cultural policies and a brief description separated by a dash i.e. Cultural policies - description Each entry should be in a new line. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes. Overall, the CPLUS settings offer users the flexibility to tailor the platform to their specific requirements and optimise their workflow for conducting analyses and generating reports.","title":"Reports"},{"location":"user/guide/step-1/","text":"Step 1: Scenario Information \u00b6 The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed. Scenario description : A detailed description of the analysis. Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user. Figure 1 shows an example of Step 1 Once the information has been provided, click Step 2 . If the QGIS canvas CRS is not set to WGS84 (EPSG: 4326), the zoom to the pilot area will not happen. Figure 1: Step 1 focuses on Scenario Information Pilot area \u00b6 The pilot study area covers Bushbuck Ridge , South Africa. When a user's study area is outside of this region, some of the activities and Priority-weighted layers will be disabled. This is because those datasets are specific to the Bushbuck Ridge study area and are of no use for other AOIs. It's important for a user to take this into account, as step 2 and step 3 will be affected by this. If the selected extent is outside of this region, the Bushbuck Ridge activities will be disabled. The same goes for the Priority Weighted layers. If a user is outside the Bushbuck Ridge region, they will need to create custom activities and/or PWLs. An explanation of these follows in the other sections. Click here to explore the step 2 section. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 1"},{"location":"user/guide/step-1/#step-1-scenario-information","text":"The first step focuses on the Scenario Information . A Scenario refers to an overall analysis done in an area of interest (AOI). Different criteria and priorities for spatial decision-making and comparison will be considered for each scenario. Scenario name : A name for the analysis to be performed. Scenario description : A detailed description of the analysis. Extent : The area of interest for this analysis. This can be calculated from the current canvas view extent, a layer, or an extent drawn by the user. Figure 1 shows an example of Step 1 Once the information has been provided, click Step 2 . If the QGIS canvas CRS is not set to WGS84 (EPSG: 4326), the zoom to the pilot area will not happen. Figure 1: Step 1 focuses on Scenario Information","title":"Step 1: Scenario Information"},{"location":"user/guide/step-1/#pilot-area","text":"The pilot study area covers Bushbuck Ridge , South Africa. When a user's study area is outside of this region, some of the activities and Priority-weighted layers will be disabled. This is because those datasets are specific to the Bushbuck Ridge study area and are of no use for other AOIs. It's important for a user to take this into account, as step 2 and step 3 will be affected by this. If the selected extent is outside of this region, the Bushbuck Ridge activities will be disabled. The same goes for the Priority Weighted layers. If a user is outside the Bushbuck Ridge region, they will need to create custom activities and/or PWLs. An explanation of these follows in the other sections. Click here to explore the step 2 section. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Pilot area"},{"location":"user/guide/step-2/","text":"Step 2: Pathways and activities \u00b6 This step deals with the Natural Climate Solution (NCS) pathways and the Activities . An NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal management). An activity is a combination of NCS pathways represented in an AOI spatial layer. Figure 1 shows the UI. Figure 1: Step 2 allows the user to create and edit NCS pathways and Activities Activities buttons: Add : Adds a new activity. Delete : Delete an activity. Editing : Edit an existing activity. Ordering pixel value: Edit activity order in the scenario analysis and output layer. NCS pathways buttons: Add : Adds a new pathway. Delete : Delete a pathway. Editing : Edit an existing pathway. Refresh view : Checks the base directory for data. Validation inspector: Checks the validation of NCS pathways against a predefined set of rules. How to add NCS pathway \u00b6 Click on the left green plus button to add a new pathway ( Figure 3 ). You can use two methods to add the NCS pathway Method 1: Manually add NCS pathway \u00b6 In this method, you will create a new NCS pathway by providing a name, description, and selecting the applicable map layer as shown in Figure 2 below. Figure 2: Input fields in the NCS Pathway Editor when using a local map layer Step 1 Enter NCS Pathway Details In the Name field, enter name for your NCS pathway. This name will help you identify the pathway in the system. In the Description field, enter a brief description of the NCS pathway. This description will provide context and help others understand the purpose of the pathway. Step 2 Select Pathway Type Pathway Type: Select the type of the NCS pathway. Protect: Protect the world\u2019s natural ecosystems from unsustainable practices and degradation. Manage: Farming systems and working lands must shift from net carbon emitters to carbon sinks. Restore: Restore ecosystem types and globally can reduce global greenhouse gas emissions and store additional carbon up to 3 gigatons annually. Step 3 Select Map Layer - Click the Local map layer radio button to load the widgets for specifying a map layer in your computer. - In the Map Layer dropdown menu, select the map layer that is relevant to your NCS pathway. You can choose - from the list of available map layers that you have downloaded and imported into the system, or - from the layers in the QGIS map canvas. For example, if you are creating an NCS pathway for Agroforestry, you would select the Agroforestry map layer. Step 4 Add NCS Pathway Once you have entered all the required details, click on the OK button to add the NCS pathway. Method 2 add using online default \u00b6 In this method, you will add a new NCS pathway using online defaults. This option is available if you have an account on the Trends.Earth platform. Step 1 Add Online Defaults Click the Online defaults radio button to load the layers in the online server. Choose the NCS pathway you want to use from the list of available options. Once you select the NCS pathway, the name and description fields will be automatically populated. Select the pathway type. Click on the OK button to add the NCS pathway. Figure 3: Input fields in the NCS Pathway Editor when using an online layer If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will have an exclamation mark next to it. The user will need to rectify the issue before continuing to step 3. Add pathways to an existing activity: Select the activity to which a pathway should be added. Select the pathway you want to add to the activity. Click the right arrow to add a pathway to the selected activity. Click the double right arrow to add all pathways to the activity. The user can also drag and drop a pathway onto the desired activity. How to add a new activity? \u00b6 Click on the right green plus button to add an activity ( Figure 4 ). Provide a Name and Description . (Optional) Activity Mask excludes specific areas, restricting pathways to a targeted activity. Click OK . The new activity will be added. Figure 4: Activity creator/editor Activity Mask \u00b6 Activity Masking enables users to exclude specific areas from pathways. This functionality helps in refining analyses by isolating regions that are not relevant or need to be avoided during operations. How does the Activity Masking work? \u00b6 Imagine planning a journey or mapping an area, and you want to exclude specific region like restricted zones, private properties, or hazardous locations. This masking tool allows you to mark those areas, ensuring they are excluded from your plans or analysis. It is like instructing the system, avoid these areas, enabling you to focus on relevant zones and create more precise and efficient plans. Here is the list of activities displayed without applying any mask. This means all areas are included, and no regions have been excluded or hidden from the analysis. After applying the mask, the specified area becomes restricted for that particular activity. This ensures that no operations or tasks are carried out within that area, effectively excluding it from the analysis. As shown in the image below, after applying the mask, the specified area is marked as restricted for that particular activity. This restriction ensures that no operations or tasks related to the specific activity take place within the designated area, effectively excluding it from the further analysis. How to add Activity Mask? \u00b6 Click on the Activity Mask checkbox. This will allow to add the activity mask. To add new activity mask click on the icon. This will open a Select mask layer pop up window. Select your desired 1\ufe0f\u20e3 mask you want to add and then click on the 2\ufe0f\u20e3 Open button. This process will add the mask on your activity. Edit Activity Mask \u00b6 Select the activity mask and click on the icon. This will open a Select mask layer pop up window from where you choose your desired activity mask. Delete Activity Mask \u00b6 Select the activity mask and click on the icon. A confirmation dialog box will appear, allowing you to confirm the deletion of the selected activity mask or you can close the process. Ordering of the pixel values for the scenario output \u00b6 Open the Style pixel value editor by clicking on the button. Select the activity which needs to be moved up or down in the stack. Drag-and-drop the activity where it needs to be in the stack. Click OK once done. The final step is to select each of the activities a user wants to include in the scenario run. A user can exclude activities if they do not want to include them, even if the activity has pathways. Figure 5: Selected activities Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an activity, otherwise a warning message will be displayed. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 2"},{"location":"user/guide/step-2/#step-2-pathways-and-activities","text":"This step deals with the Natural Climate Solution (NCS) pathways and the Activities . An NCS pathway can be defined as a composite spatial layer on specific land use classes and other factors that determine areas ideal for a specific use case (e.g. Animal management). An activity is a combination of NCS pathways represented in an AOI spatial layer. Figure 1 shows the UI. Figure 1: Step 2 allows the user to create and edit NCS pathways and Activities Activities buttons: Add : Adds a new activity. Delete : Delete an activity. Editing : Edit an existing activity. Ordering pixel value: Edit activity order in the scenario analysis and output layer. NCS pathways buttons: Add : Adds a new pathway. Delete : Delete a pathway. Editing : Edit an existing pathway. Refresh view : Checks the base directory for data. Validation inspector: Checks the validation of NCS pathways against a predefined set of rules.","title":"Step 2: Pathways and activities"},{"location":"user/guide/step-2/#how-to-add-ncs-pathway","text":"Click on the left green plus button to add a new pathway ( Figure 3 ). You can use two methods to add the NCS pathway","title":"How to add NCS pathway"},{"location":"user/guide/step-2/#method-1-manually-add-ncs-pathway","text":"In this method, you will create a new NCS pathway by providing a name, description, and selecting the applicable map layer as shown in Figure 2 below. Figure 2: Input fields in the NCS Pathway Editor when using a local map layer Step 1 Enter NCS Pathway Details In the Name field, enter name for your NCS pathway. This name will help you identify the pathway in the system. In the Description field, enter a brief description of the NCS pathway. This description will provide context and help others understand the purpose of the pathway. Step 2 Select Pathway Type Pathway Type: Select the type of the NCS pathway. Protect: Protect the world\u2019s natural ecosystems from unsustainable practices and degradation. Manage: Farming systems and working lands must shift from net carbon emitters to carbon sinks. Restore: Restore ecosystem types and globally can reduce global greenhouse gas emissions and store additional carbon up to 3 gigatons annually. Step 3 Select Map Layer - Click the Local map layer radio button to load the widgets for specifying a map layer in your computer. - In the Map Layer dropdown menu, select the map layer that is relevant to your NCS pathway. You can choose - from the list of available map layers that you have downloaded and imported into the system, or - from the layers in the QGIS map canvas. For example, if you are creating an NCS pathway for Agroforestry, you would select the Agroforestry map layer. Step 4 Add NCS Pathway Once you have entered all the required details, click on the OK button to add the NCS pathway.","title":"Method 1: Manually add NCS pathway"},{"location":"user/guide/step-2/#method-2-add-using-online-default","text":"In this method, you will add a new NCS pathway using online defaults. This option is available if you have an account on the Trends.Earth platform. Step 1 Add Online Defaults Click the Online defaults radio button to load the layers in the online server. Choose the NCS pathway you want to use from the list of available options. Once you select the NCS pathway, the name and description fields will be automatically populated. Select the pathway type. Click on the OK button to add the NCS pathway. Figure 3: Input fields in the NCS Pathway Editor when using an online layer If the NCS pathway is broken (e.g. layer or file cannot be found), the pathway text will have an exclamation mark next to it. The user will need to rectify the issue before continuing to step 3. Add pathways to an existing activity: Select the activity to which a pathway should be added. Select the pathway you want to add to the activity. Click the right arrow to add a pathway to the selected activity. Click the double right arrow to add all pathways to the activity. The user can also drag and drop a pathway onto the desired activity.","title":"Method 2 add using online default"},{"location":"user/guide/step-2/#how-to-add-a-new-activity","text":"Click on the right green plus button to add an activity ( Figure 4 ). Provide a Name and Description . (Optional) Activity Mask excludes specific areas, restricting pathways to a targeted activity. Click OK . The new activity will be added. Figure 4: Activity creator/editor","title":"How to add a new activity?"},{"location":"user/guide/step-2/#activity-mask","text":"Activity Masking enables users to exclude specific areas from pathways. This functionality helps in refining analyses by isolating regions that are not relevant or need to be avoided during operations.","title":"Activity Mask"},{"location":"user/guide/step-2/#how-does-the-activity-masking-work","text":"Imagine planning a journey or mapping an area, and you want to exclude specific region like restricted zones, private properties, or hazardous locations. This masking tool allows you to mark those areas, ensuring they are excluded from your plans or analysis. It is like instructing the system, avoid these areas, enabling you to focus on relevant zones and create more precise and efficient plans. Here is the list of activities displayed without applying any mask. This means all areas are included, and no regions have been excluded or hidden from the analysis. After applying the mask, the specified area becomes restricted for that particular activity. This ensures that no operations or tasks are carried out within that area, effectively excluding it from the analysis. As shown in the image below, after applying the mask, the specified area is marked as restricted for that particular activity. This restriction ensures that no operations or tasks related to the specific activity take place within the designated area, effectively excluding it from the further analysis.","title":"How does the Activity Masking work?"},{"location":"user/guide/step-2/#how-to-add-activity-mask","text":"Click on the Activity Mask checkbox. This will allow to add the activity mask. To add new activity mask click on the icon. This will open a Select mask layer pop up window. Select your desired 1\ufe0f\u20e3 mask you want to add and then click on the 2\ufe0f\u20e3 Open button. This process will add the mask on your activity.","title":"How to add Activity Mask?"},{"location":"user/guide/step-2/#edit-activity-mask","text":"Select the activity mask and click on the icon. This will open a Select mask layer pop up window from where you choose your desired activity mask.","title":"Edit Activity Mask"},{"location":"user/guide/step-2/#delete-activity-mask","text":"Select the activity mask and click on the icon. A confirmation dialog box will appear, allowing you to confirm the deletion of the selected activity mask or you can close the process.","title":"Delete Activity Mask"},{"location":"user/guide/step-2/#ordering-of-the-pixel-values-for-the-scenario-output","text":"Open the Style pixel value editor by clicking on the button. Select the activity which needs to be moved up or down in the stack. Drag-and-drop the activity where it needs to be in the stack. Click OK once done. The final step is to select each of the activities a user wants to include in the scenario run. A user can exclude activities if they do not want to include them, even if the activity has pathways. Figure 5: Selected activities Before proceeding to Step 3, a user needs to define at least one NCS pathway layer for an activity, otherwise a warning message will be displayed. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Ordering of the pixel values for the scenario output"},{"location":"user/guide/step-3/","text":"Step 3: Priority weighting \u00b6 The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 1 . Weight values range from 0 to 5, and affect how important a Priority Weighting Layer (PWL) is compared to other layers. A value of 0 indicates that the PWL has a lower importance. A value of 5 means that the PWL has a higher importance. Figure 1: Step 3 allows the user to set the weights of each Priority Group Priority Groups \u00b6 The Priority groups are used to assign weights to specific PWLs based on their importance. These PWLs are subsequently applied during the weighting of NCS pathways when creating a scenario analysis. Add priority groups \u00b6 To add a new priority group, the user must click on the button, as shown in Figure 1 . This will open a Priority Group Dialog box, where user required to fill the following information. Group name: Name of the group. Group description: Description of the group. Group value: Numeric value that reflect the importance of the priority layer. Assign priority layers: This allows users to allocate importance values to different PWLs. To assign a priority layer, click on the Assign priority layers and select from the available PWLs in the list.(see Figure 3 ) Figure 2: Priority Group Dialog After filling in the required information, click on the OK button to add it to the Priority groups . Figure 3: Assign priority layers Edit group layer \u00b6 Select the layer and click on the icon. This will open the Priority Group Dialog , allowing you to edit the group name, group description, group value, and assign new priority layers. Figure 4: Priority Group Dialog Edit Click OK to apply the changes. Remove group layer \u00b6 Select the layer and click on the to remove the layer from the priority group. Prority Weighting Layers \u00b6 The priority weighting layers can be selected, added and removed into each priority group by using the arrow buttons. Add priority layers \u00b6 Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer to the group. Remove priority layers \u00b6 Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer to the group. Create custom priority layers \u00b6 Click on to add a new custom priority layer, or to edit an existing priority layer. This will open the Priority Layer dialog (see Figure 5 ). Methods to create layers \u00b6 Method 1: Create manually \u00b6 The following parameters need to be set: Priority layer : The layer that represents the priority layer. Priority layer name : A unique identifier for the priority layer. Priority layer description : A detailed description of the priority layer. Click the Assign NCS Pathways button to select NCS pathways to be associated with the priority layer (see Figure 5 ) Figure 5: Priority layer dialog Select the NCS pathways you want to be associated with the priority layer (see Figure 6 ). Click OK . Figure 6: NCS pathway selection for priority layers Method 2: Create Online \u00b6 After clicking on this option a drop down menu will appear with the available online defaults. Select the desired online default. Select the applicable NCS pathways, then click on the 1\ufe0f\u20e3 OK button, to create the PWL. Click the Remove PWL button to remove one or more of the selected PWLs from the list. NCS Pathways/PWLs Matrix of Relative Impact Values \u00b6 The NCS Pathways/PWLs Matrix of Relative Impact Values is used to assign impact coefficients to describe how each pathway influences each Priority Weighting Layer (PWL). These coefficients range from \u20133 to +3 and are evaluated separately from the PWL weightings. The system also clearly distinguishes between impact-based and fragmentation-based PWLs, ensuring that the correct type of coefficient is applied during evaluation. Opening the Matrix Manager \u00b6 To open the Matrix of Relative Impact Values Manager, first ensure that a Priority Weighting Layer is selected. Use the button to add a new custom priority layer. Select a layer from the Priority Weighted Layers panel. Click the Create Matrix of Relative Impact Values for Priority Weighted Layer button to open the manager. Assigning Impact Coefficients \u00b6 In the Matrix Manager, each pathway and PWL pair is represented in a table. Enter an impact coefficient between \u20133 and +3 to indicate the relative influence of that pathway on the selected PWL. These coefficients are stored and used during model evaluation alongside, but independently from, the weighting values applied to PWLs. NCS Pathways Matrix of Relative Impact Values \u00b6 Identifying Carbon Layers \u00b6 Because layer names alone are not reliable indicators of carbon content, the interface includes a dedicated checkbox (1\ufe0f\u20e3 Enable if layer has carbon storage values ) that allows users to mark a layer as containing carbon storage or carbon impact values. Once selected, the layer is treated as a carbon layer during prioritisation and is automatically added to the carbon-specific tab within the interface. Layers not marked as carbon layers are listed instead in the general impact matrix. Opening the Matrix Manager \u00b6 To open the NCS Pathways Matrix of Relative Impact Values Manager, click the 1\ufe0f\u20e3 Create Matrix of Relative Impact Values button to open the manager. For each eligible pathway, the plugin converts the carbon calculation results into a carbon impact potential raster. This raster is normalised to a consistent scale so that it can be compared with other pathway-variable relationships. At the top of the manager 2 tabs are available: Carbon Impact Priority Weighting Layers Assigning Impact Values \u00b6 Carbon layers use an impact weight range from \u20131 to +1, while non-carbon layers continue to use the \u20133 to +3 range. This separation ensures that carbon values remain proportionate without overwhelming other prioritisation factors. Navigate to the Carbon Impact tab. Enter a Carbon Impact Rating (\u20131 to +1) for each NCS Pathway. Navigate to the Priority Weighting Layers tab. Enter an impact coefficient (\u20133 to +3) for each NCS Pathway and PWL combination. Create a Net Present Value (NPV) \u00b6 The plugin supports adding additional investability factors, such as years of project experience, by allowing users to incorporate constant raster layers into their analysis. Users can create or load constant raster layers representing custom variables. The plugin automatically normalizes these values, typically scaling them between 0 and 1 so they contribute consistently alongside other metrics. Opening the Manager \u00b6 Click on the icon to open the Investability Variable Manager. Adding a Net Present Value (NPV) \u00b6 From the Investibility Type dropdown select Net Present Value . Select an Activity to open its coresponding configuration. Enter the Number of Years and Discount Rate . Input the Revenue and Cost values for the respective years. Adding Custom Investability Variables \u00b6 Users have the ability to add a new investability variable besides NPV and years experience. Click the Add New Investability Type button. Provide a Name for your investabilty type. Define the Normalization Range values. Setting groups values \u00b6 Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 3"},{"location":"user/guide/step-3/#step-3-priority-weighting","text":"The final step deals with the Weighting priorities and Priority groups . These weights will be applied when the user starts running the scenario. An example is shown in Figure 1 . Weight values range from 0 to 5, and affect how important a Priority Weighting Layer (PWL) is compared to other layers. A value of 0 indicates that the PWL has a lower importance. A value of 5 means that the PWL has a higher importance. Figure 1: Step 3 allows the user to set the weights of each Priority Group","title":"Step 3: Priority weighting"},{"location":"user/guide/step-3/#priority-groups","text":"The Priority groups are used to assign weights to specific PWLs based on their importance. These PWLs are subsequently applied during the weighting of NCS pathways when creating a scenario analysis.","title":"Priority Groups"},{"location":"user/guide/step-3/#add-priority-groups","text":"To add a new priority group, the user must click on the button, as shown in Figure 1 . This will open a Priority Group Dialog box, where user required to fill the following information. Group name: Name of the group. Group description: Description of the group. Group value: Numeric value that reflect the importance of the priority layer. Assign priority layers: This allows users to allocate importance values to different PWLs. To assign a priority layer, click on the Assign priority layers and select from the available PWLs in the list.(see Figure 3 ) Figure 2: Priority Group Dialog After filling in the required information, click on the OK button to add it to the Priority groups . Figure 3: Assign priority layers","title":"Add priority groups"},{"location":"user/guide/step-3/#edit-group-layer","text":"Select the layer and click on the icon. This will open the Priority Group Dialog , allowing you to edit the group name, group description, group value, and assign new priority layers. Figure 4: Priority Group Dialog Edit Click OK to apply the changes.","title":"Edit group layer"},{"location":"user/guide/step-3/#remove-group-layer","text":"Select the layer and click on the to remove the layer from the priority group.","title":"Remove group layer"},{"location":"user/guide/step-3/#prority-weighting-layers","text":"The priority weighting layers can be selected, added and removed into each priority group by using the arrow buttons.","title":"Prority Weighting Layers"},{"location":"user/guide/step-3/#add-priority-layers","text":"Select the target layer from the priority weighting layers list and the destination group from the priority groups and use the left arrow button to add the layer to the group.","title":"Add priority layers"},{"location":"user/guide/step-3/#remove-priority-layers","text":"Select the target layer from the priority weighting layers list from its priority group and use the right arrow button to remove the layer to the group.","title":"Remove priority layers"},{"location":"user/guide/step-3/#create-custom-priority-layers","text":"Click on to add a new custom priority layer, or to edit an existing priority layer. This will open the Priority Layer dialog (see Figure 5 ).","title":"Create custom priority layers"},{"location":"user/guide/step-3/#methods-to-create-layers","text":"","title":"Methods to create layers"},{"location":"user/guide/step-3/#method-1-create-manually","text":"The following parameters need to be set: Priority layer : The layer that represents the priority layer. Priority layer name : A unique identifier for the priority layer. Priority layer description : A detailed description of the priority layer. Click the Assign NCS Pathways button to select NCS pathways to be associated with the priority layer (see Figure 5 ) Figure 5: Priority layer dialog Select the NCS pathways you want to be associated with the priority layer (see Figure 6 ). Click OK . Figure 6: NCS pathway selection for priority layers","title":"Method 1: Create manually"},{"location":"user/guide/step-3/#method-2-create-online","text":"After clicking on this option a drop down menu will appear with the available online defaults. Select the desired online default. Select the applicable NCS pathways, then click on the 1\ufe0f\u20e3 OK button, to create the PWL. Click the Remove PWL button to remove one or more of the selected PWLs from the list.","title":"Method 2: Create Online"},{"location":"user/guide/step-3/#ncs-pathwayspwls-matrix-of-relative-impact-values","text":"The NCS Pathways/PWLs Matrix of Relative Impact Values is used to assign impact coefficients to describe how each pathway influences each Priority Weighting Layer (PWL). These coefficients range from \u20133 to +3 and are evaluated separately from the PWL weightings. The system also clearly distinguishes between impact-based and fragmentation-based PWLs, ensuring that the correct type of coefficient is applied during evaluation.","title":"NCS Pathways/PWLs Matrix of Relative Impact Values"},{"location":"user/guide/step-3/#opening-the-matrix-manager","text":"To open the Matrix of Relative Impact Values Manager, first ensure that a Priority Weighting Layer is selected. Use the button to add a new custom priority layer. Select a layer from the Priority Weighted Layers panel. Click the Create Matrix of Relative Impact Values for Priority Weighted Layer button to open the manager.","title":"Opening the Matrix Manager"},{"location":"user/guide/step-3/#assigning-impact-coefficients","text":"In the Matrix Manager, each pathway and PWL pair is represented in a table. Enter an impact coefficient between \u20133 and +3 to indicate the relative influence of that pathway on the selected PWL. These coefficients are stored and used during model evaluation alongside, but independently from, the weighting values applied to PWLs.","title":"Assigning Impact Coefficients"},{"location":"user/guide/step-3/#ncs-pathways-matrix-of-relative-impact-values","text":"","title":"NCS Pathways Matrix of Relative Impact Values"},{"location":"user/guide/step-3/#identifying-carbon-layers","text":"Because layer names alone are not reliable indicators of carbon content, the interface includes a dedicated checkbox (1\ufe0f\u20e3 Enable if layer has carbon storage values ) that allows users to mark a layer as containing carbon storage or carbon impact values. Once selected, the layer is treated as a carbon layer during prioritisation and is automatically added to the carbon-specific tab within the interface. Layers not marked as carbon layers are listed instead in the general impact matrix.","title":"Identifying Carbon Layers"},{"location":"user/guide/step-3/#opening-the-matrix-manager_1","text":"To open the NCS Pathways Matrix of Relative Impact Values Manager, click the 1\ufe0f\u20e3 Create Matrix of Relative Impact Values button to open the manager. For each eligible pathway, the plugin converts the carbon calculation results into a carbon impact potential raster. This raster is normalised to a consistent scale so that it can be compared with other pathway-variable relationships. At the top of the manager 2 tabs are available: Carbon Impact Priority Weighting Layers","title":"Opening the Matrix Manager"},{"location":"user/guide/step-3/#assigning-impact-values","text":"Carbon layers use an impact weight range from \u20131 to +1, while non-carbon layers continue to use the \u20133 to +3 range. This separation ensures that carbon values remain proportionate without overwhelming other prioritisation factors. Navigate to the Carbon Impact tab. Enter a Carbon Impact Rating (\u20131 to +1) for each NCS Pathway. Navigate to the Priority Weighting Layers tab. Enter an impact coefficient (\u20133 to +3) for each NCS Pathway and PWL combination.","title":"Assigning Impact Values"},{"location":"user/guide/step-3/#create-a-net-present-value-npv","text":"The plugin supports adding additional investability factors, such as years of project experience, by allowing users to incorporate constant raster layers into their analysis. Users can create or load constant raster layers representing custom variables. The plugin automatically normalizes these values, typically scaling them between 0 and 1 so they contribute consistently alongside other metrics.","title":"Create a Net Present Value (NPV)"},{"location":"user/guide/step-3/#opening-the-manager","text":"Click on the icon to open the Investability Variable Manager.","title":"Opening the Manager"},{"location":"user/guide/step-3/#adding-a-net-present-value-npv","text":"From the Investibility Type dropdown select Net Present Value . Select an Activity to open its coresponding configuration. Enter the Number of Years and Discount Rate . Input the Revenue and Cost values for the respective years.","title":"Adding a Net Present Value (NPV)"},{"location":"user/guide/step-3/#adding-custom-investability-variables","text":"Users have the ability to add a new investability variable besides NPV and years experience. Click the Add New Investability Type button. Provide a Name for your investabilty type. Define the Normalization Range values.","title":"Adding Custom Investability Variables"},{"location":"user/guide/step-3/#setting-groups-values","text":"Move the slider to adjust the weight of each group, values can also be set manually, by using the left input spin box. Click here to explore the step 4 section. Click here to explore the log section.","title":"Setting groups values"},{"location":"user/guide/step-4/","text":"Step 4: Select outputs and Processing options \u00b6 Click on the 1\ufe0f\u20e3 Step 4 option, to go to Step 4. NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. Saving outputs \u00b6 Saving Outputs: In Step 4 , choose which results you want to save. Each option represents a group of output layers that will be loaded in the map canvas as well as those layers that will be used in the output report. Select an option to save it to your computer for later use. Not selecting an option means it is only available for your current session. This helps optimise memory usage. Choose wisely to make your computer run more efficiently! NOTE: For the output report to be generated, the Landuse activity and Scenario highest position analysis checkboxes need to be selected as the map layers are required Processing options \u00b6 Process the scenario online: By default, this option is off. When selected, the scenario is sent to a remote server via the Internet for processing. This enables real-time analysis using the server's resources. It is useful for quick results or complex data that may strain local devices. However, it needs a stable internet connection. If Online defaults is chosen previously then this option will be automatically selected. Scenario report options \u00b6 Benefits of custom activity metrics table: The Metrics Generator enables plugin users to incorporate additional metrics or calculations for each activity. It includes automated expressions that assist in calculating measures such as irrecoverable carbon, financial metrics like the net present value (NPV) of each activity, and other weighting measures such as jobs per hectare. The tool leverages the full functionality of the expression builder, allowing users to create fully customised expressions based on the available project variables. The Expression Builder within the Metrics Generator has been enhanced with a CPLUS library, which offers automated calculations for irrecoverable carbon, PWL measures, and NPV. These features come with helpful guidance for their use. It is also important to reference the variables list when creating custom options. Note: Please note that expressions can be applied on a column-by-column basis or can be cell-specific, providing full granularity for the measures and metrics associated with each activity. How to use custom activity metrics table? \u00b6 To use the custom activity metrics table , you need to check the 1\ufe0f\u20e3 checkbox , after which you can access the 2\ufe0f\u20e3 edit option which allows you to create custom metrics table. After clicking on the edit option user will receive the following window. You can follow these steps to create the custom metrics table: Step 1: \u00b6 The first step in creating the custom metrics table provides an 1\ufe0f\u20e3 example demonstrating that you can use different expressions for each cell. It also includes a 2\ufe0f\u20e3 Next button, which allows you to proceed to the next step, and a 3\ufe0f\u20e3 Cancel button, which enables you to exit the process. Step 2: \u00b6 This step allows you to define a metric profile by selecting a 1\ufe0f\u20e3 Profile , then adding 2\ufe0f\u20e3 Columns and specifying their corresponding 3\ufe0f\u20e3 Properties . A metric profile represents a collection of columns grouped according to user-defined criteria - for example, by climate, finance, or forestation themes. The grouping options are entirely flexible, depending on how the user wishes to organize the columns and their associated properties. The primary benefit of profiles is that they enable users to configure column groupings and easily select which profiles to apply in different scenario analysis reports. A Default profile is automatically created when the plugin is used for the first time. Profiles \u00b6 Click on the drop-down menu to select the current profile. Add Profile: Click on the icon to add a new profile. This will open a Add New Profile dialog box where you can enter the name of the profile. Enter the profile name and click on the OK button to add it to the list of profiles and set it as the current profile. If the profile name already exists you will receive the following error. Rename Profile: Click on the icon to rename the current profile. This will open a Rename Profile dialog box where you can enter the name of the profile. Enter the profile name and click on the OK button to update the name. If the profile name already exists you will receive the following error. Copy Profile: Click on the icon to copy the current profile. This will open a Copy Profile dialog which allows one to specify a new name for the copied profile. Enter the name of the copied profile and click on the OK button to add it to the list of profiles and set it as the current profile. A Copy suffix will, by default, be appended to the name of the source profile. If the profile name already exists you will receive the following error. Delete Profile Click on the icon to remove the current profile. Columns \u00b6 Add Column Click on the icon to add a new column. This will open a Set Column Name dialog box where you can enter the name of the column. Enter the column name and click on the OK button to add it to the Columns table. If the column name already exists you will receive the following error. Remove Column Click on the icon to remove the selected column. Change Column Order Click on the icon to move the selected column up in the list and click on the icon to move the selected column down in the list. Properties \u00b6 Header label: The default header name is based on the selected column. You can change it to any name you prefer, but the field must be filled in. If the Header label is empty, you will encounter the error header label is empty . Metric: Metric is the expression that will be used to calculate the value of the column. You can also define a custom metric by clicking on the button. Click on the 1\ufe0f\u20e3 Expression tab to access this window. Choose your desired expression from 3\ufe0f\u20e3 list or you can search it by entering the expression name in the 2\ufe0f\u20e3 Search field. You are required to follow the syntax of the expression as shown in the 4\ufe0f\u20e3 Detail Section . Define your expression in the 5\ufe0f\u20e3 Input field . You can use the 6\ufe0f\u20e3 operators and symbols provided to structure your expression. If any case you have entered wrong expression you will receive the following error. After defining your expression, click on the OK button to save it otherwise click on the Cancel button to cancel the process. This will open a confirmation dialog box. Check the 1\ufe0f\u20e3 \u2705 checkbox to save your preference and prevent this message from appearing again in the future. Click 2\ufe0f\u20e3 No to cancel the current process or 3\ufe0f\u20e3 Discard changes to finalise the cancellation process. Clicking on the 3\ufe0f\u20e3 Discard changes will remove all the changes you made in the current process. Formatting: Click on the 1\ufe0f\u20e3 Dropdown to choose the alignment for the column data. To format the data as a number, check the 2\ufe0f\u20e3 Format as number checkbox. Once selected, you will be able to 3\ufe0f\u20e3 Customise the data. After clicking on the 3\ufe0f\u20e3 Customise new tab will open. Click on the 1\ufe0f\u20e3 Icon to go back. Select the number category from the 2\ufe0f\u20e3 Category dropdown menu, then enter the desired number of decimal places in the 3\ufe0f\u20e3 Decimal places input field. Check the information 4\ufe0f\u20e3 Checkboxes based on your preferences, and choose the scaling value from the 5\ufe0f\u20e3 Dropdown menu. After selecting your options, the sample output will be displayed at 6\ufe0f\u20e3 Sample . Step 3: \u00b6 Click on the 1\ufe0f\u20e3 Customise activity metric to define the different metric for particular cell. Double-click on the 2\ufe0f\u20e3 Cell this will convert it into the dropdown menu. To define the metric for a specific column, select <Cell metric> from the cell dropdown menu. This allows you to add a metric for that cell. After choosing the <Cell metric> the Activity Column Expression Builder window will open. Please look at the Step 2 documentation to know how to use Activity Column Expression Builder . If you select <Cell metric> and do not define a metric for the cell, you will encounter the following 1\ufe0f\u20e3 error . Step 4: \u00b6 This step allows you to review and save the metrics configuration to be used in the scenario analysis report. After verifying the 1\ufe0f\u20e3 metrics configuration , click on the 2\ufe0f\u20e3 Finish button to save the configuration. The profile specified in Step 2 is set as the default for the scenario analysis report when the activity metrics table option is selected. Metric Profile for the Scenario Analysis Report \u00b6 You can select the desired profile for the activity table in the scenario analysis report by using the dropdown menu as shown below: Hovering over the metric builder button displays the currently active profile selected by the user. Run Scenario \u00b6 Run Scenario: Click on the Run Scenario button to execute the scenario and generate the report.A progress bar will appear, showing the status of the processing. Scenario Progress Dialog: This dialog box shows the progress of the scenario execution. Hide - Hide the dialog box. After hiding the dialog box, the View Online Task Status button will be enabled to check the status of the task. Click on the View Online Task Status button to check the status of the task. View Report \u00b6 Once the scenario is processed, you can view the report by clicking on the View Report button. Click on the View Report button, it will display a dropdown menu to view the report. Layout designer : Opens the report in the QGIS layout designer. Open PDF : Opens the created PDF. Report without the custom activity metrics table \u00b6 Report with the custom activity metrics table \u00b6 Report with pie chart \u00b6 Reports also include pie charts that summarise relevant categorical data for each scenario. These charts are automatically generated from the scenario inputs and are clearly labelled and styled to ensure the visual information is easy to interpret. Click here to explore the log section.","title":"Step 4"},{"location":"user/guide/step-4/#step-4-select-outputs-and-processing-options","text":"Click on the 1\ufe0f\u20e3 Step 4 option, to go to Step 4. NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS.","title":"Step 4: Select outputs and Processing options"},{"location":"user/guide/step-4/#saving-outputs","text":"Saving Outputs: In Step 4 , choose which results you want to save. Each option represents a group of output layers that will be loaded in the map canvas as well as those layers that will be used in the output report. Select an option to save it to your computer for later use. Not selecting an option means it is only available for your current session. This helps optimise memory usage. Choose wisely to make your computer run more efficiently! NOTE: For the output report to be generated, the Landuse activity and Scenario highest position analysis checkboxes need to be selected as the map layers are required","title":"Saving outputs"},{"location":"user/guide/step-4/#processing-options","text":"Process the scenario online: By default, this option is off. When selected, the scenario is sent to a remote server via the Internet for processing. This enables real-time analysis using the server's resources. It is useful for quick results or complex data that may strain local devices. However, it needs a stable internet connection. If Online defaults is chosen previously then this option will be automatically selected.","title":"Processing options"},{"location":"user/guide/step-4/#scenario-report-options","text":"Benefits of custom activity metrics table: The Metrics Generator enables plugin users to incorporate additional metrics or calculations for each activity. It includes automated expressions that assist in calculating measures such as irrecoverable carbon, financial metrics like the net present value (NPV) of each activity, and other weighting measures such as jobs per hectare. The tool leverages the full functionality of the expression builder, allowing users to create fully customised expressions based on the available project variables. The Expression Builder within the Metrics Generator has been enhanced with a CPLUS library, which offers automated calculations for irrecoverable carbon, PWL measures, and NPV. These features come with helpful guidance for their use. It is also important to reference the variables list when creating custom options. Note: Please note that expressions can be applied on a column-by-column basis or can be cell-specific, providing full granularity for the measures and metrics associated with each activity.","title":"Scenario report options"},{"location":"user/guide/step-4/#how-to-use-custom-activity-metrics-table","text":"To use the custom activity metrics table , you need to check the 1\ufe0f\u20e3 checkbox , after which you can access the 2\ufe0f\u20e3 edit option which allows you to create custom metrics table. After clicking on the edit option user will receive the following window. You can follow these steps to create the custom metrics table:","title":"How to use custom activity metrics table?"},{"location":"user/guide/step-4/#step-1","text":"The first step in creating the custom metrics table provides an 1\ufe0f\u20e3 example demonstrating that you can use different expressions for each cell. It also includes a 2\ufe0f\u20e3 Next button, which allows you to proceed to the next step, and a 3\ufe0f\u20e3 Cancel button, which enables you to exit the process.","title":"Step 1:"},{"location":"user/guide/step-4/#step-2","text":"This step allows you to define a metric profile by selecting a 1\ufe0f\u20e3 Profile , then adding 2\ufe0f\u20e3 Columns and specifying their corresponding 3\ufe0f\u20e3 Properties . A metric profile represents a collection of columns grouped according to user-defined criteria - for example, by climate, finance, or forestation themes. The grouping options are entirely flexible, depending on how the user wishes to organize the columns and their associated properties. The primary benefit of profiles is that they enable users to configure column groupings and easily select which profiles to apply in different scenario analysis reports. A Default profile is automatically created when the plugin is used for the first time.","title":"Step 2:"},{"location":"user/guide/step-4/#profiles","text":"Click on the drop-down menu to select the current profile. Add Profile: Click on the icon to add a new profile. This will open a Add New Profile dialog box where you can enter the name of the profile. Enter the profile name and click on the OK button to add it to the list of profiles and set it as the current profile. If the profile name already exists you will receive the following error. Rename Profile: Click on the icon to rename the current profile. This will open a Rename Profile dialog box where you can enter the name of the profile. Enter the profile name and click on the OK button to update the name. If the profile name already exists you will receive the following error. Copy Profile: Click on the icon to copy the current profile. This will open a Copy Profile dialog which allows one to specify a new name for the copied profile. Enter the name of the copied profile and click on the OK button to add it to the list of profiles and set it as the current profile. A Copy suffix will, by default, be appended to the name of the source profile. If the profile name already exists you will receive the following error. Delete Profile Click on the icon to remove the current profile.","title":"Profiles"},{"location":"user/guide/step-4/#columns","text":"Add Column Click on the icon to add a new column. This will open a Set Column Name dialog box where you can enter the name of the column. Enter the column name and click on the OK button to add it to the Columns table. If the column name already exists you will receive the following error. Remove Column Click on the icon to remove the selected column. Change Column Order Click on the icon to move the selected column up in the list and click on the icon to move the selected column down in the list.","title":"Columns"},{"location":"user/guide/step-4/#properties","text":"Header label: The default header name is based on the selected column. You can change it to any name you prefer, but the field must be filled in. If the Header label is empty, you will encounter the error header label is empty . Metric: Metric is the expression that will be used to calculate the value of the column. You can also define a custom metric by clicking on the button. Click on the 1\ufe0f\u20e3 Expression tab to access this window. Choose your desired expression from 3\ufe0f\u20e3 list or you can search it by entering the expression name in the 2\ufe0f\u20e3 Search field. You are required to follow the syntax of the expression as shown in the 4\ufe0f\u20e3 Detail Section . Define your expression in the 5\ufe0f\u20e3 Input field . You can use the 6\ufe0f\u20e3 operators and symbols provided to structure your expression. If any case you have entered wrong expression you will receive the following error. After defining your expression, click on the OK button to save it otherwise click on the Cancel button to cancel the process. This will open a confirmation dialog box. Check the 1\ufe0f\u20e3 \u2705 checkbox to save your preference and prevent this message from appearing again in the future. Click 2\ufe0f\u20e3 No to cancel the current process or 3\ufe0f\u20e3 Discard changes to finalise the cancellation process. Clicking on the 3\ufe0f\u20e3 Discard changes will remove all the changes you made in the current process. Formatting: Click on the 1\ufe0f\u20e3 Dropdown to choose the alignment for the column data. To format the data as a number, check the 2\ufe0f\u20e3 Format as number checkbox. Once selected, you will be able to 3\ufe0f\u20e3 Customise the data. After clicking on the 3\ufe0f\u20e3 Customise new tab will open. Click on the 1\ufe0f\u20e3 Icon to go back. Select the number category from the 2\ufe0f\u20e3 Category dropdown menu, then enter the desired number of decimal places in the 3\ufe0f\u20e3 Decimal places input field. Check the information 4\ufe0f\u20e3 Checkboxes based on your preferences, and choose the scaling value from the 5\ufe0f\u20e3 Dropdown menu. After selecting your options, the sample output will be displayed at 6\ufe0f\u20e3 Sample .","title":"Properties"},{"location":"user/guide/step-4/#step-3","text":"Click on the 1\ufe0f\u20e3 Customise activity metric to define the different metric for particular cell. Double-click on the 2\ufe0f\u20e3 Cell this will convert it into the dropdown menu. To define the metric for a specific column, select <Cell metric> from the cell dropdown menu. This allows you to add a metric for that cell. After choosing the <Cell metric> the Activity Column Expression Builder window will open. Please look at the Step 2 documentation to know how to use Activity Column Expression Builder . If you select <Cell metric> and do not define a metric for the cell, you will encounter the following 1\ufe0f\u20e3 error .","title":"Step 3:"},{"location":"user/guide/step-4/#step-4","text":"This step allows you to review and save the metrics configuration to be used in the scenario analysis report. After verifying the 1\ufe0f\u20e3 metrics configuration , click on the 2\ufe0f\u20e3 Finish button to save the configuration. The profile specified in Step 2 is set as the default for the scenario analysis report when the activity metrics table option is selected.","title":"Step 4:"},{"location":"user/guide/step-4/#metric-profile-for-the-scenario-analysis-report","text":"You can select the desired profile for the activity table in the scenario analysis report by using the dropdown menu as shown below: Hovering over the metric builder button displays the currently active profile selected by the user.","title":"Metric Profile for the Scenario Analysis Report"},{"location":"user/guide/step-4/#run-scenario","text":"Run Scenario: Click on the Run Scenario button to execute the scenario and generate the report.A progress bar will appear, showing the status of the processing. Scenario Progress Dialog: This dialog box shows the progress of the scenario execution. Hide - Hide the dialog box. After hiding the dialog box, the View Online Task Status button will be enabled to check the status of the task. Click on the View Online Task Status button to check the status of the task.","title":"Run Scenario"},{"location":"user/guide/step-4/#view-report","text":"Once the scenario is processed, you can view the report by clicking on the View Report button. Click on the View Report button, it will display a dropdown menu to view the report. Layout designer : Opens the report in the QGIS layout designer. Open PDF : Opens the created PDF.","title":"View Report"},{"location":"user/guide/step-4/#report-without-the-custom-activity-metrics-table","text":"","title":"Report without the custom activity metrics table"},{"location":"user/guide/step-4/#report-with-the-custom-activity-metrics-table","text":"","title":"Report with the custom activity metrics table"},{"location":"user/guide/step-4/#report-with-pie-chart","text":"Reports also include pie charts that summarise relevant categorical data for each scenario. These charts are automatically generated from the scenario inputs and are clearly labelled and styled to ensure the visual information is easy to interpret. Click here to explore the log section.","title":"Report with pie chart"},{"location":"user/manual/","text":"User Manual \u00b6 Welcome to the CPLUS plugin's user manual. This section of the documentation describes every step in the plugin and what the various steps of that plugin do. You may prefer to work through our user guide . Here is a brief overview of the content provided here: Calculations and Formulas: This section provides details about the calculations and formulas used within the platform. Settings: Users can access this section to manage the plugin settings. Step 1: This page guides users through Step 1 of a process or workflow, detailing the necessary actions and inputs required. Step 2: Users can refer to this section to understand Step 2 of the process, including the activities and pathways involved. Step 3: Step 3 is explained in detail in this documentation, outlining the weighting priorities and configuration options. Step 4: Step 4 is explained in detail in this documentation, outlining the adding outputs to the report. Logs: Documentation for the log. Scenario File This explains the scenario file details.","title":"Conservation International"},{"location":"user/manual/#user-manual","text":"Welcome to the CPLUS plugin's user manual. This section of the documentation describes every step in the plugin and what the various steps of that plugin do. You may prefer to work through our user guide . Here is a brief overview of the content provided here: Calculations and Formulas: This section provides details about the calculations and formulas used within the platform. Settings: Users can access this section to manage the plugin settings. Step 1: This page guides users through Step 1 of a process or workflow, detailing the necessary actions and inputs required. Step 2: Users can refer to this section to understand Step 2 of the process, including the activities and pathways involved. Step 3: Step 3 is explained in detail in this documentation, outlining the weighting priorities and configuration options. Step 4: Step 4 is explained in detail in this documentation, outlining the adding outputs to the report. Logs: Documentation for the log. Scenario File This explains the scenario file details.","title":"User Manual"},{"location":"user/manual/calculation-and-formula/","text":"Manual \u00b6 The manual is divided into two main sections. The first section explains the complete workflow, including the calculations and formulas used throughout the CPLUS processing process. This section helps users understand how pathways and carbon layers are processed, how activities are generated, and which algorithms are applied to create the priority-weighted (weighted activity) layer. It also covers how the highest-position values are calculated. The second section offers a succinct overview of each step, providing references to detailed explanations for further clarification. A description of the generated report is also provided. CPLUS calculations and formulas \u00b6 Figure 1 shows the workflow of the CPLUS model. The workflow can be split into four parts: Natural climate solution (NCS) weighted carbon pathway(s) Activity Priority weighted layer (Weighted activity) Highest position (Scenario result) Figure 1: CPLUS workflow Evaluation Normalization Across Pathways \u00b6 Conservation planning analyses often use pathways that differ in structure, scale, or number of input variables. Without correction, pathways containing more variables may contribute disproportionately to the results. To ensure fairness and comparability, the plugin performs an Evaluation Normalization step before any pathway is processed into activities. Figure 2 shows the Evaluation normalization workflow. Figure 2: Evaluation Normalization workflow Purpose of Evaluation Normalization The goal of this step is to: Equalize the influence of pathways with different matrix sizes Rescale all evaluation variables so they contribute proportionally Integrate user-defined priorities into the weighting Ensure the final activities reflect both user intent and balanced mathematical treatment This ensures that no pathway or variable dominates merely because it has more inputs, higher numeric ranges, or larger matrices. Normalization Workflow \u00b6 The Evaluation Normalization step consists of four operations: 1. Suitability Coefficient \u00d7 Impact Weight \u00d7 User Weight Each suitability matrix (representing system-defined suitability) is multiplied by a matrix of: Impact weights (assigned per variable) User weights (representing pathway importance) This produces a weighted evaluation matrix for each pathway. Concept: Suitability defines how appropriate a location is, while impact and user weights define how important each variable is. 2. Scaling Pathways with Different Numbers of Variables Pathways may have very different structures. For example: Biodiversity \u2192 3 \u00d7 5 matrix Livelihoods \u2192 2 \u00d7 3 Freshwater \u2192 1 \u00d7 4 Carbon \u2192 3 \u00d7 3 If left uncorrected, larger matrices contribute larger numbers simply because they contain more values. To prevent over-representation, all weighted matrices are rescaled to a common magnitude. This ensures that each pathway contributes proportionally to its assigned user weight\u2014not according to its raw matrix size. 3. Normalizing Variable Influence Within each pathway, variables may have naturally different ranges (e.g., from 0\u20133 vs 0\u201310). The plugin applies a normalization step so that each variable contributes equally within its pathway before combining them. This prevents numeric ranges from skewing the evaluation results. 4. Producing Balanced Weighted Pathway Layers The result of the operations above is a balanced, normalized, and user-weighted evaluation layer for each pathway: -Biodiversity -Livelihoods -Freshwater -Carbon These evaluation layers are the inputs to the next stage of the CPLUS workflow, where they are used to generate: NCS weighted carbon Activities Priority weighted layers Highest position results Evaluation normalization ensures that the downstream results accurately reflect user priorities and scientifically balanced structures. NCS weighted carbon \u00b6 The following steps/rules are considered to create the NCS weighted carbon layer(s): Carbon layers: When multiple Carbon layers are provided, the average is calculated from the layers to create a single Carbon layer The produced Carbon layer is multiplied by the Carbon coefficient provided by the user in the settings If the Carbon coefficient is zero, the value is ignored NCS pathways: Multiply the pathway raster with the Suitability index If the index is zero, the pathway raster is used as-is Equation 1 shows how the NCS weighted carbon layer is calculated \\[ \\operatorname{NCS weighted carbon} ={CarbonCoefficient}\\times{\\frac{(Carbon_1 + Carbon_2 + .... + Carbon_n)}{n}} + ({SuitabilityIndex}\\times{NcsPathway}) \\] Equation 1: NCS weighted carbon where CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster; \u2003\u2003 Carbon is a carbon raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; \u2003\u2003 NcsPathway is the NCS pathway raster; and \u2003\u2003 n is the number of carbon rasters. The results from the above calculation are normalised to create the normalised NCS Weighted Carbon layer A normalised raster's pixel values range from 0 to 1 Normalisation is done as shown in Equation 2 \\[ \\operatorname{Normalised NCS weighted carbon} =\\frac{value - min}{max - min} \\] Equation 2: Normalised NCS weighted carbon where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; and \u2003\u2003 max is the maximum value of the raster. Activity \u00b6 Because an activity can consist of multiple pathways, the normalised results will be summed All NCS weighted carbon layers, as created from Equation 2 , are summed as shown in Equation 3 to create the activity from the pathways \\[ \\operatorname{Summed pathways} = NcsWeightedCarbon_1 + NcsWeightedCarbon_2 + ... + NcsWeightedCarbon_n \\] Equation 3: Summed pathways for the activity where NcsWeightedCarbon is a pathway set up by the user; and \u2003\u2003 n is the number of pathways. Now that the pathways have been summed for the activity, the result needs to be normalised The Suitability index and the Carbon coefficient then needs to be taken into account after the normalised raster has been created This calculation is shown in Equation 4 \\[ \\operatorname{Final activity} ={(SuitabilityIndex + CarbonCoefficient)}\\times{\\frac{value - min}{max - min}} \\] Equation 4: Final activity created from pathways where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; \u2003\u2003 max is the maximum value of the raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; and \u2003\u2003 CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster. The resulting output is the final activity Priority weighted layer (Weighted activity) \u00b6 This step is performed after the activities have been created The PWL is more important, and will therefore be multiplied by five to take this into account The PWL weighted is calculated as shown in Equation 5 \\[ \\operatorname{Priority weighted layer} ={FinalActivity} + ({5}\\times{Priority weighted layer}) \\] Equation 5: Priority weighted layer (Weighted activity) calculation The resulting PWL will then be used as input to the Highest position calculation Naturebase Decision Tree \u00b6 The plugin incorporates The Nature Conservancy (TNC) decision-tree rules to ensure that overlapping pathway areas are resolved consistently and without double counting. These rules are implemented as a series of If/Then conditions , supplied by Conservation International, and define which pathway should take priority when spatial overlaps occur. The decision tree follows TNC\u2019s official Natural Climate Solutions (NCS) accounting framework. When two or more pathways overlap, the plugin evaluates the pixel using these principles: Cropland supersedes all other pathways Existing croplands are reserved for food security and therefore override any restoration or management pathways. Wetlands supersede all non-cropland pathways When wetlands overlap with forests, grasslands or other biomes, mitigation is counted toward the wetland pathway. Biodiversity protection constraints apply Pathways that would cause demonstrable harm to native ecosystems are excluded. NCS Hierarchy (Protect \u2192 Manage \u2192 Restore) After applying base rules, protection activities outrank management, which outrank restoration activities. Scenario-specific rules may apply Depending on the selected scenario, additional prioritization logic may be used (e.g., maximum cost-effective potential or maximum mitigation potential). These steps ensure that each pixel is assigned to a single valid pathway in accordance with global NCS accounting standards. The plugin automatically applies these rules in all calculations, matrices, summaries, and reports. Visualization of Base Accounting Rules (1) and Prioritization Rules (2) Highest Position \u00b6 The Highest position tool determines the raster in a stack with the highest value at a given pixel. Essentially the result is a classification, where each class represents a specific activity. If multiple rasters have the highest pixel value at a given pixel, the first raster with that pixel value in the stack will be used. Figure 2 shows an example from the QGIS description of the Highest position tool. Figure 3: Highest position example In the plugin, the nodata values are ignored. This means that if at least one raster has a pixel value at that cell there will be a raster stack value. If none of the rasters in the stack has a pixel value at that cell (e.g. each raster pixel is nodata ) the output will be nodata at that pixel. Here is an explanation of how to use the Highest position tool: Figure 3 shows the layer for the Highest position at stack position 1 Figure 4: Layer 1 used as the highest position input Figure 4 shows the layer for the Highest position at stack position 2 Figure 5: Layer 2 used as the highest position input Figure 6 shows the result from the Highest position calculation (Scenario result) Stack layer 1 (blue): Figure 2 raster had the highest pixel value Stack layer 2 (red): Figure 3 raster had the highest pixel value Figure 6: Highest position result Carbon Calculations for User-Defined Pathways \u00b6 The plugin supports carbon impact calculations for user-defined pathways by applying distinct methods for Protection, Improved Management, and Restoration. Each pathway type requires its own calculation approach because carbon dynamics differ depending on whether carbon is being safeguarded, enhanced, or gradually sequestered over time. Protection Pathways \u00b6 For Protection pathways, the plugin calculates the total stored carbon within the selected area using authoritative global carbon rasters that include both biomass and soil organic carbon. These values represent existing carbon stocks and are not treated as avoided emissions. All reports clearly label the result as \u201cstored carbon\u201d to reflect this distinction. The calculation follows the avoided-emissions methodology used in Naturebase workflows and draws on the reference implementation available in the avoided emissions analysis codebase. Improved Management Pathways \u00b6 Improved Management pathways rely on user-defined carbon impact values , which are entered through a popup interface. Because management practices vary widely and cannot be accurately inferred from spatial datasets, the plugin depends on these per-hectare values to perform the carbon calculation. This approach allows users to incorporate project-specific data, expert knowledge, or published values to ensure accurate and relevant carbon estimates for their scenarios. Restoration Pathways \u00b6 Restoration pathways require a baseline comparison to determine how much carbon can be regained over time. The plugin integrates Trends.Earth to identify pixels that have remained stable for at least 20 years and uses these as a representation of healthy baseline carbon conditions. Restoration impact is calculated as the difference between the current pixel carbon value and this baseline, and is then projected over a long-term sequestration timeline, typically spanning 50 years or more. This method reflects the gradual nature of carbon accumulation as ecosystems recover. Reporting \u00b6 All pathway-specific carbon calculations are included in the final scenario outputs. The report clearly identifies the method used for each pathway type, ensuring transparency and avoiding confusion between stored carbon, user-defined management impacts, and long-term restoration sequestration. Naturebase Carbon Impact Calculation \u00b6 The plugin automatically calculates the carbon impact of each scenario using the mitigation potential values provided by Naturebase. Because Naturebase pathways already include carbon mitigation expressed in consistent units, the plugin can directly sum these values across all pathways selected in a scenario. The resulting total carbon impact is added to the final output report and reflected in any scenario summaries. To enable this calculation for a scenario, users should add the cplus_activity_naturebase_carbon_impact variable in Step 2 of the Activity Metrics Wizard . This ensures that the carbon metric is correctly applied and that the scenario\u2019s total mitigation value is recorded using Naturebase\u2019s native units of analysis. This concludes the section on how the calculations are done. References \u00b6 https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126 Plugin \u00b6 Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI. Dock widget \u00b6 This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consists of three tabs, each focussing on a particular phase of the analysis. Here is a short description of those steps: Step 1 : Scenario information. Click here for a detailed explanation. Step 2 : NCS pathways and activities. Click here for a detailed explanation. Step 3 : Weighting priorities (weighted activities). Click here for a detailed explanation. For a detailed explanation of the plugin settings, the user can to refer the setting documentation","title":"Calculation and Formula"},{"location":"user/manual/calculation-and-formula/#manual","text":"The manual is divided into two main sections. The first section explains the complete workflow, including the calculations and formulas used throughout the CPLUS processing process. This section helps users understand how pathways and carbon layers are processed, how activities are generated, and which algorithms are applied to create the priority-weighted (weighted activity) layer. It also covers how the highest-position values are calculated. The second section offers a succinct overview of each step, providing references to detailed explanations for further clarification. A description of the generated report is also provided.","title":"Manual"},{"location":"user/manual/calculation-and-formula/#cplus-calculations-and-formulas","text":"Figure 1 shows the workflow of the CPLUS model. The workflow can be split into four parts: Natural climate solution (NCS) weighted carbon pathway(s) Activity Priority weighted layer (Weighted activity) Highest position (Scenario result) Figure 1: CPLUS workflow","title":"CPLUS calculations and formulas"},{"location":"user/manual/calculation-and-formula/#evaluation-normalization-across-pathways","text":"Conservation planning analyses often use pathways that differ in structure, scale, or number of input variables. Without correction, pathways containing more variables may contribute disproportionately to the results. To ensure fairness and comparability, the plugin performs an Evaluation Normalization step before any pathway is processed into activities. Figure 2 shows the Evaluation normalization workflow. Figure 2: Evaluation Normalization workflow Purpose of Evaluation Normalization The goal of this step is to: Equalize the influence of pathways with different matrix sizes Rescale all evaluation variables so they contribute proportionally Integrate user-defined priorities into the weighting Ensure the final activities reflect both user intent and balanced mathematical treatment This ensures that no pathway or variable dominates merely because it has more inputs, higher numeric ranges, or larger matrices.","title":"Evaluation Normalization Across Pathways"},{"location":"user/manual/calculation-and-formula/#normalization-workflow","text":"The Evaluation Normalization step consists of four operations: 1. Suitability Coefficient \u00d7 Impact Weight \u00d7 User Weight Each suitability matrix (representing system-defined suitability) is multiplied by a matrix of: Impact weights (assigned per variable) User weights (representing pathway importance) This produces a weighted evaluation matrix for each pathway. Concept: Suitability defines how appropriate a location is, while impact and user weights define how important each variable is. 2. Scaling Pathways with Different Numbers of Variables Pathways may have very different structures. For example: Biodiversity \u2192 3 \u00d7 5 matrix Livelihoods \u2192 2 \u00d7 3 Freshwater \u2192 1 \u00d7 4 Carbon \u2192 3 \u00d7 3 If left uncorrected, larger matrices contribute larger numbers simply because they contain more values. To prevent over-representation, all weighted matrices are rescaled to a common magnitude. This ensures that each pathway contributes proportionally to its assigned user weight\u2014not according to its raw matrix size. 3. Normalizing Variable Influence Within each pathway, variables may have naturally different ranges (e.g., from 0\u20133 vs 0\u201310). The plugin applies a normalization step so that each variable contributes equally within its pathway before combining them. This prevents numeric ranges from skewing the evaluation results. 4. Producing Balanced Weighted Pathway Layers The result of the operations above is a balanced, normalized, and user-weighted evaluation layer for each pathway: -Biodiversity -Livelihoods -Freshwater -Carbon These evaluation layers are the inputs to the next stage of the CPLUS workflow, where they are used to generate: NCS weighted carbon Activities Priority weighted layers Highest position results Evaluation normalization ensures that the downstream results accurately reflect user priorities and scientifically balanced structures.","title":"Normalization Workflow"},{"location":"user/manual/calculation-and-formula/#ncs-weighted-carbon","text":"The following steps/rules are considered to create the NCS weighted carbon layer(s): Carbon layers: When multiple Carbon layers are provided, the average is calculated from the layers to create a single Carbon layer The produced Carbon layer is multiplied by the Carbon coefficient provided by the user in the settings If the Carbon coefficient is zero, the value is ignored NCS pathways: Multiply the pathway raster with the Suitability index If the index is zero, the pathway raster is used as-is Equation 1 shows how the NCS weighted carbon layer is calculated \\[ \\operatorname{NCS weighted carbon} ={CarbonCoefficient}\\times{\\frac{(Carbon_1 + Carbon_2 + .... + Carbon_n)}{n}} + ({SuitabilityIndex}\\times{NcsPathway}) \\] Equation 1: NCS weighted carbon where CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster; \u2003\u2003 Carbon is a carbon raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; \u2003\u2003 NcsPathway is the NCS pathway raster; and \u2003\u2003 n is the number of carbon rasters. The results from the above calculation are normalised to create the normalised NCS Weighted Carbon layer A normalised raster's pixel values range from 0 to 1 Normalisation is done as shown in Equation 2 \\[ \\operatorname{Normalised NCS weighted carbon} =\\frac{value - min}{max - min} \\] Equation 2: Normalised NCS weighted carbon where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; and \u2003\u2003 max is the maximum value of the raster.","title":"NCS weighted carbon"},{"location":"user/manual/calculation-and-formula/#activity","text":"Because an activity can consist of multiple pathways, the normalised results will be summed All NCS weighted carbon layers, as created from Equation 2 , are summed as shown in Equation 3 to create the activity from the pathways \\[ \\operatorname{Summed pathways} = NcsWeightedCarbon_1 + NcsWeightedCarbon_2 + ... + NcsWeightedCarbon_n \\] Equation 3: Summed pathways for the activity where NcsWeightedCarbon is a pathway set up by the user; and \u2003\u2003 n is the number of pathways. Now that the pathways have been summed for the activity, the result needs to be normalised The Suitability index and the Carbon coefficient then needs to be taken into account after the normalised raster has been created This calculation is shown in Equation 4 \\[ \\operatorname{Final activity} ={(SuitabilityIndex + CarbonCoefficient)}\\times{\\frac{value - min}{max - min}} \\] Equation 4: Final activity created from pathways where value is the pixel value; \u2003\u2003 min is the minimum value of the raster; \u2003\u2003 max is the maximum value of the raster; \u2003\u2003 SuitabilityIndex is the NCS pathway index value; and \u2003\u2003 CarbonCoefficient is the carbon coefficient value multiplied with the averaged carbon raster. The resulting output is the final activity","title":"Activity"},{"location":"user/manual/calculation-and-formula/#priority-weighted-layer-weighted-activity","text":"This step is performed after the activities have been created The PWL is more important, and will therefore be multiplied by five to take this into account The PWL weighted is calculated as shown in Equation 5 \\[ \\operatorname{Priority weighted layer} ={FinalActivity} + ({5}\\times{Priority weighted layer}) \\] Equation 5: Priority weighted layer (Weighted activity) calculation The resulting PWL will then be used as input to the Highest position calculation","title":"Priority weighted layer (Weighted activity)"},{"location":"user/manual/calculation-and-formula/#naturebase-decision-tree","text":"The plugin incorporates The Nature Conservancy (TNC) decision-tree rules to ensure that overlapping pathway areas are resolved consistently and without double counting. These rules are implemented as a series of If/Then conditions , supplied by Conservation International, and define which pathway should take priority when spatial overlaps occur. The decision tree follows TNC\u2019s official Natural Climate Solutions (NCS) accounting framework. When two or more pathways overlap, the plugin evaluates the pixel using these principles: Cropland supersedes all other pathways Existing croplands are reserved for food security and therefore override any restoration or management pathways. Wetlands supersede all non-cropland pathways When wetlands overlap with forests, grasslands or other biomes, mitigation is counted toward the wetland pathway. Biodiversity protection constraints apply Pathways that would cause demonstrable harm to native ecosystems are excluded. NCS Hierarchy (Protect \u2192 Manage \u2192 Restore) After applying base rules, protection activities outrank management, which outrank restoration activities. Scenario-specific rules may apply Depending on the selected scenario, additional prioritization logic may be used (e.g., maximum cost-effective potential or maximum mitigation potential). These steps ensure that each pixel is assigned to a single valid pathway in accordance with global NCS accounting standards. The plugin automatically applies these rules in all calculations, matrices, summaries, and reports. Visualization of Base Accounting Rules (1) and Prioritization Rules (2)","title":"Naturebase Decision Tree"},{"location":"user/manual/calculation-and-formula/#highest-position","text":"The Highest position tool determines the raster in a stack with the highest value at a given pixel. Essentially the result is a classification, where each class represents a specific activity. If multiple rasters have the highest pixel value at a given pixel, the first raster with that pixel value in the stack will be used. Figure 2 shows an example from the QGIS description of the Highest position tool. Figure 3: Highest position example In the plugin, the nodata values are ignored. This means that if at least one raster has a pixel value at that cell there will be a raster stack value. If none of the rasters in the stack has a pixel value at that cell (e.g. each raster pixel is nodata ) the output will be nodata at that pixel. Here is an explanation of how to use the Highest position tool: Figure 3 shows the layer for the Highest position at stack position 1 Figure 4: Layer 1 used as the highest position input Figure 4 shows the layer for the Highest position at stack position 2 Figure 5: Layer 2 used as the highest position input Figure 6 shows the result from the Highest position calculation (Scenario result) Stack layer 1 (blue): Figure 2 raster had the highest pixel value Stack layer 2 (red): Figure 3 raster had the highest pixel value Figure 6: Highest position result","title":"Highest Position"},{"location":"user/manual/calculation-and-formula/#carbon-calculations-for-user-defined-pathways","text":"The plugin supports carbon impact calculations for user-defined pathways by applying distinct methods for Protection, Improved Management, and Restoration. Each pathway type requires its own calculation approach because carbon dynamics differ depending on whether carbon is being safeguarded, enhanced, or gradually sequestered over time.","title":"Carbon Calculations for User-Defined Pathways"},{"location":"user/manual/calculation-and-formula/#protection-pathways","text":"For Protection pathways, the plugin calculates the total stored carbon within the selected area using authoritative global carbon rasters that include both biomass and soil organic carbon. These values represent existing carbon stocks and are not treated as avoided emissions. All reports clearly label the result as \u201cstored carbon\u201d to reflect this distinction. The calculation follows the avoided-emissions methodology used in Naturebase workflows and draws on the reference implementation available in the avoided emissions analysis codebase.","title":"Protection Pathways"},{"location":"user/manual/calculation-and-formula/#improved-management-pathways","text":"Improved Management pathways rely on user-defined carbon impact values , which are entered through a popup interface. Because management practices vary widely and cannot be accurately inferred from spatial datasets, the plugin depends on these per-hectare values to perform the carbon calculation. This approach allows users to incorporate project-specific data, expert knowledge, or published values to ensure accurate and relevant carbon estimates for their scenarios.","title":"Improved Management Pathways"},{"location":"user/manual/calculation-and-formula/#restoration-pathways","text":"Restoration pathways require a baseline comparison to determine how much carbon can be regained over time. The plugin integrates Trends.Earth to identify pixels that have remained stable for at least 20 years and uses these as a representation of healthy baseline carbon conditions. Restoration impact is calculated as the difference between the current pixel carbon value and this baseline, and is then projected over a long-term sequestration timeline, typically spanning 50 years or more. This method reflects the gradual nature of carbon accumulation as ecosystems recover.","title":"Restoration Pathways"},{"location":"user/manual/calculation-and-formula/#reporting","text":"All pathway-specific carbon calculations are included in the final scenario outputs. The report clearly identifies the method used for each pathway type, ensuring transparency and avoiding confusion between stored carbon, user-defined management impacts, and long-term restoration sequestration.","title":"Reporting"},{"location":"user/manual/calculation-and-formula/#naturebase-carbon-impact-calculation","text":"The plugin automatically calculates the carbon impact of each scenario using the mitigation potential values provided by Naturebase. Because Naturebase pathways already include carbon mitigation expressed in consistent units, the plugin can directly sum these values across all pathways selected in a scenario. The resulting total carbon impact is added to the final output report and reflected in any scenario summaries. To enable this calculation for a scenario, users should add the cplus_activity_naturebase_carbon_impact variable in Step 2 of the Activity Metrics Wizard . This ensures that the carbon metric is correctly applied and that the scenario\u2019s total mitigation value is recorded using Naturebase\u2019s native units of analysis. This concludes the section on how the calculations are done.","title":"Naturebase Carbon Impact Calculation"},{"location":"user/manual/calculation-and-formula/#references","text":"https://www.pnas.org/doi/10.1073/pnas.1710465114 https://royalsocietypublishing.org/doi/10.1098/rstb.2019.0126","title":"References"},{"location":"user/manual/calculation-and-formula/#plugin","text":"Detailed descriptions for each UI element of the plugin. This covers steps 1 to 3, dialogs, and the settings UI.","title":"Plugin"},{"location":"user/manual/calculation-and-formula/#dock-widget","text":"This is the main UI of the plugin. The dock widget opens on the right side of QGIS. The dock widget consists of three tabs, each focussing on a particular phase of the analysis. Here is a short description of those steps: Step 1 : Scenario information. Click here for a detailed explanation. Step 2 : NCS pathways and activities. Click here for a detailed explanation. Step 3 : Weighting priorities (weighted activities). Click here for a detailed explanation. For a detailed explanation of the plugin settings, the user can to refer the setting documentation","title":"Dock widget"},{"location":"user/manual/logs/","text":"Logs User Manual \u00b6 Log: Click on the Log option available to view the logs of the processing scenario and the scenario history. Scenario History: In this section, users can explore the history of previously executed scenarios. It serves as an archive of past processing scenarios, allowing users to review, analyse, and reference historical data. Users can retrieve valuable information about past activities, outcomes, and trends, facilitating informed decision-making and performance evaluation. The scenario history provides a comprehensive overview of past system activities, offering insights into long-term patterns and performance metrics. Offline Scenarios : In this scenario, reports are stored locally and can be accessed even when the system is offline. To view the offline scenario, the user has to select the report and then click on refresh button, this will load the scenario and display on the map canvas. Online Scenarios : The stored online scenarios in the log help users load and analyse scenarios they have run online. To view the online scenario, the user has to select the report and then click on the refresh button, this will load the scenario and display on the map canvas. Benefits of storing logs of online scenarios: Keep track of executed scenarios. Allow users to review and analyse previously run scenarios. Provide a record for troubleshooting and auditing purposes. Facilitate comparison between different scenarios for better decision-making. After the completion of report generation, the user will receive an email confirming the successful completion of the report. Once the scenario is completed that scenario history will be shown in the scenario history section. In the bottom right corner of the scenario history, you will find four buttons with the following functions: Plus Icon: This button allows you to save the scenario to the scenario history section. Clicking on it enables you to include additional scenarios for review and analysis within the scenario history. Refresh Button: This button serves the function of loading the selected scenario details into Step 1 of the interface. Upon selecting a scenario from the list within the Scenario History section, users can click the Round Arrow button to load the details of that scenario into Step 1. This action facilitates a seamless transition from reviewing scenario history to initiating further analysis or action within the system. Information Icon: By clicking on the information icon, users can access useful information related to the scenarios. This feature provides additional insights, explanations, or tips to enhance the understanding and interpretation of the scenario history data. Scenario Comparison Report: This feature allows users to run scenario comparisons, and generate comparison reports. These reports are saved in the base data directory specified in the CPLUS plugin settings. Run the Scenario: Ensure the scenario runs successfully. Save Scenario History: Click on the plus icon (+) to save the scenario history into the logs. The user can save the scenario after the scenario runs successfully. Select Scenarios for Comparison: The user needs to select the scenarios they want to compare from the list of available logs. Scenario 1 (Agro_Testing): This scenario report has two activities Agroforestry and Alien Plant Removal . The report was generated based on these two activities. Scenario 2 (Agro_Testing_1): This scenario report has three activities Agroforestry , Alien Plant Removal and Avoided Deforestation and Degradation . The report was generated based on these three activities. Comparison Icon: Click on the file comparison icon to initiate the comparison. Upon clicking the icon, the comparison report generation will start. A popup will appear that shows the progress bar indicating the status of the report generation process. The user can close the popup by clicking on the Close button or can view the generated report by clicking on the View Report button. Accessing the Comparison Report: Once the comparison report is generated, it will be saved in the base data directory specified in the CPLUS plugin settings. Comparison Report: Navigate to the base data directory to access the comparison report. The comparison report includes the following key components: Scenario Activity Area Comparison Table: This table shows a detailed comparison of activity areas across the selected scenarios. It provides insights into how different activities perform in various areas, highlighting similarities and differences between scenarios. Scenario Maps: The following set of maps offers a side-by-side comparison of the different scenarios selected for this report. These scenario maps are the final output of the highest position analysis done for each scenario. The maps indicate which activities are best suited to each area in the stated area of interest, providing a visual representation of the comparative analysis. Minus Icon: The minus icon serves the purpose of removing the scenario from the scenario history section. Clicking on this icon allows users to delete specific scenarios from the history, streamlining the displayed records to focus on relevant information. Processing Scenario Logs: This section provides a detailed record of logs about the ongoing processing scenario. It offers real-time insights into the actions, events, and outcomes within the current scenario. Users can monitor the progress, identify any errors or issues, and troubleshoot accordingly. These logs are essential for tracking the execution flow and diagnosing any anomalies during the processing workflow. Info: The success info will be seen in the processing log section once the scenario runs successfully.","title":"Logs"},{"location":"user/manual/logs/#logs-user-manual","text":"Log: Click on the Log option available to view the logs of the processing scenario and the scenario history. Scenario History: In this section, users can explore the history of previously executed scenarios. It serves as an archive of past processing scenarios, allowing users to review, analyse, and reference historical data. Users can retrieve valuable information about past activities, outcomes, and trends, facilitating informed decision-making and performance evaluation. The scenario history provides a comprehensive overview of past system activities, offering insights into long-term patterns and performance metrics. Offline Scenarios : In this scenario, reports are stored locally and can be accessed even when the system is offline. To view the offline scenario, the user has to select the report and then click on refresh button, this will load the scenario and display on the map canvas. Online Scenarios : The stored online scenarios in the log help users load and analyse scenarios they have run online. To view the online scenario, the user has to select the report and then click on the refresh button, this will load the scenario and display on the map canvas. Benefits of storing logs of online scenarios: Keep track of executed scenarios. Allow users to review and analyse previously run scenarios. Provide a record for troubleshooting and auditing purposes. Facilitate comparison between different scenarios for better decision-making. After the completion of report generation, the user will receive an email confirming the successful completion of the report. Once the scenario is completed that scenario history will be shown in the scenario history section. In the bottom right corner of the scenario history, you will find four buttons with the following functions: Plus Icon: This button allows you to save the scenario to the scenario history section. Clicking on it enables you to include additional scenarios for review and analysis within the scenario history. Refresh Button: This button serves the function of loading the selected scenario details into Step 1 of the interface. Upon selecting a scenario from the list within the Scenario History section, users can click the Round Arrow button to load the details of that scenario into Step 1. This action facilitates a seamless transition from reviewing scenario history to initiating further analysis or action within the system. Information Icon: By clicking on the information icon, users can access useful information related to the scenarios. This feature provides additional insights, explanations, or tips to enhance the understanding and interpretation of the scenario history data. Scenario Comparison Report: This feature allows users to run scenario comparisons, and generate comparison reports. These reports are saved in the base data directory specified in the CPLUS plugin settings. Run the Scenario: Ensure the scenario runs successfully. Save Scenario History: Click on the plus icon (+) to save the scenario history into the logs. The user can save the scenario after the scenario runs successfully. Select Scenarios for Comparison: The user needs to select the scenarios they want to compare from the list of available logs. Scenario 1 (Agro_Testing): This scenario report has two activities Agroforestry and Alien Plant Removal . The report was generated based on these two activities. Scenario 2 (Agro_Testing_1): This scenario report has three activities Agroforestry , Alien Plant Removal and Avoided Deforestation and Degradation . The report was generated based on these three activities. Comparison Icon: Click on the file comparison icon to initiate the comparison. Upon clicking the icon, the comparison report generation will start. A popup will appear that shows the progress bar indicating the status of the report generation process. The user can close the popup by clicking on the Close button or can view the generated report by clicking on the View Report button. Accessing the Comparison Report: Once the comparison report is generated, it will be saved in the base data directory specified in the CPLUS plugin settings. Comparison Report: Navigate to the base data directory to access the comparison report. The comparison report includes the following key components: Scenario Activity Area Comparison Table: This table shows a detailed comparison of activity areas across the selected scenarios. It provides insights into how different activities perform in various areas, highlighting similarities and differences between scenarios. Scenario Maps: The following set of maps offers a side-by-side comparison of the different scenarios selected for this report. These scenario maps are the final output of the highest position analysis done for each scenario. The maps indicate which activities are best suited to each area in the stated area of interest, providing a visual representation of the comparative analysis. Minus Icon: The minus icon serves the purpose of removing the scenario from the scenario history section. Clicking on this icon allows users to delete specific scenarios from the history, streamlining the displayed records to focus on relevant information. Processing Scenario Logs: This section provides a detailed record of logs about the ongoing processing scenario. It offers real-time insights into the actions, events, and outcomes within the current scenario. Users can monitor the progress, identify any errors or issues, and troubleshoot accordingly. These logs are essential for tracking the execution flow and diagnosing any anomalies during the processing workflow. Info: The success info will be seen in the processing log section once the scenario runs successfully.","title":"Logs User Manual"},{"location":"user/manual/scenario-file/","text":"Scenario files \u00b6 The scenario files are stored in the base directory of the system. The base directory can be configured from the settings. You can refer to the Settings Documentation for detailed instructions on how to set the base directory. In the base directory, you will find the scenario files necessary for analysis. Users can navigate to the specific scenario folder they wish to view or analyse. Within each scenario folder, all details related to that particular scenario are available. Users can access processing logs, generated reports, activity details, and pathway information associated with the selected scenario. This organised structure enables users to efficiently manage and analyse scenario data, facilitating informed decision-making and performance evaluation.","title":"Scenario File"},{"location":"user/manual/scenario-file/#scenario-files","text":"The scenario files are stored in the base directory of the system. The base directory can be configured from the settings. You can refer to the Settings Documentation for detailed instructions on how to set the base directory. In the base directory, you will find the scenario files necessary for analysis. Users can navigate to the specific scenario folder they wish to view or analyse. Within each scenario folder, all details related to that particular scenario are available. Users can access processing logs, generated reports, activity details, and pathway information associated with the selected scenario. This organised structure enables users to efficiently manage and analyse scenario data, facilitating informed decision-making and performance evaluation.","title":"Scenario files"},{"location":"user/manual/settings/","text":"Settings \u00b6 To go to the settings the user can click on the plugin toolbar icon to reveal the option. Setting: click on the settings option to go to the plugin settings. Upon clicking the settings page will open. CPLUS Dropdown: Click on the dropdown icon to reveal the CPLUS setting options. Click on the CPLUS to view the options like general, snapping, sieve, mask layer and trends earth login. 1 General: Click on the General option for basic settings such as General, Scenario Analysis, and Sieve settings. General Settings \u00b6 Base data directory: Directory to read data from, and to which results will be written. 2 Scenario Analysis Setting: Coefficient for carbon layers: Applied to carbon layers during processing. Pathway suitability index: Index multiplied to the pathways. Lower values mean the pathway is less important, and higher values mean it's more important. Snapping \u00b6 Snapping will set rasters to match the cell alignment of a reference layer. Resample method: Resampling performed on pixel values. The user can choose the method of their choice from the dropdown. The available methods are as follows: Nearest neighbour : Closest pixel value. This will be best to use if a user wants to preserve the original pixel values. Bilinear : Computes the pixel values from the two closest pixels (2 x 2 kernel). Cubic : Computes the pixel values from the four closest pixels (4 x 4 kernel). Cubic B-Spline : Cubic resampling based on B-Spline (4 x 4 kernel). Lanczos : Lanczos windowed sinc interpolation (6x6 kernel). Average : Computes the average of all non- nodata contributing pixels. Mode : Select the value that appears most often of all the sampled pixels. Maximum : Selects the maximum value which appears of all the sampled pixels. Minimum : Selects the minimum value which appears of all the sampled pixels. Median : Selects the median value that appears in all the sampled pixels. First quartile (Q1) : Select the first quartile value that appears in all the sampled pixels. Third quartile (Q3) : Select the third quartile value that appears in all the sampled pixels. Reference layer: The reference layer to which the cell alignment will be applied. The user can choose a file from the system. Rescale values: Rescale values according to cell size. The user can check or uncheck. Sieve Settings \u00b6 The Sieve Function is a tool designed to filter raster data based on a specified threshold. It enables users to define a minimum area threshold, such that any contiguous area in the raster dataset smaller than the specified size will be removed or filtered out. This functionality is particularly useful for projects or activities that require a minimum spatial extent to be meaningful or practical. For instance, it might not be feasible to undertake an activity on a parcel of land that is smaller than a certain size, such as a hectare. By setting the desired threshold, users can ensure that only areas meeting the specified minimum extent are retained in the dataset, while smaller features are eliminated. This process helps streamline data analysis and ensures that only relevant spatial entities are considered for further processing or analysis. The user can use this by checking the checkbox available in front of the Sieve . Threshold Size: Enter the desired threshold value in the Threshold field. This value represents the minimum number of connected pixels that should be preserved when sieving. Any contiguous area smaller than this threshold will be filtered out. Reference Layer: The reference layer to which the sieve function will be applied. The user can choose the layer from the system. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes. 3 Mask Layers: Masking Layers: Masking layers are used to specify areas that should be excluded from further analysis. Adding a Layer to the Mask: When the user adds a layer to the mask, they specify that the areas covered by that layer should be excluded from the analysis or processing steps. Exclusion of Layer Area: By adding a layer to the mask, the user is essentially creating a filter that excludes the areas represented by that layer. Impact on Analysis: Any analysis or operations performed on the masked data will skip the areas covered by the added layer. This ensures that the analysis focuses only on the relevant geographic features while disregarding the specified layer. Relevance to GIS: Masking layers play a crucial role in GIS analysis, allowing users to focus on specific areas of interest and filter out irrelevant or undesired features from consideration. In summary, adding a layer to the mask in a context allows for the selective exclusion of specific geographic areas from analysis or visualisation, improving the accuracy and relevance of outputs. Arrow: Click on the available Arrow button in front of the Mask Layer to see the options for adding or deleting the layers from the mask feature. Upon clicking the user will see the options. Plus Icon: Click on the Plus icon, to add the layer to the mask layer from the system. Upon clicking the icon the system will show the available layer, and choose the desired layer to add to the mask layer. Minus Icon: Select the added layer and click on the Minus icon, to remove that layer. Ok: After adding the layer/layers to the mask layer, click on the OK button to save the layers in the mask layer and skip them from further analysis. 4 Irrecoverable Carbon Reference Layer: The Irrecoverable Carbon layer is used in a calculation with the protected pathways to calculate the total irrecoverable carbon per activity. 1 local path: Users are required to click on this radio button if they want to use the local path for the Irrecoverable Carbon layer. 2 Input Field: Users can click on this input field to enter the path manually or they can click on the three dots ... on the right side of the input field to open the file explorer from where they select the irrecoverable carbon layer. If the Irrecoverable Carbon layer is not found in the system, the system will show an error message. 1 Online source: Users are required to click on this radio button if they want to use the online source for the Irrecoverable Carbon layer. 2 URL: this field contains the url to down the Irrecoverable Carbon layer from the online source. 3 Save as: Specify the location and name for saving the downloaded Irrecoverable Carbon layer in the system. 4 Start download: Click on this button to download the resource. 5 Download not started: Current status of the downloading process. There are three types of statuses : Download Not started , Download ongoing , and Download successful . If the download fails, the system will show an error message. 5 Trends.Earth Login Information: NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. Register for Trends.Earth (step 1): Click on the Register for Trends.Earth (Step 1) button to initiate the registration process for Trends.Earth. Upon clicking, a registration form will open. The user needs to enter the following information: Email: Enter your email address. Name: Enter your full name. Organisation: Enter the name of your organisation. Country/Region: Select your country or region from the dropdown list. After entering the details, click on the OK button to submit the form. After clicking the OK button, a success message will pop up: Message: User registered: your password has been emailed to the user's email address. Enter that password in CPLUS settings to finish setting up the plugin. The user will receive an email at the address entered in the form. This email will contain the user and password needed to complete the setup. After successful registration, a pop-up will prompt the user to set a new master authentication password. Setting the Master Password: Always enable the Store/Update master password in your Wallet/Keyring option to save the password securely in the Wallet/Keyring of your computer. Once set, the master password can be reset; however, the current master password will be needed prior to resetting. During the reset process, there is an option to generate a complete backup of the current database. Important: If the user forgets the master password, there is no way to retrieve or override it. There is also no means of retrieving encrypted information without knowing the master password. If a user inputs their existing password incorrectly three times, the dialog will offer to erase the database. Reminder: Do not forget your master password and store it securely for later use, as it is not retrievable. Required Field: Enter the new master password in the required password field. Verify Password Field: Re-enter the new master password in the verify password field to confirm it. Store/Update Master Password in your Wallet/KeyRing Checkbox: Enable the Store/Update master password in your Wallet/Keyring checkbox to save the password securely in your computer's Wallet/Keyring. OK Button: Click the OK button to submit and set the new master password. Cancel Button: Click the Cancel button to cancel the operation and exit the form without setting a new master password. Enter username and password (step 2): Click on the Enter username and password (step 2) button to log in to Trends.Earth account. Upon clicking on this button the Trends.Earth login form will open. To log in enter the email and password in the respective fields. Click on the OK button to log in to the Trends.Earth account. After successful submission, the success message will pop up. Update profile: Click on the Update profile button to update the profile. Upon clicking the update profile form will open. The user can update the fields they want to update. - Email: Enter the email address to update the email. - Name: Enter the name to update the name. - Organisation: Enter the name of organisation to update the organisation. - Country: Select the country from the dropdown list to update the country. Click on the Save button to save the changes. After a successful update, a success message will pop up. Reset password: Click on the Reset Password button to reset the password. Upon clicking the reset password form will open. Enter your email address below. If you have an account, an email will be sent to you (from api@trends.earth) with a new password. Email: Enter the email address in the provided field. OK Button: Click the OK button to submit the email address and request a password reset. Cancel Button: Click the Cancel button to cancel the password reset request and exit the form. Upon clicking the OK button, a confirmation popup will open with the following message: Confirmation Message: Are you sure you want to reset your password for xyz@gmail.com? Your new password will be mailed to you. No Button: Click the No button to cancel the password reset and close the confirmation popup. Yes Button: Click the Yes button to confirm the password reset. An email with your new password will be sent to you. On successful submission, the success message popup will be shown to the user. The user will receive an email with the new password. Delete user: Click on the Delete user button to delete the user. Upon clicking the delete user form will open. Message: Are you sure you want to delete the user xyz@gmail.com? All your tasks will be lost and you will no longer be able to process data online using Trends.Earth. No Button: Click the No button to cancel the deletion and close the form. Yes Button: Click the Yes button to confirm the deletion of the user. This will permanently delete your account and all associated tasks. Reporting: Click on the Reporting option for reports-related settings. Under the Reporting settings, users can configure the information to be included in the generated reports. These settings include: Organisation : (optional) Organisation or institute name. Contact email : (optional) Contact email of the user. Website : (optional) Link to the website of your company or institute. Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.). Logo preview : Visual preview of the default CI logo, or the custom logo a user selected. Footer : (optional) Will be added to the report. Disclaimer : Change as desired, otherwise use the default disclaimer. License : Change as desired, otherwise use the default license description. List of stakeholders and relationships : Enter the stakeholder's name and a brief description of the relationship separated by a dash i.e. Stakeholder's name - Relationship description Each entry should be in a new line. Cultural considerations : Enter the cultural considerations and a brief description separated by a dash i.e. Cultural considerations - description Each entry should be in a new line. Cultural Policies : Enter the cultural policies and a brief description separated by a dash i.e. Cultural policies - description Each entry should be in a new line. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes.","title":"Settings"},{"location":"user/manual/settings/#settings","text":"To go to the settings the user can click on the plugin toolbar icon to reveal the option. Setting: click on the settings option to go to the plugin settings. Upon clicking the settings page will open. CPLUS Dropdown: Click on the dropdown icon to reveal the CPLUS setting options. Click on the CPLUS to view the options like general, snapping, sieve, mask layer and trends earth login. 1 General: Click on the General option for basic settings such as General, Scenario Analysis, and Sieve settings.","title":"Settings"},{"location":"user/manual/settings/#general-settings","text":"Base data directory: Directory to read data from, and to which results will be written. 2 Scenario Analysis Setting: Coefficient for carbon layers: Applied to carbon layers during processing. Pathway suitability index: Index multiplied to the pathways. Lower values mean the pathway is less important, and higher values mean it's more important.","title":"General Settings"},{"location":"user/manual/settings/#snapping","text":"Snapping will set rasters to match the cell alignment of a reference layer. Resample method: Resampling performed on pixel values. The user can choose the method of their choice from the dropdown. The available methods are as follows: Nearest neighbour : Closest pixel value. This will be best to use if a user wants to preserve the original pixel values. Bilinear : Computes the pixel values from the two closest pixels (2 x 2 kernel). Cubic : Computes the pixel values from the four closest pixels (4 x 4 kernel). Cubic B-Spline : Cubic resampling based on B-Spline (4 x 4 kernel). Lanczos : Lanczos windowed sinc interpolation (6x6 kernel). Average : Computes the average of all non- nodata contributing pixels. Mode : Select the value that appears most often of all the sampled pixels. Maximum : Selects the maximum value which appears of all the sampled pixels. Minimum : Selects the minimum value which appears of all the sampled pixels. Median : Selects the median value that appears in all the sampled pixels. First quartile (Q1) : Select the first quartile value that appears in all the sampled pixels. Third quartile (Q3) : Select the third quartile value that appears in all the sampled pixels. Reference layer: The reference layer to which the cell alignment will be applied. The user can choose a file from the system. Rescale values: Rescale values according to cell size. The user can check or uncheck.","title":"Snapping"},{"location":"user/manual/settings/#sieve-settings","text":"The Sieve Function is a tool designed to filter raster data based on a specified threshold. It enables users to define a minimum area threshold, such that any contiguous area in the raster dataset smaller than the specified size will be removed or filtered out. This functionality is particularly useful for projects or activities that require a minimum spatial extent to be meaningful or practical. For instance, it might not be feasible to undertake an activity on a parcel of land that is smaller than a certain size, such as a hectare. By setting the desired threshold, users can ensure that only areas meeting the specified minimum extent are retained in the dataset, while smaller features are eliminated. This process helps streamline data analysis and ensures that only relevant spatial entities are considered for further processing or analysis. The user can use this by checking the checkbox available in front of the Sieve . Threshold Size: Enter the desired threshold value in the Threshold field. This value represents the minimum number of connected pixels that should be preserved when sieving. Any contiguous area smaller than this threshold will be filtered out. Reference Layer: The reference layer to which the sieve function will be applied. The user can choose the layer from the system. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes. 3 Mask Layers: Masking Layers: Masking layers are used to specify areas that should be excluded from further analysis. Adding a Layer to the Mask: When the user adds a layer to the mask, they specify that the areas covered by that layer should be excluded from the analysis or processing steps. Exclusion of Layer Area: By adding a layer to the mask, the user is essentially creating a filter that excludes the areas represented by that layer. Impact on Analysis: Any analysis or operations performed on the masked data will skip the areas covered by the added layer. This ensures that the analysis focuses only on the relevant geographic features while disregarding the specified layer. Relevance to GIS: Masking layers play a crucial role in GIS analysis, allowing users to focus on specific areas of interest and filter out irrelevant or undesired features from consideration. In summary, adding a layer to the mask in a context allows for the selective exclusion of specific geographic areas from analysis or visualisation, improving the accuracy and relevance of outputs. Arrow: Click on the available Arrow button in front of the Mask Layer to see the options for adding or deleting the layers from the mask feature. Upon clicking the user will see the options. Plus Icon: Click on the Plus icon, to add the layer to the mask layer from the system. Upon clicking the icon the system will show the available layer, and choose the desired layer to add to the mask layer. Minus Icon: Select the added layer and click on the Minus icon, to remove that layer. Ok: After adding the layer/layers to the mask layer, click on the OK button to save the layers in the mask layer and skip them from further analysis. 4 Irrecoverable Carbon Reference Layer: The Irrecoverable Carbon layer is used in a calculation with the protected pathways to calculate the total irrecoverable carbon per activity. 1 local path: Users are required to click on this radio button if they want to use the local path for the Irrecoverable Carbon layer. 2 Input Field: Users can click on this input field to enter the path manually or they can click on the three dots ... on the right side of the input field to open the file explorer from where they select the irrecoverable carbon layer. If the Irrecoverable Carbon layer is not found in the system, the system will show an error message. 1 Online source: Users are required to click on this radio button if they want to use the online source for the Irrecoverable Carbon layer. 2 URL: this field contains the url to down the Irrecoverable Carbon layer from the online source. 3 Save as: Specify the location and name for saving the downloaded Irrecoverable Carbon layer in the system. 4 Start download: Click on this button to download the resource. 5 Download not started: Current status of the downloading process. There are three types of statuses : Download Not started , Download ongoing , and Download successful . If the download fails, the system will show an error message. 5 Trends.Earth Login Information: NOTE: User need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. Register for Trends.Earth (step 1): Click on the Register for Trends.Earth (Step 1) button to initiate the registration process for Trends.Earth. Upon clicking, a registration form will open. The user needs to enter the following information: Email: Enter your email address. Name: Enter your full name. Organisation: Enter the name of your organisation. Country/Region: Select your country or region from the dropdown list. After entering the details, click on the OK button to submit the form. After clicking the OK button, a success message will pop up: Message: User registered: your password has been emailed to the user's email address. Enter that password in CPLUS settings to finish setting up the plugin. The user will receive an email at the address entered in the form. This email will contain the user and password needed to complete the setup. After successful registration, a pop-up will prompt the user to set a new master authentication password. Setting the Master Password: Always enable the Store/Update master password in your Wallet/Keyring option to save the password securely in the Wallet/Keyring of your computer. Once set, the master password can be reset; however, the current master password will be needed prior to resetting. During the reset process, there is an option to generate a complete backup of the current database. Important: If the user forgets the master password, there is no way to retrieve or override it. There is also no means of retrieving encrypted information without knowing the master password. If a user inputs their existing password incorrectly three times, the dialog will offer to erase the database. Reminder: Do not forget your master password and store it securely for later use, as it is not retrievable. Required Field: Enter the new master password in the required password field. Verify Password Field: Re-enter the new master password in the verify password field to confirm it. Store/Update Master Password in your Wallet/KeyRing Checkbox: Enable the Store/Update master password in your Wallet/Keyring checkbox to save the password securely in your computer's Wallet/Keyring. OK Button: Click the OK button to submit and set the new master password. Cancel Button: Click the Cancel button to cancel the operation and exit the form without setting a new master password. Enter username and password (step 2): Click on the Enter username and password (step 2) button to log in to Trends.Earth account. Upon clicking on this button the Trends.Earth login form will open. To log in enter the email and password in the respective fields. Click on the OK button to log in to the Trends.Earth account. After successful submission, the success message will pop up. Update profile: Click on the Update profile button to update the profile. Upon clicking the update profile form will open. The user can update the fields they want to update. - Email: Enter the email address to update the email. - Name: Enter the name to update the name. - Organisation: Enter the name of organisation to update the organisation. - Country: Select the country from the dropdown list to update the country. Click on the Save button to save the changes. After a successful update, a success message will pop up. Reset password: Click on the Reset Password button to reset the password. Upon clicking the reset password form will open. Enter your email address below. If you have an account, an email will be sent to you (from api@trends.earth) with a new password. Email: Enter the email address in the provided field. OK Button: Click the OK button to submit the email address and request a password reset. Cancel Button: Click the Cancel button to cancel the password reset request and exit the form. Upon clicking the OK button, a confirmation popup will open with the following message: Confirmation Message: Are you sure you want to reset your password for xyz@gmail.com? Your new password will be mailed to you. No Button: Click the No button to cancel the password reset and close the confirmation popup. Yes Button: Click the Yes button to confirm the password reset. An email with your new password will be sent to you. On successful submission, the success message popup will be shown to the user. The user will receive an email with the new password. Delete user: Click on the Delete user button to delete the user. Upon clicking the delete user form will open. Message: Are you sure you want to delete the user xyz@gmail.com? All your tasks will be lost and you will no longer be able to process data online using Trends.Earth. No Button: Click the No button to cancel the deletion and close the form. Yes Button: Click the Yes button to confirm the deletion of the user. This will permanently delete your account and all associated tasks. Reporting: Click on the Reporting option for reports-related settings. Under the Reporting settings, users can configure the information to be included in the generated reports. These settings include: Organisation : (optional) Organisation or institute name. Contact email : (optional) Contact email of the user. Website : (optional) Link to the website of your company or institute. Custom logo : (optional) If enabled, the user needs to provide a custom logo. Most formats should suffice (png, jpeg, etc.). Logo preview : Visual preview of the default CI logo, or the custom logo a user selected. Footer : (optional) Will be added to the report. Disclaimer : Change as desired, otherwise use the default disclaimer. License : Change as desired, otherwise use the default license description. List of stakeholders and relationships : Enter the stakeholder's name and a brief description of the relationship separated by a dash i.e. Stakeholder's name - Relationship description Each entry should be in a new line. Cultural considerations : Enter the cultural considerations and a brief description separated by a dash i.e. Cultural considerations - description Each entry should be in a new line. Cultural Policies : Enter the cultural policies and a brief description separated by a dash i.e. Cultural policies - description Each entry should be in a new line. To apply the settings user needs to click on the OK button. Click on Cancel will close the dialog without applying any changes.","title":"Sieve Settings"},{"location":"user/manual/step-1/","text":"Step 1: Scenario information \u00b6 Step 1 of the process involves setting up the scenario details and parameters. Users are provided with several options to define the scenario: Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report. Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report. Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored. Map Canvas Extent : The AOI will be the current extent the user has in QGIS. Draw on Canvas : Allows the user to manually draw the AOI. Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area Overall, Step 1 provides users with a comprehensive set of tools to define the scenario parameters, ensuring accuracy and relevance in subsequent analysis and reporting. Click here to explore the step 2 section. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 1"},{"location":"user/manual/step-1/#step-1-scenario-information","text":"Step 1 of the process involves setting up the scenario details and parameters. Users are provided with several options to define the scenario: Step 1 allows a user to set up the scenario details and parameters. Scenario name : This title will be used throughout the processing, will be used for the groups added to the QGIS canvas, and in the generated report. Scenario description : A detailed description of the scenario the user will be running. This information will be added to the final report. Extent : The area of interest (AOI) for analysis. Any spatial data outside this region will be ignored. Map Canvas Extent : The AOI will be the current extent the user has in QGIS. Draw on Canvas : Allows the user to manually draw the AOI. Zoom to Pilot Area : Zooms to the Bushbuckridge pilot study area Overall, Step 1 provides users with a comprehensive set of tools to define the scenario parameters, ensuring accuracy and relevance in subsequent analysis and reporting. Click here to explore the step 2 section. Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 1: Scenario information"},{"location":"user/manual/step-2/","text":"Step 2: NCS Pathways and Activities \u00b6 Step 2 focuses on the activities and pathways. Step 2 of the process revolves around configuring NCS (Natural Climate Solutions) pathways and activities. This step is crucial for defining the activities to be performed and pathways to be followed during the analysis. NCS pathways : Natural climate solution (NCS) Pathways which can be added to activities. Multiple pathways can be added to each activity. Add NCS Pathways: The user can add the NCS pathways according to their preferences to add the NCS pathways, click on the plus icon to open the NCS pathways add window. There are two ways to add the NCS Pathways: Add Manually Name: Enter the name of the NCS pathway. Description: Enter the description of the NCS pathway. Pathway Type: Select the type of the NCS pathway. Protect: Protect the world\u2019s natural ecosystems from unsustainable practices and degradation. Manage: Farming systems and working lands must shift from net carbon emitters to carbon sinks. Restore: Restore ecosystem types and globally can reduce global greenhouse gas emissions and store additional carbon up to 3 gigatons annually. Map Layer: Choose the map layer from the downloaded data available in the system. For example add map layer for Agroforestry After entering all details, click on the OK button to add the NCS pathway. Add Online Note: To use the Online Defaults option, the user needs to have an account on Trends.Earth platform. The user can add the NCS pathways online by clicking on the Online defaults radio button and selecting the default online layers from the dropdown menu. Name and the description will be filled automatically after choosing the NCS pathway. Click on the OK button to add the NCS pathway. After choosing from online default Activities : Each selected activity will be created and used to perform the analysis. Description : A description of the activity or pathway selected. : Add the selected pathway to the selected activity. : Adds all pathways to the selected activity. : Add a new activity. : Remove the selected activity. : Edit the selected activity. : Order the pixel values (activities) will be in the scenario output layer. Activity Editor dialog \u00b6 Name : The name of the new activity or activity being edited. Activity title will be used in the report Description : A detailed description of the activity. This will be used in the report Activity Mask : Activity Mask can be set to a specific mask to limit the pathways that can be added to the activity.By checking the box user will be able to apply the activity mask. Style : Styles used for the activity: Scenario layer : Colouring which will be used in the Scenario output for this activity Output activity layer : Colour ramp which will be applied to the activity raster output layer Activity Mask \u00b6 Activity Masking enables users to exclude specific areas from analysis. This functionality helps in refining analyses by isolating regions that are not relevant or need to be avoided during operations or planning. How Activity Masking works? \u00b6 Imagine planning a journey or mapping an area, and you want to exclude specific region like restricted zones, private properties, or hazardous locations. This masking tool allows you to mark those areas, ensuring they are excluded from your plans or analysis. It is like instructing the system, avoid these areas, enabling you to focus on relevant zones and create more precise and efficient plans. Here are activities displayed without applying any activity mask. This means all areas are included, and no regions have been excluded or hidden from the analysis. After applying the mask, the specified area becomes restricted for any activities or work. This ensures that no operations or tasks are carried out within that area, effectively excluding it from the analysis. As shown in the image below, after applying the mask, the specified area is marked as restricted for that particular activity. This restriction ensures that no operations or tasks related to the specific activity take place within the designated area, effectively excluding it from the further analysis. Apply Activity Mask \u00b6 \u2705 Activity Mask : By checking this, the user will be able to add an activity mask. : Add new activity mask. Click on this button to add a new activity mask. After clicking on the button, a new window will open from where user can select the shapefile. 1. File: Desired activity mask you want to apply. 2. Open: After selecting the file, click the Open button to include it in the activity. 3. Close: Click on the Close button to close the window. :Edit activity mask. Select the file you want to edit and then click on the Icon . This will open a new window, allowing you to choose a new activity mask. This will open a new window, allowing you to choose a new activity mask. 1. File: Desired activity mask you want to add. 2. Open: After selecting the file, click the Open button to include it in the activity. 3. Close: Click on the Close button to close the window. : Remove the selected activity mask. Select the activity mask you want to remove and click on the Icon . After clicking on the remove button, a confirmation dialog box will appear, prompting you to confirm the action. No: Click on the No button to cancel the action. Yes: Click on the Yes button to confirm the action and remove the activity mask. x: Click on the x button to close the dialog box. Ordering of the pixel values for the scenario output \u00b6 A user can order the stack using the Style Pixel Value Editor . Overall, Step 2 provides users with comprehensive tools for defining and configuring NCS pathways and activities, enabling efficient and accurate analysis and visualisation of natural climate solutions. NCS Pathway Validation \u00b6 Error Model: Whenever an error occurs the user will see the Error Model at the top. In this model, the user gets a basic idea about where to check for the detailed error logs. **Message:** NCS pathways are not valid or there is an ongoing validation process. Use the validation inspector to see more details. Validation Inspector: Click on the Validation Inspect/Magnifying Glass icon, to view the detailed error logs. Upon clicking the validation error window will pop up, where all the detailed logs are available. Arrows: Click on the available Arrow button in front of the error to expand that error log. Expand All: Click on the Expand All button, to expand all the error messages. Collapse All: Click on the Collapse All button, to collapse all the messages. Revalidate: Click on the Revalidate button, to revalidate. Upon clicking the button, it will rerun the validations. Close: Click on the Close button, to close the validation inspector window. The user can also check the validation inspector window to view the failed validations. Error Types Rule: Must be of raster data type Rule: Must have the same CRS Rule: Must have a projected CRS type Rule: NoData value must be -9999 Rule: Must have the same spatial resolution Rule: NCS and respective carbon layers should have the same spatial resolution Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"Step 2"},{"location":"user/manual/step-2/#step-2-ncs-pathways-and-activities","text":"Step 2 focuses on the activities and pathways. Step 2 of the process revolves around configuring NCS (Natural Climate Solutions) pathways and activities. This step is crucial for defining the activities to be performed and pathways to be followed during the analysis. NCS pathways : Natural climate solution (NCS) Pathways which can be added to activities. Multiple pathways can be added to each activity. Add NCS Pathways: The user can add the NCS pathways according to their preferences to add the NCS pathways, click on the plus icon to open the NCS pathways add window. There are two ways to add the NCS Pathways: Add Manually Name: Enter the name of the NCS pathway. Description: Enter the description of the NCS pathway. Pathway Type: Select the type of the NCS pathway. Protect: Protect the world\u2019s natural ecosystems from unsustainable practices and degradation. Manage: Farming systems and working lands must shift from net carbon emitters to carbon sinks. Restore: Restore ecosystem types and globally can reduce global greenhouse gas emissions and store additional carbon up to 3 gigatons annually. Map Layer: Choose the map layer from the downloaded data available in the system. For example add map layer for Agroforestry After entering all details, click on the OK button to add the NCS pathway. Add Online Note: To use the Online Defaults option, the user needs to have an account on Trends.Earth platform. The user can add the NCS pathways online by clicking on the Online defaults radio button and selecting the default online layers from the dropdown menu. Name and the description will be filled automatically after choosing the NCS pathway. Click on the OK button to add the NCS pathway. After choosing from online default Activities : Each selected activity will be created and used to perform the analysis. Description : A description of the activity or pathway selected. : Add the selected pathway to the selected activity. : Adds all pathways to the selected activity. : Add a new activity. : Remove the selected activity. : Edit the selected activity. : Order the pixel values (activities) will be in the scenario output layer.","title":"Step 2: NCS Pathways and Activities"},{"location":"user/manual/step-2/#activity-editor-dialog","text":"Name : The name of the new activity or activity being edited. Activity title will be used in the report Description : A detailed description of the activity. This will be used in the report Activity Mask : Activity Mask can be set to a specific mask to limit the pathways that can be added to the activity.By checking the box user will be able to apply the activity mask. Style : Styles used for the activity: Scenario layer : Colouring which will be used in the Scenario output for this activity Output activity layer : Colour ramp which will be applied to the activity raster output layer","title":"Activity Editor dialog"},{"location":"user/manual/step-2/#activity-mask","text":"Activity Masking enables users to exclude specific areas from analysis. This functionality helps in refining analyses by isolating regions that are not relevant or need to be avoided during operations or planning.","title":"Activity Mask"},{"location":"user/manual/step-2/#how-activity-masking-works","text":"Imagine planning a journey or mapping an area, and you want to exclude specific region like restricted zones, private properties, or hazardous locations. This masking tool allows you to mark those areas, ensuring they are excluded from your plans or analysis. It is like instructing the system, avoid these areas, enabling you to focus on relevant zones and create more precise and efficient plans. Here are activities displayed without applying any activity mask. This means all areas are included, and no regions have been excluded or hidden from the analysis. After applying the mask, the specified area becomes restricted for any activities or work. This ensures that no operations or tasks are carried out within that area, effectively excluding it from the analysis. As shown in the image below, after applying the mask, the specified area is marked as restricted for that particular activity. This restriction ensures that no operations or tasks related to the specific activity take place within the designated area, effectively excluding it from the further analysis.","title":"How Activity Masking works?"},{"location":"user/manual/step-2/#apply-activity-mask","text":"\u2705 Activity Mask : By checking this, the user will be able to add an activity mask. : Add new activity mask. Click on this button to add a new activity mask. After clicking on the button, a new window will open from where user can select the shapefile. 1. File: Desired activity mask you want to apply. 2. Open: After selecting the file, click the Open button to include it in the activity. 3. Close: Click on the Close button to close the window. :Edit activity mask. Select the file you want to edit and then click on the Icon . This will open a new window, allowing you to choose a new activity mask. This will open a new window, allowing you to choose a new activity mask. 1. File: Desired activity mask you want to add. 2. Open: After selecting the file, click the Open button to include it in the activity. 3. Close: Click on the Close button to close the window. : Remove the selected activity mask. Select the activity mask you want to remove and click on the Icon . After clicking on the remove button, a confirmation dialog box will appear, prompting you to confirm the action. No: Click on the No button to cancel the action. Yes: Click on the Yes button to confirm the action and remove the activity mask. x: Click on the x button to close the dialog box.","title":"Apply Activity Mask"},{"location":"user/manual/step-2/#ordering-of-the-pixel-values-for-the-scenario-output","text":"A user can order the stack using the Style Pixel Value Editor . Overall, Step 2 provides users with comprehensive tools for defining and configuring NCS pathways and activities, enabling efficient and accurate analysis and visualisation of natural climate solutions.","title":"Ordering of the pixel values for the scenario output"},{"location":"user/manual/step-2/#ncs-pathway-validation","text":"Error Model: Whenever an error occurs the user will see the Error Model at the top. In this model, the user gets a basic idea about where to check for the detailed error logs. **Message:** NCS pathways are not valid or there is an ongoing validation process. Use the validation inspector to see more details. Validation Inspector: Click on the Validation Inspect/Magnifying Glass icon, to view the detailed error logs. Upon clicking the validation error window will pop up, where all the detailed logs are available. Arrows: Click on the available Arrow button in front of the error to expand that error log. Expand All: Click on the Expand All button, to expand all the error messages. Collapse All: Click on the Collapse All button, to collapse all the messages. Revalidate: Click on the Revalidate button, to revalidate. Upon clicking the button, it will rerun the validations. Close: Click on the Close button, to close the validation inspector window. The user can also check the validation inspector window to view the failed validations. Error Types Rule: Must be of raster data type Rule: Must have the same CRS Rule: Must have a projected CRS type Rule: NoData value must be -9999 Rule: Must have the same spatial resolution Rule: NCS and respective carbon layers should have the same spatial resolution Click here to explore the step 3 section. Click here to explore the step 4 section. Click here to explore the log section.","title":"NCS Pathway Validation"},{"location":"user/manual/step-3/","text":"Step 3: Weighting priorities \u00b6 Step 3 focuses on weighting priorities, which involves assigning importance to different priority groups and weighted layers. This step is critical for determining the relative significance of various factors in the analysis. Priority groups : Users can define different priority groups to which priority weighting layers (PWLs) can be assigned. These groups represent different categories or themes that contribute to the overall analysis. : Add a new priority group. : Edit the selected priority group. : Remove the selected priority group. Priority Weighting Layers (PWL) : Users can assign importance values to each priority group by associating them with priority weighted layers. These layers represent the spatial data layers or attributes that contribute to the analysis. : Remove the selected PWL from the priority group. : Add the selected PWL to the selected priority group. : Create matrix of relative impact values for priority weighting layers. : Create a financial priority weighted layer. : Manage constant rasters. : Add a new PWL. : Edit the selected PWL. : Remove the selected PWL. Matrix of Relative Impact values Editor dialog \u00b6 The NCS Pathways and PWLs Matrix tool provides a structured way to define how each Natural Climate Solutions (NCS) pathway influences specific Priority/Weighting Layers (PWLs). Using a scale from \u20133 to +3, users can describe whether a pathway has a negative, neutral, or positive effect on key variables. Understanding the Matrix of Relative Impact values tool In Step 3 of the workflow, the plugin displays a matrix where: Rows \u2192 NCS pathways Columns \u2192 PWL variables Users assign a coefficient (\u20133 to +3) to each pathway\u2013PWL combination. The matrix focuses only on impact-based PWLs, where the pathway directly influences the variable (e.g., carbon, biodiversity, water, livelihoods). Fragmentation-based PWLs, those related to spatial configuration or landscape compatibility, are handled separately and do not require coefficients. Carbon-related variables (biomass, sequestration potential, soil carbon) fit naturally within this scheme and can be assigned positive or negative impact scores. Below is an example of the relative impact of pathways on different variables: Purpose of Matrix of Relative Impact values tool Earlier steps in the workflow evaluate implementability, producing maps that show how suitable or feasible it is to apply each pathway in each location. These implementability variables are pathway-specific and relate to costs, logistics, governance, access, degradation type, and other factors. However, implementability does not reflect the broader system-level outcomes of restoration. Impact variables such as: carbon benefits biodiversity gains livelihood contributions freshwater regulation remain essential for holistic planning. The impact coefficient system captures these direct effects, allowing users to integrate impact modelling into the evaluation. In many analyses, implementability results are later combined with impact-based outcomes in a second multicriteria assessment, which the CPLUS plugin fully supports. File Icon: Click on the file icon to open the matrix of relative impact values tool. Upon clicking, a new window will open for adding coefficient values to each pathway\u2013PWL combination. Below is an example of a completed matrix table with coefficient values between -3 and 3. Any other values is not allowed by the system. Reset Matrix: Values may be modified individually, or the entire table can be reset and repopulated as needed. Save: Save the matrix table after adding or editing coefficient values. Cancel: Cancel to discard any changes made to the matrix table. Financial Priority Weighted Layer Editor dialog \u00b6 The Net Present Value (NPV) Tool is designed to assist users in making informed financial decisions by evaluating and prioritising activities based on their projected cash flows and the time value of money. This manual provides comprehensive instructions on how to utilise the NPV tool effectively. Understanding Net Present Value (NPV): Net Present Value (NPV) is a financial metric that calculates the value of a series of future cash flows in today's terms. By discounting future cash flows to their present value, NPV allows users to assess the profitability of an investment or project. Purpose of the NPV Tool The primary purpose of the NPV Tool is to help users prioritise activities by providing a clear picture of the financial implications. This aids in holistic decision-making during the planning process, ensuring that the activities with the highest potential value are prioritised and executed. File Icon: Click on the file icon to create a new financial priority weighted layer. Upon clicking, a new window will open specifically for creating the NPV Net Present Value layer. Net Present Value (NPV) \u00b6 NPV checkbox: By default, on the first-time load, the NPV configurations for all activities are disabled. To enable the Net Present Value (NPV) for an activity, check the NPV group box. Number of years: Enter the number of years. The number of rows in the table will adjust according to the entered number. Discount Rate %: Enter the discount rate. Years Table: Input the Project total revenues per hectare and Project total cost per hectare values for the respective years. Note that the Year and Discount Value cells are greyed out as they are automatically populated. NOTE: For an enabled NPV PWL, all revenue and cost values must be specified. If any values are missing, an error message will display the activities and corresponding years with missing values when attempting to create or update the PWLs. Net Present Value per Hectare: When the discount rate, revenue, and cost values are updated, the total NPV is automatically recalculated and shown in the net present value per hectare box. Copy icon: The user can copy the NPV by clicking on the copy icon available next to the net present value per hectare box. User-defined NPV Checkbox: By enabling this checkbox we can manually set the Net present value per hectare value. Min/Max Normalisation Range: It is recommended to keep the Use computed NPVs check box enabled (default option). This ensures that the minimum and maximum normalisation values are synced and automatically updated based on user input. The min/max values will be based on enabled NPV parameters for activities. Disabled NPV parameters will be excluded from the computation. Remove Existing WPL Checkbox: When the Remove existing PWLs for disabled activity NPVs check box is enabled, any previously created NPV PWLs will be deleted upon updating the NPVs. Cancel Button: Click on the cancel button to cancel the adding NPV. Update Button: Click the Update button to show a dialog displaying the progress of creating/updating the NPVs. When creating NPV PWL rasters, the corresponding PWLs will be created or updated in the list of PWLs. The naming convention for these layers is [activity name] NPV Norm . An NPV layer, which is a constant raster containing the normalised value, will be created under the {BASE_DIR}/priority_layers/npv directory. The extents are based on the user-defined extents specified in Step 1. Manage Constant Rasters Editor dialog \u00b6 Some evaluation criteria, such as years of project experience or other investability factors, are not spatially variable and must be introduced as constant raster layers. These layers ensure that non-spatial attributes are treated consistently alongside spatial data such as PW or NPV rasters. By converting these variables into normalized and weighted raster layers, they can be incorporated into the broader project evaluation workflow. Understanding Constant Rasters A constant raster is a layer in which every cell holds the same value. These values typically represent project-level attributes that do not change across space. Examples include: Years of project experience Market Trends Confidence in Ability to Deliver Since these variables can influence investment prioritization, they must be normalized and included in the analysis in a controlled and comparable way. Normalization ensures that each variable contributes proportionally to the overall evaluation. This typically involves scaling values to a 0\u20131 range, where the highest-performing project receives a value of 1, and others are scaled accordingly. This process aligns these variables with other normalized layers like PW and NPV. Purpose of Constant Rasters The purpose of incorporating constant rasters is to: Integrate non-spatial project attributes into spatial evaluation workflows Standardize the influence of investability variables through normalization Ensure consistency in multi-criteria decision analysis and scoring Allow users to input, modify, or replace investability values without altering the underlying geospatial structure This enables more balanced, transparent, and defensible project prioritization results. Add new Priority Weighting Layer (PWL) \u00b6 : Allows users to add a new Priority Weighting Layer. Methods to create layers \u00b6 Method 1: Create manually \u00b6 The following parameters need to be set: Priority layer : The layer that represents the priority layer. Priority layer name : A unique identifier for the priority layer. Priority layer description : A detailed description of the priority layer. Click the Assign activities button to select activities to be associated with the priority layer. Select the activities you want to be associated with the priority layer. Click OK . List of activities a user can select. Multiple activities can be selected. OK : Save the selected activities. Select All : Select each of the available activities. Clear Selection : Deselects each of the selected activities. Toggle Selection : Switches each option from deselected to selected, or selected to de-selected. Method 2: Create Online \u00b6 Click on the Online defaults to select the default priority layer from the available options. Then click OK to add the priority layer to PWL.","title":"Step 3"},{"location":"user/manual/step-3/#step-3-weighting-priorities","text":"Step 3 focuses on weighting priorities, which involves assigning importance to different priority groups and weighted layers. This step is critical for determining the relative significance of various factors in the analysis. Priority groups : Users can define different priority groups to which priority weighting layers (PWLs) can be assigned. These groups represent different categories or themes that contribute to the overall analysis. : Add a new priority group. : Edit the selected priority group. : Remove the selected priority group. Priority Weighting Layers (PWL) : Users can assign importance values to each priority group by associating them with priority weighted layers. These layers represent the spatial data layers or attributes that contribute to the analysis. : Remove the selected PWL from the priority group. : Add the selected PWL to the selected priority group. : Create matrix of relative impact values for priority weighting layers. : Create a financial priority weighted layer. : Manage constant rasters. : Add a new PWL. : Edit the selected PWL. : Remove the selected PWL.","title":"Step 3: Weighting priorities"},{"location":"user/manual/step-3/#matrix-of-relative-impact-values-editor-dialog","text":"The NCS Pathways and PWLs Matrix tool provides a structured way to define how each Natural Climate Solutions (NCS) pathway influences specific Priority/Weighting Layers (PWLs). Using a scale from \u20133 to +3, users can describe whether a pathway has a negative, neutral, or positive effect on key variables. Understanding the Matrix of Relative Impact values tool In Step 3 of the workflow, the plugin displays a matrix where: Rows \u2192 NCS pathways Columns \u2192 PWL variables Users assign a coefficient (\u20133 to +3) to each pathway\u2013PWL combination. The matrix focuses only on impact-based PWLs, where the pathway directly influences the variable (e.g., carbon, biodiversity, water, livelihoods). Fragmentation-based PWLs, those related to spatial configuration or landscape compatibility, are handled separately and do not require coefficients. Carbon-related variables (biomass, sequestration potential, soil carbon) fit naturally within this scheme and can be assigned positive or negative impact scores. Below is an example of the relative impact of pathways on different variables: Purpose of Matrix of Relative Impact values tool Earlier steps in the workflow evaluate implementability, producing maps that show how suitable or feasible it is to apply each pathway in each location. These implementability variables are pathway-specific and relate to costs, logistics, governance, access, degradation type, and other factors. However, implementability does not reflect the broader system-level outcomes of restoration. Impact variables such as: carbon benefits biodiversity gains livelihood contributions freshwater regulation remain essential for holistic planning. The impact coefficient system captures these direct effects, allowing users to integrate impact modelling into the evaluation. In many analyses, implementability results are later combined with impact-based outcomes in a second multicriteria assessment, which the CPLUS plugin fully supports. File Icon: Click on the file icon to open the matrix of relative impact values tool. Upon clicking, a new window will open for adding coefficient values to each pathway\u2013PWL combination. Below is an example of a completed matrix table with coefficient values between -3 and 3. Any other values is not allowed by the system. Reset Matrix: Values may be modified individually, or the entire table can be reset and repopulated as needed. Save: Save the matrix table after adding or editing coefficient values. Cancel: Cancel to discard any changes made to the matrix table.","title":"Matrix of Relative Impact values Editor dialog"},{"location":"user/manual/step-3/#financial-priority-weighted-layer-editor-dialog","text":"The Net Present Value (NPV) Tool is designed to assist users in making informed financial decisions by evaluating and prioritising activities based on their projected cash flows and the time value of money. This manual provides comprehensive instructions on how to utilise the NPV tool effectively. Understanding Net Present Value (NPV): Net Present Value (NPV) is a financial metric that calculates the value of a series of future cash flows in today's terms. By discounting future cash flows to their present value, NPV allows users to assess the profitability of an investment or project. Purpose of the NPV Tool The primary purpose of the NPV Tool is to help users prioritise activities by providing a clear picture of the financial implications. This aids in holistic decision-making during the planning process, ensuring that the activities with the highest potential value are prioritised and executed. File Icon: Click on the file icon to create a new financial priority weighted layer. Upon clicking, a new window will open specifically for creating the NPV Net Present Value layer.","title":"Financial Priority Weighted Layer Editor dialog"},{"location":"user/manual/step-3/#net-present-value-npv","text":"NPV checkbox: By default, on the first-time load, the NPV configurations for all activities are disabled. To enable the Net Present Value (NPV) for an activity, check the NPV group box. Number of years: Enter the number of years. The number of rows in the table will adjust according to the entered number. Discount Rate %: Enter the discount rate. Years Table: Input the Project total revenues per hectare and Project total cost per hectare values for the respective years. Note that the Year and Discount Value cells are greyed out as they are automatically populated. NOTE: For an enabled NPV PWL, all revenue and cost values must be specified. If any values are missing, an error message will display the activities and corresponding years with missing values when attempting to create or update the PWLs. Net Present Value per Hectare: When the discount rate, revenue, and cost values are updated, the total NPV is automatically recalculated and shown in the net present value per hectare box. Copy icon: The user can copy the NPV by clicking on the copy icon available next to the net present value per hectare box. User-defined NPV Checkbox: By enabling this checkbox we can manually set the Net present value per hectare value. Min/Max Normalisation Range: It is recommended to keep the Use computed NPVs check box enabled (default option). This ensures that the minimum and maximum normalisation values are synced and automatically updated based on user input. The min/max values will be based on enabled NPV parameters for activities. Disabled NPV parameters will be excluded from the computation. Remove Existing WPL Checkbox: When the Remove existing PWLs for disabled activity NPVs check box is enabled, any previously created NPV PWLs will be deleted upon updating the NPVs. Cancel Button: Click on the cancel button to cancel the adding NPV. Update Button: Click the Update button to show a dialog displaying the progress of creating/updating the NPVs. When creating NPV PWL rasters, the corresponding PWLs will be created or updated in the list of PWLs. The naming convention for these layers is [activity name] NPV Norm . An NPV layer, which is a constant raster containing the normalised value, will be created under the {BASE_DIR}/priority_layers/npv directory. The extents are based on the user-defined extents specified in Step 1.","title":"Net Present Value (NPV)"},{"location":"user/manual/step-3/#manage-constant-rasters-editor-dialog","text":"Some evaluation criteria, such as years of project experience or other investability factors, are not spatially variable and must be introduced as constant raster layers. These layers ensure that non-spatial attributes are treated consistently alongside spatial data such as PW or NPV rasters. By converting these variables into normalized and weighted raster layers, they can be incorporated into the broader project evaluation workflow. Understanding Constant Rasters A constant raster is a layer in which every cell holds the same value. These values typically represent project-level attributes that do not change across space. Examples include: Years of project experience Market Trends Confidence in Ability to Deliver Since these variables can influence investment prioritization, they must be normalized and included in the analysis in a controlled and comparable way. Normalization ensures that each variable contributes proportionally to the overall evaluation. This typically involves scaling values to a 0\u20131 range, where the highest-performing project receives a value of 1, and others are scaled accordingly. This process aligns these variables with other normalized layers like PW and NPV. Purpose of Constant Rasters The purpose of incorporating constant rasters is to: Integrate non-spatial project attributes into spatial evaluation workflows Standardize the influence of investability variables through normalization Ensure consistency in multi-criteria decision analysis and scoring Allow users to input, modify, or replace investability values without altering the underlying geospatial structure This enables more balanced, transparent, and defensible project prioritization results.","title":"Manage Constant Rasters Editor dialog"},{"location":"user/manual/step-3/#add-new-priority-weighting-layer-pwl","text":": Allows users to add a new Priority Weighting Layer.","title":"Add new Priority Weighting Layer (PWL)"},{"location":"user/manual/step-3/#methods-to-create-layers","text":"","title":"Methods to create layers"},{"location":"user/manual/step-3/#method-1-create-manually","text":"The following parameters need to be set: Priority layer : The layer that represents the priority layer. Priority layer name : A unique identifier for the priority layer. Priority layer description : A detailed description of the priority layer. Click the Assign activities button to select activities to be associated with the priority layer. Select the activities you want to be associated with the priority layer. Click OK . List of activities a user can select. Multiple activities can be selected. OK : Save the selected activities. Select All : Select each of the available activities. Clear Selection : Deselects each of the selected activities. Toggle Selection : Switches each option from deselected to selected, or selected to de-selected.","title":"Method 1: Create manually"},{"location":"user/manual/step-3/#method-2-create-online","text":"Click on the Online defaults to select the default priority layer from the available options. Then click OK to add the priority layer to PWL.","title":"Method 2: Create Online"},{"location":"user/manual/step-4/","text":"Step4: Select outputs and processing options \u00b6 Step 4: Step 4 guides the user to select the outputs to be saved into the file system for report generation. By clicking on the Step 4 option, the user will navigate to the section dedicated to producing outputs. Here, the user finds a list of available outputs, each representing data that can be included in the report. When the user selects an output, it signifies that the user wants it to be saved onto their file system, making it accessible beyond the current session. Conversely, leaving an option unselected means that the data will be stored as a memory layer, useful for temporary use within the current session. This step is crucial for tailoring the outputs to include only the necessary information, thereby optimising memory usage. By choosing specific outputs to be saved, the user can generate fewer output layers which utilises system resources more efficiently. Select Outputs There are 5 options available in the select outputs. 1. NCS With Carbon: This output is initially unchecked by default. When selected, it triggers the generation of the NCS pathways output, providing insights into the pathways associated with NCS (Natural climate solution) and carbon sequestration. 2. Landuse Activity: Initially, this output is checked by default. It generates landuse activity layer outputs, providing valuable insights into various landuse activities. Users have the option to uncheck it if they do not wish to include landuse data in the report. 3. Landuse Activity Normalised: By default, this output is checked. It generates landuse project normalised outputs, providing a normalised view of landuse activities for enhanced analysis. Users have the option to uncheck it if they do not wish to include landuse normalised data in the report. 4. Landuse Activity Weighted with PWL (Priority weighted layers): By default, this output is checked. It generates landuse projects weighted outputs. Unselecting this option will disable report generation this is because the weighted output is the required output for report generation. 5. Scenario Highest Position analysis: By default, this output is checked. It generates the final highest position analysis outputs. Unselecting this option will disable report generation this is because the highest position analysis output is the required output for report generation. Processing Options NOTE: Users need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. The user can also choose the processing option, deciding whether they want to process online or offline. Process the scenario online: By default, this option is unchecked. When the user selects this option, the scenario is processed online using the API. This means that the system sends the scenario data to a remote server or service via the Internet. The remote server performs the necessary computations or analysis based on the provided scenario data. Processing online allows for real-time analysis and can leverage the computing power and resources available on the remote server. This option might be preferred when the user requires quicker results or when the scenario data is too large or complex to be processed efficiently on the user's local device. However, processing online may require a stable internet connection. If the user has previously selected Online defaults , this option will be selected automatically. Scenario report options: Below are the benefits of the scenario report options. The Metrics Generator enables plugin users to incorporate additional metrics or calculations for each activity. It includes automated expressions that assist in calculating measures such as irrecoverable carbon, financial metrics like the net present value (NPV) of each activity, and other weighting measures such as jobs per hectare. The tool leverages the full functionality of the expression builder, allowing users to create fully customised expressions based on the available project variables. The Expression Builder within the Metrics Generator has been enhanced with a CPLUS library, which offers automated calculations for irrecoverable carbon, PWL measures, and NPV. These features come with helpful guidance for their use. It is also important to reference the variables list when creating custom options. The Metrics Generator introduces the concept of a metric profile that represents a collection of columns grouped according to user-defined criteria. The grouping options are entirely flexible, depending on how the user wishes to organize the columns and their associated properties. The primary benefit of profiles is that they enable users to configure column groupings and easily select which profiles to apply in different scenario analysis reports. Note: Please note that expressions can be applied on a column-by-column basis or can be cell-specific, providing full granularity for the measures and metrics associated with each activity. 1 Use custom activity metrics table: Users must check the checkbox to enable this option. After doing so, they need to click on the icon to access the metrics table. Users are required to follow these steps to create a custom activity metrics table. Step 1: 1 x: Close the wizard. 2 Help: Provides the qgis help documentation. 3 Back: Go back to the previous step (Disabled in the first step). 4 Next: Proceed to the next step. 5 Cancel: Cancel the current operation. Step 2: 1 Profiles: Users can specify profiles for managing column groupings by selecting the current metric profile. Add Profile allows users to add a new profile. This opens a Add New Profile dialog box where a user can enter the name of the profile. A user can enter the profile name to add it to the list of profiles and set it as the current profile. If the profile name already exists, the following error message will be shown: Rename Profile allows users to rename the current profile. This opens a Rename Profile dialog box where a user can enter the name of the profile. A user can enter the updated profile name. If the profile name already exists, the following error message will be shown: Copy Profile allows users to copy the current profile. This will open a Copy Profile dialog which allows a user to specify a new name for the copied profile. A user can enter the name of the copied profile to add it to the list of profiles and set it as the current profile. A Copy suffix is, by default, appended to the name of the source profile. If the profile name already exists, the following error message will be shown: Delete Profile allows users to remove the current profile. 2 Columns: Users can add or remove columns from the table. : Allows users to add column to the table. x: Close the dialog box. Input Field: Users are required to enter the column name in this input field. Cancel: Cancel the process. OK: Users can complete the add column process by clicking on this button. If users click on this button without filling the column name then the process will be complete without any column being added. If users fill in a column name which is already available in the table then the users will encounter the error There is already existing column name . : Allows users to remove a column from the table. Users are required to select the column which they want to remove from the table and then click on this button to remove it from the table. and : Allows users to reorder the columns in the table. Select the column from the table and then click on the either any option to reorder the column. 3 Properties: This contains the properties of the column. Header label: The default header name is based on the selected column. Users can change it to any name they prefer, but the field must be filled in. If the Header label is empty then the users will encounter with the error header label is empty . Metric: Users can select the metric from the dropdown list. User can clear the metric filed by clicking on the x mark available inside the input field and can add their own custom metric. Create Custom Metric: Users can create their own custom metric by clicking on the \u03b5 epsilon button located on the right side of the Metric input field. This will open the Column Expression Builder dialog box. 1 Expression: Users can access the expression tab by clicking here. 2 Input Area: User can enter the expression in this input area. 3 Operators and symbols: Users can access the operators and symbols from here. 4 Functions: Users can choose the function that their expression is related to. 5 Details Section: This section shows the details of the expression like how users can fill the expression, what are the available arguments and operators etc. For Example: 1 Input Area: Contains the expression we have entered. 2 Functions: For example, we have selected the CASE from Conditionals . 3 Details Section: This section shows the details of the expression like how users can fill the expression, what are the available arguments and operators etc. 4 Preview: This section displays the feature details. In our case, we have entered the incorrect input without following the proper syntax, resulting in an error in the preview. After filling all the details users are required to click on the OK button to complete the process or they can click on the Cancel button to cancel the process. When users click on the Cancel button a popup dialog box will appear asking for confirmation to cancel the process. \u2705: Users can check this checkbox to remember their choice and avoid showing this message again in the future. No: Users can click on the No button to go back to the editing the process. Discard changes: Users can click on this button to complete the cancel process. This will discard the changes and close the window. 4 Formatting: This contains the formatting options for the column. Horizontal alignment: Users can select the horizontal alignment of the column from the dropdown list, choosing between left, center, right, or justify alignment. Format as number: Users are required to check the checkbox to use this option, then users will be use the Customise... button to customise the number format. 1 Number Format: Users can use this button to go back to the previous window. 2 Category: Users can select the category of the number format from the dropdown list. 3 Format: Users can select the format of the number from the dropdown list. (This field varies depending on the selected category.) 4 Decimal places: Users can enter the number of decimal places to be displayed. (This field varies depending on the selected category.) 5 Show trailing zeros: Users can select this checkbox to display trailing zeros. (This field varies depending on the selected category.) 6 Sample: Users can see the sample of the number format selected. Step 3: 1 Customise activity metric: Checking this checkbox allows users to customise the metric of a specific cell. 2 Customise cell metric: Double-clicking on a cell converts it into a dropdown menu. Users can then select the <Cell metrics> option from the menu, enabling them to customise the cell metric. This will open the Activity Expression Builder window. Please check the Step 2 to know more about how to customise the metric. If users try to proceed without defining the <Cell-metric> then users will encounter an error message. Step 4: This is the last step where a user review all the columns and metrics they have defined. After clicking on the Finish button will complete the process, with the current profile set as the active profile, and redirected to the Qgis plugin Step 4 from where users can generate the report with the custom activity metrics table . Active Metric Profile: A user can select the desired profile for the custom activity table in the scenario analysis report by using the dropdown menu as shown below: Hovering over the metric builder button displays the currently active profile selected by the user. Run Scenario: After checking or unchecking the checkbox, click on the Run Scenario button to execute the scenario and generate the report. 1. Progress Bar: Upon clicking this button, a pop-up window will appear, displaying a progress bar indicating the report generation status. 2. View Report Dropdown: Once the report is generated, the user can click on the View Report dropdown, to view the options. The following options are available there. Layout designer: Opens the report in the QGIS layout designer. Open PDF: Opens the created PDF. Help: Takes the user to the User's documentation site. 3. Hide: This option hides the Progress Dialog Box. 4. Cancel: Click on the Cancel button to terminate the report generation process. Upon clicking this button, it will transform into the Close button. Click on the Close button to dismiss the pop-up window. View Task Status Online \u00b6 After clicking on the Hide button this button will be enabled to view the task status. Click on the View Task Online button to view the task status. Report without custom metrics table \u00b6 Users can see in the report there is no custom metrics table. Report with custom metrics table \u00b6 Users can see in the report that the custom metrics table is included. Click here to explore the log section.","title":"Step 4"},{"location":"user/manual/step-4/#step4-select-outputs-and-processing-options","text":"Step 4: Step 4 guides the user to select the outputs to be saved into the file system for report generation. By clicking on the Step 4 option, the user will navigate to the section dedicated to producing outputs. Here, the user finds a list of available outputs, each representing data that can be included in the report. When the user selects an output, it signifies that the user wants it to be saved onto their file system, making it accessible beyond the current session. Conversely, leaving an option unselected means that the data will be stored as a memory layer, useful for temporary use within the current session. This step is crucial for tailoring the outputs to include only the necessary information, thereby optimising memory usage. By choosing specific outputs to be saved, the user can generate fewer output layers which utilises system resources more efficiently. Select Outputs There are 5 options available in the select outputs. 1. NCS With Carbon: This output is initially unchecked by default. When selected, it triggers the generation of the NCS pathways output, providing insights into the pathways associated with NCS (Natural climate solution) and carbon sequestration. 2. Landuse Activity: Initially, this output is checked by default. It generates landuse activity layer outputs, providing valuable insights into various landuse activities. Users have the option to uncheck it if they do not wish to include landuse data in the report. 3. Landuse Activity Normalised: By default, this output is checked. It generates landuse project normalised outputs, providing a normalised view of landuse activities for enhanced analysis. Users have the option to uncheck it if they do not wish to include landuse normalised data in the report. 4. Landuse Activity Weighted with PWL (Priority weighted layers): By default, this output is checked. It generates landuse projects weighted outputs. Unselecting this option will disable report generation this is because the weighted output is the required output for report generation. 5. Scenario Highest Position analysis: By default, this output is checked. It generates the final highest position analysis outputs. Unselecting this option will disable report generation this is because the highest position analysis output is the required output for report generation. Processing Options NOTE: Users need to register and login with a Trends.Earth account to use the online API for processing with CPLUS. The user can also choose the processing option, deciding whether they want to process online or offline. Process the scenario online: By default, this option is unchecked. When the user selects this option, the scenario is processed online using the API. This means that the system sends the scenario data to a remote server or service via the Internet. The remote server performs the necessary computations or analysis based on the provided scenario data. Processing online allows for real-time analysis and can leverage the computing power and resources available on the remote server. This option might be preferred when the user requires quicker results or when the scenario data is too large or complex to be processed efficiently on the user's local device. However, processing online may require a stable internet connection. If the user has previously selected Online defaults , this option will be selected automatically. Scenario report options: Below are the benefits of the scenario report options. The Metrics Generator enables plugin users to incorporate additional metrics or calculations for each activity. It includes automated expressions that assist in calculating measures such as irrecoverable carbon, financial metrics like the net present value (NPV) of each activity, and other weighting measures such as jobs per hectare. The tool leverages the full functionality of the expression builder, allowing users to create fully customised expressions based on the available project variables. The Expression Builder within the Metrics Generator has been enhanced with a CPLUS library, which offers automated calculations for irrecoverable carbon, PWL measures, and NPV. These features come with helpful guidance for their use. It is also important to reference the variables list when creating custom options. The Metrics Generator introduces the concept of a metric profile that represents a collection of columns grouped according to user-defined criteria. The grouping options are entirely flexible, depending on how the user wishes to organize the columns and their associated properties. The primary benefit of profiles is that they enable users to configure column groupings and easily select which profiles to apply in different scenario analysis reports. Note: Please note that expressions can be applied on a column-by-column basis or can be cell-specific, providing full granularity for the measures and metrics associated with each activity. 1 Use custom activity metrics table: Users must check the checkbox to enable this option. After doing so, they need to click on the icon to access the metrics table. Users are required to follow these steps to create a custom activity metrics table. Step 1: 1 x: Close the wizard. 2 Help: Provides the qgis help documentation. 3 Back: Go back to the previous step (Disabled in the first step). 4 Next: Proceed to the next step. 5 Cancel: Cancel the current operation. Step 2: 1 Profiles: Users can specify profiles for managing column groupings by selecting the current metric profile. Add Profile allows users to add a new profile. This opens a Add New Profile dialog box where a user can enter the name of the profile. A user can enter the profile name to add it to the list of profiles and set it as the current profile. If the profile name already exists, the following error message will be shown: Rename Profile allows users to rename the current profile. This opens a Rename Profile dialog box where a user can enter the name of the profile. A user can enter the updated profile name. If the profile name already exists, the following error message will be shown: Copy Profile allows users to copy the current profile. This will open a Copy Profile dialog which allows a user to specify a new name for the copied profile. A user can enter the name of the copied profile to add it to the list of profiles and set it as the current profile. A Copy suffix is, by default, appended to the name of the source profile. If the profile name already exists, the following error message will be shown: Delete Profile allows users to remove the current profile. 2 Columns: Users can add or remove columns from the table. : Allows users to add column to the table. x: Close the dialog box. Input Field: Users are required to enter the column name in this input field. Cancel: Cancel the process. OK: Users can complete the add column process by clicking on this button. If users click on this button without filling the column name then the process will be complete without any column being added. If users fill in a column name which is already available in the table then the users will encounter the error There is already existing column name . : Allows users to remove a column from the table. Users are required to select the column which they want to remove from the table and then click on this button to remove it from the table. and : Allows users to reorder the columns in the table. Select the column from the table and then click on the either any option to reorder the column. 3 Properties: This contains the properties of the column. Header label: The default header name is based on the selected column. Users can change it to any name they prefer, but the field must be filled in. If the Header label is empty then the users will encounter with the error header label is empty . Metric: Users can select the metric from the dropdown list. User can clear the metric filed by clicking on the x mark available inside the input field and can add their own custom metric. Create Custom Metric: Users can create their own custom metric by clicking on the \u03b5 epsilon button located on the right side of the Metric input field. This will open the Column Expression Builder dialog box. 1 Expression: Users can access the expression tab by clicking here. 2 Input Area: User can enter the expression in this input area. 3 Operators and symbols: Users can access the operators and symbols from here. 4 Functions: Users can choose the function that their expression is related to. 5 Details Section: This section shows the details of the expression like how users can fill the expression, what are the available arguments and operators etc. For Example: 1 Input Area: Contains the expression we have entered. 2 Functions: For example, we have selected the CASE from Conditionals . 3 Details Section: This section shows the details of the expression like how users can fill the expression, what are the available arguments and operators etc. 4 Preview: This section displays the feature details. In our case, we have entered the incorrect input without following the proper syntax, resulting in an error in the preview. After filling all the details users are required to click on the OK button to complete the process or they can click on the Cancel button to cancel the process. When users click on the Cancel button a popup dialog box will appear asking for confirmation to cancel the process. \u2705: Users can check this checkbox to remember their choice and avoid showing this message again in the future. No: Users can click on the No button to go back to the editing the process. Discard changes: Users can click on this button to complete the cancel process. This will discard the changes and close the window. 4 Formatting: This contains the formatting options for the column. Horizontal alignment: Users can select the horizontal alignment of the column from the dropdown list, choosing between left, center, right, or justify alignment. Format as number: Users are required to check the checkbox to use this option, then users will be use the Customise... button to customise the number format. 1 Number Format: Users can use this button to go back to the previous window. 2 Category: Users can select the category of the number format from the dropdown list. 3 Format: Users can select the format of the number from the dropdown list. (This field varies depending on the selected category.) 4 Decimal places: Users can enter the number of decimal places to be displayed. (This field varies depending on the selected category.) 5 Show trailing zeros: Users can select this checkbox to display trailing zeros. (This field varies depending on the selected category.) 6 Sample: Users can see the sample of the number format selected. Step 3: 1 Customise activity metric: Checking this checkbox allows users to customise the metric of a specific cell. 2 Customise cell metric: Double-clicking on a cell converts it into a dropdown menu. Users can then select the <Cell metrics> option from the menu, enabling them to customise the cell metric. This will open the Activity Expression Builder window. Please check the Step 2 to know more about how to customise the metric. If users try to proceed without defining the <Cell-metric> then users will encounter an error message. Step 4: This is the last step where a user review all the columns and metrics they have defined. After clicking on the Finish button will complete the process, with the current profile set as the active profile, and redirected to the Qgis plugin Step 4 from where users can generate the report with the custom activity metrics table . Active Metric Profile: A user can select the desired profile for the custom activity table in the scenario analysis report by using the dropdown menu as shown below: Hovering over the metric builder button displays the currently active profile selected by the user. Run Scenario: After checking or unchecking the checkbox, click on the Run Scenario button to execute the scenario and generate the report. 1. Progress Bar: Upon clicking this button, a pop-up window will appear, displaying a progress bar indicating the report generation status. 2. View Report Dropdown: Once the report is generated, the user can click on the View Report dropdown, to view the options. The following options are available there. Layout designer: Opens the report in the QGIS layout designer. Open PDF: Opens the created PDF. Help: Takes the user to the User's documentation site. 3. Hide: This option hides the Progress Dialog Box. 4. Cancel: Click on the Cancel button to terminate the report generation process. Upon clicking this button, it will transform into the Close button. Click on the Close button to dismiss the pop-up window.","title":"Step4: Select outputs and processing options"},{"location":"user/manual/step-4/#view-task-status-online","text":"After clicking on the Hide button this button will be enabled to view the task status. Click on the View Task Online button to view the task status.","title":"View Task Status Online"},{"location":"user/manual/step-4/#report-without-custom-metrics-table","text":"Users can see in the report there is no custom metrics table.","title":"Report without custom metrics table"},{"location":"user/manual/step-4/#report-with-custom-metrics-table","text":"Users can see in the report that the custom metrics table is included. Click here to explore the log section.","title":"Report with custom metrics table"},{"location":"user/quickstart/","text":"Quick start \u00b6 Instructions for a user on how to get the plugin working. First section deals with QGIS, and what versions are best to work with. This is followed by a section on how to install the CPLUS plugin, ending with a short tutorial accompanied by a video to show the user how to use the plugin. QGIS version \u00b6 The CPLUS plugin might have issues with older versions of QGIS. QGIS 3.22 or higher has thoroughly been tested with no major known issues. Here is a list of possible issues which may occur if using an outdated version of QGIS are being used: Processing stalls and does not continue Symbologies (e.g. colour ramps) cannot be applied to the output layers Reports cannot be generated Best will be to update QGIS to the latest version, even for other plugins, as bugs and improvements will be available for those versions. To update QGIS, a user can do the following: Go to the QGIS download webpage Download or follow the instructions for the operating system (OS) on which QGIS needs to be installed If a specific version (not the latest version) of QGIS needs to be installed, click on the All releases tab OSGeo4W network installer \u00b6 This section will only be helpful for Windows users. The OSGeo4W network installer provides much more option in a user-friendly UI. Advantages of using this installer: Easily allows a user to install both the latest and the latest LTR versions of QGIS User can select the exact libraries and versions they want to install (e.g. gdal) Option to include (or not include) GRASS and SAGA Extensions for QGIS If a user wants to update an existing QGIS installation, simply run the osgeo.exe in the installation directory Simply run the osgeo.exe to update already installed libraries, or install new libraries Easy to remove libraries or extensions Python modules And much more... Installation \u00b6 Plugin repository \u00b6 During the development phase, the plugin is available to install via a dedicated plugin repository. This link should be used: https://raw.githubusercontent.com/ConservationInternational/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS application Click on Plugins -> Manage and Install Plugins (see Figure 1 ) to open the plugin manager Open the Settings tab Click the Add button Provide the following parameters: Name : Provide a name for the repository URL : Paste the above repository URL Click OK The result should be similar to the following: Install from QGIS plugin repository \u00b6 Open QGIS application Click on Plugins -> Manage and Install Plugins (see Figure 1 ) to open the plugin manager Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin. Install from ZIP file \u00b6 Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/ConservationInternational/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin Install from custom plugin repository \u00b6 Current repository: https://raw.githubusercontent.com/ConservationInternational/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above URL to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository. Short tutorial \u00b6 Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Quick Start"},{"location":"user/quickstart/#quick-start","text":"Instructions for a user on how to get the plugin working. First section deals with QGIS, and what versions are best to work with. This is followed by a section on how to install the CPLUS plugin, ending with a short tutorial accompanied by a video to show the user how to use the plugin.","title":"Quick start"},{"location":"user/quickstart/#qgis-version","text":"The CPLUS plugin might have issues with older versions of QGIS. QGIS 3.22 or higher has thoroughly been tested with no major known issues. Here is a list of possible issues which may occur if using an outdated version of QGIS are being used: Processing stalls and does not continue Symbologies (e.g. colour ramps) cannot be applied to the output layers Reports cannot be generated Best will be to update QGIS to the latest version, even for other plugins, as bugs and improvements will be available for those versions. To update QGIS, a user can do the following: Go to the QGIS download webpage Download or follow the instructions for the operating system (OS) on which QGIS needs to be installed If a specific version (not the latest version) of QGIS needs to be installed, click on the All releases tab","title":"QGIS version"},{"location":"user/quickstart/#osgeo4w-network-installer","text":"This section will only be helpful for Windows users. The OSGeo4W network installer provides much more option in a user-friendly UI. Advantages of using this installer: Easily allows a user to install both the latest and the latest LTR versions of QGIS User can select the exact libraries and versions they want to install (e.g. gdal) Option to include (or not include) GRASS and SAGA Extensions for QGIS If a user wants to update an existing QGIS installation, simply run the osgeo.exe in the installation directory Simply run the osgeo.exe to update already installed libraries, or install new libraries Easy to remove libraries or extensions Python modules And much more...","title":"OSGeo4W network installer"},{"location":"user/quickstart/#installation","text":"","title":"Installation"},{"location":"user/quickstart/#plugin-repository","text":"During the development phase, the plugin is available to install via a dedicated plugin repository. This link should be used: https://raw.githubusercontent.com/ConservationInternational/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS application Click on Plugins -> Manage and Install Plugins (see Figure 1 ) to open the plugin manager Open the Settings tab Click the Add button Provide the following parameters: Name : Provide a name for the repository URL : Paste the above repository URL Click OK The result should be similar to the following:","title":"Plugin repository"},{"location":"user/quickstart/#install-from-qgis-plugin-repository","text":"Open QGIS application Click on Plugins -> Manage and Install Plugins (see Figure 1 ) to open the plugin manager Figure 1: QGIS plugin manager Search for CPLUS in the All page of the plugin manager. From the found results, click on the CPLUS result item and a page with plugin information will show up. Click the Install Plugin button at the bottom of the dialog to install the plugin.","title":"Install from QGIS plugin repository"},{"location":"user/quickstart/#install-from-zip-file","text":"Alternatively the plugin can be installed using Install from ZIP option on the QGIS plugin manager. Download zip file from the required plugin released version https://github.com/ConservationInternational/cplus-plugin/releases/download/{tagname}/cplus.{version}.zip Open QGIS application and open plugin manager Click on Plugins -> Manage and Install Plugins Click on Install from ZIP ( Figure 2 ) Select the zip file which contains the plugin Click Install Plugin Figure 2: Plugin manager install from zip option From the Install from ZIP page, select the zip file and click the Install button to install plugin","title":"Install from ZIP file"},{"location":"user/quickstart/#install-from-custom-plugin-repository","text":"Current repository: https://raw.githubusercontent.com/ConservationInternational/cplus-plugin/release/docs/repository/plugins.xml Open the QGIS plugin manager, then select the Settings page ( Figure 3 ) NOTE: The plugin is currently in experimental phase, so enable Show also Experimental Plugins Figure 3: Custom repository installation Click Add button on the Plugin Repositories group box and use the above URL to create the new plugin repository. The plugin should now be available from the list of all plugins that can be installed. Disable QGIS official plugin repository in order to not fetch plugins from it. NOTE: While the development phase is on going the plugin will be flagged as experimental, make sure to enable the QGIS plugin manager in the Settings page to show the experimental plugins in order to be able to install it. When the development work is complete the plugin will be available on the QGIS official plugin repository.","title":"Install from custom plugin repository"},{"location":"user/quickstart/#short-tutorial","text":"Short example ( Figure 4 ) on how to set parameters in step 1, implementation models in step 2, and weighing in step 3. For a more detailed instructions on how to use the plugin, see the guide and the manual . Figure 4: Quick guide on how to use the plugin","title":"Short tutorial"}]}